"use strict";

function _templateObject236() {
  var data = _taggedTemplateLiteral(["<label ?aria-label=\"", "\" ?id=\"", "\" ?role=\"", "\" ?type=\"", "\" class=\"zbutton ", "\">", "</label>"]);

  _templateObject236 = function _templateObject236() {
    return data;
  };

  return data;
}

function _templateObject235() {
  var data = _taggedTemplateLiteral(["<span class=\"zbutton__text\">", "</span>"]);

  _templateObject235 = function _templateObject235() {
    return data;
  };

  return data;
}

function _templateObject234() {
  var data = _taggedTemplateLiteral(["<i class=\"zbutton__icon ", " \"> ", " </i>"]);

  _templateObject234 = function _templateObject234() {
    return data;
  };

  return data;
}

function _templateObject233() {
  var data = _taggedTemplateLiteral(["", " ", " ", ""]);

  _templateObject233 = function _templateObject233() {
    return data;
  };

  return data;
}

function _templateObject232() {
  var data = _taggedTemplateLiteral(["<button ?aria-label=\"", "\" id=\"", "\" role=\"", "\" ?type=\"", "\" class=\"zbutton ", "\">", "</button>"]);

  _templateObject232 = function _templateObject232() {
    return data;
  };

  return data;
}

function _templateObject231() {
  var data = _taggedTemplateLiteral(["<span class=\"zcolorselect__preview zh-transparentbg\"><canvas style=\"background-color: ", ";\"></canvas></span>"]);

  _templateObject231 = function _templateObject231() {
    return data;
  };

  return data;
}

function _templateObject230() {
  var data = _taggedTemplateLiteral(["<span class=\"zcolorselect__preview\" style=\"", "\">", "</span>"]);

  _templateObject230 = function _templateObject230() {
    return data;
  };

  return data;
}

function _templateObject229() {
  var data = _taggedTemplateLiteral(["<span class=\"zcolorbutton__preview zh-nofill\"></span>"]);

  _templateObject229 = function _templateObject229() {
    return data;
  };

  return data;
}

function _templateObject228() {
  var data = _taggedTemplateLiteral(["<div class=\"zselectbox__selected\"> ", " </div> ", ""]);

  _templateObject228 = function _templateObject228() {
    return data;
  };

  return data;
}

function _templateObject227() {
  var data = _taggedTemplateLiteral(["<div>", "</div>"]);

  _templateObject227 = function _templateObject227() {
    return data;
  };

  return data;
}

function _templateObject226() {
  var data = _taggedTemplateLiteral(["<div class=\"", "\">", "</div>"]);

  _templateObject226 = function _templateObject226() {
    return data;
  };

  return data;
}

function _templateObject225() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject225 = function _templateObject225() {
    return data;
  };

  return data;
}

function _templateObject224() {
  var data = _taggedTemplateLiteral(["<div class=\"zinputfield__spinbuttonpane\"> ", " ", " </div>"]);

  _templateObject224 = function _templateObject224() {
    return data;
  };

  return data;
}

function _templateObject223() {
  var data = _taggedTemplateLiteral(["<input class='zinputfield__textbox' tabindex=\"", "\" ?aria-valuemin=", " ?aria-valuemax=", " ?readonly=", " ?aria-readonly=", " ?disabled=", " ?aria-disabled=", " ?maxlength=", ">"]);

  _templateObject223 = function _templateObject223() {
    return data;
  };

  return data;
}

function _templateObject222() {
  var data = _taggedTemplateLiteral(["", " ", " ", " ", " ", " ", ""]);

  _templateObject222 = function _templateObject222() {
    return data;
  };

  return data;
}

function _templateObject221() {
  var data = _taggedTemplateLiteral(["<div class=\"zinputfield ", "\" ?title=", " tabindex=\"-1\" role=\"spinbutton\" style=\"width:", "px\" ?id=", " >", "</div>"]);

  _templateObject221 = function _templateObject221() {
    return data;
  };

  return data;
}

function _templateObject220() {
  var data = _taggedTemplateLiteral(["<span class=\"zprogress__label\">", "</span>"]);

  _templateObject220 = function _templateObject220() {
    return data;
  };

  return data;
}

function _templateObject219() {
  var data = _taggedTemplateLiteral(["<span class=\"zprogress__label\">", "</span>"]);

  _templateObject219 = function _templateObject219() {
    return data;
  };

  return data;
}

function _templateObject218() {
  var data = _taggedTemplateLiteral(["<span class=\"zprogress__label\">", "</span>"]);

  _templateObject218 = function _templateObject218() {
    return data;
  };

  return data;
}

function _templateObject217() {
  var data = _taggedTemplateLiteral(["", " <div class=\"zprogress--circle zprogress\"> ", " <svg class=\"zprogress__loader ", "\" style=\"width:", "px;height:", "px;\"> <circle class=\"circle__track ", "\" cx=\"", "\" cy=\"", "\" r=\"", "\" stroke-dasharray=\"", "\" stroke-dashoffset=\"0\" stroke-width=\"", "\" style=\"", "\"> <title>", "</title> </circle> <circle class=\"circle__load ", "\" cx=\"", "\" cy=\"", "\" r=\"", "\" stroke-dasharray=\"", "\" stroke-dashoffset=\"", "\" stroke-width=\"", "\" style=\"", "\"> <title>", "</title> </circle> </svg> </div> ", ""]);

  _templateObject217 = function _templateObject217() {
    return data;
  };

  return data;
}

function _templateObject216() {
  var data = _taggedTemplateLiteral(["<div class=\"ztooltip\" ?style=\"", "\"> <div class=\"ztooltip__content\"> <div class=\"ztooltip__text\">", "</div> </div> <div class=\"ztooltip__pointer ", "\" ?style=\"", "\" ></div> </div>"]);

  _templateObject216 = function _templateObject216() {
    return data;
  };

  return data;
}

function _templateObject215() {
  var data = _taggedTemplateLiteral(["<span class=\"zprogress__label\">", "</span>"]);

  _templateObject215 = function _templateObject215() {
    return data;
  };

  return data;
}

function _templateObject214() {
  var data = _taggedTemplateLiteral(["<span class=\"zprogress__text ", "\" style=\"width:", "\" >", "</span>"]);

  _templateObject214 = function _templateObject214() {
    return data;
  };

  return data;
}

function _templateObject213() {
  var data = _taggedTemplateLiteral(["<span class=\"zprogress__text h-reversecolor ", "\">", "</span>"]);

  _templateObject213 = function _templateObject213() {
    return data;
  };

  return data;
}

function _templateObject212() {
  var data = _taggedTemplateLiteral(["<span class=\"zprogress__label\">", "</span>"]);

  _templateObject212 = function _templateObject212() {
    return data;
  };

  return data;
}

function _templateObject211() {
  var data = _taggedTemplateLiteral([" ", " <div class=\"zprogress ", "\" ?style=\"", "\" > ", " <div class=\"zprogress__bar ", " ", "\" ?style=\"", "\" > ", " </div> </div> ", " ", " \t"]);

  _templateObject211 = function _templateObject211() {
    return data;
  };

  return data;
}

function _templateObject210() {
  var data = _taggedTemplateLiteral(["<div class=\"ztooltip__pointer\"></div>"]);

  _templateObject210 = function _templateObject210() {
    return data;
  };

  return data;
}

function _templateObject209() {
  var data = _taggedTemplateLiteral(["<div class=\"ztooltip__content\">", "</div> ", ""]);

  _templateObject209 = function _templateObject209() {
    return data;
  };

  return data;
}

function _templateObject208() {
  var data = _taggedTemplateLiteral(["<div class=\"ztooltip\" style='display:none;'>", "</div>"]);

  _templateObject208 = function _templateObject208() {
    return data;
  };

  return data;
}

function _templateObject207() {
  var data = _taggedTemplateLiteral(["<span class='ztokenfield__text' ?title='", "'> ", " </span>"]);

  _templateObject207 = function _templateObject207() {
    return data;
  };

  return data;
}

function _templateObject206() {
  var data = _taggedTemplateLiteral(["<img src='", "' class='ztokenfield__image' />"]);

  _templateObject206 = function _templateObject206() {
    return data;
  };

  return data;
}

function _templateObject205() {
  var data = _taggedTemplateLiteral(["<i class='ztokenfield__image ", "'></i>"]);

  _templateObject205 = function _templateObject205() {
    return data;
  };

  return data;
}

function _templateObject204() {
  var data = _taggedTemplateLiteral(["<div class='ztokenfield__token ", " ", "' tabindex='-1' id='", "' .zdata='", "' ?style='", "'> ", " ", " ", " </div>"]);

  _templateObject204 = function _templateObject204() {
    return data;
  };

  return data;
}

function _templateObject203() {
  var data = _taggedTemplateLiteral(["<input type='text' id='", "-edit-input' class='ztokenfield__textbox ztokenfield__editinput' tabindex='0'/>"]);

  _templateObject203 = function _templateObject203() {
    return data;
  };

  return data;
}

function _templateObject202() {
  var data = _taggedTemplateLiteral([" ", ""]);

  _templateObject202 = function _templateObject202() {
    return data;
  };

  return data;
}

function _templateObject201() {
  var data = _taggedTemplateLiteral(["", " <input type='text' aria-haspopup='true' role='textbox' aria-expanded='false' aria-owns='", "-menu' id='", "-input' autocomplete='off' tabindex='", "' class='ztokenfield__textbox' ?disabled='", "'/> <input type='text' style='", "' tabindex='-1' id='", "-copy-helper' />"]);

  _templateObject201 = function _templateObject201() {
    return data;
  };

  return data;
}

function _templateObject200() {
  var data = _taggedTemplateLiteral(["<div>", "</div>"]);

  _templateObject200 = function _templateObject200() {
    return data;
  };

  return data;
}

function _templateObject199() {
  var data = _taggedTemplateLiteral(["", " ", " ", ""]);

  _templateObject199 = function _templateObject199() {
    return data;
  };

  return data;
}

function _templateObject198() {
  var data = _taggedTemplateLiteral(["", " ", " ", ""]);

  _templateObject198 = function _templateObject198() {
    return data;
  };

  return data;
}

function _templateObject197() {
  var data = _taggedTemplateLiteral(["", " ", ""]);

  _templateObject197 = function _templateObject197() {
    return data;
  };

  return data;
}

function _templateObject196() {
  var data = _taggedTemplateLiteral(["<div class='zdatetimepicker--multipleselectbox'> ", " </div >"]);

  _templateObject196 = function _templateObject196() {
    return data;
  };

  return data;
}

function _templateObject195() {
  var data = _taggedTemplateLiteral(["<span class='zdatetimepicker__timelabel'>", "</span>"]);

  _templateObject195 = function _templateObject195() {
    return data;
  };

  return data;
}

function _templateObject194() {
  var data = _taggedTemplateLiteral(["", " ", ""]);

  _templateObject194 = function _templateObject194() {
    return data;
  };

  return data;
}

function _templateObject193() {
  var data = _taggedTemplateLiteral(["", " ", " "]);

  _templateObject193 = function _templateObject193() {
    return data;
  };

  return data;
}

function _templateObject192() {
  var data = _taggedTemplateLiteral(["<td role='gridcell' class='", "' data-value=\"", "\">", "</td>"]);

  _templateObject192 = function _templateObject192() {
    return data;
  };

  return data;
}

function _templateObject191() {
  var data = _taggedTemplateLiteral(["<tr role='row'>"]);

  _templateObject191 = function _templateObject191() {
    return data;
  };

  return data;
}

function _templateObject190() {
  var data = _taggedTemplateLiteral(["<div class=\"zdatetimepicker__drilldownview\"> <table role=\"grid\" class=\"zdatetimepicker__drilldowncell\"> <tbody> ", " </tbody> </table> </div> </div>"]);

  _templateObject190 = function _templateObject190() {
    return data;
  };

  return data;
}

function _templateObject189() {
  var data = _taggedTemplateLiteral(["<div class='zdatetimepicker__", "drilldown zdatetimepicker__monthcontainer' ?style='", "'> ", " ", ""]);

  _templateObject189 = function _templateObject189() {
    return data;
  };

  return data;
}

function _templateObject188() {
  var data = _taggedTemplateLiteral(["<div class=\"zdatetimepicker__rightnav\"> ", " ", " ", " ", " </div>"]);

  _templateObject188 = function _templateObject188() {
    return data;
  };

  return data;
}

function _templateObject187() {
  var data = _taggedTemplateLiteral(["<span class='zdatetimepicker__yearnav'> ", " </span>"]);

  _templateObject187 = function _templateObject187() {
    return data;
  };

  return data;
}

function _templateObject186() {
  var data = _taggedTemplateLiteral(["<span class='zdatetimepicker__monthnav'> ", " </span>"]);

  _templateObject186 = function _templateObject186() {
    return data;
  };

  return data;
}

function _templateObject185() {
  var data = _taggedTemplateLiteral(["<div class=\"zdatetimepicker__monthyearnav ", "\"> ", " ", " </div>"]);

  _templateObject185 = function _templateObject185() {
    return data;
  };

  return data;
}

function _templateObject184() {
  var data = _taggedTemplateLiteral(["<div class=\"zdatetimepicker__leftnav\"> ", " ", " </div>"]);

  _templateObject184 = function _templateObject184() {
    return data;
  };

  return data;
}

function _templateObject183() {
  var data = _taggedTemplateLiteral(["<div class=\"zdatetimepicker__navbar ", "\"> ", " ", " ", " ", " ", " </div > "]);

  _templateObject183 = function _templateObject183() {
    return data;
  };

  return data;
}

function _templateObject182() {
  var data = _taggedTemplateLiteral(["<span class='zdatetimepicker__secondaryinfo'>", "</span>"]);

  _templateObject182 = function _templateObject182() {
    return data;
  };

  return data;
}

function _templateObject181() {
  var data = _taggedTemplateLiteral(["<td role='gridcell' ?class='", "' ?data-time='", "' ?title='", "'> <span class='zdatetimepicker__text'>", " </span> ", " </td>"]);

  _templateObject181 = function _templateObject181() {
    return data;
  };

  return data;
}

function _templateObject180() {
  var data = _taggedTemplateLiteral(["<tr> ", ""]);

  _templateObject180 = function _templateObject180() {
    return data;
  };

  return data;
}

function _templateObject179() {
  var data = _taggedTemplateLiteral(["<th class=", ">", "</th>"]);

  _templateObject179 = function _templateObject179() {
    return data;
  };

  return data;
}

function _templateObject178() {
  var data = _taggedTemplateLiteral(["<div class=\"zdatetimepicker__monthcontainer zdatetimepicker__days\" ?style='", "'> ", " <div class=\"zdatetimepicker__calendar\"> ", " <table role=\"grid\" class=", "> <thead> <tr role='row' class='zdatetimepicker__week'> ", " </tr> </thead> <tbody> ", " </tbody> </table> </div> </div>"]);

  _templateObject178 = function _templateObject178() {
    return data;
  };

  return data;
}

function _templateObject177() {
  var data = _taggedTemplateLiteral(["", " ", " ", " "]);

  _templateObject177 = function _templateObject177() {
    return data;
  };

  return data;
}

function _templateObject176() {
  var data = _taggedTemplateLiteral(["", " ", " "]);

  _templateObject176 = function _templateObject176() {
    return data;
  };

  return data;
}

function _templateObject175() {
  var data = _taggedTemplateLiteral(["<li class='zdatetimepicker__list'> <div class='zdatetimepicker'> ", " ", " </div> </li>"]);

  _templateObject175 = function _templateObject175() {
    return data;
  };

  return data;
}

function _templateObject174() {
  var data = _taggedTemplateLiteral(["<ul class='zdatetimepicker__container'> ", " </ul>"]);

  _templateObject174 = function _templateObject174() {
    return data;
  };

  return data;
}

function _templateObject173() {
  var data = _taggedTemplateLiteral(["<div class='zdatetimepicker__pointer'></div>"]);

  _templateObject173 = function _templateObject173() {
    return data;
  };

  return data;
}

function _templateObject172() {
  var data = _taggedTemplateLiteral(["", " ", " ", " ", ""]);

  _templateObject172 = function _templateObject172() {
    return data;
  };

  return data;
}

function _templateObject171() {
  var data = _taggedTemplateLiteral(["<input ?disabled=", " ?tabindex=", " class=\"zselectbox__textbox\" ?value=", " ?placeholder=", " autocomplete=\"off\" />"]);

  _templateObject171 = function _templateObject171() {
    return data;
  };

  return data;
}

function _templateObject170() {
  var data = _taggedTemplateLiteral(["", " ", ""]);

  _templateObject170 = function _templateObject170() {
    return data;
  };

  return data;
}

function _templateObject169() {
  var data = _taggedTemplateLiteral(["<div class=\"zselectbox__selected\"> ", " </div> ", " ", ""]);

  _templateObject169 = function _templateObject169() {
    return data;
  };

  return data;
}

function _templateObject168() {
  var data = _taggedTemplateLiteral(["<div>"]);

  _templateObject168 = function _templateObject168() {
    return data;
  };

  return data;
}

function _templateObject167() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__opacitycontainer\"> ", " ", " </div>"]);

  _templateObject167 = function _templateObject167() {
    return data;
  };

  return data;
}

function _templateObject166() {
  var data = _taggedTemplateLiteral(["<button id=", " aria-label=\"", "\" role=\"button\" type=\"button\" class=\"zbutton zcolorpicker__navigatable zcolorpicker__actionbutton zbutton zcolorpicker__nocolorbutton\"> ", " <span class=\"zbutton__text zcolorpicker__text\">", "</span> </button>"]);

  _templateObject166 = function _templateObject166() {
    return data;
  };

  return data;
}

function _templateObject165() {
  var data = _taggedTemplateLiteral(["<button id=", " aria-label=\"", "\" role=\"button\" type=\"button\" class=\"zcolorpicker__navigatable zcolorpicker__actionbutton zbutton zcolorpicker__defaultcolorbutton\"> <span class=\"zcolorpicker__icon\" style=\"background-color: ", ";\"></span> <span class=\"zbutton__text zcolorpicker__text\">", "</span> </button>"]);

  _templateObject165 = function _templateObject165() {
    return data;
  };

  return data;
}

function _templateObject164() {
  var data = _taggedTemplateLiteral(["<span class=\"zcolorpicker__colorfieldpreview zcolorpicker__transparentbg\"> <div class=\"zcolorpicker__dynamiccolor\" style=\"background-color: ", ";\"></div> </span>"]);

  _templateObject164 = function _templateObject164() {
    return data;
  };

  return data;
}

function _templateObject163() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__colorfield\"> ", " <input id=", " ?readonly=", " aria-label=\"", "\" class=\"zcolorpicker__textbox zcolorpicker__navigatable ", "\"> </div>"]);

  _templateObject163 = function _templateObject163() {
    return data;
  };

  return data;
}

function _templateObject162() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__colorfieldcontainer\"> ", " ", " </div>"]);

  _templateObject162 = function _templateObject162() {
    return data;
  };

  return data;
}

function _templateObject161() {
  var data = _taggedTemplateLiteral(["<button id=", " aria-label=\"", "\" role=\"button\" type=\"button\" class=\"zcolorpicker__navigatable zcolorpicker__actionbutton zbutton zcolorpicker__morecolorbutton zbutton--menu\"> ", " <span class=\"zbutton__text zcolorpicker__text\">", "</span> ", " </button>"]);

  _templateObject161 = function _templateObject161() {
    return data;
  };

  return data;
}

function _templateObject160() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__pointer\"></div>"]);

  _templateObject160 = function _templateObject160() {
    return data;
  };

  return data;
}

function _templateObject159() {
  var data = _taggedTemplateLiteral(["", " ", " <div class=\"zcolorpicker__showhidecontainer\"> <div class=\"zcolorpicker__default\"> ", " ", " ", " ", " ", " ", " ", " ", " </div> ", " </div> "]);

  _templateObject159 = function _templateObject159() {
    return data;
  };

  return data;
}

function _templateObject158() {
  var data = _taggedTemplateLiteral(["<label class=\"zcolorpicker__othercolormodefieldlabel\">A</label>"]);

  _templateObject158 = function _templateObject158() {
    return data;
  };

  return data;
}

function _templateObject157() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__hexcolorfieldlabelcontainer\"> <label class=\"zcolorpicker__hexcolorfieldlabel\">HEX</label> ", " </div>"]);

  _templateObject157 = function _templateObject157() {
    return data;
  };

  return data;
}

function _templateObject156() {
  var data = _taggedTemplateLiteral(["<div tabindex=\"-1\" class=\"zinputfield zcolorpicker__colorfield ", " style=\"\"> <input id=", " data-zprop=\"hex\" maxlength=\"7\" class=\"zinputfield__textbox\" aria-label=", "> </div>"]);

  _templateObject156 = function _templateObject156() {
    return data;
  };

  return data;
}

function _templateObject155() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__commandbaractionsright\"> ", " </div>"]);

  _templateObject155 = function _templateObject155() {
    return data;
  };

  return data;
}

function _templateObject154() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__commandbaractionscenter\"> ", " </div>"]);

  _templateObject154 = function _templateObject154() {
    return data;
  };

  return data;
}

function _templateObject153() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__commandbaractionsleft\"> ", " </div>"]);

  _templateObject153 = function _templateObject153() {
    return data;
  };

  return data;
}

function _templateObject152() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__commandbar zcolorpicker__footer\"> ", " ", " ", " </div>"]);

  _templateObject152 = function _templateObject152() {
    return data;
  };

  return data;
}

function _templateObject151() {
  var data = _taggedTemplateLiteral(["<div id=", " class=\"zcolorpicker__transparentbg zcolorpicker__currentcolorpreview\"> <span class=\"zcolorpicker__dynamiccolor\" style=\"background-color: ", ";\"> </span> </div>"]);

  _templateObject151 = function _templateObject151() {
    return data;
  };

  return data;
}

function _templateObject150() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__previewbox\"> <div class=\"zcolorpicker__transparentbg zcolorpicker__newcolorpreview\"> <span class=\"zcolorpicker__dynamiccolor\" style=\"background-color: ", ";\"> </span> </div> ", " </div>"]);

  _templateObject150 = function _templateObject150() {
    return data;
  };

  return data;
}

function _templateObject149() {
  var data = _taggedTemplateLiteral(["<label class=\"zcolorpicker__othercolormodefieldlabel\">", "</label>"]);

  _templateObject149 = function _templateObject149() {
    return data;
  };

  return data;
}

function _templateObject148() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__othercolormodefieldlabelcontainer\"> ", " </div>"]);

  _templateObject148 = function _templateObject148() {
    return data;
  };

  return data;
}

function _templateObject147() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__colorfieldcontainer ", "\"> ", " ", " ", " ", " </div>"]);

  _templateObject147 = function _templateObject147() {
    return data;
  };

  return data;
}

function _templateObject146() {
  var data = _taggedTemplateLiteral([" <span class=\"zcolorpicker__mapmarker\" style=\"left: ", "%; top: ", "%;\"> </span>"]);

  _templateObject146 = function _templateObject146() {
    return data;
  };

  return data;
}

function _templateObject145() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__pointer\"></div>"]);

  _templateObject145 = function _templateObject145() {
    return data;
  };

  return data;
}

function _templateObject144() {
  var data = _taggedTemplateLiteral(["", " ", " <div class=\"zcolorpicker__maparea\" ?id=", "> ", " ", " </div> <div class=\"zcolorpicker__colormodecontainer\"> ", " <div class=\"zcolorpicker__slidercontainer\"> ", " ", " </div> </div> ", " ", " ", " ", " "]);

  _templateObject144 = function _templateObject144() {
    return data;
  };

  return data;
}

function _templateObject143() {
  var data = _taggedTemplateLiteral(["", " <input class='zinputfield__textbox' tabindex=\"", "\" ?aria-valuemin=", " ?aria-valuemax=", " ?readonly=", " ?aria-readonly=", " ?disabled=", " ?aria-disabled=", " ?maxlength=", "> ", " ", " \t"]);

  _templateObject143 = function _templateObject143() {
    return data;
  };

  return data;
}

function _templateObject142() {
  var data = _taggedTemplateLiteral(["<div class=\"zinputfield ", "\" ?title=", " tabindex=\"-1\" role=\"spinbutton\" style=\"width:", "px\" ?id=", " >", "</div>"]);

  _templateObject142 = function _templateObject142() {
    return data;
  };

  return data;
}

function _templateObject141() {
  var data = _taggedTemplateLiteral(["<div class=\"zinputfield__spinbuttonpane\"> ", " ", " </div>"]);

  _templateObject141 = function _templateObject141() {
    return data;
  };

  return data;
}

function _templateObject140() {
  var data = _taggedTemplateLiteral(["<input class='zinputfield__textbox' tabindex=\"", "\" ?aria-valuemin=", " ?aria-valuemax=", " ?readonly=", " ?aria-readonly=", " ?disabled=", " ?aria-disabled=", " ?maxlength=", "> ", " ", ""]);

  _templateObject140 = function _templateObject140() {
    return data;
  };

  return data;
}

function _templateObject139() {
  var data = _taggedTemplateLiteral(["<div class=\"zinputfield ", "\" ?title=", " tabindex=\"-1\" role=\"spinbutton\" ?style=\"", "\" ?id=", " >", "</div>"]);

  _templateObject139 = function _templateObject139() {
    return data;
  };

  return data;
}

function _templateObject138() {
  var data = _taggedTemplateLiteral(["<span class=\"zselectbox__text\">", "</span>"]);

  _templateObject138 = function _templateObject138() {
    return data;
  };

  return data;
}

function _templateObject137() {
  var data = _taggedTemplateLiteral(["", " ", " ", ""]);

  _templateObject137 = function _templateObject137() {
    return data;
  };

  return data;
}

function _templateObject136() {
  var data = _taggedTemplateLiteral(["<span class=\"zselectbox__text zselectbox__placeholder\">", "</span>"]);

  _templateObject136 = function _templateObject136() {
    return data;
  };

  return data;
}

function _templateObject135() {
  var data = _taggedTemplateLiteral(["<div class=\"zselectbox__selected\"> ", " </div> ", " ", ""]);

  _templateObject135 = function _templateObject135() {
    return data;
  };

  return data;
}

function _templateObject134() {
  var data = _taggedTemplateLiteral(["<div>", "</div>"]);

  _templateObject134 = function _templateObject134() {
    return data;
  };

  return data;
}

function _templateObject133() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__actiongroup zcolorpicker__action\"> ", " </div>"]);

  _templateObject133 = function _templateObject133() {
    return data;
  };

  return data;
}

function _templateObject132() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__header zcolorpicker__titlebar\"> <span class=\"zcolorpicker__title zcolorpicker__text\">", "</span> ", " </div>"]);

  _templateObject132 = function _templateObject132() {
    return data;
  };

  return data;
}

function _templateObject131() {
  var data = _taggedTemplateLiteral(["<div ?id=", " class=\"zslider ", "\"> <div class=\"zslider__track ", "\"> ", " </div> <div role=\"slider\" class=\"zslider__thumb ", "\" style=\"left:", "%;\"> ", " </div> </div>"]);

  _templateObject131 = function _templateObject131() {
    return data;
  };

  return data;
}

function _templateObject130() {
  var data = _taggedTemplateLiteral(["<li ?data-shade=\"", "\" data-palette-name=\"", "\" class=\"zcolorpicker__colorpan ", "\" tabindex=", " ?data-tone-type=\"", "\" ?data-theme=\"", "\" ?data-tone-percent=\"", "\" ?data-zcolor=\"", "\" ?data-base-color=\"", "\" style=\"background-color:", ";\" ?aria-hidden=\"", "\" ?aria-selected=\"", "\" title=\"", "\"></li>"]);

  _templateObject130 = function _templateObject130() {
    return data;
  };

  return data;
}

function _templateObject129() {
  var data = _taggedTemplateLiteral(["<li class=\"zcolorpicker__addcolor\">", "</li>"]);

  _templateObject129 = function _templateObject129() {
    return data;
  };

  return data;
}

function _templateObject128() {
  var data = _taggedTemplateLiteral(["<ul> ", " </ul>"]);

  _templateObject128 = function _templateObject128() {
    return data;
  };

  return data;
}

function _templateObject127() {
  var data = _taggedTemplateLiteral(["<ul class=\"zcolorpicker__shades\"> ", " ", " </ul> "]);

  _templateObject127 = function _templateObject127() {
    return data;
  };

  return data;
}

function _templateObject126() {
  var data = _taggedTemplateLiteral(["<div class=\"zcolorpicker__navigatable\"> ", " </div>"]);

  _templateObject126 = function _templateObject126() {
    return data;
  };

  return data;
}

function _templateObject125() {
  var data = _taggedTemplateLiteral(["<span class=\"zcolorpicker__paletteheading\"> ", " </span>"]);

  _templateObject125 = function _templateObject125() {
    return data;
  };

  return data;
}

function _templateObject124() {
  var data = _taggedTemplateLiteral(["<div ?id=", " data-custom=\"", "\" class=\"zcolorpicker__palettecontainer ", "\" data-palettename=\"", "\"> ", " <div class=\"zcolorpicker__palette\"> ", " </div> </div> "]);

  _templateObject124 = function _templateObject124() {
    return data;
  };

  return data;
}

function _templateObject123() {
  var data = _taggedTemplateLiteral(["<canvas class=\"", "\"></canvas>"]);

  _templateObject123 = function _templateObject123() {
    return data;
  };

  return data;
}

function _templateObject122() {
  var data = _taggedTemplateLiteral(["<input type=text class=\"", " ", "\">"]);

  _templateObject122 = function _templateObject122() {
    return data;
  };

  return data;
}

function _templateObject121() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject121 = function _templateObject121() {
    return data;
  };

  return data;
}

function _templateObject120() {
  var data = _taggedTemplateLiteral(["<i class=\"zmenu__icon zh-loading\"> <svg class=\"zmenu__svg zmenu__loader zeffects--rotate\"> <circle class=\"circle__track\"></circle> <circle class=\"circle__load\"></circle> </svg> </i>"]);

  _templateObject120 = function _templateObject120() {
    return data;
  };

  return data;
}

function _templateObject119() {
  var data = _taggedTemplateLiteral(["<ul data-footer=\"true\" class=\"zmenu--loading\" id=\"", "-loader\"> <li class=\"zsuggestfield__nonselectable\"> ", " </li> </ul>"]);

  _templateObject119 = function _templateObject119() {
    return data;
  };

  return data;
}

function _templateObject118() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject118 = function _templateObject118() {
    return data;
  };

  return data;
}

function _templateObject117() {
  var data = _taggedTemplateLiteral(["<ul class='zmenu__footer' data-footer=true > ", " </ul>"]);

  _templateObject117 = function _templateObject117() {
    return data;
  };

  return data;
}

function _templateObject116() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject116 = function _templateObject116() {
    return data;
  };

  return data;
}

function _templateObject115() {
  var data = _taggedTemplateLiteral(["<ul class='zmenu__body' data-body=true > ", " </ul>"]);

  _templateObject115 = function _templateObject115() {
    return data;
  };

  return data;
}

function _templateObject114() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject114 = function _templateObject114() {
    return data;
  };

  return data;
}

function _templateObject113() {
  var data = _taggedTemplateLiteral(["<div class=\"zmenu__search\"> ", " <input id=\"", "\" autocomplete=\"off\" type=\"text\" class=\"zmenu__textbox\" autocomplete=\"off\"> </div>"]);

  _templateObject113 = function _templateObject113() {
    return data;
  };

  return data;
}

function _templateObject112() {
  var data = _taggedTemplateLiteral(["<ul class='zmenu__header' data-header=true > ", " ", " </ul>"]);

  _templateObject112 = function _templateObject112() {
    return data;
  };

  return data;
}

function _templateObject111() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject111 = function _templateObject111() {
    return data;
  };

  return data;
}

function _templateObject110() {
  var data = _taggedTemplateLiteral([" ", " ", " ", " ", " "]);

  _templateObject110 = function _templateObject110() {
    return data;
  };

  return data;
}

function _templateObject109() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject109 = function _templateObject109() {
    return data;
  };

  return data;
}

function _templateObject108() {
  var data = _taggedTemplateLiteral(["", " ", ""]);

  _templateObject108 = function _templateObject108() {
    return data;
  };

  return data;
}

function _templateObject107() {
  var data = _taggedTemplateLiteral(["<ul class='", "' data-footer=true > ", " </ul>"]);

  _templateObject107 = function _templateObject107() {
    return data;
  };

  return data;
}

function _templateObject106() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject106 = function _templateObject106() {
    return data;
  };

  return data;
}

function _templateObject105() {
  var data = _taggedTemplateLiteral(["<ul class='", "' data-body=true > ", " </ul>"]);

  _templateObject105 = function _templateObject105() {
    return data;
  };

  return data;
}

function _templateObject104() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject104 = function _templateObject104() {
    return data;
  };

  return data;
}

function _templateObject103() {
  var data = _taggedTemplateLiteral(["<ul class='", "' data-header=true > ", " </ul>"]);

  _templateObject103 = function _templateObject103() {
    return data;
  };

  return data;
}

function _templateObject102() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject102 = function _templateObject102() {
    return data;
  };

  return data;
}

function _templateObject101() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject101 = function _templateObject101() {
    return data;
  };

  return data;
}

function _templateObject100() {
  var data = _taggedTemplateLiteral(["", " ", " ", " ", " ", " "]);

  _templateObject100 = function _templateObject100() {
    return data;
  };

  return data;
}

function _templateObject99() {
  var data = _taggedTemplateLiteral(["<div class=\"", "\" ?id=", ">", "</div>"]);

  _templateObject99 = function _templateObject99() {
    return data;
  };

  return data;
}

function _templateObject98() {
  var data = _taggedTemplateLiteral(["<div class='", "'>", "</div>"]);

  _templateObject98 = function _templateObject98() {
    return data;
  };

  return data;
}

function _templateObject97() {
  var data = _taggedTemplateLiteral(["", " ", " ", " "]);

  _templateObject97 = function _templateObject97() {
    return data;
  };

  return data;
}

function _templateObject96() {
  var data = _taggedTemplateLiteral(["<div class=\"zmenu__pointer\" ></div>"]);

  _templateObject96 = function _templateObject96() {
    return data;
  };

  return data;
}

function _templateObject95() {
  var data = _taggedTemplateLiteral(["<span class=\"zmenu__description\" >", "</span>"]);

  _templateObject95 = function _templateObject95() {
    return data;
  };

  return data;
}

function _templateObject94() {
  var data = _taggedTemplateLiteral(["<span class=\"zmenu__shortcut\" >", "</span>"]);

  _templateObject94 = function _templateObject94() {
    return data;
  };

  return data;
}

function _templateObject93() {
  var data = _taggedTemplateLiteral(["<span class=\"zmenu__text\" >", "</span>"]);

  _templateObject93 = function _templateObject93() {
    return data;
  };

  return data;
}

function _templateObject92() {
  var data = _taggedTemplateLiteral([" ", " ", " ", " "]);

  _templateObject92 = function _templateObject92() {
    return data;
  };

  return data;
}

function _templateObject91() {
  var data = _taggedTemplateLiteral(["<div class=\"zmenu__iconcontainer\" >", "</div>"]);

  _templateObject91 = function _templateObject91() {
    return data;
  };

  return data;
}

function _templateObject90() {
  var data = _taggedTemplateLiteral(["", " ", " ", " ", " "]);

  _templateObject90 = function _templateObject90() {
    return data;
  };

  return data;
}

function _templateObject89() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject89 = function _templateObject89() {
    return data;
  };

  return data;
}

function _templateObject88() {
  var data = _taggedTemplateLiteral(["<a class=\"zmenu__link\" href=", " target=", " rel='", "' >", "</a>"]);

  _templateObject88 = function _templateObject88() {
    return data;
  };

  return data;
}

function _templateObject87() {
  var data = _taggedTemplateLiteral(["<li ?id=", " ?data-item-type=", " class=\"", "\" role=\"", "\" data-unique-key=\"", "\" .itemData=\"", "\"></li>"]);

  _templateObject87 = function _templateObject87() {
    return data;
  };

  return data;
}

function _templateObject86() {
  var data = _taggedTemplateLiteral(["<span class=\"zmenu__text\" >", "</span>"]);

  _templateObject86 = function _templateObject86() {
    return data;
  };

  return data;
}

function _templateObject85() {
  var data = _taggedTemplateLiteral(["<li ?id=", " ?data-item-type=", " class=\"", "\" role=\"", "\" ?name=", " data-unique-key=\"", "\" .itemData=\"", "\"> ", " </li>"]);

  _templateObject85 = function _templateObject85() {
    return data;
  };

  return data;
}

function _templateObject84() {
  var data = _taggedTemplateLiteral(["<li ?id=", " ?data-item-type=", " class=\"", "\" role=\"", "\" ?name=", " ?data-menu-id=\"", "\" data-unique-key=\"", "\" ?data-label='", "' ?checked=\"", "\" .itemData=\"", "\"> ", " </li>"]);

  _templateObject84 = function _templateObject84() {
    return data;
  };

  return data;
}

function _templateObject83() {
  var data = _taggedTemplateLiteral([" ", " "]);

  _templateObject83 = function _templateObject83() {
    return data;
  };

  return data;
}

function _templateObject82() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject82 = function _templateObject82() {
    return data;
  };

  return data;
}

function _templateObject81() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject81 = function _templateObject81() {
    return data;
  };

  return data;
}

function _templateObject80() {
  var data = _taggedTemplateLiteral([" ", " "]);

  _templateObject80 = function _templateObject80() {
    return data;
  };

  return data;
}

function _templateObject79() {
  var data = _taggedTemplateLiteral(["<ul class=\"", "\" ?id=", ">", "</ul>"]);

  _templateObject79 = function _templateObject79() {
    return data;
  };

  return data;
}

function _templateObject78() {
  var data = _taggedTemplateLiteral(["<div class=\"zalertdialog__commandbar zalertdialog__footer ", "\"> ", " ", " </div>"]);

  _templateObject78 = function _templateObject78() {
    return data;
  };

  return data;
}

function _templateObject77() {
  var data = _taggedTemplateLiteral(["<div class=\"zdialog__suppression\"> <div class=\"zcheckbox\"><input id=\"zalert__suppression--box\" type=\"checkbox\" class=\"zcheckbox__helper\"><label for=\"zalert__suppression--box\" class=\"zcheckbox__label\">", "</label></div> </div>"]);

  _templateObject77 = function _templateObject77() {
    return data;
  };

  return data;
}

function _templateObject76() {
  var data = _taggedTemplateLiteral(["<div class=\"zdialog__secondarytext\">", "</div>"]);

  _templateObject76 = function _templateObject76() {
    return data;
  };

  return data;
}

function _templateObject75() {
  var data = _taggedTemplateLiteral(["<div class=\"zdialog__primarytext\">", "</div>"]);

  _templateObject75 = function _templateObject75() {
    return data;
  };

  return data;
}

function _templateObject74() {
  var data = _taggedTemplateLiteral(["<div class=\"zdialog__alerticon\">", "</div>"]);

  _templateObject74 = function _templateObject74() {
    return data;
  };

  return data;
}

function _templateObject73() {
  var data = _taggedTemplateLiteral(["<div class=\"zdialog__actiongroup\">", "</div>"]);

  _templateObject73 = function _templateObject73() {
    return data;
  };

  return data;
}

function _templateObject72() {
  var data = _taggedTemplateLiteral(["<span class=\"zdialog__title\">", "</span>"]);

  _templateObject72 = function _templateObject72() {
    return data;
  };

  return data;
}

function _templateObject71() {
  var data = _taggedTemplateLiteral(["<div class=\"zdialog__header zdraggable\"> ", " ", " </div>"]);

  _templateObject71 = function _templateObject71() {
    return data;
  };

  return data;
}

function _templateObject70() {
  var data = _taggedTemplateLiteral([" ", " <div class=\"zdialog__content\"> ", " <div class=\"zdialog__description\"> ", " ", " ", " </div> </div> ", ""]);

  _templateObject70 = function _templateObject70() {
    return data;
  };

  return data;
}

function _templateObject69() {
  var data = _taggedTemplateLiteral(["<div class=\"zdialog zdialog--alert\" tabindex=\"-1\" role=\"alertdialog\" aria-modal=\"true\" aria-expanded=\"true\">", "</div>"]);

  _templateObject69 = function _templateObject69() {
    return data;
  };

  return data;
}

function _templateObject68() {
  var data = _taggedTemplateLiteral(["<div class=\"zalertbanner__action\" title=", "><button type=\"button\" class=\"zalertbanner__close\">", "</button></div>"]);

  _templateObject68 = function _templateObject68() {
    return data;
  };

  return data;
}

function _templateObject67() {
  var data = _taggedTemplateLiteral([" ", ""]);

  _templateObject67 = function _templateObject67() {
    return data;
  };

  return data;
}

function _templateObject66() {
  var data = _taggedTemplateLiteral(["<span class=\"zalertbanner__text\">", " ", "</span>"]);

  _templateObject66 = function _templateObject66() {
    return data;
  };

  return data;
}

function _templateObject65() {
  var data = _taggedTemplateLiteral(["<div class=\"zalertbanner__table\"></div>"]);

  _templateObject65 = function _templateObject65() {
    return data;
  };

  return data;
}

function _templateObject64() {
  var data = _taggedTemplateLiteral([" ", " ", " ", " ", " ", " "]);

  _templateObject64 = function _templateObject64() {
    return data;
  };

  return data;
}

function _templateObject63() {
  var data = _taggedTemplateLiteral(["<div class=\"zalertbanner ", "\">", "</div>"]);

  _templateObject63 = function _templateObject63() {
    return data;
  };

  return data;
}

function _templateObject62() {
  var data = _taggedTemplateLiteral(["<div class=\"ztooltip__pointer ", "\"></div>"]);

  _templateObject62 = function _templateObject62() {
    return data;
  };

  return data;
}

function _templateObject61() {
  var data = _taggedTemplateLiteral(["<div class='ztooltip ", "'> <div class='ztooltip__content'></div> ", " </div>"]);

  _templateObject61 = function _templateObject61() {
    return data;
  };

  return data;
}

function _templateObject60() {
  var data = _taggedTemplateLiteral(["<div class=\"zslider__tick\" data-val=\"", "\"></div>"]);

  _templateObject60 = function _templateObject60() {
    return data;
  };

  return data;
}

function _templateObject59() {
  var data = _taggedTemplateLiteral(["<div class=\"zslider__scale ", "\"> ", " </div>"]);

  _templateObject59 = function _templateObject59() {
    return data;
  };

  return data;
}

function _templateObject58() {
  var data = _taggedTemplateLiteral(["<div class=\"zslider__label\" data-val=\"", "\">", "</div>"]);

  _templateObject58 = function _templateObject58() {
    return data;
  };

  return data;
}

function _templateObject57() {
  var data = _taggedTemplateLiteral(["<div class=\"zslider__labels ", "\"> ", " </div>"]);

  _templateObject57 = function _templateObject57() {
    return data;
  };

  return data;
}

function _templateObject56() {
  var data = _taggedTemplateLiteral(["<div class=\"zslider__tick\" data-val=\"", "\"></div>"]);

  _templateObject56 = function _templateObject56() {
    return data;
  };

  return data;
}

function _templateObject55() {
  var data = _taggedTemplateLiteral(["<div class=\"zslider__scale ", "\"> ", " </div>"]);

  _templateObject55 = function _templateObject55() {
    return data;
  };

  return data;
}

function _templateObject54() {
  var data = _taggedTemplateLiteral(["", " ", " ", " "]);

  _templateObject54 = function _templateObject54() {
    return data;
  };

  return data;
}

function _templateObject53() {
  var data = _taggedTemplateLiteral(["<div class=\"zslider__rangelabel\"> <span class=\"zslider__textcontainer\"><span class=\"zslider__text\">", "</span></span> </div>"]);

  _templateObject53 = function _templateObject53() {
    return data;
  };

  return data;
}

function _templateObject52() {
  var data = _taggedTemplateLiteral(["<div class=\"zslider__rangelabels ", "\"> ", " </div>"]);

  _templateObject52 = function _templateObject52() {
    return data;
  };

  return data;
}

function _templateObject51() {
  var data = _taggedTemplateLiteral(["<div role=\"slider\" class=\"zslider__thumb ", "\" ?aria-disabled=\"", "\" aria-orientation=\"", "\" aria-valuemin=\"", "\" aria-valuemax=\"", "\" tabindex=\"", "\" data-val=\"", "\" aria-valuenow=\"", "\" aria-valuetext=\"", "\">", "</div>"]);

  _templateObject51 = function _templateObject51() {
    return data;
  };

  return data;
}

function _templateObject50() {
  var data = _taggedTemplateLiteral(["<div class=\"zslider__notallowedrange zslider__notallowedrange", "\"></div>"]);

  _templateObject50 = function _templateObject50() {
    return data;
  };

  return data;
}

function _templateObject49() {
  var data = _taggedTemplateLiteral(["<div class=\"zslider__selected\"></div>"]);

  _templateObject49 = function _templateObject49() {
    return data;
  };

  return data;
}

function _templateObject48() {
  var data = _taggedTemplateLiteral(["<div class=\"zslider__rangegroup ", "\" style=\"", "\">", "</div>"]);

  _templateObject48 = function _templateObject48() {
    return data;
  };

  return data;
}

function _templateObject47() {
  var data = _taggedTemplateLiteral([" <div class=\"zslider__shadowtrack\" style=\"", "\"></div> ", " ", " <div class=\"zslider__track\"> ", " <div class=\"zslider__selection\" style=\"", "\"></div> ", " ", " </div> ", " ", " ", " ", " "]);

  _templateObject47 = function _templateObject47() {
    return data;
  };

  return data;
}

function _templateObject46() {
  var data = _taggedTemplateLiteral(["<div class=\"zslider\" >", "</div>"]);

  _templateObject46 = function _templateObject46() {
    return data;
  };

  return data;
}

function _templateObject45() {
  var data = _taggedTemplateLiteral(["<div class=\"", "__commandbaractionsright ", "\">", "</div>"]);

  _templateObject45 = function _templateObject45() {
    return data;
  };

  return data;
}

function _templateObject44() {
  var data = _taggedTemplateLiteral(["<div class=\"", "__commandbaractionscenter ", "\"> ", "</div>"]);

  _templateObject44 = function _templateObject44() {
    return data;
  };

  return data;
}

function _templateObject43() {
  var data = _taggedTemplateLiteral(["<div class=\"", "__commandbaractionsleft ", "\">", "</div>"]);

  _templateObject43 = function _templateObject43() {
    return data;
  };

  return data;
}

function _templateObject42() {
  var data = _taggedTemplateLiteral([" ", " ", " ", " \t"]);

  _templateObject42 = function _templateObject42() {
    return data;
  };

  return data;
}

function _templateObject41() {
  var data = _taggedTemplateLiteral(["<div class=\"zdialog__footnote\">", "</div>"]);

  _templateObject41 = function _templateObject41() {
    return data;
  };

  return data;
}

function _templateObject40() {
  var data = _taggedTemplateLiteral(["<div class=\"zdialog__commandbar zdialog__footer ", "\"> ", "", " </div>"]);

  _templateObject40 = function _templateObject40() {
    return data;
  };

  return data;
}

function _templateObject39() {
  var data = _taggedTemplateLiteral(["<div class=\"zdialog__content\"> ", " </div>"]);

  _templateObject39 = function _templateObject39() {
    return data;
  };

  return data;
}

function _templateObject38() {
  var data = _taggedTemplateLiteral(["<div class=\"zdialog__actiongroup zdialog__action\">", "</div>"]);

  _templateObject38 = function _templateObject38() {
    return data;
  };

  return data;
}

function _templateObject37() {
  var data = _taggedTemplateLiteral(["<div role=\"heading\" class=\"zdialog__title zdialog__text\">", "</div>"]);

  _templateObject37 = function _templateObject37() {
    return data;
  };

  return data;
}

function _templateObject36() {
  var data = _taggedTemplateLiteral([" <div class=\"zdialog__header zdialog__titlebar zdraggable\"> ", " ", " </div> ", " ", " ", ""]);

  _templateObject36 = function _templateObject36() {
    return data;
  };

  return data;
}

function _templateObject35() {
  var data = _taggedTemplateLiteral(["<div ?aria-label=\"", "\" ?id=\"", "\" ?role=\"", "\" class=\"zdialog ", "\">", "</div>"]);

  _templateObject35 = function _templateObject35() {
    return data;
  };

  return data;
}

function _templateObject34() {
  var data = _taggedTemplateLiteral(["<span class=\"ztabpanel__text\" >", "</span>"]);

  _templateObject34 = function _templateObject34() {
    return data;
  };

  return data;
}

function _templateObject33() {
  var data = _taggedTemplateLiteral([" ", " ", " ", ""]);

  _templateObject33 = function _templateObject33() {
    return data;
  };

  return data;
}

function _templateObject32() {
  var data = _taggedTemplateLiteral(["<a tabindex=\"-1\" href=#", " > ", " </a>"]);

  _templateObject32 = function _templateObject32() {
    return data;
  };

  return data;
}

function _templateObject31() {
  var data = _taggedTemplateLiteral(["<li role=\"tab\" ?title=", " tabindex=-1 ?id=\"", "\" class=\"", "\" ?style=\"", "\" data-panel-id=", " ?aria-disabled=\"", "\" ?data-disabled=", " ?aria-hidden=", " ?data-hidden=", ">", " </li>"]);

  _templateObject31 = function _templateObject31() {
    return data;
  };

  return data;
}

function _templateObject30() {
  var data = _taggedTemplateLiteral(["<ul role=tablist class=\"", "\"> ", " </ul>"]);

  _templateObject30 = function _templateObject30() {
    return data;
  };

  return data;
}

function _templateObject29() {
  var data = _taggedTemplateLiteral(["<div class=\"", "\"> </div>"]);

  _templateObject29 = function _templateObject29() {
    return data;
  };

  return data;
}

function _templateObject28() {
  var data = _taggedTemplateLiteral([" ", " ", " ", " "]);

  _templateObject28 = function _templateObject28() {
    return data;
  };

  return data;
}

function _templateObject27() {
  var data = _taggedTemplateLiteral(["<div class=\"zpopover__pointer\"></div>"]);

  _templateObject27 = function _templateObject27() {
    return data;
  };

  return data;
}

function _templateObject26() {
  var data = _taggedTemplateLiteral(["<div class=\"zpopover__loading\" id=\"zpopover--loader\"> <i class=\"zpopover__icon h-loading\"> <svg class=\"zpopover__svg zpopover__loader zeffects--rotate\"> <circle class=\"circle__track\"></circle> <circle class=\"circle__load\"></circle> </svg> </i> </div>"]);

  _templateObject26 = function _templateObject26() {
    return data;
  };

  return data;
}

function _templateObject25() {
  var data = _taggedTemplateLiteral(["<div class=\"zpopover__content\"> ", " </div>"]);

  _templateObject25 = function _templateObject25() {
    return data;
  };

  return data;
}

function _templateObject24() {
  var data = _taggedTemplateLiteral(["<div class=\"zpopover__action\">", "</div>"]);

  _templateObject24 = function _templateObject24() {
    return data;
  };

  return data;
}

function _templateObject23() {
  var data = _taggedTemplateLiteral(["<div role=\"heading\" class=\"zpopover__text\">", "</div>"]);

  _templateObject23 = function _templateObject23() {
    return data;
  };

  return data;
}

function _templateObject22() {
  var data = _taggedTemplateLiteral(["<div id=\"zpopover__title\" class=\"zpopover__title ", "\"> ", " ", " </div>"]);

  _templateObject22 = function _templateObject22() {
    return data;
  };

  return data;
}

function _templateObject21() {
  var data = _taggedTemplateLiteral(["", " ", " ", ""]);

  _templateObject21 = function _templateObject21() {
    return data;
  };

  return data;
}

function _templateObject20() {
  var data = _taggedTemplateLiteral(["<span class=\"zbutton__bgprogress zbutton__bgprogress--", "\" style=\"width:", "%;\" ></span>"]);

  _templateObject20 = function _templateObject20() {
    return data;
  };

  return data;
}

function _templateObject19() {
  var data = _taggedTemplateLiteral(["<span class=\"zbutton__", "line\" style=\"width:", "%;\" ></span>"]);

  _templateObject19 = function _templateObject19() {
    return data;
  };

  return data;
}

function _templateObject18() {
  var data = _taggedTemplateLiteral([" ", " ", " ", ""]);

  _templateObject18 = function _templateObject18() {
    return data;
  };

  return data;
}

function _templateObject17() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject17 = function _templateObject17() {
    return data;
  };

  return data;
}

function _templateObject16() {
  var data = _taggedTemplateLiteral(["<span class='zbutton__text'>", "</span>"]);

  _templateObject16 = function _templateObject16() {
    return data;
  };

  return data;
}

function _templateObject15() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject15 = function _templateObject15() {
    return data;
  };

  return data;
}

function _templateObject14() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject14 = function _templateObject14() {
    return data;
  };

  return data;
}

function _templateObject13() {
  var data = _taggedTemplateLiteral([" ", " ", " ", ""]);

  _templateObject13 = function _templateObject13() {
    return data;
  };

  return data;
}

function _templateObject12() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject12 = function _templateObject12() {
    return data;
  };

  return data;
}

function _templateObject11() {
  var data = _taggedTemplateLiteral([" ", " "]);

  _templateObject11 = function _templateObject11() {
    return data;
  };

  return data;
}

function _templateObject10() {
  var data = _taggedTemplateLiteral(["<button ?aria-label=\"", "\" ?id=\"", "\" ?role=\"", "\" ?type=\"", "\" ?title=\"", "\" class=\"zbutton ", "\">", "</button>"]);

  _templateObject10 = function _templateObject10() {
    return data;
  };

  return data;
}

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _templateObject9() {
  var data = _taggedTemplateLiteral(["<a ?class=", " aria-label=", ">", "</a>"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["", ""]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["<div class=\"zdatetimepicker__commandbaractionsright\">", "</div>"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["<div class=\"zdatetimepicker__commandbaractionscenter\"> ", "</div>"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["<div class=\"zdatetimepicker__commandbaractionsleft\">", "</div>"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["", " ", " ", ""]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<div class=\"zdatetimepicker__column\"> ", " </div>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["<div class=\"zdatetimepicker__commandbar ", "\"> ", " </div>"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["<i class=\"", "\"> ", " </i>"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function ($) {
  /* Core Variable */
  var needToInit = true,
      userAgent = navigator.userAgent.toLowerCase(),
      sourceDiv = document.createElement('div'),
      sourceText = document.createTextNode(' '),
      objectProperties = ['_CLASSES', '_EVENTS', '_SELECTORS', '_attrs', '_props']; // No I18N

  sourceDiv.appendChild(sourceText);
  var ZComponents = {
    pluginPrefix: "z",
    // No I18N
    changeSet: 'v4_1_3',
    // No I18N
    isRTL: false,
    selector: 'data-ctype',
    // No I18N
    version: 'v4_1_3',
    // No I18N
    environment: 'production',
    // No I18N
    userAgent: userAgent,
    webComponents: {},
    SVG: {},
    Templates: {},
    webComponentsSupport: false,
    _animationEnd: 'webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend transitionend',
    // No I18N
    _transitionEnd: 'webkitTransitionEnd, otransitionend, oTransitionEnd, msTransitionEnd, transitionend',
    // No I18N
    locale: 'en-US',
    // No I18N
    zIndex: 1000,
    // ZIndex can be used for components like dialog.
    $window: $(window),
    $document: $(document),
    $body: $('body'),
    // No I18N
    DOMUtil: $,
    DOMUtilInstance: window.$ZCDOMUtil || $,
    keys: {},
    minimizeArray: [],
    keyCode: {
      BACKSPACE: 8,
      COMMA: 188,
      DELETE: 46,
      DOWN: 40,
      END: 35,
      ENTER: 13,
      ESCAPE: 27,
      HOME: 36,
      LEFT: 37,
      NUMPAD_ADD: 107,
      NUMPAD_DECIMAL: 110,
      NUMPAD_DIVIDE: 111,
      NUMPAD_ENTER: 108,
      NUMPAD_MULTIPLY: 106,
      NUMPAD_SUBTRACT: 109,
      PAGE_DOWN: 34,
      PAGE_UP: 33,
      PERIOD: 190,
      RIGHT: 39,
      SPACE: 32,
      TAB: 9,
      UP: 38,
      ALT: 18
    },
    isEmpty: function isEmpty(obj) {
      return !(obj && Object.keys(obj).length);
    },
    iterateData: function iterateData(data, callback) {
      return Array(data).join(0).split(0).map(callback);
    },
    getKebabCaseKey: function getKebabCaseKey(string) {
      return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    },
    getID: function getID(cName, element, prefix, suffix) {
      cName = cName || ''; // No I18N

      if (element instanceof this.DOMUtilInstance) {
        element = element[0];
      }

      return element && element.id || cName + '-' + (prefix ? prefix + '-' : '') + Math.round(Math.random() * 100000000) + (suffix ? '-' + suffix : ''); // No I18N
    },
    _getIconInfo: function _getIconInfo(iconClass, svgIconId, defaultSVGId, defaultIconClassName, options) {
      var svgIconClass, hasIcon;
      options = options || {};
      svgIconId = !iconClass && !svgIconId ? defaultSVGId : svgIconId;

      if (svgIconId) {
        var iconInfo = svgIconId.split(' '); // No I18N

        svgIconId = iconInfo[0];
        svgIconClass = iconInfo[1] ? iconInfo.slice(1).join(' ') : undefined; // No I18N

        iconClass = undefined;
        hasIcon = true;
      }

      options.icon = hasIcon || defaultIconClassName || iconClass;
      options.iconClassName = ((defaultIconClassName || '') + ' ' + (iconClass || '')).trim(); // No I18N

      options.SVGIconClassName = svgIconClass || options.SVGIconClassName || ''; // No I18N

      if (svgIconId) {
        options.SVGIconId = (svgIconId.indexOf('#') < 0 ? '#' : '') + svgIconId; // No I18N
      }

      return options;
    },
    createElement: function createElement(opt, compWOPrefix, doNotInitialize) {
      opt = opt || {};
      var compWithZPrefix = 'z' + compWOPrefix; // No I18N

      var options = Object.create(opt),
          tagNames = ZC.tagNames[compWithZPrefix],
          normalTag = tagNames[0],
          customTag = tagNames[1],
          appendTo = options.appendTo,
          tempElement = options.mainElement || document.getElementById(options.id); // Object.create is used to avoid same memory reference problem.

      if (tempElement) {
        var componentData = $(tempElement).data(compWithZPrefix),
            container,
            _element2;

        if (componentData) {
          if (componentData.container) {
            container = componentData.container[0];
          }

          _element2 = componentData.element[0];
          return options.isCE ? _element2 : container ? [_element2, container] : [_element2];
        }
      }

      var tagName = (options.isCE ? customTag : normalTag) || 'div',
          // No I18N
      domEle = options.id && document.getElementById(options.id),
          element = domEle || document.createElement(tagName),
          $element = $(element),
          attributes = options.customAttributes,
          isCustomTag = tagName.indexOf('-') > -1; // No I18N

      if (options.id) {
        attributes = attributes || {};
        attributes.id = options.id;
      }

      if (attributes) {
        $element.attr(attributes);
      } // This part of code is moved above, since for datepicker like components, setProperties has to be called before the children components are initialized
      // (faced an issue for beforedatecellrender event)


      if (isCustomTag) {
        // window.setTimeout(function() { // ##revisit temporarily added since setProperties is undefined error thrown.
        element.setProperties(options); // }, 20)
        // element.textContent = options.text; to be removed
      }

      if (!options.templateRender) {
        appendTo = $(appendTo || 'body')[0];

        if (options.insertBefore) {
          appendTo.parentNode.insertBefore(element, appendTo);
        } else {
          appendTo.appendChild(element);
        }
      }

      if (!isCustomTag && !doNotInitialize) {
        var instance = ZC[compWOPrefix]($element, options); // Initialize the component if its not a custom tag.

        if (opt.templateRender) {
          // If this.container & this.element are different, both this.element and this.container should be moved to the appropriate position in the template.
          if (instance.container && instance.container[0] !== instance.element[0]) {
            return [instance.element[0], instance.container[0]];
          }

          return [instance.element[0]];
        }

        return instance.element;
      }

      return element;
    },
    OS: {
      isLinux: function isLinux() {
        return navigator.appVersion.indexOf('Linux') > -1;
      },
      isMac: function isMac() {
        return /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
      },
      isWindows: function isWindows() {
        return navigator.platform.indexOf('Win') > -1; // No I18N
      }
    },
    _getEvents: function _getEvents() {
      var current = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return parent.concat(current).filter(function (elem, pos, arr) {
        return arr.indexOf(elem) === pos;
      });
    },
    registerComponent: function registerComponent(componentName, parentComponent, protoObj) {
      var subComponent;

      if (protoObj) {
        subComponent = true;
      } else {
        protoObj = parentComponent;
        parentComponent = this.CoreComponent;
      }

      var len = objectProperties.length,
          prop;
      var compWOPrefix = componentName.toLowerCase().replace(/^z/, ''); // No I18N

      var compWithZPrefix = 'z' + compWOPrefix; // No I18N

      var parentProto = parentComponent.prototype; // typeof protoObj will be a function for Javascript ES6 Class.

      if (subComponent && _typeof(protoObj) === 'object') {
        // No I18N
        protoObj = this._objectTypeFallback(protoObj, compWithZPrefix, parentComponent, parentProto);
      }

      var proto = protoObj.prototype,
          tempProp;

      for (var i = 0; i < len; i++) {
        prop = objectProperties[i];
        tempProp = prop.replace('_', ''); // No I18N

        if (prop === '_EVENTS') {
          proto[prop] = this._getEvents(proto[tempProp], parentProto[tempProp]);
          proto[prop] = this._getEvents(proto[prop], parentProto[prop]);
          proto[prop].push('beforedestroy'); // No I18N
        } else {
          proto[prop] = $.extend(true, prop === '_attrs' ? {
            rtl: false,
            templateData: null,
            templateFunc: null,
            zclassName: null,
            templateRender: null
          } : {}, parentProto[tempProp] || {}, parentProto[prop] || {}, proto[tempProp] || {});
        }
      }

      proto._DEFAULTS = $.extend(true, {}, proto._attrs, proto._props); // Since we have used 'z' prefix in all the templates & tagNames

      var tagNames = ZC.tagNames[compWithZPrefix];

      if (tagNames && tagNames[1] && this.webComponentsSupport) {
        this.register(tagNames[1], protoObj, parentComponent);
      }

      this[componentName] = protoObj;

      if (!this[compWithZPrefix]) {
        var DEFAULTS = {},
            Templates = {};

        if (subComponent) {
          var parentObject = this[parentProto.name];

          if (parentObject) {
            $.extend(Templates, parentObject.Templates);
          }
        }

        this[compWithZPrefix] = {
          DEFAULTS: DEFAULTS,
          Templates: Templates
        };
        var methodName = 'create' + componentName.substr(1); // No I18N

        if (!ZC[methodName]) {
          ZC[methodName] = function (options) {
            return ZC.createElement(options, compWOPrefix);
          };
        }
      }

      this[compWOPrefix] = function (element, options) {
        // To Support ZC.<componentName>() Invocation.
        element = $(element);

        if (element.length > 1) {
          // To help initializing multiple elements.
          var resultArray = [];

          for (var k = 0; k < element.length; k++) {
            resultArray[k] = this._createComponent(element[k], options, componentName, protoObj);
          }

          return resultArray;
        }

        return this._createComponent(element, options, componentName, protoObj);
      };

      var compPluginName = this.pluginPrefix + compWOPrefix;

      $.prototype[compPluginName] = function (options) {
        // Assigning the childComponent to global scope... [ Alternative to JQuery's Method ]
        var returnValue = this,
            length = this.length;

        if (!options || _typeof(options) === 'object') {
          // component is initialized
          options = options || {};

          for (var _i = 0; _i < length; _i++) {
            ZComponents._createComponent(this[_i], options, componentName, protoObj, true);
          }
        } else if (typeof options === 'string' && options.indexOf('_') < 0) {
          // No I18N
          // Public Method Invocation
          var params = Array.prototype.slice.call(arguments, 1);

          for (var _i2 = 0; _i2 < length; _i2++) {
            var componentInstance = $(this[_i2]).data(compWithZPrefix);

            if (componentInstance) {
              returnValue = componentInstance[options].apply(componentInstance, params);
            }
          }
        } else {
          return false;
        }

        return returnValue;
      };
    },
    _defineGetProp: function _defineGetProp(proto, attrName, value) {
      Object.defineProperty(proto, attrName, {
        get: function get() {
          return value;
        }
      });
    },
    _extend: function _extend(target, base) {
      // target.prototype = $.extend({},base.prototype,target.prototype);
      $.each(target.prototype, function (prop, value) {
        if (typeof value === 'function') {
          // No I18N
          target.prototype[prop] = function () {
            var _super = function _super() {
              return base.prototype[prop].apply(this, arguments);
            };

            return function () {
              this._super = _super;
              return value.apply(this, arguments);
            };
          }();
        }
      });
    },
    _createComponent: function _createComponent(element, options, cName, prototype, returnElement) {
      element = $(element);
      var cnamelower = cName.toLowerCase();

      if (element[0] && (element[0] === window || element[0].nodeType)) {
        var _element$data;

        if (element.data(cnamelower)) {
          return returnElement ? element : element.data(cnamelower);
        }

        var data = this._getInitOpts(element, cnamelower, options, prototype),
            instance = new ZComponents[cName](element, data, options);

        if (ZC.environment === 'development' && ZC.handleExceptions) {
          // No I18N
          // Exception handling will be performed for development environment only.
          instance = ZC.handleExceptions(instance);
        }

        if (!document.body.contains(element[0])) {
          // existing element was removed during component initialization.
          element = instance.element;
        }

        element.data((_element$data = {}, _defineProperty(_element$data, cnamelower, instance), _defineProperty(_element$data, "componentName", cnamelower), _element$data));
        return instance;
      }
    },
    _getInitOpts: function _getInitOpts(element, componentName, options, mainProto) {
      var eleOptions = ZC._getOpts(element, mainProto);

      if (eleOptions.override) {
        // handling the case where two or more components share the same set of attributes.
        var newArray = {};

        for (var obj in eleOptions) {
          if (obj.indexOf(componentName) === 0) {
            var result = obj.replace(componentName, ''),
                // No I18N
            keyName = result[0].toLowerCase() + result.substring(1);
            newArray[keyName] = eleOptions[obj];
          }
        }

        eleOptions = newArray;
      }

      return $.extend(true, {}, ZC[componentName] ? ZC[componentName].DEFAULTS : {}, eleOptions, options);
    },
    _getOpts: function _getOpts(element, mainProto) {
      element = element instanceof ZC.DOMUtilInstance ? element[0] : element;

      if (element) {
        var tagName = element.tagName || '',
            object; // NeedCodeRevisit

        if (window.customElements ? customElements.get(tagName.toLowerCase()) : undefined) {
          object = element.$c[element.$c.parentElement ? '_subOpts' : '_opts']; // No I18N
        } else {
          object = $.data(element, 'ZCOpts'); // No I18N

          if (!object && element.attributes) {
            var dataAttr = element.getAttribute('data'); // No I18N

            if (dataAttr) {
              // Retrieving options present in data attribute as a json.
              object = ZComponents._getObject(dataAttr, element, mainProto);
            }

            object = this[element.dataset ? '_getDataSet' : '_getDataAttributes'](element, object || {}, mainProto); // No I18N

            $.data(element, 'ZCOpts', object); // No I18N
          }
        }

        return object || {};
      }
    },
    getOpts: function getOpts() {
      return ZC._getOpts.apply(ZC, arguments);
    },
    _getObject: function _getObject(data, element, mainProto, aName) {
      if (_typeof(data) === 'object') {
        // No I18N
        return data;
      }

      data = data || element.getAttribute('data'); // No I18N

      data = data.indexOf('{') < 0 ? "{ ".concat(data, " }") : data; // No I18N

      try {
        data = JSON.parse(data.replace(/'/g, '"')); // No I18N
      } catch (error) {
        // props check added since data might contain braces in them intentionally.
        data = !aName || mainProto && Object.keys(mainProto.prototype._props).indexOf(aName) > -1 ? {} : data;
      }

      return data;
    },
    _getDataSet: function _getDataSet(element, object, mainProto) {
      var data = element.dataset,
          value;

      for (var i in data) {
        // Removed hasOwnProperty check since i will be obviously present in data

        /* replace svg and Html as Caps */
        value = data[i];
        i = i.replace(/(Html|Svg|svg|Hsv|Hsl|Rgb)/g, function (x) {
          return x.toUpperCase();
        });
        object[i] = value === 'true' || value === 'false' ? value === 'true' : value.indexOf('{') < 0 ? value : ZComponents._getObject(value, undefined, mainProto, i); // No I18N
      }

      return object;
    },
    _getDataAttributes: function _getDataAttributes(element, object, mainProto) {
      var data = element.attributes,
          len = data.length;

      for (var i = 0; i < len; i++) {
        var name = data[i].nodeName,
            value = data[i].nodeValue === '' ? 'true' : data[i].nodeValue; // No I18N

        if (name !== 'data' && name.match(/^data-/)) {
          // No I18N
          // data-* attributes and other attributes
          name = ZC._getCamelCaseStr(name.replace(/^data-/, '')); // No I18N

          /*  replacing the hyphenated names to camelCase
              modified the optionName since providing data-inner-html attribute in html element will be converted to innerHtml only.
              replace svg and Html as Caps */

          object[name] = value === 'true' || value === 'false' ? value === 'true' : value.indexOf('{') < 0 ? value : ZC._getObject(value, undefined, mainProto, name); // No I18N
        }
      }

      return object;
    },
    _getCamelCaseStr: function _getCamelCaseStr(str) {
      return str.replace(/(-html|-svg|svg|-hsv|-hsl|-rgb)|(-\w)/gi, function (x) {
        return x.replace('-', '').toUpperCase();
      }); // changing the Ui by using the above regex replaces the menuId key also. So, we need below stmt in addition.
      // Since, it is a costly operation, Currently that component needs to handle it. If we need this for more no of components, we will enable them.
      // str = str.replace(/(ui|Ui)[A-Z]+/g, function(match){ return match.toUpperCase()});
    },
    _init: function _init() {
      if (ZComponents.webComponentsSupport) {
        var componentList = ZComponents.webComponents;

        if (componentList) {
          for (var key in componentList) {
            if (!customElements.get(key)) {
              window.customElements.define(key, componentList[key].definition);
            }
          }
        }

        window.document.dispatchEvent(new CustomEvent('zwebcomponentsready', {
          // No I18N
          bubbles: true
        }));
      }

      ZComponents.setProperties();
    },
    setProperties: function setProperties() {
      var doc = document.documentElement || {},
          body = document.body || {};
      ZComponents.documentObject = {
        height: Math.max(doc.clientHeight, doc.scrollHeight, doc.offsetHeight, body.offsetHeight, body.scrollHeight),
        width: Math.max(doc.clientWidth, doc.scrollHeight, doc.offsetHeight, body.offsetWidth, body.scrollWidth)
      };
      ZComponents.windowObject = {
        height: window.innerHeight,
        width: window.innerWidth
      };
    },
    _render: function _render(data, componentName, templateName, element, appendTo, otherParams) {
      // No I18N
      var isCE = otherParams.isCE;
      var skipParent = otherParams.skipParent;
      var container = otherParams.container;
      var refElement = otherParams.refElement;
      var isContainer = false,
          templates = ZC[componentName].Templates;
      data.zElement = false;
      templateName = templateName || 'children'; // No I18N

      templateName = isCE ? 'WC' + (templateName[0].toUpperCase() + templateName.substr(1)) : templateName;

      if (!skipParent && !container) {
        var _templateFunc = templates[isCE ? 'WCContainer' : 'container']; // No I18N

        if (_templateFunc) {
          element = ZT.DOM(_templateFunc(data)); // No I18N

          if (appendTo) {
            $(element).appendTo(appendTo);
          } else if (refElement) {
            $(element).insertAfter(refElement);
          }

          isContainer = true;
        }
      } else {
        element = element || (skipParent ? container || refElement : refElement);
      }

      var templateFunc = templates[templateName];

      if (templateFunc) {
        ZT.renderView(templateFunc(data), element);
      }

      if (isContainer) {
        data.zElement = true;
        !data.isCE && !data.differentAppend && $(refElement).hide();
      }

      return element; // element has to be returned always since methods using ZC._render has stored the element for further processing.
    },
    // stored in ZC scope in order to use in Alert Dialog like components.
    _handleFocus: function _handleFocus(element, componentName) {
      element = $(element);
      var keyCodes = ZC.keyCode,
          keyCode,
          focusClass = 'has-focus',
          // No I18N
      mfocusCls = 'has-mfocus',
          // No I18N
      kfocusCls = 'has-kfocus',
          // No I18N
      nameSpace = '.fs.' + componentName,
          // No I18N
      eventType = '',
          // No I18N
      isUI = false,
          blurEventName = 'blur' + nameSpace,
          // No I18N
      focusEventName = 'focus' + nameSpace,
          // No I18N
      eventNames = 'mousedown' + nameSpace + ' keydown' + nameSpace + ' keyup' + nameSpace; // No I18N

      /* Since event order is mousedown, focus, mouseup followed by click. Binding mousedown here. */

      element.off(eventNames + ' ' + blurEventName + ' ' + focusEventName).on(eventNames, function (event) {
        // No I18N
        if (event.originalEvent && event.type !== 'keyup') {
          // No I18N
          // If the element is already active element, then the focus event is not triggered after mousedown. So, activeElement check included.
          isUI = document.activeElement !== element[0]; // since originalEvent is present for triggered focus events too. Maintaining a variable to distinguish triggered focus and UI focus.
        }

        keyCode = event.keyCode;
        eventType = event.type === 'mousedown' ? mfocusCls : kfocusCls; // No I18N

        if (event.type === 'keydown' && keyCode !== keyCodes.ENTER && keyCode !== keyCodes.SPACE || event.type === 'keyup' && keyCode !== keyCodes.TAB) {
          // No I18N
          return;
        }

        element.addClass(focusClass + ' ' + eventType); // No I18N
      }).on(blurEventName, function () {
        return element.removeClass(focusClass + ' ' + mfocusCls + ' ' + kfocusCls);
      }) // No I18N
      .on(focusEventName, function () {
        // originalEvent check is added since trigger(focus) should focus the element.
        if (!isUI) {
          element.addClass(focusClass + ' ' + kfocusCls);
        }

        isUI = false;
      });
    },
    encodeHTML: function encodeHTML(str) {
      sourceText.nodeValue = str;
      return sourceDiv.innerHTML;
    },
    // Component Users can set I18N for all Components at once or individual components separately.
    setI18NKeys: function setI18NKeys(moduleName, values, replace) {
      if (_typeof(moduleName) === 'object') {
        // No I18N
        // {"zdialog" : {"close":"Close the Dialog"},"ztooltip":{"close": "Close Text"} }
        for (var i in moduleName) {
          this.keys[i] = $.extend({}, this.keys[i], moduleName[i]);
        }
      } else {
        // module name is a string. Format: "zdialog",{ "close" : "Close the Dialog"}, true or false
        this.keys[moduleName] = replace ? values : $.extend({}, this.keys[moduleName], values);
      }
    },
    _triggerFunction: function _triggerFunction(functionName, context, params) {
      // Invoking functions which are passed as strings in HTML Elements.
      var executionContext = ZC._getContext(functionName);

      return executionContext && executionContext.apply(context, params);
    },
    _getContext: function _getContext(functionName) {
      if (typeof functionName === 'string') {
        var executionContext = window,
            namespaces = functionName.split('.'); // No I18N

        for (var i = 0; i < namespaces.length && executionContext; i++) {
          executionContext = executionContext[namespaces[i]];
        }

        return executionContext;
      }

      return functionName;
    },
    getI18NText: function getI18NText(moduleName, key, stringArray) {
      var defaultKeys;

      if (arguments.length === 4) {
        defaultKeys = stringArray;
        stringArray = arguments[3];
      }

      var keyObject = ZComponents.keys[moduleName] || {},
          ii8nText = keyObject[key] || '';

      if (ii8nText === '' && defaultKeys) {
        // No I18N
        ii8nText = defaultKeys[key];
      }

      if (stringArray) {
        for (var i = 0; i < stringArray.length; i++) {
          ii8nText = ii8nText.replace('{' + i + '}', stringArray[i]); // No I18N
        }
      }

      return ii8nText;
    },
    create: function create(initObject) {
      var componentName = initObject.ctype.replace(initObject.ctype.charAt(0), ''); // No I18N

      return this['create' + componentName.charAt(0).toUpperCase() + componentName.substring(1)](initObject); // No I18N
    },
    getRTLBasedDir: function getRTLBasedDir(direction, rtl) {
      if (rtl) {
        return direction.replace(/(left|right)/, function ($0) {
          return $0 === 'left' ? 'right' : 'left';
        }); // No I18N
      }

      return direction;
    },
    Browser: {
      isMobile: /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent),
      isIE: userAgent.indexOf('msie') > -1 || userAgent.indexOf('.net') > -1,
      // No I18N
      isEdge: userAgent.indexOf('edge') > -1,
      // No I18N
      isSafari: userAgent.indexOf('safari') > -1 && userAgent.indexOf('chrome') < 0,
      // No I18N
      isChrome: window.chrome,
      isFirefox: userAgent.indexOf('firefox') > -1,
      getIEVersion: function getIEVersion() {
        var rv = -1; // Return value assumes failure.

        if (ZC.Browser.isIE) {
          var match = userAgent.match(/MSIE (\d*)/i);

          if (!match) {
            match = userAgent.match(/Trident.*rv:(\d*)/i);
          }

          if (match) {
            rv = parseInt(match[1]);
          }
        }

        return rv;
      },
      getFirefoxVersion: function getFirefoxVersion() {
        var res = -1;

        if (ZC.Browser.isFirefox) {
          res = parseInt(userAgent.match(/Firefox\/(\d*)/i)[1]);
        }

        return res;
      }
    },
    _objectTypeFallback: function _objectTypeFallback(protoObj, cnamelower, parentComponent, parentProto) {
      var propsToBeMergedWithParent = ['name', 'attrs', 'props', 'CLASSES', 'EVENTS', 'SELECTORS']; // No I18N

      protoObj.name = cnamelower; // class is created by extending parent component

      var childClass =
      /*#__PURE__*/
      function (_parentComponent) {
        _inherits(childClass, _parentComponent);

        function childClass() {
          _classCallCheck(this, childClass);

          return _possibleConstructorReturn(this, _getPrototypeOf(childClass).apply(this, arguments));
        }

        return childClass;
      }(parentComponent);

      var childPrototype = childClass.prototype;

      for (var property in protoObj) {
        if (protoObj.hasOwnProperty(property)) {
          var value = protoObj[property];
          var parentValue = childPrototype[property];
          var propertyDescriptor = void 0;
          var isFunc = typeof value === 'function'; // No I18N

          var doesParentHasProperty = void 0;

          if (!isFunc) {
            var currentProto = parentProto; // Looping is done becos property descriptor is not returned if it is the property of the __proto__ object.

            while (currentProto && !(doesParentHasProperty = currentProto.hasOwnProperty(property))) {
              currentProto = Object.getPrototypeOf(currentProto);
            }

            if (doesParentHasProperty) {
              propertyDescriptor = Object.getOwnPropertyDescriptor(currentProto, property);
            }
          } // If function, property descriptor need not be checked.
          // If the property is writable, it could be assigned directly. Else it is deleted and reassigned using getter in the else part.


          if (isFunc || !doesParentHasProperty || propertyDescriptor.writable) {
            childPrototype[property] = value;
          } else {
            if (doesParentHasProperty) {
              if (_typeof(value) === 'object') {
                // No I18N
                // The property need not be deleted because it is not present in the childPrototype but in its prototype chain.
                // delete childPrototype[property];
                // Only certain properties are merged, others are overridden.
                if (propsToBeMergedWithParent.indexOf(property) !== -1) {
                  if (Array.isArray(value)) {
                    value = parentValue.concat(value);
                  } else {
                    value = $.extend(true, {}, parentValue, value);
                  }
                }
              } else if (value === parentValue) {
                continue; // delete childPrototype[property];
              }
            }

            this._defineGetProp(childPrototype, property, value);
          }
        }
      }

      this._extend(childClass, parentComponent);

      protoObj = childClass;
      return protoObj;
    }
  };
  window.ZComponents = ZComponents;
  var ZC = ZComponents;
  ZC.Templates.Utilities = {};
  document.addEventListener('DOMContentLoaded', ZC._init); // No I18N

  window.addEventListener('resize', ZC.setProperties); // No I18N

  var CoreComponent =
  /*#__PURE__*/
  function () {
    _createClass(CoreComponent, [{
      key: "name",
      get: function get() {
        return "corecomponent";
      }
    }]);

    function CoreComponent(element) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, CoreComponent);

      // this.name = this.constructor.name || this.constructor.name.toLowerCase(); // construtor.name will be present for components which is extended by simply providing an object.
      this.element = element; // ZC[this.name] ? ZC[this.name].DEFAULTS : {}, ZC._getOpts(element) were removed form assigning to this._opts
      // which was already handled by getOpts()

      this._opts = $.extend(true, {}, this._DEFAULTS, options);

      this._create(element, this._opts);
      /* Common Getter and Setter Methods for all properties present in a Component. */
      // NeedCodeRevisit - This function call is need?


      if (element) {
        this._defineGetterSetter();
      }
    }

    _createClass(CoreComponent, [{
      key: "_getID",
      value: function _getID(element, prefix, suffix) {
        return ZC.getID(this.name, element, prefix, suffix);
      }
    }, {
      key: "_alterBorderRadius",
      value: function _alterBorderRadius(opts, clear) {
        return ZC.alterBorderRadius && ZC.alterBorderRadius(_objectSpread({}, opts, {
          element: opts.element || this.getElement(),
          forElement: opts.forElement || this._opts.forElement
        }), clear);
      }
    }, {
      key: "_isValid",
      value: function _isValid(key, value) {
        return this._ALLOWEDVALUES[key].indexOf(value) > -1;
      }
      /** Should be removed after discussing with Raju - Revisit
      _bindHandlers(events) {
          for (let handler in events) {
              let eventInfo = events[handler],
                  eventNames, key = handler + 'Handler', // No I18N
                  isDynamicEvent = false;
              if (typeof eventInfo === 'string') {
                  eventNames = eventInfo.split(' ')
              } else if (typeof eventInfo === 'object') {
                  isDynamicEvent = true;
                  eventNames = eventInfo.event.split(' ');
              }
              this._data[key] = {
                  namespace: this.name,
                  handler: this['_' + handler + 'Handler'].bind(this)
              }
              if (eventNames.length > 1 || isDynamicEvent) {
                  this._data[key].eventNames = eventNames;
              }
          }
      } */

    }, {
      key: "_addEvents",
      value: function _addEvents(eventHandlers) {
        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getElement();

        for (var handler in eventHandlers) {
          var _event = this._suffixCName(eventHandlers[handler]);

          _event && element.off(_event).on(_event, this['_' + handler + 'Handler'].bind(this)); // No I18N
        }
      }
    }, {
      key: "_suffixCName",
      value: function _suffixCName(events) {
        var _this = this;

        return events ? events.split(' ').reduce(function (acc, event) {
          return acc + event + '.' + _this.name + ' ';
        }, '') : '.' + this.name; // No I18N
      }
    }, {
      key: "_removeEvents",
      value: function _removeEvents(events) {
        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getElement();
        element.off(this._suffixCName(events));
      }
    }, {
      key: "_setParentClass",
      value: function _setParentClass(value) {
        var data = this._data,
            oldValue = data.parentClass;

        if (oldValue !== value) {
          var element = this._useParent || !this.container ? this.element : this.container;

          if (element) {
            oldValue && element.removeClass(oldValue);
            element.addClass(value);
          }

          this._data.parentClass = value;
        }
      }
    }, {
      key: "_commonPropSetters",
      value: function _commonPropSetters() {
        this._data = {};
        var opts = this._opts,
            element = this.element[0],
            dir = element.dir || document.body.dir; // No I18N

        opts.rtl = dir === 'rtl' || opts.rtl; // No I18N

        if (opts.templateData && _typeof(opts.templateData) === 'object') {
          // No I18N
          $.extend(true, this._data, opts.templateData);
        }

        this._data.isCE = opts.isCE; // Removed window.getComputedStyle since it is recalculating the style and takes a lot of time to execute.
      }
    }, {
      key: "_create",
      value: function _create(element, options) {
        this._commonPropSetters();

        this._useParent = this.isCE;

        this._init.apply(this, arguments);

        if (this._useParent) {
          this.container = element;
        }

        var opts = this._opts; // Attributes & class names will be added to the parent containers only when the container is not created from template.

        var base = this;
        this._data.parentClass = (opts.zclassName || opts.className || '') + (opts.rtl ? ' zh-rtl' : '');
        Object.defineProperty(this._data, 'className', {
          // No I18N
          set: function set(value) {
            base._setParentClass(value || base._data.parentClass);
          },
          get: function get() {
            return base._data.parentClass;
          }
        });

        this._initialRender();

        this._construct.apply(this, arguments);

        this._data.rendered = true;

        this._bindEvents();
      }
    }, {
      key: "_initialRender",
      value: function _initialRender() {
        this._render();
      }
    }, {
      key: "_appendEle",
      value: function _appendEle(appendTo) {
        if (appendTo) {
          appendTo = $(appendTo)[0];

          if (appendTo) {
            var container = this.getElement()[0];

            if (appendTo.lastElementChild !== container) {
              appendTo.appendChild(container);
            }
          }
        }
      }
    }, {
      key: "_init",
      value: function _init() {}
    }, {
      key: "_buildData",
      value: function _buildData() {}
    }, {
      key: "_postRender",
      value: function _postRender() {}
    }, {
      key: "_postEachRender",
      value: function _postEachRender() {}
    }, {
      key: "_preRender",
      value: function _preRender(data) {
        return data;
      }
    }, {
      key: "_construct",
      value: function _construct() {}
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {}
    }, {
      key: "_handleFocus",
      value: function _handleFocus(element, eludeFocusBinding) {
        ZC._handleFocus(element || this.container, this.name, eludeFocusBinding);
      }
    }, {
      key: "_defineGetterSetter",
      value: function _defineGetterSetter() {
        var attrName,
            compAttrs = Object.keys(this._DEFAULTS),
            len = compAttrs.length,
            i;

        for (i = 0; i < len; i++) {
          attrName = compAttrs[i]; // Checking whether a method is already available in the same name as property.
          // For Ex: In tokenfield component, the name search will be used to denote a property as well as a method.

          if (!this[attrName]) {
            // Not able to checkin by having functions inside loops.. So using another _defineProperty method.
            this._defineProperty(attrName);
          }
        }
      }
    }, {
      key: "_defineProperty",
      value: function _defineProperty(attrName) {
        Object.defineProperty(this, attrName, {
          set: function set(value) {
            this.setAttribute(attrName, value);
          },
          get: function get() {
            return this.getAttribute(attrName);
          }
        });
      }
    }, {
      key: "_display",
      value: function _display(hide) {
        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.element;

        if (!ZC._display) {
          var flexElement = sourceDiv.cloneNode(),
              flexString = ['-webkit-box', '-moz-box', '-ms-flexbox', '-webkit-flex', 'flex'].map(function (val) {
            return 'display:' + val;
          }).join(';'); // No I18N

          document.body.appendChild(flexElement).setAttribute('style', flexString);
          ZC._display = window.getComputedStyle(flexElement).display;
          flexElement.parentElement.removeChild(flexElement);
        } // more than one elements might be passed from the components. For Ex: Refer Date Picker Drilldown Animation. So, reverting the code to jQuery syntax.


        $(element).css('display', hide ? 'none' : ZC._display); // No I18N

        return element;
      }
    }, {
      key: "_dispatchEvent",
      value: function _dispatchEvent(eventName, event, data, element, isFromUI) {
        var eventType = eventName,
            componentName = this.eventPrefix || this.name,
            value;

        if (this.isCE) {
          eventType = 'z' + eventType; // No I18N
        }

        var type = eventType || eventName;
        element = element || this.element;
        var prop,
            orig,
            callback = this._opts[type];
        data = data || {};
        data.fromUI = isFromUI;
        data.element = element;
        data.container = this.getElement();
        data.options = this._opts;
        event = $.Event(event);
        event.type = (componentName && !this.isCE ? componentName + type : type).toLowerCase(); // the original event may come from any element
        // so we need to reset the target on the new event

        event.originalTarget = event.target; // saving the original target.

        event.target = element;
        orig = event.originalEvent;

        if (orig) {
          for (prop in orig) {
            if (!(prop in event)) {
              event[prop] = orig[prop];
            }
          }
        }

        if (this.isCE) {
          event = this._dispatchCEEvent(eventType, data, element, event.originalEvent);
        } else {
          event.detail = data; // Executing the callbacks assigned as property to the instance. Example: instance.onclick = function(){}

          element.trigger(event, data);
        } // Temporarily commented. Need to discuss. - Revisit
        // type = type[0].toUpperCase()+type.substr(1);


        if (this['on' + type]) {
          this['on' + type](event, data);
        }

        data = [event].concat(data);

        if (!this.isCE) {
          if (callback && typeof callback === 'string') {
            // No I18N
            value = ZC._triggerFunction(callback, element[0], data);
          } else {
            value = typeof callback === 'function' ? callback.apply(element, data) : undefined; // No I18N
          }
        }

        return typeof value === 'boolean' ? value : !event.isDefaultPrevented(); // No I18N
      }
    }, {
      key: "_getRTLBasedDir",
      value: function _getRTLBasedDir(dir) {
        return ZC.getRTLBasedDir(dir, this._opts.rtl);
      }
    }, {
      key: "_getI18NText",
      value: function _getI18NText(key, stringArray, optionKey) {
        var defaultKeys = this._opts.labels || this._opts.messages,
            i18nText = optionKey ? this._opts[optionKey][key] : undefined;

        if (i18nText) {
          return i18nText;
        }

        var keyObject = ZC.keys[this.name] || {},
            ii8nText = keyObject[key] || ''; // No I18N

        if (ii8nText === '' && defaultKeys) {
          // No I18N
          ii8nText = defaultKeys[key];
        }

        if (stringArray) {
          for (var i = 0; i < stringArray.length; i++) {
            ii8nText = ii8nText.replace("{".concat(i, "}"), stringArray[i]);
          }
        }

        return ii8nText;
      }
    }, {
      key: "listen",
      value: function listen(eventName, callback) {
        this['on' + (eventName[0].toUpperCase() + eventName.substr(1)).replace(this.name, '')] = callback; // No I18N
      }
    }, {
      key: "getElement",
      value: function getElement() {
        return this.container || this.element;
      }
    }, {
      key: "getAttribute",
      value: function getAttribute(optionName) {
        return this._opts[optionName];
      }
    }, {
      key: "getAttributes",
      value: function getAttributes() {
        return $.extend(true, {}, this._opts); // extending in order to avoid object overriding.
      }
    }, {
      key: "setAttributes",
      value: function setAttributes(options) {
        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.element;

        for (var i in options) {
          this.setAttribute(i, options[i], true);
        }

        this._renderAttrChange();
      } // This method is used to convert a JSON object to a valid style string that can be used for the template.

    }, {
      key: "_getStyle",
      value: function _getStyle(obj) {
        if (obj && _typeof(obj) === 'object') {
          // No I18N
          var styleStr = ''; // No I18N

          for (var key in obj) {
            if (obj[key]) {
              styleStr += "".concat(key, ":").concat(obj[key], ";");
            }
          }

          return styleStr;
        }

        return obj; // the following method replaces comma in values as well and forloop is faster than stringify so it is replaced.
        // return JSON.stringify(obj).replace(/{|}|"/g, '').replace(/,/g, ';'); // No I18N
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute() {}
    }, {
      key: "_getOptVal",
      value: function _getOptVal(value, oldValue) {
        if (value && _typeof(value) === 'object' && _typeof(oldValue) === 'object') {
          // No I18N
          if (!(value instanceof Array) && !(oldValue instanceof Array) && !(value instanceof Date) && !(value instanceof RegExp) && !(value instanceof $) && !(value instanceof Element) && value !== window && !value.nodeName) {
            return $.extend(true, {}, oldValue, value);
          }

          return value;
        }

        return value;
      }
    }, {
      key: "_isNotNull",
      value: function _isNotNull(value) {
        return !this._isNull(value);
      }
    }, {
      key: "_isNull",
      value: function _isNull(value) {
        return value === undefined || value === null;
      }
    }, {
      key: "_render",
      value: function _render(data) {
        var templateName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._opts.templateFunc;
        var element = arguments.length > 2 ? arguments[2] : undefined;
        var skipParent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._skipParent;
        data = data || Object.assign({}, this._opts, this._data);
        data = this._preRender(data);
        var componentName = this._opts.templateName || this.name;
        var hasContainer = !!ZC[componentName].Templates[data.isCE ? 'WCContainer' : 'container']; // No I18N
        // Snippet to use existing container instead of creating new one.
        // if (!data.rendered && hasContainer) {
        //     let containerId = data.attrs && data.attrs.id;
        //     if (containerId) {
        //         let outerContainer = $('#' + containerId); // No I18N
        //         if (outerContainer.length) {
        //             hasContainer = false;
        //             this.container = outerContainer;
        //         }
        //     }
        // }

        skipParent = typeof skipParent === 'boolean' ? skipParent : hasContainer ? data.rendered : true; // No I18N

        var renderParam = {
          isCE: this._data.isCE,
          skipParent: skipParent,
          container: this.container ? this.container[0] : undefined,
          refElement: this.element && !data.differentAppend ? this.element[0] : undefined
        }; // this._opts.templateName is used to prevent default template name from running.

        var container = ZC._render(data, componentName, templateName, element, data.differentAppend, renderParam);

        if (container && data.zElement) {
          // ZC._render always returns values. Since specific template can be rendered by setting skipParent as true, assigning this.container in that case will be erroneous. So, added skipParent check too.
          this.container = $(container);
        }

        var parentEle = this.getElement();

        if (data.attrs) {
          element = data.alwaysSetAttrs ? parentEle : element ? $(element) : this._useParent || !this.container ? this.element : undefined;

          if (element) {
            element.attr(data.attrs);
          }
        }

        if (!this._data.rendered) {
          this._postRender(parentEle, this._opts);
        }

        this._postEachRender(parentEle, data);

        return container;
      }
    }, {
      key: "setAttribute",
      value: function setAttribute(optionName, value, isInternal) {
        var _this2 = this;

        var opts = this._opts,
            oldValue = opts[optionName],
            isSpecialAttr,
            container = this.getElement();

        if (value === undefined) {
          value = this._DEFAULTS[optionName];
        } // Added null check since null is an object


        if ((_typeof(oldValue) !== 'object' || oldValue === null) && oldValue === value) {
          // No I18N
          // checking whether the value is actually modified or not.
          return;
        }

        value = this._getOptVal(value, oldValue);

        if (this.isCE && this.element[0]._initialized || !this.isCE) {
          this._setAttribute(optionName, value);
        } // Added container check since some components do not have container itself. Eg: List


        isSpecialAttr = container && !this._stopAttrUpdate;

        if (isSpecialAttr) {
          if (optionName === 'rtl') {
            // No I18N
            container[value ? 'addClass' : 'removeClass']('zh-rtl'); // No I18N
          } else if (optionName === 'className' || optionName === 'zclassName') {
            // No I18N
            this._updateClass(value, oldValue);
          } else if (optionName === 'disabled') {
            // No I18N
            this._disable(value);
          } else if (optionName === 'appendTo') {
            // No I18N
            this._appendEle(value || 'body'); // No I18N

          } else if (optionName === 'templateFunc') {
            // No I18N
            this._domChanged = true;
          } else if (optionName === 'templateData') {
            // No I18N
            if (value) {
              $.extend(true, this._data, value);
              this._domChanged = true;
            } else if (oldValue) {
              Object.keys(oldValue).forEach(function (key) {
                return _this2._data[key] = null;
              });
              this._domChanged = true;
            }
          } else {
            isSpecialAttr = false;
          }
        }

        this._stopAttrUpdate = false;

        if (isSpecialAttr) {
          opts[optionName] = value;
        }

        if (!isInternal) {
          this._renderAttrChange();
        }
      }
    }, {
      key: "_renderAttrChange",
      value: function _renderAttrChange() {
        if (this._reInit) {
          this._domChanged = true;

          this._buildData();
        }

        if (this._domChanged) {
          this._render();

          this._domChanged = this._reInit = false;
        }
      }
    }, {
      key: "_setBtnValue",
      value: function _setBtnValue(attrs, btnObj) {
        var mainElement = btnObj && btnObj.mainElement;

        if (mainElement) {
          ZC.button(mainElement).setAttributes(attrs);
        } else {
          this._domChanged = true;
        }
      }
    }, {
      key: "_setUndefined",
      value: function _setUndefined(arr, addTxt) {
        for (var i = 0, len = arr.length; i < len; i++) {
          this['_' + arr[i] + addTxt] = undefined;
        }
      }
    }, {
      key: "_disable",
      value: function _disable(disable, element, preventClsManip) {
        var useData = !element,
            dCls = 'is-disabled'; // No I18N

        element = element || this.getElement();

        if (!preventClsManip) {
          if (useData) {
            this._updateClass(disable ? dCls : '', !disable && dCls);
          } else {
            element[disable ? 'addClass' : 'removeClass'](dCls); // No I18N
          }
        }

        this._addedByComponent = true;

        if (disable) {
          element.attr({
            'aria-disabled': true,
            // No I18N
            disabled: true // No I18N

          });
        } else {
          element.removeAttr('aria-disabled disabled'); // No I18N
        }

        this._addedByComponent = false;
      }
    }, {
      key: "_emptyElement",
      value: function _emptyElement(container, start) {
        while (start) {
          var tempNode = start.nextSibling;
          container.removeChild(start);
          start = tempNode;
        }
      } // To update this._data.className

    }, {
      key: "_updateClass",
      value: function _updateClass(className, removeOrReplace, container) {
        if (container) {
          container[removeOrReplace ? 'removeClass' : 'addClass'](className); // No I18N
        } else {
          var data = this._data,
              oldClass = data.className;

          if (removeOrReplace) {
            if (typeof removeOrReplace === 'boolean') {
              // No I18N
              removeOrReplace = className;
              className = ''; // No I18N
            }

            oldClass = oldClass.replace(new RegExp('(?:^|( +)?)' + removeOrReplace + '(?:$|( +)?)', 'g'), ' ' + className + ' '); // No I18N
          } else {
            oldClass += ' ' + className;
          }

          data.className = oldClass;
        }
      }
    }, {
      key: "_destroy",
      value: function _destroy() {}
    }, {
      key: "destroy",
      value: function destroy() {
        if (this.container || this.element) {
          // This check is added to avoid calling destroy method more than once
          this._dispatchEvent('beforedestroy'); // No I18N


          var $element = this.element,
              container = this.container,
              actualElement = container || $element;
          actualElement.off('.' + this.name);

          this._destroy();

          !container && !this._useParent && $element.empty();
          ZT.removeCacheData(actualElement[0]);
          $element && $element.removeData(this.name).removeData('ZCOpts'); // No I18N

          this._setParentClass(' '); // No I18N
          // undefined is replaced by space since className property setter has undefined check


          if (!this._useParent && container) {
            container.remove();
            $element[0].style.display = ''; // No I18N
          }

          if (this.isCE && !this._eleRemoval) {
            this._destroyCE(true);
          }

          this.container = this.element = undefined;
        }
      }
    }, {
      key: "_translateEToA",
      value: function _translateEToA(result) {
        var locale = this._opts.locale || ''; // No I18N

        if (locale === 'ar' || locale.indexOf('ar-') === 0) {
          // No I18N
          return String(result).replace(/[0-9]/g, function (w) {
            return String.fromCharCode(w.charCodeAt(0) + 1584);
          });
        }

        return result;
      }
    }, {
      key: "_translateAToE",
      value: function _translateAToE(_char) {
        var locale = this._opts.locale || ''; // No I18N

        if (locale === 'ar' || locale.indexOf('ar-') === 0) {
          // No I18N
          return String(_char).replace(/[\u0660-\u0669]/g, function (c) {
            return c.charCodeAt(0) - 0x0660;
          });
        }

        return _char;
      }
    }, {
      key: "_removeSpecialChars",
      value: function _removeSpecialChars(string) {
        return string.replace(/[^a-zA-Z0-9-]/g, ''); // No I18N
      } // _mapJSONToData  (data, key, encode){
      //     let dataMapper = this._opts.dataMapping;
      //     let value;
      //     if (typeof dataMapper === 'function'){ // No I18N
      //         value = dataMapper(data, key);
      //     } else {
      //         value = data[key];
      //     }
      //     return value && encode ? ZC.encodeHTML(value) : value;
      // }

    }, {
      key: "_mapJSONToData",
      value: function _mapJSONToData(data, mapper, encode) {
        if (this._isNotNull(mapper) && this._isNotNull(data)) {
          mapper = mapper.trim().split('.'); // No I18N

          for (var i = 0; i < mapper.length; i++) {
            data = data[mapper[i]];
          }

          return data && encode ? this._encodeContent(data) : data;
        }
      }
    }, {
      key: "_encodeContent",
      value: function _encodeContent(data) {
        return this._opts.isLabelHTMLEncoded ? data : ZC.encodeHTML(data);
      }
    }, {
      key: "_isAlphaNumericKey",
      value: function _isAlphaNumericKey(orgEvent) {
        var keyCode = orgEvent.keyCode;
        return !(orgEvent.metaKey || orgEvent.ctrlKey) && (keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222 || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 97 && keyCode <= 122 || keyCode === ZC.keyCode.SPACE || keyCode === ZC.keyCode.DELETE || keyCode === ZC.keyCode.BACKSPACE);
      }
    }, {
      key: "_getItemId",
      value: function _getItemId(data, baseId) {
        // Special characters are removed while generating the Id.
        var dataMapping = this._opts.dataMapping;
        var id = data.zitemid || (data.unselectable ? ZC.getID(null, baseId) : ZC.encodeHTML(baseId + '-' + this._removeSpecialChars(String(_typeof(data) === 'object' ? this._mapJSONToData(data, dataMapping.value) || this._mapJSONToData(data, dataMapping.label) : data)))); // No I18N

        return id;
      }
    }, {
      key: "_escapeQuery",
      value: function _escapeQuery(query) {
        return query.replace(new RegExp("([',\",(,),\\\\,\\[,\\]])", 'g'), '\\$1'); // No I18N
      }
    }, {
      key: "_getMatchingRegex",
      value: function _getMatchingRegex(query, filter) {
        query = this._escapeQuery(query);
        var regex = {
          contains: '(' + query + ')',
          // No I18N
          startswith: '(^' + query + ')',
          // No I18N
          endswith: '(' + query + '$)',
          // No I18N
          equals: '(^' + query + '$)' // No I18N

        };
        return new RegExp(regex[filter.criteria.toLowerCase()], 'g' + (filter.caseSensitive ? '' : 'i')); // No I18N
      }
    }, {
      key: "_getSearchBy",
      value: function _getSearchBy(fields) {
        if (fields) {
          if (typeof fields === 'string') {
            // No I18N
            fields = fields.split(','); // No I18N
          }
        } else {
          fields = [this._dataMapping.label];
        }

        return fields.map(function (by) {
          return by.trim();
        });
      }
    }, {
      key: "_getCustomContent",
      value: function _getCustomContent(data, template, highlight) {
        var _this3 = this;

        if (template) {
          if (typeof template === 'string') {
            // No I18N
            return template.replace(/(#?#[^# ]+#?#)/g, function (match) {
              var prop = match.replace(/#/g, ''); // No I18N

              var content = data[prop];

              if (_this3._isNotNull(content)) {
                content = _this3._encodeContent(content);

                if (highlight) {
                  content = _this3._highlight(content, prop);
                }

                return content;
              }

              return match;
            });
          } else if (typeof template === 'function') {
            // No I18N
            return template(data);
          }
        } else {
          var content = this._encodeContent(data.label);

          if (highlight) {
            content = this._highlight(content, this._dataMapping.label);
          }

          return content; // No I18N
        }
      }
    }, {
      key: "_isFunc",
      value: function _isFunc(func) {
        return typeof func === 'function'; // No I18N
      }
    }, {
      key: "disable",
      value: function disable() {
        var _disable2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        this._opts.disabled = _disable2;

        this._disable(_disable2);

        this._renderAttrChange();
      }
    }, {
      key: "enable",
      value: function enable() {
        this.disable(false);
      }
    }]);

    return CoreComponent;
  }();

  ZC.CoreComponent = CoreComponent;
  ZC.tagNames = {
    zpopover: ['div', 'z-popover'],
    zbutton: ['button', 'z-button'],
    ztabpanel: ['div', 'z-tabpanel'],
    zdialog: ['div', 'z-dialog'],
    zslider: ['div', 'z-slider'],
    zalertbanner: ['div', 'z-alertbanner'],
    zalertdialog: ['div', 'z-alertdialog'],
    zmenu: ['div', 'z-menu'],
    zsuggestfield: ['input', 'z-suggestfield'],
    zcolorpicker: ['div', 'z-colorpicker'],
    znumberfield: ['input', 'z-numberfield'],
    zadvancedcolorpicker: ['div', 'z-advancedcolorpicker'],
    zselect: ['select', 'z-select'],
    zcombobox: ['select', 'z-combobox'],
    zdatepicker: ['div', 'z-datepicker'],
    zdatetimepicker: ['div', 'z-datetimepicker'],
    ztimeinput: ['div', 'z-timeinput'],
    ztimefield: ['input', 'z-timefield'],
    ztokenfield: ['input', 'z-tokenfield'],
    zprogressbar: ['div', 'z-progressbar'],
    zprogresswheel: ['div', 'z-progresswheel'],
    zdatefield: ['input', 'z-datefield'],
    zcolorselect: ['div', 'z-colorselect'],
    zmenubutton: ['button', 'z-menubutton'],
    zfileupload: ['label', 'z-fileupload']
  };
  ZC.AJAX = {
    transport: function transport(params, successCallback, failureCallback, alwaysCallback) {
      var request = $.ajax({
        url: params.sourceURL,
        data: params.data,
        type: params.type,
        dataType: params.dataType,
        success: function success(data) {
          successCallback(data);
        },
        fail: function fail(error, exception) {
          failureCallback(error, exception);
        },
        error: function error(_error, exception) {
          failureCallback(_error, exception);
        },
        always: function always() {
          // temporary fix until DOM UTIL returns promise object.
          alwaysCallback && alwaysCallback();
        }
      });
      return request;
    }
  };

  ZC.alterBorderRadius = function (options, clear) {
    // alternative names: change, modify
    // options: element, forElement, direction, offset, hasSideAlignment ( set true if submenu )
    var cls = 'zh-radiusbottomleft zh-radiustopleft zh-radiusbottomright zh-radiustopright zh-radiustop zh-radiusbottom zh-radiusright zh-radiusleft',
        // No I18N
    ele = options.element,
        target = options.forElement; // Resetting the border radius which was set previously.

    ele.add(target).removeClass(cls); // No I18N

    if (clear) {
      return;
    }

    var sideAdjustments = ['right-top', 'right-bottom', 'left-top', 'left-bottom'],
        // No I18N
    pairs = {
      right: 'left',
      // No I18N
      left: 'right',
      // No I18N
      top: 'bottom',
      // No I18N
      bottom: 'top' // No I18N

    },
        dir = options.direction,
        pos = options.offset;

    if (options.hasSideAlignment && sideAdjustments.indexOf(dir) < 0) {
      // denotes submenu like cases where the element will not open in top/bottom directions.
      ele.addClass(dir.replace(/([a-z]+)-([a-z]+)/g, function (match, w1, w2) {
        return 'zh-radius' + pairs[w2] + pairs[w1];
      })); // No I18N

      pos.left += dir.indexOf('left') === 0 ? 1 : -1;
    } else {
      // setting the border radius based on the element opening direction.
      var pInt = parseInt,
          topLeft = 0,
          topRight = 0,
          bottomLeft = 0,
          bottomRight = 0;

      if (target.length) {
        // usage of css method should be avoided ##revisit later
        topLeft = pInt(target.css('border-top-left-radius')); // No I18N

        topRight = pInt(target.css('border-top-right-radius')); // No I18N

        bottomLeft = pInt(target.css('border-bottom-left-radius')); // No I18N

        bottomRight = pInt(target.css('border-bottom-right-radius')); // No I18N
      }

      if (topLeft <= 5 && topRight <= 5 && bottomLeft <= 5 && bottomRight <= 5) {
        // circular type targets should be excluded.
        var borderSuffix, targetSuffix;

        if (dir.indexOf('top') === 0 || dir.indexOf('bottom') === 0) {
          // No I18N
          dir.replace(/(\w+)-(\w+)/g, function (match, w1, w2) {
            // only top-right, top-left, bottom-right, bottom-left has to be considered
            var isGreater = target.outerWidth(true) < ele.width();
            borderSuffix = pairs[w1] + (isGreater ? w2 : '');
            targetSuffix = w1 + (isGreater ? '' : w2);
          });
          pos.top += dir.indexOf('top') === 0 ? 1 : -1; // This change is needed after Flex and RTL related CSS changes.
        } else if (/^right(-)?(\w)*$/.test(dir) || /^left(-)?(\w)*$/.test(dir)) {
          dir.replace(/^right|left(-)?(\w)*$/g, function (w1) {
            borderSuffix = pairs[w1.split('-')[0]];
          });
          targetSuffix = pairs[borderSuffix];
        }

        ele.addClass('zh-radius' + borderSuffix); // No I18N

        target.addClass('zh-radius' + targetSuffix); // No I18N
      } else {
        // adjust the top value of the element by 2 pixels.
        pos.top = pos.top + 2;
      }
    }

    return pos;
  };

  ZC.localeInfo = {
    'en-US': {
      // No I18N
      daysAbbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      // No I18N
      days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      // No I18N
      months: ['January', // No I18N
      'February', // No I18N
      'March', // No I18N
      'April', // No I18N
      'May', // No I18N
      'June', // No I18N
      'July', // No I18N
      'August', // No I18N
      'September', // No I18N
      'October', // No I18N
      'November', // No I18N
      'December'],
      // No I18N
      monthsAbbreviated: ['Jan', // No I18N
      'Feb', // No I18N
      'Mar', // No I18N
      'Apr', // No I18N
      'May', // No I18N
      'Jun', // No I18N
      'Jul', // No I18N
      'Aug', // No I18N
      'Sep', // No I18N
      'Oct', // No I18N
      'Nov', // No I18N
      'Dec'],
      // No I18N
      firstDayOfWeek: 0,
      // No I18N
      dateFormat: {
        // No I18N
        'short': 'M/d/yyyy',
        // No I18N
        medium: 'MMM d, yyyy',
        // No I18N
        'long': 'MMMM d, yyyy',
        // No I18N
        full: 'dddd, MMMM d, yyyy' // No I18N

      },
      timeFormat: {
        // No I18N
        'short': 'h:mm tt',
        // No I18N
        medium: 'h:mm:ss tt',
        // No I18N
        'long': 'hh:mm:ss tt' // No I18N

      },
      dateTimeFormat: {
        // No I18N
        'short': 'MMM d, yyyy, hh:mm:ss tt',
        // No I18N
        medium: 'MMM d, yyyy, hh:mm:ss tt',
        // No I18N
        'long': "dddd, MMMM d, yyyy 'at' h:mm tt",
        // No I18N
        full: "dddd, MMMM d, yyyy 'at' h:mm tt" // No I18N

      },
      numberFormat: {
        // No I18N
        thousandSeparator: ',',
        // No I18N
        decimalSeparator: '.' // No I18N

      },
      currency: {
        // No I18N
        code: 'USD',
        // No I18N
        name: 'United States Dollar',
        // No I18N
        symbol: "$" // No I18N

      }
    }
  };

  ZC.init = function (container, callback, attr) {
    needToInit && this._init();
    container = container ? $(container) : $('body');
    var attr1 = attr || this.selector,
        attrSelector = '[' + attr1 + ']',
        // No I18N
    uiComponents = document.querySelectorAll ? container[0].querySelectorAll(attrSelector) : $(attrSelector, container);

    if (container[0].attributes[attr1] || container[0].dataset && container[0].dataset[attr1]) {
      uiComponents = $(container).add(uiComponents);
    }

    if (uiComponents.length) {
      var base = this;
      this.eachAsync(uiComponents, {
        delay: 20,
        loop: function loop(i, ele) {
          base._initComponent(ele, undefined, attr);
        },
        end: function end() {
          base._end(container, uiComponents, callback);
        }
      });
    } else {
      this._end(container, uiComponents, callback);
    }
  };

  ZC.destroy = function (container, callback, attr) {
    container = container ? $(container) : $('body');
    attr = attr || this.selector;
    var attrSelector = '[' + attr + ']',
        // No I18N
    uiComponents = $(attrSelector, container);

    if (container.is(attrSelector)) {
      uiComponents = $(container).add(uiComponents);
    }

    if (uiComponents.length) {
      var base = this;
      this.eachAsync(uiComponents, {
        delay: 20,
        loop: function loop(i, ele) {
          $(ele)[ele.getAttribute(attr)]('destroy');
        },
        end: function end() {
          base._end(container, uiComponents, callback, true);
        }
      });
    } else {
      this._end(container, uiComponents, callback, true);
    }
  };

  ZC.eachAsync = function (array, opts) {
    // will be modified later
    var i = 0,
        l = array.length,
        _loop = opts.loop || function () {};

    this.whileAsync($.extend(opts, {
      test: function test() {
        return i < l;
      },
      loop: function loop() {
        var val = array[i];
        return val && _loop.call(val, i++, val);
      }
    }));
  };

  ZC.whileAsync = function (opts) {
    // async utility from jquery
    var delay = Math.abs(opts.delay) || 10,
        bulk = isNaN(opts.bulk) ? 500 : Math.abs(opts.bulk),
        test = opts.test || function () {
      return true;
    },
        loop = opts.loop || function () {},
        end = opts.end || function () {};

    (function executeLoop() {
      var t = false,
          begin = new Date();

      while (t = test()) {
        loop();

        if (bulk === 0 || new Date() - begin > bulk) {
          break;
        }
      }

      if (t) {
        setTimeout(executeLoop, delay);
      } else {
        end();
      }
    })();
  };

  ZC._end = function (mainDiv, uiComponents, callback, isDestroy) {
    this.$document.trigger('zcomponent' + (isDestroy ? 'destroyed' : 'initialized'), mainDiv); // No I18N

    callback && callback(uiComponents);
  };

  ZC._initDeferredComponents = function (componentsMap, timeout, callback) {
    setTimeout(function () {
      $.each(componentsMap, function (ctype, componentGroup) {
        $(componentGroup).each(function (i, component) {
          this._initComponent($(component), ctype);
        });
      });
      callback && callback(componentsMap);
    }, timeout || 10000); // Default is 10 seconds
  };

  ZC._initComponent = function (element, ctype, attr) {
    element = $(element);
    element[ctype || element.attr(attr || this.selector)]();
  };
})(jQuery);

(function (ZC) {
  if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {
    module.exports = function () {
      return ZC;
    }();
  }
})(ZComponents);

var ZEventNameSpacing =
/*#__PURE__*/
function () {
  function ZEventNameSpacing() {
    _classCallCheck(this, ZEventNameSpacing);

    this.functionMaps = {};
  }

  _createClass(ZEventNameSpacing, [{
    key: "addEventListener",
    value: function addEventListener(element, event, func) {
      this.functionMaps[event] = func;

      if (func) {
        element.addEventListener(event.split('.')[0], func);
      }
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(element, event) {
      if (this.functionMaps[event]) {
        element.removeEventListener(event.split('.')[0], this.functionMaps[event]);
        delete this.functionMaps[event];
      }
    }
  }]);

  return ZEventNameSpacing;
}();

var ZPolyfill = {};

try {
  ZPolyfill.WeakMap = WeakMap;
} catch (WeakMap) {
  ZPolyfill.WeakMap = function (id, Object) {
    var _this4 = this;

    var dP = Object.defineProperty;
    var hOP = Object.hasOwnProperty;
    var proto = WeakMap.prototype;

    proto["delete"] = function (key) {
      return _this4.has(key) && delete key[_this4._];
    };

    proto.get = function (key) {
      return _this4.has(key) ? key[_this4._] : void 0;
    };

    proto.has = function (key) {
      return hOP.call(key, _this4._);
    };

    proto.set = function (key, value) {
      dP(key, _this4._, {
        configurable: true,
        value: value
      });
      return _this4;
    };

    return WeakMap;

    function WeakMap(iterable) {
      dP(this, '_', {
        // No I18N
        value: '_@ungap/weakmap' + id++ // No I18N

      });

      if (iterable) {
        iterable.forEach(add, this);
      }
    }

    function add(pair) {
      this.set(pair[0], pair[1]);
    }
  }(Math.random(), Object);
}

var ZWeakMap = ZPolyfill.WeakMap;
var ZCTemplates = {
  nodeRef: new ZWeakMap(),
  templateCache: {},
  uniqueId: "{zt-".concat(String(Math.random()).slice(2), "}"),
  // No I18N
  attrSuffix: '$zta$',
  // No I18N
  attrRegEx: /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/,
  // No I18N
  Event: new ZEventNameSpacing(),
  renderView: function renderView(htmlResult, container) {
    var instance = new ZNodeProcessor(),
        ref = this.nodeRef;
    var nodeRef = ref.get(container);

    if (!nodeRef) {
      instance._emptyElement(container, container.firstChild);

      ref.set(container, nodeRef = instance);

      nodeRef._addPlaceholders(container);
    }

    nodeRef._setResult(htmlResult);

    nodeRef.update();
  },
  removeCacheData: function removeCacheData(container) {
    var nodeRef = this.nodeRef.get(container);

    if (nodeRef) {
      this.nodeRef.set(container, null);
    }
  },
  DOM: function DOM(htmlResult) {
    var instance = new ZNodeProcessor();

    if (htmlResult instanceof ZTemplates) {
      return instance._processHTML(htmlResult, true).childNodes[0];
    }
  },
  functionList: new ZWeakMap(),
  prevValues: new ZWeakMap(),
  _specialFunc: function _specialFunc(f) {
    return function () {
      var d = f.apply(void 0, arguments);
      ZT.functionList.set(d, true);
      return d;
    };
  },
  _isSpecialFunc: function _isSpecialFunc(o) {
    return typeof o === 'function' && this.functionList.has(o); // No I18N
  },
  html: function html(strings) {
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    return new ZTemplates(strings, values, 'html'); // No I18N
  },
  _updateTemplateCache: function _updateTemplateCache(result) {
    var cache = this.templateCache;
    var value = cache[result.type];

    if (!value) {
      value = {
        strings: new ZWeakMap(),
        keys: {}
      };
      cache[result.type] = value;
    }

    var template = value.strings.get(result.strings);

    if (template) {
      return template;
    }

    var key = result.strings.join(this.uniqueId);
    template = value.keys[key];

    if (!template) {
      template = new ZNodeTraverser(result, result.getTemplate());
      value.keys[key] = template;
    }

    value.strings.set(result.strings, template);
    return template;
  },
  _processAttr: function _processAttr(node, attrName, strings) {
    var prefix = attrName[0],
        actualAttr = attrName.slice(1);

    if (prefix === '?') {
      return [new ZConditionalAttributePart(node, actualAttr)];
    } else if (prefix === '.') {
      return new ZPropertyPart(node, actualAttr, strings)._parts;
    } else if (attrName.indexOf('on-') > -1) {
      return [new ZEventPart(node, attrName.slice(3))];
    }

    return new ZAttributeUpdater(node, attrName, strings)._parts;
  },
  _processTextValue: function _processTextValue() {
    return new ZNodeProcessor();
  },
  _isPlainText: function _isPlainText(value) {
    return value === null || !(_typeof(value) === 'object' || typeof value === 'function'); // No I18N
  },
  _getTemplate: function () {
    var createTemplate = function createTemplate() {
      return document.createElement('template');
    }; // No I18N


    if ('content' in createTemplate()) {
      // No I18N
      return function (value) {
        // --- Not supported by IE
        var template = createTemplate();
        template.innerHTML = value;
        return template;
      };
    }

    return function (value) {
      // IE 9 & Above
      var template = document.createDocumentFragment();
      var tempNode = document.createElement('div'); // No I18N

      var fillUsingTable = function fillUsingTable() {
        tempNode.innerHTML = '<table>' + value + '</table>'; // No I18N

        return tempNode.firstChild.firstChild;
      };

      if (/^(<td|<th|<tr)/.test(value)) {
        if (/^<tr/.test(value)) {
          tempNode = fillUsingTable();
        } else {
          tempNode = fillUsingTable().firstChild;
        }
      } else {
        tempNode.innerHTML = value;
      }

      var children = tempNode.childNodes;

      while (children[0]) {
        template.appendChild(children[0]);
      } // IE 9 && above //JQuery is used
      // let template = document.createDocumentFragment();
      // if (/^(<tr|<td|<th)/.test(value)) {
      //     let children = $(value).toArray();
      //     for (let i = 0; i < children.length; i++) {
      //         template.appendChild(children[i]);
      //     }
      // } else {
      //     let tempNode = document.createElement('div'); // No I18N
      //     tempNode.innerHTML = value;
      //     let children = tempNode.childNodes;
      //     while (children[0]) {
      //         template.appendChild(children[0]);
      //     }
      // }
      // IE 10 && IE 11
      // let template = document.createDocumentFragment();
      // let tempTag = 'div';// No I18N
      // if (/^<tr/.test(value)) {
      //     tempTag = 'thead'; // No I18N
      // } else if (/^(<td|<th)/.test(value)) {
      //     tempTag = 'tr'; // No I18N
      // }
      // let tempNode = document.createElement(tempTag);
      // tempNode.innerHTML = value;
      // let children = tempNode.childNodes;
      // while (children[0]) {
      //     template.appendChild(children[0]);
      // }


      template.content = template;
      return template;
    };
  }()
};
var ZT = ZCTemplates;
ZT.placeholder = "<!--".concat(ZT.uniqueId, "-->");
ZT.customHTML = ZT._specialFunc(function (value) {
  return function (part) {
    var prevValue = ZT.prevValues.get(part);

    if (prevValue === value && ZT._isPlainText(value)) {
      return;
    }

    var template = ZT._getTemplate(value);

    part._setResult(document.importNode(template.content, true));

    ZT.prevValues.set(part, value);
  };
});

var ZTemplates =
/*#__PURE__*/
function () {
  function ZTemplates(strings, values, type) {
    _classCallCheck(this, ZTemplates);

    this.strings = strings;
    this.values = values;
    this.type = type;
  }

  _createClass(ZTemplates, [{
    key: "_getHTML",
    value: function _getHTML() {
      var length = this.strings.length - 1;
      var html = '';

      for (var i = 0; i < length; i++) {
        var s = this.strings[i],
            isAttr = false;
        html += s.replace(ZT.attrRegEx, function (match, space, attrName, value) {
          isAttr = true;
          return space + attrName + ZT.attrSuffix + value + ZT.uniqueId;
        });

        if (!isAttr) {
          html += ZT.placeholder;
        }
      }

      return html + this.strings[length];
    }
  }, {
    key: "getTemplate",
    value: function getTemplate() {
      return ZT._getTemplate(this._getHTML());
    }
  }]);

  return ZTemplates;
}();

var ZTemplateUpdater =
/*#__PURE__*/
function () {
  function ZTemplateUpdater(template) {
    _classCallCheck(this, ZTemplateUpdater);

    this.template = template;
    this._parts = [];
    this._partIndex = this._nodeIndex = 0;
  }

  _createClass(ZTemplateUpdater, [{
    key: "_updateNodes",
    value: function _updateNodes() {
      var template = document.importNode(this.template._template.content, true);

      this._traverseDOM(template);

      return template;
    }
  }, {
    key: "_traverseDOM",
    value: function _traverseDOM(node) {
      var dynamicParts = this.template._parts;
      node = node.firstChild;

      while (node && this._partIndex < dynamicParts.length) {
        var part = dynamicParts[this._partIndex];

        if (this._nodeIndex === part.index) {
          if (part.type === 'node') {
            // No I18N
            var _part = ZT._processTextValue();

            _part._setRefNodes(node);

            this._parts.push(_part);
          } else {
            var _this$_parts;

            (_this$_parts = this._parts).push.apply(_this$_parts, _toConsumableArray(ZT._processAttr(node, part.name, part.strings)));
          }

          this._partIndex++;
        } else {
          this._nodeIndex++;

          this._traverseDOM(node);

          node = node.nextSibling;
        }
      }
    }
  }, {
    key: "updateValues",
    value: function updateValues(values) {
      for (var i = 0, len = this._parts.length; i < len; i++) {
        var part = this._parts[i];

        if (part) {
          part._setResult(values[i]);

          part.update();
        }
      }
    }
  }]);

  return ZTemplateUpdater;
}();

var ZAttributeUpdater =
/*#__PURE__*/
function () {
  function ZAttributeUpdater(node, attrName, strings) {
    _classCallCheck(this, ZAttributeUpdater);

    this.node = node;
    this.attrName = attrName;
    this.strings = strings;
    this._parts = [];

    for (var i = 0; i < strings.length - 1; i++) {
      this._parts[i] = this._createPart();
    }
  }

  _createClass(ZAttributeUpdater, [{
    key: "_createPart",
    value: function _createPart() {
      return new ZAttributePart(this);
    }
  }, {
    key: "_getValue",
    value: function _getValue() {
      var strings = this.strings,
          attrValue = '',
          len = strings.length - 1;

      for (var i = 0; i < len; i++) {
        attrValue += strings[i];
        var part = this._parts[i];

        if (part) {
          var value = part.value;

          if (part.value || part.value === 0) {
            attrValue += typeof value === 'string' ? value : String(value); // No I18N
          }
        }
      }

      attrValue += strings[len];
      return attrValue;
    }
  }, {
    key: "update",
    value: function update() {
      this.node.setAttribute(this.attrName, this._getValue());
    }
  }]);

  return ZAttributeUpdater;
}();

var ZAttributePart =
/*#__PURE__*/
function () {
  function ZAttributePart(instance) {
    _classCallCheck(this, ZAttributePart);

    this._attrPart = instance;
    this._changed = false;
  }

  _createClass(ZAttributePart, [{
    key: "_setResult",
    value: function _setResult(value) {
      if (value !== this.value) {
        this.value = value;
        this._changed = true;
      }
    }
  }, {
    key: "update",
    value: function update() {
      this._changed && this._attrPart.update();
      this._changed = false;
    }
  }]);

  return ZAttributePart;
}();

var ZNodeTraverser =
/*#__PURE__*/
function () {
  function ZNodeTraverser(result, template) {
    _classCallCheck(this, ZNodeTraverser);

    this._template = template;
    this._placeholderRegEx = new RegExp("".concat(ZT.uniqueId, "|").concat(ZT.placeholder));
    this._index = -1;
    this._parts = [];
    this._partIndex = 0;
    this._nodesToBeRemoved = [];

    this._storeDynamicParts(template, result);

    for (var i = 0; i < this._nodesToBeRemoved.length; i++) {
      var node = this._nodesToBeRemoved[i];

      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
  }

  _createClass(ZNodeTraverser, [{
    key: "_storeDynamicParts",
    value: function _storeDynamicParts(template, result) {
      this._traverseDOM(template.content, result);
    }
  }, {
    key: "_traverseDOM",
    value: function _traverseDOM(node, result) {
      var previousNode;
      node = node.firstChild;

      while (node) {
        this._index++;
        previousNode = node;

        switch (node.nodeType) {
          case 1:
            if (node.hasAttributes()) {
              var attrs = node.attributes,
                  count = 0;

              for (var i = 0; i < attrs.length; i++) {
                if (attrs[i].value.indexOf(ZT.uniqueId) >= 0) {
                  count++;
                }
              }

              for (var j = count; j > 0; j--) {
                var attrPart = result.strings[this._partIndex],
                    name = ZT.attrRegEx.exec(attrPart);

                if (name) {
                  name = name[2];
                }

                var placeholderAttrName = name.toLowerCase() + ZT.attrSuffix,
                    attrValue = node.getAttribute(placeholderAttrName),
                    strings = attrValue.split(this._placeholderRegEx);

                this._parts.push({
                  type: 'attr',
                  // No I18N
                  index: this._index,
                  name: name,
                  strings: strings
                });

                node.removeAttribute(placeholderAttrName);
                this._partIndex += strings.length - 1;
              }
            }

            break;

          case 8:
            if (node.nodeValue === ZT.uniqueId) {
              var parent = node.parentNode,
                  previousSibling = node.previousSibling;

              if (parent && !previousSibling || previousSibling !== previousNode || previousSibling.nodeType !== 3) {
                parent.insertBefore(document.createComment(''), node);
              } else {
                this._index--;
              }

              this._parts.push({
                type: 'node',
                // No I18N
                index: this._index++
              });

              this._nodesToBeRemoved.push(node);

              if (!node.nextSibling && parent) {
                parent.insertBefore(document.createComment(''), node);
              } else {
                this._index--;
              }

              node = previousNode;
              this._partIndex++;
            }

            break;
        }

        this._traverseDOM(node, result);

        node = node.nextSibling;
      }
    }
  }]);

  return ZNodeTraverser;
}();

var ZEventPart =
/*#__PURE__*/
function () {
  function ZEventPart(element, eventName) {
    _classCallCheck(this, ZEventPart);

    this.element = element;
    this.eventName = eventName;
  }

  _createClass(ZEventPart, [{
    key: "_setResult",
    value: function _setResult(value) {
      this.currentVal = value;
    }
  }, {
    key: "update",
    value: function update() {
      var currentHandler = this.currentVal ? this.currentVal.handler : null,
          oldHandler = this.value ? this.value.handler : null;

      if (!currentHandler && oldHandler) {
        ZT.Event.removeEventListener(this.element, this.eventName + '.' + this.value.namespace, this._handleEvent.bind(this));
      }

      if (currentHandler && !oldHandler) {
        var eventNames = this.currentVal.eventNames;

        if (!eventNames) {
          eventNames = [this.eventName];
        }

        for (var i = 0; i < eventNames.length; i++) {
          ZT.Event.addEventListener(this.element, eventNames[i] + '.' + this.currentVal.namespace, this._handleEvent.bind(this));
        }
      }

      this.value = this.currentVal;
      this.currentVal = {};
    }
  }, {
    key: "_handleEvent",
    value: function _handleEvent(event) {
      if (this.value && typeof this.value.handler === 'function') {
        this.value.handler.call(this.element, event);
      }
    }
  }]);

  return ZEventPart;
}();

var ZPropertyPart =
/*#__PURE__*/
function (_ZAttributeUpdater) {
  _inherits(ZPropertyPart, _ZAttributeUpdater);

  function ZPropertyPart() {
    _classCallCheck(this, ZPropertyPart);

    return _possibleConstructorReturn(this, _getPrototypeOf(ZPropertyPart).apply(this, arguments));
  }

  _createClass(ZPropertyPart, [{
    key: "_getValue",
    value: function _getValue() {
      return this._parts[0].value;
    }
  }, {
    key: "update",
    value: function update() {
      this.node[this.attrName] = this._getValue();
    }
  }]);

  return ZPropertyPart;
}(ZAttributeUpdater);

var ZConditionalAttributePart =
/*#__PURE__*/
function () {
  function ZConditionalAttributePart(node, attrName, strings) {
    _classCallCheck(this, ZConditionalAttributePart);

    this.node = node;
    this.attrName = attrName;
    this.strings = strings;
  }

  _createClass(ZConditionalAttributePart, [{
    key: "_setResult",
    value: function _setResult(value) {
      this.currentVal = value;
    }
  }, {
    key: "update",
    value: function update() {
      var value = this.currentVal,
          node = this.node;

      if (this.value !== value) {
        if (value) {
          value = typeof value === 'boolean' ? '' : value; // No I18N

          node.setAttribute(this.attrName, value);
        } else {
          node.removeAttribute(this.attrName);
        }
      }

      this.value = value;
    }
  }]);

  return ZConditionalAttributePart;
}();

var ZNodeProcessor =
/*#__PURE__*/
function () {
  function ZNodeProcessor() {
    _classCallCheck(this, ZNodeProcessor);
  }

  _createClass(ZNodeProcessor, [{
    key: "_emptyElement",
    value: function _emptyElement(container, start, end) {
      var node = start;

      while (node && node !== end) {
        var tempNode = node.nextSibling;
        container.removeChild(node);
        node = tempNode;
      }
    }
  }, {
    key: "_setResult",
    value: function _setResult(value) {
      this.currentVal = value;
    }
  }, {
    key: "_addPlaceholders",
    value: function _addPlaceholders(container) {
      this.start = container.appendChild(document.createComment('')); // No I18N

      this.end = container.appendChild(document.createComment('')); // No I18N
    }
  }, {
    key: "_setRefNodes",
    value: function _setRefNodes(node) {
      this.start = node;
      this.end = node.nextSibling;
    }
  }, {
    key: "update",
    value: function update() {
      while (ZT._isSpecialFunc(this.currentVal)) {
        var func = this.currentVal;
        this.currentVal = {};
        func(this);
      }

      var value = this.currentVal;

      if (ZT._isPlainText(value)) {
        if (value !== this.value) {
          this._updateNode(value);
        }
      } else if (value instanceof ZTemplates) {
        this._processHTML(value);
      } else if (value instanceof Node) {
        this._insertNode(value);
      } else if (value instanceof Array) {
        this._processValues(value);
      }
    }
  }, {
    key: "_processValues",
    value: function _processValues(values) {
      if (!(this.value instanceof Array)) {
        this.value = [];
        this.remove();
      }

      var nodeParts = this.value,
          nodePart,
          i,
          len = values.length;

      for (i = 0; i < len; i++) {
        nodePart = nodeParts[i];

        if (!nodePart) {
          nodePart = new ZNodeProcessor();
          nodeParts.push(nodePart);

          if (i === 0) {
            nodePart._appendNodePart(this);
          } else {
            nodePart._insertAfterPart(nodeParts[i - 1]);
          }
        }

        nodePart._setResult(values[i]);

        nodePart.update();
      }

      if (i < nodeParts.length) {
        nodeParts.length = i;
        this.remove(nodePart && nodePart.end);
      }
    }
  }, {
    key: "_appendNodePart",
    value: function _appendNodePart(part) {
      part._insert(this.start = document.createComment(''));

      part._insert(this.end = document.createComment(''));
    }
  }, {
    key: "_insertAfterPart",
    value: function _insertAfterPart(previousPart) {
      previousPart._insert(this.start = document.createComment(''));

      this.end = previousPart.end;
      previousPart.end = this.start;
    }
  }, {
    key: "remove",
    value: function remove() {
      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.start;

      this._emptyElement(this.start.parentNode, start.nextSibling, this.end);
    }
  }, {
    key: "_insert",
    value: function _insert(node) {
      this.end.parentNode.insertBefore(node, this.end);
    }
  }, {
    key: "_insertNode",
    value: function _insertNode(value) {
      if (this.value === value) {
        return;
      }

      this.remove();

      this._insert(value);

      this.value = value;
    }
  }, {
    key: "_updateNode",
    value: function _updateNode(value) {
      var node = this.start.nextSibling;
      value = value || '';

      if (node === this.end.previousSibling && node.nodeType === 3) {
        node.textContent = value;
      } else {
        this._insertNode(document.createTextNode(typeof value === 'string' ? value : String(value))); // No I18N

      }

      this.value = value;
    }
  }, {
    key: "_processHTML",
    value: function _processHTML(value, doNotRender) {
      var template = ZT._updateTemplateCache(value),
          updatedTemplate;

      if (this.value && this.value.template === template) {
        this.value.updateValues(value.values);
      } else {
        var instance = new ZTemplateUpdater(template);
        updatedTemplate = instance._updateNodes();
        instance.updateValues(value.values);

        if (!doNotRender) {
          this._insertNode(updatedTemplate);
        }

        this.value = instance;
      }

      return updatedTemplate;
    }
  }]);

  return ZNodeProcessor;
}(); // To facilitate require('ztemplates.js')


(function (ZT) {
  if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {
    // No I18N
    module.exports = function () {
      return ZT;
    }();
  }
})(ZCTemplates);
/* $Id$ */

/* eslint-disable */


ZComponents.Date = function (ZC) {
  var $ = ZC.DOMUtil;
  "use strict"; // No I18N


  return {
    monthsAbbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    // No I18N
    daysAbbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    // No I18N
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    // No I18N
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    // No I18N
    invalidInput: "Invalid date/time provided. Please provide correct input",
    // No I18N
    century: 21,
    AM: "AM",
    // No I18N
    PM: "PM",
    // No I18N
    _setMonth: function _setMonth(date, val) {
      var day = date.getDate();

      if (isNaN(date)) {
        return date;
      }

      val -= 1;
      val %= 12;
      date.setMonth(val);

      while (val > 0 && date.getMonth() !== val) {
        date.setDate(--day);
      }

      return date;
    },
    parsePattern: function parsePattern(pattern) {
      pattern = pattern.replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, "");
      var acceptedVal = /d(?:d{1,3})?|M(?:M{1,3})?|yy(?:yy)?|h(?:h)?|H(?:H)?|m(?:m)?|s(?:s)|t{2}|z(?:z{1,3})?/g;
      var dateSeperator = pattern.replace(acceptedVal, '\0').split('\0'),
          dateParts = pattern.match(acceptedVal);

      if (!dateSeperator || !dateSeperator.length || !dateParts || !dateParts.length) {
        return false;
      }

      return {
        dateSeperator: dateSeperator,
        dateParts: dateParts
      };
    },
    _parseDateValue: function _parseDateValue(date, pattern, otherFormats) {
      if (!date) {
        return;
      }

      var val,
          parsedDate = {},
          pattern,
          formattedDate,
          matchFound = false,
          finalValue;
      var patterns = [];

      if (date instanceof Date) {
        return {
          date: date,
          isValid: true
        };
      }

      if (otherFormats.length) {
        patterns = otherFormats.slice();
      }

      patterns.unshift(pattern);
      var date1 = date;
      var dateParts = date.match(/[^ -/:-@\u5e74\u6708\u65e5[-`{-~\t\n\r]+/g) || [];

      for (var j = 0; j < patterns.length; j++) {
        date = date1; // typeof patterns[j] === "string" && (patterns[j] = this.parsePattern(patterns[j]));	// No I18N	 

        finalValue = this.parseDate(date, patterns[j]);

        if (finalValue && finalValue.isValid) {
          matchFound = true;
          break;
        }
      }

      if (!matchFound) {
        finalValue = this.getDateFromOffset(date1, finalValue ? finalValue.date : undefined, patterns[0], dateParts);
      }

      return finalValue;
    },
    parseDate: function parseDate(date, pattern) {
      var val,
          parsedDate = {},
          pattern,
          formattedDate,
          filtered,
          matchFound = false;

      if (!date) {
        return undefined;
      }

      if (date instanceof Date) {
        return {
          date: date,
          isValid: true
        };
      }

      if (typeof date !== "string" || typeof date === "string" && !date.length) {
        // No I18N
        return undefined;
      }

      var filterDate = function filterDate(date) {
        var month = date.slice(0, dateParts[i].length),
            part = dateParts[i].slice(0, month.length);
        return month.toLowerCase() === part.toLowerCase();
      };

      var date1 = date,
          specialCharacters;
      date = date1;

      if (typeof pattern === "string") {
        var matches = pattern.match(/(["'])(?:(?=(\\?))\2.)*?\1/g);

        if (matches) {
          specialCharacters = matches.map(function (val) {
            return val.replace(/'/g, "");
          });
        }

        pattern = this.parsePattern(pattern); // No I18N
      }

      var part,
          dateParts = date.match(/[^ -/:-@\u5e74\u6708\u65e5[-`{-~\t\n\r]+/g) || [];

      if (specialCharacters) {
        dateParts = dateParts.filter(function (part) {
          return specialCharacters.indexOf(part) === -1;
        });
      }

      var pParts = pattern.dateParts.slice(),
          days;
      date = new Date();

      if (dateParts.length === pParts.length) {
        for (var i = 0; i < pParts.length; i++) {
          val = parseInt(dateParts[i], 10), part = pParts[i];

          if (isNaN(val)) {
            if (part === "MMM" || part === "MMMM") {
              // No I18N
              switch (part) {
                case "MMM": // No I18N

                case "MMMM":
                  // No I18N
                  filtered = this.monthsAbbreviated.filter(filterDate);
                  val = this.monthsAbbreviated.indexOf(filtered[0]) + 1;
                  break;
              }

              parsedDate[part] = val;
            } else if (part === "dddd" || part === "ddd") {
              // No I18N
              val = dateParts[pParts.indexOf("d") > -1 ? pParts.indexOf("d") : pParts.indexOf("dd") > -1];
              parsedDate[part] = val;
            } else if (part === "tt" && (dateParts[i] === "AM" || dateParts[i] === "PM")) {
              // No I18N
              var key = pParts.indexOf("hh") === -1 ? "h" : "hh"; // No I18N

              var value = dateParts[pParts.indexOf(key)],
                  hourValue = parseInt(value),
                  modValue = hourValue % 12;
              var startingTime = dateParts[i] === "PM" ? 12 : 0; // No I18N

              parsedDate[key] = modValue === 0 ? startingTime : hourValue + startingTime;
              parsedDate[part] = value;
            }
          } else {
            if (part === "yyyy" || part === "yy") {
              // No I18N	
              if (val > 9999) {
                dateParts[i] = "9999"; // No I18N	
              }
            }

            if (!(part.indexOf("d") > -1 && val > 31 || part.indexOf("M") > -1 && val > 12 || part.indexOf("y") > -1 && part.length !== dateParts[i].length)) {
              // No I18N	
              parsedDate[part] = val;
            } else {
              break;
            }
          }
        }
      }

      if (Object.keys(parsedDate).length && dateParts.length === Object.keys(parsedDate).length) {
        date = this._getFormattedDate(parsedDate, date);

        if (pattern.dateParts.indexOf("s") === -1 && pattern.dateParts.indexOf("ss") === -1) {
          // No I18N	
          date.setSeconds(0, 0);
        }

        date = {
          date: date,
          isValid: true
        };
      } else {
        date = {
          date: date,
          isValid: false
        };
      }

      return date;
    },
    getDateFromOffset: function getDateFromOffset(dateOffset, date, datePattern, dateParts) {
      if (!date) {
        return;
      }

      var offsetValue;

      if (dateOffset.indexOf("TODAY") === 0) {
        // No I18N
        offsetValue = dateOffset.substring(5);
      } else if (dateOffset.indexOf("FROM_VALUE") === 0) {
        // No I18N
        offsetValue = dateOffset.substring(10);
      } else {
        return {
          date: undefined,
          isValid: false
        };
      }

      var pattern = /([+-][0-9]+)(DAYS|MONTHS|YEARS|WEEKS)/g,
          matches = pattern.exec(offsetValue),
          day = date.getDate(),
          month = date.getMonth(),
          year = date.getFullYear(),
          hour = date.getHours(),
          minutes = date.getMinutes(),
          seconds = date.getSeconds();

      if (!matches) {
        try {
          var value = {
            date: this._getDateByIntelligence(dateOffset, datePattern, dateParts),
            isValid: true
          };
          return value;
        } catch (exception) {
          var value = {
            date: undefined,
            isValid: false
          };
          return value;
        }
      }

      while (matches) {
        switch (matches[2] || "DAYS") {
          // No I18N
          case "DAYS":
            // No I18N
            day += parseInt(matches[1], 10);
            break;

          case "WEEKS":
            day += parseInt(matches[1], 10) * 7;
            break;

          case "MONTHS":
            // No I18N
            month += parseInt(matches[1], 10);
            day = Math.min(day, new Date(year, month + 1, 0).getDate());
            break;

          case "YEARS":
            // No I18N
            year += parseInt(matches[1], 10);
            day = Math.min(day, new Date(year, month + 1, 0).getDate());
            break;

          case "HOURS":
            // No I18N
            hour += parseInt(matches[1], 10);
            break;

          case "MINUTES":
            // No I18N
            minutes += parseInt(matches[1], 10);
            break;

          case "SECONDS":
            // No I18N
            seconds += parseInt(matches[1], 10);
            break;
        }

        matches = pattern.exec(offsetValue);
      }

      date = this._getDate(year, month, day, hour, minutes, seconds);
      var returnObj = {
        date: date,
        isValid: true
      };
      return returnObj;
    },
    convertOffsetToValue: function convertOffsetToValue(offset) {
      var pattern = /([+-]{1}([0-9])+$)/g,
          match = pattern.exec(offset);

      if (!match) {
        return 0;
      }

      return parseInt(match[0]);
    },
    _getFormattedDate: function _getFormattedDate(parsedDate, date) {
      var executionOrder = ["yyyy", "yy", "M", "MM", "MMM", "MMMM", "d", "dd", "ddd", "dddd", "H", "HH", "h", "hh", "m", "mm", "s", "ss"],
          formattedDate,
          pattern; // No I18N

      if (!date) {
        return;
      }

      for (var i = 0; i < executionOrder.length; i++) {
        pattern = executionOrder[i];

        if (pattern in parsedDate && !isNaN(parsedDate[pattern])) {
          formattedDate = new Date(date);

          switch (pattern) {
            case "M":
            case "MM":
            case "MMM":
            case "MMMM":
              // No I18N
              formattedDate = this._setMonth(formattedDate, parsedDate[pattern]);
              break;

            case "yyyy":
              // No I18N
              parsedDate[pattern] > 9999 ? formattedDate.setFullYear(9999) : formattedDate.setFullYear(parsedDate[pattern]);
              break;

            case "yy":
              var century = this.century - 1;
              var year = century.toString() + parsedDate[pattern];
              formattedDate.setFullYear(parseInt(year));
              break;

            case "d":
            case "dd":
            case "ddd":
            case "dddd":
              // No I18N      					
              formattedDate.setDate(parsedDate[pattern]);
              break;

            case "H":
            case "HH":
              // No I18N 
              formattedDate.setHours(parsedDate[pattern]);
              break;

            case "h":
            case "hh":
              // No I18N 
              formattedDate.setHours(parsedDate[pattern]);
              break;

            case "m":
            case "mm":
              // No I18N 
              formattedDate.setMinutes(parsedDate[pattern]);
              break;

            case "s":
            case "ss":
              // No I18N 
              formattedDate.setSeconds(parsedDate[pattern]);
              break;
          }

          if (!isNaN(formattedDate)) {
            date = formattedDate;
          }
        }
      }

      return formattedDate;
    },
    _getDateByIntelligence: function _getDateByIntelligence(date, pattern, dateParts) {
      var dateObject = new Date(date),
          matches = date.match(new RegExp("[-/. ?]", "g")) || [],
          noMatchFound;

      if (!isNaN(dateObject)) {
        if (matches.length === 1) {
          if (dateObject.getFullYear() === 2001) {
            dateObject.setFullYear(new Date().getFullYear());
          }
        }

        return dateObject;
      } else {
        var values = dateParts,
            colonMatch = date.match(new RegExp(":", "g")),
            colonCount;

        if (colonMatch) {
          var invalidTime = false,
              hourValue,
              minuteValue,
              secondValue;
          colonCount = colonMatch.length;
          var elements = ["AM", "PM", "am", "pm"],
              periodIndex; // No I18N

          if (values) {
            values[0] && (values[0] = parseInt(values[0]));
            values[1] && (values[1] = parseInt(values[1]));
            values[2] && !isNaN(values[2]) && (values[2] = parseInt(values[2]));
          }

          for (var i = 0; i < elements.length; i++) {
            if (values.indexOf(elements[i]) > -1) {
              periodIndex = values.indexOf(elements[i]);
              break;
            }
          }

          if (colonCount === 0) {
            invalidTime = true;
          } else if (colonCount === 1) {
            if (periodIndex && periodIndex > -1) {
              var period = values[periodIndex].toUpperCase();

              if (values[0] >= 1 && values[0] <= 12 && values[1] >= 0 && values[1] <= 59) {
                var modValue = values[0] % 12;

                if (period === "AM") {
                  // No I18N	
                  hourValue = modValue === 0 ? 0 : values[0];
                }

                if (period === "PM") {
                  // No I18N	
                  hourValue = modValue === 0 ? 12 : values[0] + 12;
                }

                minuteValue = values[1];
              } else {
                invalidTime = true;
              }
            } else {
              if (values[0] >= 0 && values[0] <= 23 && values[1] >= 0 && values[1] <= 59) {
                hourValue = values[0], minuteValue = values[1];
              } else {
                invalidTime = true;
              }
            }
          } else if (colonCount === 2) {
            if (periodIndex && periodIndex > -1) {
              var period = values[periodIndex].toUpperCase();

              if (values[0] >= 1 && values[0] <= 12 && values[1] >= 0 && values[1] <= 59 && values[2] >= 0 && values[2] <= 59) {
                var modValue = values[0] % 12;

                if (period === "AM") {
                  // No I18N	
                  hourValue = modValue === 0 ? 0 : values[0];
                }

                if (period === "PM") {
                  // No I18N	
                  hourValue = modValue === 0 ? 12 : values[0] + 12;
                }

                minuteValue = values[1], secondValue = values[2];
              }
            } else {
              if (values[0] >= 0 && values[0] <= 23 && values[1] >= 0 && values[1] <= 59 && values[2] >= 0 && values[1] <= 59) {
                hourValue = values[0], minuteValue = values[1], secondValue = values[2];
              } else {
                invalidTime = true;
              }
            }
          } else {
            invalidTime = true;
          }

          if (!invalidTime) {
            date = new Date();
            hourValue !== undefined && date.setHours(hourValue);
            minuteValue !== undefined && date.setMinutes(minuteValue);
            secondValue !== undefined ? date.setSeconds(secondValue) : date.setSeconds(0);
          } else {
            noMatchFound = true;
          }
        } else if (matches.length) {
          var dateElements = date.split(matches[0]),
              month,
              year;

          if (dateElements[0].length === 4) {
            year = parseInt(dateElements[0]);
            month = parseInt(dateElements[1]);
          } else if (dateElements[1].length === 4) {
            month = parseInt(dateElements[0]);
            year = parseInt(dateElements[1]);
          }

          if (month !== undefined && year !== undefined) {
            date = new Date();
            date.setFullYear(year);
            date.setDate(1);
            date.setMonth(month);
          } else {
            noMatchFound = true;
          }
        } else {
          noMatchFound = true;
        }

        if (noMatchFound) {
          throw new Error(this.invalidInput);
        }

        return date;
      }
    },
    _getDate: function _getDate(year, month, date, hours, mins, seconds) {
      return new Date(year, month, date, hours, mins, seconds);
    },
    getUTCDate: function getUTCDate() {
      return new Date(Date.UTC.apply(Date, arguments));
    },
    areDatesEqual: function areDatesEqual(first, second) {
      if (first && second) {
        return first.getFullYear() === second.getFullYear() && first.getMonth() === second.getMonth() && first.getDate() === second.getDate();
      }
    },
    areTimesEqual: function areTimesEqual(first, second) {
      if (first && second) {
        return first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes() && first.getSeconds() === second.getSeconds();
      }
    },
    isGreater: function isGreater(first, second) {
      if (first && second) {
        if (first.getTime() < second.getTime()) {
          return false;
        }

        return true;
      }
    },
    _appendZerosToValue: function _appendZerosToValue(number, chars, last) {
      var zeros = ["", "0", "00", "000", "0000"]; // No I18N 

      number = number.toString();
      chars = chars || 2;
      last = chars - number.length;

      if (last) {
        return zeros[chars].substring(0, last) + number;
      }

      return number;
    },
    _replaceMatchedText: function _replaceMatchedText(date, match) {
      if (date) {
        var minutes;
        var result;
        var sign;

        switch (match) {
          case "d":
            // No I18N
            result = date.getDate();
            break;

          case "dd":
            // No I18N
            var date = date.getDate();
            result = (date < 10 ? "0" : "") + date; // No I18N

            break;

          case "ddd":
            // No I18N
            result = this.daysAbbreviated[date.getDay()];
            break;

          case "dddd":
            // No I18N
            result = this.days[date.getDay()];
            break;

          case "M":
            // No I18N
            result = date.getMonth() + 1;
            break;

          case "MM":
            // No I18N
            var month = date.getMonth() + 1;
            result = (month < 10 ? "0" : "") + month; // No I18N

            break;

          case "MMM":
            // No I18N
            result = this.monthsAbbreviated[date.getMonth()];
            break;

          case "MMMM":
            // No I18N
            result = this.months[date.getMonth()];
            break;

          case "yy":
            // No I18N
            result = this._appendZerosToValue(date.getFullYear() % 100);
            break;

          case "yyyy":
            // No I18N
            result = this._appendZerosToValue(date.getFullYear(), 4);
            break;

          case "h":
            // No I18N
            result = date.getHours() % 12 || 12;
            break;

          case "hh":
            // No I18N
            var hours = date.getHours() % 12 || 12;
            result = (hours < 10 ? "0" : "") + hours; // No I18N

            break;

          case "H":
            // No I18N
            result = date.getHours();
            break;

          case "HH":
            // No I18N
            var hours = date.getHours();
            result = (hours < 10 ? "0" : "") + hours; // No I18N

            break;

          case "m":
            // No I18N
            result = date.getMinutes();
            break;

          case "mm":
            // No I18N
            var minutes = date.getMinutes();
            result = (minutes < 10 ? "0" : "") + minutes; // No I18N

            break;

          case "s":
            // No I18N
            result = date.getSeconds();
            break;

          case "ss":
            // No I18N
            var seconds = date.getSeconds();
            result = (seconds < 10 ? "0" : "") + seconds; // No I18N

            break;

          case "tt":
            // No I18N
            result = date.getHours() < 12 ? "AM" : "PM"; // No I18N

            break;

          case "z": // No I18N

          case "zz":
          case "zzz":
            result = date.toString().split(" ")[5];
            break;
        }

        return result !== undefined ? result : match.slice(1, match.length - 1);
      }
    },
    formatDate: function formatDate(date, format) {
      var dateFormatRegExp = /dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|HH|H|hh|h|mm|m|fff|ff|f|tt|ss|s|zzz|zz|z|"[^"]*"|'[^']*'/g; // No I18N

      var base = this;

      if (date && date instanceof Date) {
        return format.replace(dateFormatRegExp, this._replaceMatchedText.bind(this, date));
      }

      return date;
    }
  };
}(ZComponents);
/** $Id$ */

/*
 * Contains library methods for color , math , array.
 * Contributors :
 * J.Karthik - jkarthik@zohocorp.com ,
 * Sridhar P.G - sridharpg@zohocorp.com ,
 * Padmanabhan - padmanabhan.p@zohocorp.com
 */


(function (ZC) {
  var $ = ZC.DOMUtil;
  ZC.ColorUtil = {
    // rgb - An Array containing values for red, green, blue.

    /**
     * determinant value 0.25 means 25% darken.
     * which internally means (100 - 25) 75% luminance modulated.
     * luminance_new = (1 - determinant) * luminance.
     */
    darken: function darken(rgb, determinant) {
      determinant = this.limit(determinant, 0, 1);
      var a = [{
        mode: 'MODIFY',
        // No I18N
        value: 1 - determinant
      }];
      return this.hsl(rgb, {
        luminance: a
      });
    },

    /**
     * determinant value 0.6 means 60% lighten.
     * which internally means (100 - 60) 40% luminance modulated and 60% luminance shifted.
     * luminance_new = (1 - determinant) * luminance + determinant
     */
    lighten: function lighten(rgb, determinant) {
      determinant = this.limit(determinant, 0, 1);
      var a = [{
        mode: 'MODIFY',
        // No I18N
        value: 1 - determinant
      }, {
        mode: 'OFFSET',
        // No I18N
        value: determinant
      }];
      return this.hsl(rgb, {
        luminance: a
      });
    },

    /**
     * Modification done accoring to MS Format.
     * social.msdn.microsoft.com/Forums/en-US/oxmlsdk/thread/f6d26f2c-114f-4a0d-8bca-a27442aec4d0
     * Based on https://www.w3.org/TR/css-color-4/#tint-shade-adjusters
     * 10% shade means - 10% black mixed with 90% pure color
     */
    shade: function shade(rgb, determinant) {
      determinant = this.limit(determinant, 0, 1);
      var a = [{
        mode: 'MODIFY',
        // No I18N
        value: 1 - determinant
      }];
      return this.rgb(rgb, {
        red: a,
        green: a,
        blue: a
      });
    },

    /* 10% tint means - 10% white mixed with 90% pure color
        */
    tint: function tint(rgb, determinant) {
      determinant = this.limit(determinant, 0, 1);
      var a = [{
        mode: 'MODIFY',
        // No I18N
        value: 1 - determinant
      }, {
        mode: 'OFFSET',
        // No I18N
        value: determinant
      }];
      return this.rgb(rgb, {
        red: a,
        green: a,
        blue: a
      });
    },
    rgb: function rgb(_rgb, rgbMod) {
      return this.modify(_rgb, rgbMod, 'linearRGB'); // No I18N
    },

    /**
     * social.msdn.microsoft.com/Forums/en-US/oxmlsdk/thread/f6d26f2c-114f-4a0d-8bca-a27442aec4d0
     */
    tolinearRGB: function tolinearRGB(rgb) {
      return rgb.map(function (value) {
        value = value / 255;

        if (value < 0) {
          return 0;
        }

        if (value <= 0.0405) {
          return value / 12.92;
        }

        if (value <= 1) {
          var x = (value + 0.055) / 1.055;
          return Math.pow(x, 2.4);
        }

        return 1;
      });
    },

    /*
        * social.msdn.microsoft.com/Forums/en-US/oxmlsdk/thread/f6d26f2c-114f-4a0d-8bca-a27442aec4d0
        */
    linearRGBtoRGB: function linearRGBtoRGB(scrgb) {
      return scrgb.map(function (value) {
        if (value < 0) {
          value = 0;
        } else if (value <= 0.0031308) {
          value *= 12.92;
        } else if (value <= 1) {
          var y = 1 / 2.4;
          value = 1.055 * Math.pow(value, y) - 0.055;
        } else {
          value = 1;
        }

        return Math.round(value *= 255);
      });
    },
    modify: function modify(rgb, modObjects, mode) {
      var _this5 = this;

      var clrArr = this["to".concat(mode)](rgb); // No I18N

      var mapping = {
        red: 0,
        green: 1,
        blue: 2,
        luminance: 2
      };

      var _loop2 = function _loop2(key) {
        var index = mapping[key];
        modObjects[key].forEach(function (modObject) {
          clrArr[index] = _this5.modifyValue(clrArr[index], modObject);
        });
      };

      for (var key in modObjects) {
        _loop2(key);
      }

      return this["".concat(mode, "toRGB")](clrArr); // No I18N
    },
    modifyValue: function modifyValue(value, modObject) {
      if (modObject.mode === 'MODIFY') {
        // No I18N
        value *= parseFloat(modObject.value);
      } else if (modObject.mode === 'OFFSET') {
        // No I18N
        value += parseFloat(modObject.value);
      }

      return value;
    },
    hsl: function hsl(rgb, hslMod) {
      return this.modify(rgb, hslMod, 'HSL'); // No I18N
    },

    /**
     * en.wikipedia.org/wiki/HSL_and_HSV
     * returns hsl , h ranges from 0 - 1, s from 0 - 1 ,  l from 0 - 1
     */
    toHSL: function toHSL(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var max = Math.max.apply(Math, _toConsumableArray(rgb));
      var min = Math.min.apply(Math, _toConsumableArray(rgb));
      var h = 0;
      var n;

      if (max === min) {
        h = 0;
      } else if (max === r) {
        n = (g - b) / (max - min);
        h = (60 * n + 360) % 360;
      } else if (max === g) {
        n = (b - r) / (max - min);
        h = 60 * n + 120;
      } else {
        // b
        n = (r - g) / (max - min);
        h = 60 * n + 240;
      }

      h /= 360;
      var l = (max + min) / (255 * 2);
      var s = 0;

      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = (max - min) / (2 * l);
      } else {
        s = (max - min) / (2 - 2 * l);
      }

      s /= 255;
      return [h, s, l];
    },

    /**
     * en.wikipedia.org/wiki/HSL_and_HSV
     * argument hsl , h ranges from 0 - 1 , s from 0 - 1 ,  l from 0 - 1
     * returns rgb
     */
    HSLtoRGB: function HSLtoRGB(hsl) {
      var _this6 = this;

      var h = hsl[0];
      var s = hsl[1];
      var l = hsl[2];
      var q;

      if (l < 0.5) {
        q = l * (1 + s);
      } else {
        q = l + s - l * s;
      }

      var p = 2 * l - q;
      var hk = h;
      var tr = hk + 1 / 3;
      var tg = hk;
      var tb = hk - 1 / 3;
      return [tr, tg, tb].map(function (value) {
        if (value < 0) {
          value += 1;
        } else if (value > 1) {
          value -= 1;
        }

        value = value % 1;

        if (value < 1 / 6) {
          value = p + (q - p) * 6 * value;
        } else if (value >= 1 / 6 && value < 0.5) {
          value = q;
        } else if (value >= 0.5 && value < 2 / 3) {
          value = p + (q - p) * 6 * (2 / 3 - value);
        } else {
          value = p;
        }

        return Math.round(_this6.limit(value, 0, 1) * 255);
      });
    },

    /* https://en.wikipedia.org/wiki/Talk%3ACMYK_color_model */
    cmykToRGB: function cmykToRGB(cmyk) {
      var r = 255 * (1 - cmyk[0]) * (1 - cmyk[3]);
      var g = 255 * (1 - cmyk[1]) * (1 - cmyk[3]);
      var b = 255 * (1 - cmyk[2]) * (1 - cmyk[3]);
      return [r, g, b];
    },

    /* https://en.wikipedia.org/wiki/Talk%3ACMYK_color_model */
    rgbToCMYK: function rgbToCMYK(rgb) {
      var c = 1 - rgb[0] / 255;
      var m = 1 - rgb[1] / 255;
      var y = 1 - rgb[2] / 255;
      var minCMY = Math.min(c, m, y);
      c = (c - minCMY) / (1 - minCMY);
      m = (m - minCMY) / (1 - minCMY);
      y = (y - minCMY) / (1 - minCMY);
      var k = minCMY; // 0/0 may result in **NaN**

      c = isNaN(c) ? 0 : c;
      m = isNaN(m) ? 0 : m;
      y = isNaN(y) ? 0 : y;
      return [c, m, y, k];
    },
    isDark: function isDark(rgb) {
      return this.brightness(rgb) < 0.5 * 255;
    },
    rgbToHex: function rgbToHex(rgb) {
      var hex = '#'; // No I18N

      rgb.forEach(function (value) {
        hex += ZC.ColorUtil.numToHex(value);
      });
      return hex;
    },
    rgbToHSV: function rgbToHSV(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var v = max * 100;
      var h = 0;
      var s = 0;
      var delta = max - min;

      if (max === 0) {
        // #000
        s = h = 0;
        return [h, s, v];
      }

      s = delta / max * 100;
      var sector = 0;

      if (delta) {
        if (r === max) {
          sector = (g - b) / delta;
        } else if (g === max) {
          sector = 2 + (b - r) / delta;
        } else {
          sector = 4 + (r - g) / delta;
        }
      }

      h = sector * 60;

      if (h < 0) {
        h += 360;
      }

      var _r = Math.round;
      h = _r(h * 100) / 100;
      s = _r(s * 100) / 100;
      v = _r(v * 100) / 100;
      return [h, s, v];
    },
    hsvToRGB: function hsvToRGB(hsv) {
      // www.cs.rit.edu/~ncs/color/t_convert.html
      var h = hsv[0];
      var s = hsv[1];
      var v = hsv[2];

      var _s = s / 100;

      var _v = v / 100;

      var r, g, b;
      r = g = b = 0;

      var set = function set(_r, _g, _b) {
        var _rd = Math.round;
        r = _rd(_r * 255);
        g = _rd(_g * 255);
        b = _rd(_b * 255);
      };

      if (_s === 0) {
        set(_v, _v, _v);
        return [r, g, b];
      }

      if (h === 360) {
        h = 0;
      }

      var _sector = h / 60;

      var sector = Math.floor(_sector);
      var factorial = _sector - sector;
      var p = _v * (1 - _s);
      var q = _v * (1 - _s * factorial);
      var t = _v * (1 - _s * (1 - factorial));

      switch (sector) {
        case 0:
          set(_v, t, p);
          break;

        case 1:
          set(q, _v, p);
          break;

        case 2:
          set(p, _v, t);
          break;

        case 3:
          set(p, q, _v);
          break;

        case 4:
          set(t, p, _v);
          break;

        default:
          set(_v, p, q);
      }

      return [r, g, b];
    },

    /* number -> 0 - 255 */
    numToHex: function numToHex(number) {
      var hexCode = parseInt(number).toString(16);
      return hexCode.length === 1 ? "0".concat(hexCode) : hexCode;
    },
    hexToNum: function hexToNum(hex) {
      return parseInt(hex, 16);
    },
    // Algorithm to find brightness www.w3.org/TR/AERT
    brightness: function brightness(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      return r * 0.299 + g * 0.587 + b * 0.114;
    },
    limit: function limit(val, min, max) {
      return Math.max(Math.min(val, max), min);
    },
    getColorInstance: function getColorInstance(color) {
      return new ZC.Color(color);
    },
    REGEX: {
      colorMode: /^(rgb|rgba|hsl|hsla|hsv|hsva|hex|hex8|cmyk)$/
    }
  };

  ZC.Color = function (color) {
    this.init(color);
    return this;
  };

  ZC.Color.prototype = {
    init: function init(color) {
      this.initialColor = color;
      color = inputToRGB(color);

      if (color) {
        this._r = color.r;
        this._g = color.g;
        this._b = color.b;
        this._a = color.a;
        this.format = color.format;
        this.colorInFormat = color.colorInFormat;
        this._valid = true;
      } else {
        this._valid = false;
      }
    },
    isValid: function isValid() {
      return this._valid;
    },
    colorCodeMapping: {
      hue: 'decimal',
      // No I18N
      saturation: 'percent',
      // No I18N
      brightness: 'percent',
      // No I18N
      lightness: 'percent',
      // No I18N
      rgb: 'decimal',
      // No I18N
      cmyk: 'percent',
      // No I18N
      opacity: 'decimal' // No I18N

    },
    getObject: function getObject(format, colorCodeMapping) {
      /* var rgb = [ this._r, this._g, this._b ];
      var r = Math.round;
      if( /(hsv)/.test(format)  ){
      	var hsv = ZC.ColorUtil.rgbToHSV( rgb );
      	return { h: r( hsv[0] ), s: r(hsv[1])+'%', v:r(hsv[2])+'%', a: this._a };
      }else if( /(hsl)/.test(format) ){
      	var hsl = ZC.ColorUtil.toHSL( rgb );
      	return { h: r( hsl[0]*360 ), s: r(hsl[1]*100) +'%', l:r(hsl[2]*100) +'%', a: this._a };
      }else if(/(cmyk)/.test(format)){
      	var cmyk = ZC.ColorUtil.rgbToCMYK( rgb );
      	return {c: r(  ) }
      }else if( format === 'hex'){
      	return ZC.ColorUtil.rgbToHex( rgb ).replace(/#/,'');
      }else if( format === 'hex8' ){
      	return ZC.ColorUtil.rgbToHex( rgb ).replace(/#/,'') + ZC.ColorUtil.numToHex( this._a*255 );
      }else{
      	return { r: r( this._r ), g: r( this._g ), b: r( this._b ), a: this._a };
      } */
      colorCodeMapping = colorCodeMapping ? $.extend({}, this.colorCodeMapping, colorCodeMapping) : this.colorCodeMapping;
      var rgb = [this._r, this._g, this._b];
      var r = Math.round;

      var fixTo2 = function fixTo2(value) {
        return r(value * 100) / 100;
      };

      var getHue = function getHue(type, frac) {
        return type === 'percent' ? fixTo2(frac * 100) + '%' : r(frac * 360); // No I18N
      };

      var getRGB = function getRGB(type, frac) {
        return type === 'percent' ? fixTo2(frac * 100) + '%' : r(frac * 255); // No I18N
      };

      var getDefault = function getDefault(type, frac) {
        return type === 'decimal' ? fixTo2(frac) : r(frac * 100) + '%'; // No I18N
      };

      if (/(hsv)/.test(format)) {
        var hsv = [];

        if (/(hsv)/.test(this.format)) {
          hsv[0] = this.colorInFormat.h;
          hsv[1] = this.colorInFormat.s;
          hsv[2] = this.colorInFormat.v;
        } else {
          hsv = ZC.ColorUtil.rgbToHSV(rgb);

          if (/(hsl)/.test(this.format)) {
            hsv[0] = this.colorInFormat.h * 360;
          }
        }

        return {
          h: getHue(colorCodeMapping.hue, hsv[0] / 360),
          s: getDefault(colorCodeMapping.saturation, hsv[1] / 100),
          v: getDefault(colorCodeMapping.brightness, hsv[2] / 100),
          a: getDefault(colorCodeMapping.opacity, this._a)
        };
      } else if (/(hsl)/.test(format)) {
        var hsl = [];

        if (/(hsl)/.test(this.format)) {
          hsl[0] = this.colorInFormat.h;
          hsl[1] = this.colorInFormat.s;
          hsl[2] = this.colorInFormat.l;
        } else {
          hsl = ZC.ColorUtil.toHSL(rgb);

          if (/(hsv)/.test(this.format)) {
            hsl[0] = this.colorInFormat.h / 360;
          }
        }

        return {
          h: getHue(colorCodeMapping.hue, hsl[0]),
          s: getDefault(colorCodeMapping.saturation, hsl[1]),
          l: getDefault(colorCodeMapping.lightness, hsl[2]),
          a: getDefault(colorCodeMapping.opacity, this._a)
        };
      } else if (/(cmyk)/.test(format)) {
        var cmyk = [];

        if (/(cmyk)/.test(this.format)) {
          cmyk[0] = this.colorInFormat.c;
          cmyk[1] = this.colorInFormat.m;
          cmyk[2] = this.colorInFormat.y;
          cmyk[3] = this.colorInFormat.k;
        } else {
          cmyk = ZC.ColorUtil.rgbToCMYK(rgb);
        }

        return {
          c: getDefault(colorCodeMapping.cmyk, cmyk[0]),
          m: getDefault(colorCodeMapping.cmyk, cmyk[1]),
          y: getDefault(colorCodeMapping.cmyk, cmyk[2]),
          k: getDefault(colorCodeMapping.cmyk, cmyk[3])
        };
      } else if (/(hex)/.test(format)) {
        return {
          hex: ZC.ColorUtil.rgbToHex(rgb).replace(/#/, ''),
          // No I18N
          a: getDefault(colorCodeMapping.opacity, this._a)
        };
      }

      return {
        r: getRGB(colorCodeMapping.rgb, rgb[0] / 255),
        g: getRGB(colorCodeMapping.rgb, rgb[1] / 255),
        b: getRGB(colorCodeMapping.rgb, rgb[2] / 255),
        a: getDefault(colorCodeMapping.opacity, this._a)
      };
    },
    getPercentageObject: function getPercentageObject(format) {
      var color = this.getObject(format);

      if (/(hsv|hsl)/.test(format)) {
        color.h = color.h / 360 * 100 + '%'; // No I18N

        color.a = color.a * 100 + '%'; // No I18N
      } else if (/(rgb)/.test(format)) {
        color.r = color.r / 255 * 100 + '%'; // No I18N

        color.g = color.g / 255 * 100 + '%'; // No I18N

        color.b = color.b / 255 * 100 + '%'; // No I18N

        color.a = color.a * 100 + '%'; // No I18N
      }

      return color;
    },
    getColor: function getColor(format, colorCodeMapping, flexible) {
      var color = this.getObject(format, colorCodeMapping);

      if (color) {
        var isAlpha = this._a !== 1;
        flexible = flexible === undefined ? true : flexible;

        if (/^(hsv)/.test(format)) {
          format = flexible ? isAlpha ? 'hsva' : 'hsv' : format; // No I18N

          if (/^(hsva)/.test(format)) {
            return 'hsva(' + color.h + ', ' + color.s + ', ' + color.v + ', ' + color.a + ')'; // No I18N
          }

          return 'hsv(' + color.h + ', ' + color.s + ', ' + color.v + ')'; // No I18N
        } else if (/^(hsl)/.test(format)) {
          format = flexible ? isAlpha ? 'hsla' : 'hsl' : format; // No I18N

          if (/^(hsla)/.test(format)) {
            return 'hsla(' + color.h + ', ' + color.s + ', ' + color.l + ', ' + color.a + ')'; // No I18N
          }

          return 'hsl(' + color.h + ', ' + color.s + ', ' + color.l + ')'; // No I18N
        } else if (/^(cmyk)$/.test(format)) {
          return 'cmyk(' + color.c + ',' + color.m + ',' + color.y + ',' + color.k + ')'; // No I18N
        } else if (/^(hex)/.test(format)) {
          format = flexible ? isAlpha ? 'hex8' : 'hex' : format; // No I18N

          if (/^(hex8)/.test(format)) {
            return '#' + color.hex + ZC.ColorUtil.numToHex(this._a * 255); // No I18N
          }

          return '#' + color.hex; // No I18N
        }

        format = flexible || !/(rgb)/.test(format) ? isAlpha ? 'rgba' : 'rgb' : format; // No I18N

        if (/^(rgba)/.test(format)) {
          return 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + color.a + ')'; // No I18N
        }

        return 'rgb(' + color.r + ', ' + color.g + ', ' + color.b + ')'; // No I18N
      }
    },
    setAlpha: function setAlpha(alpha) {
      this._a = validate('a', alpha); // No I18N
    },
    getAlpha: function getAlpha() {
      return this._a;
    },
    setColor: function setColor(color) {
      this.init(color);
    }
  }; // <http://www.w3.org/TR/css3-color/#svg-color>

  var colornames = {
    aliceblue: '#f0f8ff',
    // No I18N
    antiquewhite: '#faebd7',
    // No I18N
    aqua: '#00ffff',
    // No I18N
    aquamarine: '#7fffd4',
    // No I18N
    azure: '#f0ffff',
    // No I18N
    beige: '#f5f5dc',
    // No I18N
    bisque: '#ffe4c4',
    // No I18N
    black: '#000000',
    // No I18N
    blanchedalmond: '#ffebcd',
    // No I18N
    blue: '#0000ff',
    // No I18N
    blueviolet: '#8a2be2',
    // No I18N
    brown: '#a52a2a',
    // No I18N
    burlywood: '#deb887',
    // No I18N
    cadetblue: '#5f9ea0',
    // No I18N
    chartreuse: '#7fff00',
    // No I18N
    chocolate: '#d2691e',
    // No I18N
    coral: '#ff7f50',
    // No I18N
    cornflowerblue: '#6495ed',
    // No I18N
    cornsilk: '#fff8dc',
    // No I18N
    crimson: '#dc143c',
    // No I18N
    cyan: '#00ffff',
    // No I18N
    darkblue: '#00008b',
    // No I18N
    darkcyan: '#008b8b',
    // No I18N
    darkgoldenrod: '#b8860b',
    // No I18N
    darkgray: '#a9a9a9',
    // No I18N
    darkgreen: '#006400',
    // No I18N
    darkgrey: '#a9a9a9',
    // No I18N
    darkkhaki: '#bdb76b',
    // No I18N
    darkmagenta: '#8b008b',
    // No I18N
    darkolivegreen: '#556b2f',
    // No I18N
    darkorange: '#ff8c00',
    // No I18N
    darkorchid: '#9932cc',
    // No I18N
    darkred: '#8b0000',
    // No I18N
    darksalmon: '#e9967a',
    // No I18N
    darkseagreen: '#8fbc8f',
    // No I18N
    darkslateblue: '#483d8b',
    // No I18N
    darkslategray: '#2f4f4f',
    // No I18N
    darkslategrey: '#2f4f4f',
    // No I18N
    darkturquoise: '#00ced1',
    // No I18N
    darkviolet: '#9400d3',
    // No I18N
    deeppink: '#ff1493',
    // No I18N
    deepskyblue: '#00bfff',
    // No I18N
    dimgray: '#696969',
    // No I18N
    dimgrey: '#696969',
    // No I18N
    dodgerblue: '#1e90ff',
    // No I18N
    firebrick: '#b22222',
    // No I18N
    floralwhite: '#fffaf0',
    // No I18N
    forestgreen: '#228b22',
    // No I18N
    fuchsia: '#ff00ff',
    // No I18N
    gainsboro: '#dcdcdc',
    // No I18N
    ghostwhite: '#f8f8ff',
    // No I18N
    gold: '#ffd700',
    // No I18N
    goldenrod: '#daa520',
    // No I18N
    gray: '#808080',
    // No I18N
    green: '#008000',
    // No I18N
    greenyellow: '#adff2f',
    // No I18N
    grey: '#808080',
    // No I18N
    honeydew: '#f0fff0',
    // No I18N
    hotpink: '#ff69b4',
    // No I18N
    indianred: '#cd5c5c',
    // No I18N
    indigo: '#4b0082',
    // No I18N
    ivory: '#fffff0',
    // No I18N
    khaki: '#f0e68c',
    // No I18N
    lavender: '#e6e6fa',
    // No I18N
    lavenderblush: '#fff0f5',
    // No I18N
    lawngreen: '#7cfc00',
    // No I18N
    lemonchiffon: '#fffacd',
    // No I18N
    lightblue: '#add8e6',
    // No I18N
    lightcoral: '#f08080',
    // No I18N
    lightcyan: '#e0ffff',
    // No I18N
    lightgoldenrodyellow: '#fafad2',
    // No I18N
    lightgray: '#d3d3d3',
    // No I18N
    lightgreen: '#90ee90',
    // No I18N
    lightgrey: '#d3d3d3',
    // No I18N
    lightpink: '#ffb6c1',
    // No I18N
    lightsalmon: '#ffa07a',
    // No I18N
    lightseagreen: '#20b2aa',
    // No I18N
    lightskyblue: '#87cefa',
    // No I18N
    lightslategray: '#778899',
    // No I18N
    lightslategrey: '#778899',
    // No I18N
    lightsteelblue: '#b0c4de',
    // No I18N
    lightyellow: '#ffffe0',
    // No I18N
    lime: '#00ff00',
    // No I18N
    limegreen: '#32cd32',
    // No I18N
    linen: '#faf0e6',
    // No I18N
    magenta: '#ff00ff',
    // No I18N
    maroon: '#800000',
    // No I18N
    mediumaquamarine: '#66cdaa',
    // No I18N
    mediumblue: '#0000cd',
    // No I18N
    mediumorchid: '#ba55d3',
    // No I18N
    mediumpurple: '#9370db',
    // No I18N
    mediumseagreen: '#3cb371',
    // No I18N
    mediumslateblue: '#7b68ee',
    // No I18N
    mediumspringgreen: '#00fa9a',
    // No I18N
    mediumturquoise: '#48d1cc',
    // No I18N
    mediumvioletred: '#c71585',
    // No I18N
    midnightblue: '#191970',
    // No I18N
    mintcream: '#f5fffa',
    // No I18N
    mistyrose: '#ffe4e1',
    // No I18N
    moccasin: '#ffe4b5',
    // No I18N
    navajowhite: '#ffdead',
    // No I18N
    navy: '#000080',
    // No I18N
    oldlace: '#fdf5e6',
    // No I18N
    olive: '#808000',
    // No I18N
    olivedrab: '#6b8e23',
    // No I18N
    orange: '#ffa500',
    // No I18N
    orangered: '#ff4500',
    // No I18N
    orchid: '#da70d6',
    // No I18N
    palegoldenrod: '#eee8aa',
    // No I18N
    palegreen: '#98fb98',
    // No I18N
    paleturquoise: '#afeeee',
    // No I18N
    palevioletred: '#db7093',
    // No I18N
    papayawhip: '#ffefd5',
    // No I18N
    peachpuff: '#ffdab9',
    // No I18N
    peru: '#cd853f',
    // No I18N
    pink: '#ffc0cb',
    // No I18N
    plum: '#dda0dd',
    // No I18N
    powderblue: '#b0e0e6',
    // No I18N
    purple: '#800080',
    // No I18N
    rebeccapurple: '#663399',
    // No I18N
    red: '#ff0000',
    // No I18N
    rosybrown: '#bc8f8f',
    // No I18N
    royalblue: '#4169e1',
    // No I18N
    saddlebrown: '#8b4513',
    // No I18N
    salmon: '#fa8072',
    // No I18N
    sandybrown: '#f4a460',
    // No I18N
    seagreen: '#2e8b57',
    // No I18N
    seashell: '#fff5ee',
    // No I18N
    sienna: '#a0522d',
    // No I18N
    silver: '#c0c0c0',
    // No I18N
    skyblue: '#87ceeb',
    // No I18N
    slateblue: '#6a5acd',
    // No I18N
    slategray: '#708090',
    // No I18N
    slategrey: '#708090',
    // No I18N
    snow: '#fffafa',
    // No I18N
    springgreen: '#00ff7f',
    // No I18N
    steelblue: '#4682b4',
    // No I18N
    tan: '#d2b48c',
    // No I18N
    teal: '#008080',
    // No I18N
    thistle: '#d8bfd8',
    // No I18N
    tomato: '#ff6347',
    // No I18N
    turquoise: '#40e0d0',
    // No I18N
    violet: '#ee82ee',
    // No I18N
    wheat: '#f5deb3',
    // No I18N
    white: '#ffffff',
    // No I18N
    whitesmoke: '#f5f5f5',
    // No I18N
    yellow: '#ffff00',
    // No I18N
    yellowgreen: '#9acd32' // No I18N

  };

  var matchers = function () {
    // <http://www.w3.org/TR/css3-values/#integers>
    var INT = '[-\\+]?\\d+%?'; // No I18N
    // <http://www.w3.org/TR/css3-values/#number-value>

    var NUM = '[-\\+]?\\d*\\.\\d+%?'; // No I18N
    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.

    var VALUEPATTERN = '(?:' + NUM + ')|(?:' + INT + ')'; // No I18N
    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren

    var MATCH3 = '[\\s|\\(]+(' + VALUEPATTERN + ')[,|\\s]+(' + VALUEPATTERN + ')[,|\\s]+(' + VALUEPATTERN + ')\\s*\\)?'; // No I18N

    var MATCH4 = '[\\s|\\(]+(' + VALUEPATTERN + ')[,|\\s]+(' + VALUEPATTERN + ')[,|\\s]+(' + VALUEPATTERN + ')[,|\\s]+(' + VALUEPATTERN + ')\\s*\\)?'; // No I18N

    return {
      value: new RegExp(VALUEPATTERN),
      rgb: new RegExp('rgb' + MATCH3),
      // No I18N
      rgba: new RegExp('rgba' + MATCH4),
      // No I18N
      hsl: new RegExp('hsl' + MATCH3),
      // No I18N
      hsla: new RegExp('hsla' + MATCH4),
      // No I18N
      hsv: new RegExp('hsv' + MATCH3),
      // No I18N
      hsva: new RegExp('hsva' + MATCH4),
      // No I18N
      cmyk: new RegExp('cmyk' + MATCH4),
      // No I18N
      hex3: /^#?([0-9a-f]{1})([0-9a-f]{1})([0-9a-f]{1})$/,
      hex6: /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/,
      hex8: /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/ // hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,

    };
  }();

  var validate = function validate(prop, value) {
    var isper = /%/.test(value);
    value = isper ? parseFloat(value) / 100 : parseFloat(value);

    if (prop === 'h') {
      // No I18N
      return Math.round(ZC.ColorUtil.limit(isper ? value * 360 : value, 0, 360));
    } else if (/(s|v|l)/.test(prop)) {
      return Math.round(ZC.ColorUtil.limit(value * 100, 0, 100));
    } else if (/(c|m|y|k)/.test(prop)) {
      return Math.round(ZC.ColorUtil.limit(value, 0, 1) * 100) / 100;
    } else if (/(r|g|b)/.test(prop)) {
      return Math.round(ZC.ColorUtil.limit(isper ? value * 255 : value, 0, 255));
    } else if (prop === 'a') {
      // No I18N
      return value === undefined || isNaN(value) || value < 0 || value > 1 ? 1 : value;
    }
  };

  var inputToRGB = function inputToRGB(color) {
    color = inputToObject(color);

    if (_typeof(color) === 'object') {
      // No I18N
      var format = color.format;
      var rgb;

      if (color.hasOwnProperty('h') && color.hasOwnProperty('s') && color.hasOwnProperty('v')) {
        // No I18N
        format = format || 'hsva'; // No I18N

        color.h = validate('h', color.h); // No I18N

        color.s = validate('s', color.s); // No I18N

        color.v = validate('v', color.v); // No I18N

        rgb = ZC.ColorUtil.hsvToRGB([color.h, color.s, color.v]);
      } else if (color.hasOwnProperty('h') && color.hasOwnProperty('s') && color.hasOwnProperty('l')) {
        // No I18N
        format = format || 'hsla'; // No I18N

        color.h = validate('h', color.h) / 360; // No I18N

        color.s = validate('s', color.s) / 100; // No I18N

        color.l = validate('l', color.l) / 100; // No I18N

        rgb = ZC.ColorUtil.HSLtoRGB([color.h, color.s, color.l]);
      } else if (color.hasOwnProperty('r') && color.hasOwnProperty('g') && color.hasOwnProperty('b')) {
        // No I18N
        format = format || 'rgba'; // No I18N

        color.r = validate('r', color.r); // No I18N

        color.g = validate('g', color.g); // No I18N

        color.b = validate('b', color.b); // No I18N

        rgb = [color.r, color.g, color.b];
      } else if (color.hasOwnProperty('c') && color.hasOwnProperty('m') && color.hasOwnProperty('y') && color.hasOwnProperty('k')) {
        // No I18N
        format = format || 'cmyk'; // No I18N

        color.c = validate('c', color.c); // No I18N

        color.m = validate('m', color.m); // No I18N

        color.y = validate('y', color.y); // No I18N

        color.k = validate('k', color.k); // No I18N

        rgb = ZC.ColorUtil.cmykToRGB([color.c, color.m, color.y, color.k]);
      } else if (color.hasOwnProperty('hex')) {
        // No I18N
        format = format || 'hex'; // No I18N

        rgb = inputToObject(color.hex);

        if (!rgb) {
          return;
        }

        rgb = [rgb.r, rgb.g, rgb.b];
      }

      if (rgb) {
        return {
          r: rgb[0],
          g: rgb[1],
          b: rgb[2],
          a: validate('a', color.a),
          // No I18N
          format: format,
          colorInFormat: color
        };
      }
    }
  };

  var inputToObject = function inputToObject(color) {
    if (typeof color === 'string' || typeof color === 'number') {
      // No I18N
      color = color.trim().toLowerCase();
      var isName = false;

      if (colornames[color]) {
        color = colornames[color];
        isName = true;
      } else if (color === 'transparent') {
        // No I18N
        return {
          r: 0,
          g: 0,
          b: 0,
          a: 0
        };
      }

      var match = matchers.rgb.exec(color);

      if (match) {
        return {
          r: match[1],
          g: match[2],
          b: match[3],
          format: 'rgb' // No I18N

        };
      }

      match = matchers.rgba.exec(color);

      if (match) {
        return {
          r: match[1],
          g: match[2],
          b: match[3],
          a: match[4],
          format: 'rgba' // No I18N

        };
      }

      match = matchers.hsl.exec(color);

      if (match) {
        return {
          h: match[1],
          s: match[2],
          l: match[3],
          format: 'hsl' // No I18N

        };
      }

      match = matchers.hsla.exec(color);

      if (match) {
        return {
          h: match[1],
          s: match[2],
          l: match[3],
          a: match[4],
          format: 'hsla' // No I18N

        };
      }

      match = matchers.hsv.exec(color);

      if (match) {
        return {
          h: match[1],
          s: match[2],
          v: match[3],
          format: 'hsv' // No I18N

        };
      }

      match = matchers.hsva.exec(color);

      if (match) {
        return {
          h: match[1],
          s: match[2],
          v: match[3],
          a: match[4],
          format: 'hsva' // No I18N

        };
      }

      match = matchers.cmyk.exec(color);

      if (match) {
        return {
          c: match[1],
          m: match[2],
          y: match[3],
          k: match[4],
          format: 'cmyk' // No I18N

        };
      }

      match = matchers.hex8.exec(color);

      if (match) {
        return {
          r: ZC.ColorUtil.hexToNum(match[1]),
          g: ZC.ColorUtil.hexToNum(match[2]),
          b: ZC.ColorUtil.hexToNum(match[3]),
          a: Math.round(ZC.ColorUtil.hexToNum(match[4]) / 255 * 100) / 100,
          format: 'hex8' // No I18N

        };
      }

      match = matchers.hex6.exec(color);

      if (match) {
        return {
          r: ZC.ColorUtil.hexToNum(match[1]),
          g: ZC.ColorUtil.hexToNum(match[2]),
          b: ZC.ColorUtil.hexToNum(match[3]),
          format: isName ? 'rgba' : 'hex' // No I18N

        };
      }

      match = matchers.hex3.exec(color);

      if (match) {
        return {
          r: ZC.ColorUtil.hexToNum(match[1] + match[1]),
          g: ZC.ColorUtil.hexToNum(match[2] + match[2]),
          b: ZC.ColorUtil.hexToNum(match[3] + match[3]),
          format: 'hex' // No I18N

        };
      }
    } else if (Array.isArray(color)) {
      return {
        r: color[0],
        g: color[1],
        b: color[2],
        a: color[3],
        format: 'rgba' // No I18N

      };
    } else {
      return Object.assign({}, color);
    }
  };
})(ZComponents);
/* $Id$ */


var ZShortCut = function (ZC) {
  var $ = ZC.DOMUtil;
  "use strict"; // No I18N


  var broswerObj = ZC.OS,
      allowedModifiers = ["ctrl", "cmd", "shift", "alt"],
      // No I18N
  isMac = broswerObj.isMac(),
      handleAction = true,
      isWindows = broswerObj.isWindows(),
      allKeys = {},
      keyMap = {},
      options = {},
      isShortcutEnabled = true,
      keyUpBinded = false,
      spCharArr = {
    "<F1>": "112",
    // No I18N
    "<F2>": "113",
    // No I18N
    "<F3>": "114",
    // No I18N
    "<F4>": "115",
    // No I18N
    "<F5>": "116",
    // No I18N
    "<F6>": "117",
    // No I18N
    "<F7>": "118",
    // No I18N
    "<F8>": "119",
    // No I18N
    "<F9>": "120",
    // No I18N
    "<F10>": "121",
    // No I18N	
    "<F11>": "122",
    // No I18N
    "<F12>": "123",
    // No I18N
    "PRINTSCREEN": "44",
    // No I18N
    "NUMLOCK": "144",
    // No I18N
    "PAUSE": "19",
    // No I18N
    "INSERT": "45",
    // No I18N
    "HOME": "36",
    // No I18N
    "PAGEUP": "33",
    // No I18N
    "PAGEDOWN": "34",
    // No I18N
    "DELETE": "46",
    // No I18N
    "END": "35",
    // No I18N
    "TAB": "9",
    // No I18N
    "CAPSLOCK": "20",
    // No I18N
    "WINDOWS": "91",
    // No I18N
    "ARROW_UP": "38",
    // No I18N
    "ARROW_DOWN": "40",
    // No I18N
    "ARROW_LEFT": "37",
    // No I18N
    "ARROW_RIGHT": "39",
    // No I18N
    "ENTER": "13",
    // No I18N
    "BACKSPACE": "8",
    // No I18N
    'SPACE': "32",
    // No I18N
    "ESCAPE": "27",
    // No I18N
    "DOT": "190",
    //key - .  Dot, Delete  keys have the same keycode. '.'.charCodeAt(0) = 46, keyCode for delete = 46. In this case we have to consider dot as a special char like TAB, SPACE, DELETE ....    // No I18N
    ".": "190",
    // User can register either (.) or (dot/DOT).
    "": "226",
    //To handle (<)&(>) keys in same button in GERMAN keyboard.	//No I18N			
    "91": "219",
    //Key - \  // No I18N
    "92": "220",
    //key - ] // No I18N
    "93": "221",
    //Key - [ // No I18N
    "61": "187",
    //key - = // No I18N
    "45": "189",
    //key - - // No I18N
    "96": "192",
    //key - ` // No I18N
    "44": "188",
    //key - , // No I18N
    "47": "191",
    //key - / // No I18N
    "39": "222",
    //key - ' // No I18N
    "59": "186",
    //key - ; // No I18N
    "123": "219",
    //key - |	 // No I18N
    "124": "220",
    //Key - }	 // No I18N
    "125": "221",
    //Key - {   // No I18N
    "43": "187",
    //Key - +    // No I18N
    "95": "189",
    //Key - _    // No I18N
    "126": "192",
    //Key - ~   // No I18N
    "60": "188",
    //Key - <    // No I18N
    "62": "190",
    //Key - >    // No I18N
    "63": "191",
    //Key - ?   // No I18N
    "34": "222",
    //Key - "   // No I18N
    "58": "186",
    //Key - :     // No I18N
    "33": "49",
    //Key - !  // No I18N
    "64": "50",
    //key - @    // No I18N
    "35": "51",
    //key - #   // No I18N
    "36": "52",
    //key - $   // No I18N
    "37": "53",
    //key - %    // No I18N
    "94": "54",
    //key - ^    // No I18N
    "38": "55",
    //key - &   // No I18N
    "42": "56",
    //key - *    // No I18N
    "40": "57",
    //key - (  // No I18N
    "41": "48" //key - )    // No I18N

  };
  var tagNames = ["BUTTON", "INPUT", "TEXTAREA", "OPTION", "SELECT", "TEXTAREA", "OPTGROUP", "FIELDSET"]; // No I18N

  ZC.$document.on("keydown.shortcut", function (orgEvent) {
    // No I18N
    triggerShortcut(orgEvent, true);
  });

  function triggerShortcut(eventObj, isKeyDown) {
    if (isShortcutEnabled && isInputElement(eventObj)) {
      var keyCode = eventObj.keyCode,
          key = ""; // No I18N

      if (eventObj.ctrlKey) {
        key = "ctrl+"; // No I18N
      }

      if (broswerObj.isMac() && eventObj.metaKey) {
        key += "cmd+"; // No I18N
      }

      if (eventObj.shiftKey) {
        key += "shift+"; // No I18N
      }

      if (eventObj.altKey) {
        key += "alt+"; // No I18N
      }

      var charCode = String.fromCharCode(keyCode);

      if (keyCode >= 65 && keyCode <= 90) {
        keyCode = charCode.charCodeAt();
      }

      var tempKey = key;
      key += keyCode;
      var eventObject = allKeys[key];

      if (!eventObject) {
        for (var i in spCharArr) {
          if (spCharArr[i] === keyCode.toString()) {
            key = tempKey + i.toLowerCase();
            eventObject = allKeys[key];

            if (eventObject) {
              break;
            }
          }
        }
      }

      if (eventObject) {
        var shortcutKey = key,
            keyInfo = eventObject.keyInfo || {},
            element = eventObject.element || "",
            // No I18N
        handleOn = eventObject.handleOn,
            isDirectInit = eventObject.isDirectInit;
        element = $(element);

        if (isDirectInit && keyInfo.disabled !== true || element && (isKeyDown && handleOn !== "keyup" || !isKeyDown && handleOn === "keyup")) // No I18N
          {
            if (isDirectInit) {
              var elementId = keyInfo.elementIds;
              elementId = elementId && elementId[0];
              element = $("#" + elementId);
            }

            var isSupportDisabledAttr = element && tagNames.indexOf(element[0].tagName) !== -1;

            if (isDirectInit && !element.length || !element.is(":disabled") && isSupportDisabledAttr || // No I18N
            !isSupportDisabledAttr && !element.is("[disabled]") // No I18N
            ) {
                var triggerData = {
                  ele: element,
                  shortcutKey: eventObject.shortcutKey,
                  fromShortCut: true
                };

                if (isDirectInit) {
                  executionFunction(keyInfo.action, element, eventObj, keyInfo.params);
                } else {
                  if (element.is(":checkbox") && eventObject.event === "click") {
                    // No I18N
                    element.each(function () {
                      triggerData.ele = $(this);
                      $(this).triggerHandler(eventObject.event, triggerData);
                    });
                  } else {
                    element.trigger(eventObject.event, triggerData);
                  }
                }
              }

            eventObj.stopPropagation();
            eventObj.preventDefault();
          }
      }
    }
  }

  function executionFunction(callback, element, eventObj, data) {
    var value = undefined;

    if (callback && typeof callback === "string") {
      // No I18N
      var executableFnc = _getAsFunction(callback);

      value = executableFnc.callable(data);
    } else {
      value = typeof callback === "function" ? callback.apply(element, data) : undefined; // No I18N
    }

    return value !== undefined ? value : !eventObj.isDefaultPrevented();
  }

  function _getAsFunction(strValue) {
    if (!strValue) {
      return;
    }

    var _action = strValue.split("."),
        fn = window,
        base = "",
        methodIdx;

    $(_action).each(function (i, action) {
      methodIdx = action.indexOf('()');
      fn = methodIdx > 0 ? fn[action.substring(0, methodIdx)]() : fn[action];

      if (i == _action.length - 2) {
        base = fn;
      }
    }); //closure issue with callable needs to be addressed

    return {
      'fn': fn,
      'base': base,
      'callable': function callable() {
        fn && fn.call(base, arguments[0]);
      }
    }; //No I18N
  }

  function getKey(element, keyInfo) {
    keyInfo = keyInfo || ZC._getOpts(element);
    var shortcut = keyInfo.shortcutkey || keyInfo.shortcutKey || keyInfo.key;

    if (shortcut) {
      var keys = _typeof(shortcut) === 'object' && shortcut instanceof Array ? shortcut : [shortcut]; // No I18N

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];

        if (_typeof(keys[i]) === 'object') {
          // No I18N
          key = !isMac ? keys[i].key : keys[i].macKey ? keys[i].macKey : keys[i].key;

          if (!keys[i].key && !isMac) {
            return false;
          }
        }

        if (key && !key.macKey && isMac) {
          key = key.replace(/ctrl/i, keyInfo.skipShortcutFormat ? "Cmd" : 'cmd'); // No I18N
        }

        if (!keyInfo.skipShortcutFormat) {
          key = key.toString().toLowerCase();
        }

        keys[i] = key;
      }

      return keys;
    }
  }

  function isInputElement(orgEvent) {
    if (ZShortCut.discardInputElement) {
      var element = $(orgEvent.srcElement);

      if (element.length === 0) {
        element = $(orgEvent.target);
      }

      if (element.is("input") || element.is("textarea")) {
        return false;
      }
    }

    return true;
  }

  function sortKeyCombination(key) {
    var splittedKeys = key.split("+"),
        // No I18N
    arrangedKeys = "",
        splittedKey; // No I18N

    key = ""; // No I18N	

    for (var i = 0; i < allowedModifiers.length; i++) {
      for (var j = 0; j < splittedKeys.length; j++) {
        splittedKey = splittedKeys[j].trim();

        if (allowedModifiers[i] === splittedKey) {
          arrangedKeys += splittedKey + "+"; // No I18N
        } else if ($.inArray(splittedKey, allowedModifiers) === -1) {
          key = splittedKey;
        }

        if (splittedKey === '') {
          // No I18N
          key = "+"; // No I18N
        }
      }
    }

    if (!spCharArr[key.toUpperCase()]) {
      key = key.toUpperCase().charCodeAt(0);
    }

    return arrangedKeys += key;
  }

  function registerKey(element, key, orgEvent, handleOn, isDirectInit, keyInfo) {
    var arrangedKeys = sortKeyCombination(key);

    if (arrangedKeys) {
      var registerObj = {
        element: element,
        event: orgEvent,
        handleOn: handleOn
      };

      if (isDirectInit) {
        registerObj.isDirectInit = true;
        registerObj.keyInfo = keyInfo;
      }

      allKeys[arrangedKeys] = registerObj;
    }
  }

  function getFormattedKey(key) {
    var splitKeys = key.split("+"),
        // No I18N
    dkey = "",
        base = this;

    for (var i = 0; i < splitKeys.length; i++) {
      if (splitKeys[i].charAt(0) == splitKeys[i].charAt(0).toUpperCase()) {
        splitKeys[i] = splitKeys[i].toUpperCase();
      } else {
        splitKeys[i] = splitKeys[i].charAt(0).toUpperCase() + splitKeys[i].substring(1, splitKeys[i].length);
      }

      if (splitKeys.length - 1 !== i) {
        splitKeys[i] += "+"; // No I18N
      }

      dkey += splitKeys[i];
    }

    return dkey;
  }

  function bindKeyUpEvent() {
    keyUpBinded = true;
    ZC.$document.on("keyup.shortcut", function (orgEvent) {
      // No I18N
      triggerShortcut(orgEvent, false);
    });
  }

  function deregisterKey(key) {
    var arrangedKeys = sortKeyCombination(key);
    arrangedKeys && delete allKeys[arrangedKeys];
  }

  function _handleRegister(keyInfo, element, isDirectInit) {
    var eventName = keyInfo.eventName || "click",
        // No I18N
    handleOn = keyInfo.handleOn,
        keys = getKey(null, keyInfo);

    if (!isWindows && !keyUpBinded && handleOn === "keyup") {
      // No I18N
      bindKeyUpEvent();
    }

    if (keys) {
      var skipRegister = keyInfo.skipshortcutregister || keyInfo.skipRegistration;

      for (var i = 0; i < keys.length; i++) {
        if (!skipRegister) {
          registerKey(element, keys[i], eventName, handleOn, isDirectInit, keyInfo);
        }

        if (!keyInfo.skipShortcutFormat) {
          keys[i] = getFormattedKey(keys[i]);
        }
      }
    }

    return keys ? keys : false;
  }

  ;
  return {
    init: function init(options) {
      options = options || {};
      handleAction = options.handleAction !== false;

      if (!handleAction) {
        ZC.$document.off("keydown.shortcut"); // No I18N
      }
    },
    discardInputElement: true,
    disableAction: function disableAction(actionName) {
      var keyInfo = keyMap[actionName];

      if (keyInfo) {
        keyInfo.disabled = true;
      }
    },
    enableAction: function enableAction(actionName) {
      var keyInfo = keyMap[actionName];

      if (keyInfo) {
        keyInfo.disabled = false;
      }
    },
    addShortcuts: function addShortcuts(keysList) {
      var keysList = keysList instanceof Array ? keysList : [keysList],
          keyInfo;

      for (var i = 0; i < keysList.length; i++) {
        keyInfo = keysList[i];

        var newKey = _handleRegister(keyInfo, keyInfo.elements, true);

        keyMap[keyInfo.actionName] = keyInfo;
        keyMap[keyInfo.actionName].shortcutKey = newKey[0];
      }
    },
    register: function register(element) {
      var keyInfo = ZC._getOpts(element),
          shortcut = keyInfo.shortcutkey || keyInfo.shortcutKey;

      keyInfo.eventName = shortcut && shortcut.event ? shortcut.event : "click"; // No I18N

      return _handleRegister(keyInfo, element);
    },
    getShortcutKey: function getShortcutKey(element) {
      var keys = getKey(element);

      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          keys[i] = getFormattedKey(keys[i]);
        }

        return keys;
      }

      return false;
    },
    getInfo: function getInfo(actionName, element, registerElement) {
      if (actionName) {
        var keyInfo = keyMap[actionName] || {};
        return keyInfo.shortcutKey || keyInfo.key || ""; // No I18N
      } else if (registerElement !== false && element) {
        return this.register(element);
      } else if (element) {
        return this.getShortcutKey(element);
      }
    },
    enable: function enable() {
      isShortcutEnabled = true;
    },
    disable: function disable() {
      isShortcutEnabled = false;
    },
    deregister: function deregister(element) {
      var keys = getKey(element);

      for (var i = 0; i < keys.length; i++) {
        deregisterKey(keys[i]);
      }
    }
  };
}(ZComponents);
/*
	{
	action: "bold",	// No I18N
	disabled: true,
	hidden: false,
	checked: true,
	group: "",	// No I18N
	key: ""	// No I18N
	eventName: "keyup|keydown|click"	// No I18N
	handleOn: "keyup|keydown"	// No I18N
	elements:[]
}
*/

/* eslint-disable */


(function (ZC) {
  var openedInstance = [],
      openedEle,
      $ = ZC.DOMUtil;

  function _bindEvents(element, options) {
    (function (openedInstance) {
      var componentName = options.componentName,
          forElement,
          container,
          openMethod,
          closeMethod,
          instance = element.data(componentName);

      if (instance) {
        forElement = options.forElement || $(instance._opts.forElement);

        if (!forElement || !forElement.length) {
          return;
        }

        openMethod = componentName === 'zmenu' ? 'show' : 'open'; // No I18N

        closeMethod = componentName === 'zmenu' ? 'hide' : 'close'; // No I18N

        container = instance.element;

        if (!instance.openHandler) {
          instance.openHandler = {
            forElement: [forElement],
            closeMethod: closeMethod,
            openMethod: openMethod
          };
        } else {
          instance.openHandler.forElement.push(forElement);
        }

        var eventPrefix = instance.isCE ? 'z' : componentName; //No I18N

        element.on(eventPrefix + 'beforedestroy.' + componentName, function () {
          return ZC.removeOpenListener(componentName.slice(1), element);
        }).on(eventPrefix + 'close.' + componentName, function () {
          return openedInstance.splice(openedInstance.indexOf(instance), 1);
        });
        forElement.off('.' + componentName).data(componentName, {});
        var data = forElement.data(componentName);
        data.componentName = componentName;
        data.openMethod = openMethod;
        data.element = element;

        if (options.popOn === 'click') {
          // No I18N
          forElement.off('mousedown.' + componentName).on('mousedown.' + componentName, function (ev) {
            // No I18N
            closeOpened($(ev.currentTarget));

            if (!container.is(':visible') || openedEle !== ev.currentTarget) {
              // No I18N
              openedEle = ev.currentTarget;
              instance[openMethod](options);
              openedInstance.push(instance);
            } else {
              instance[closeMethod]();
            }
          });
        } else {
          var eventName = options.popOn;

          if (!/focus|mouseover/.test(eventName)) {
            return;
          }

          var enterEv = eventName === 'mouseover' ? 'mouseenter.' : 'focusin.',
              // No I18N
          exitEv = eventName === 'mouseover' ? 'mouseleave.' : 'focusout.'; // No I18N

          forElement.off(enterEv + componentName + ' ' + exitEv + componentName).on(enterEv + componentName, function (ev) {
            data._mouseEntered = true;
            closeOpened($(ev.currentTarget), closeMethod);

            if (!container.is(':visible')) {
              instance[openMethod](options);
              openedInstance.push(instance);
            }

            clearTimeout(data._mouseLeaveTimeout);
          }).on(exitEv + componentName, function () {
            data._mouseEntered = false;
            data._mouseLeaveTimeout = setTimeout(function () {
              container.is(':visible') && instance[closeMethod](); // No I18N
            }, options.mouseLeaveTime || 1500);
          });
          container.off(enterEv + componentName + ' ' + exitEv + componentName).on(enterEv + componentName, function () {
            clearTimeout(data._mouseLeaveTimeout);
          }).on(exitEv + componentName, function () {
            setTimeout(function () {
              !data._mouseEntered && instance[closeMethod]();
            }, 100);
          });
        }
      }
    })(openedInstance);
  }

  function closeOpened(forElement) {
    for (var i = 0; i < openedInstance.length; i++) {
      var instance = openedInstance[i];

      if (instance && instance.element.is(':visible') && !forElement.closest(instance.element).length && checkElement(forElement, instance.openHandler)) {
        instance[instance.openHandler.closeMethod]();
        openedInstance.splice(i, 1);
        i--;
      }
    }
  }

  function checkElement(forElement, instance) {
    var match = false;

    for (var i = 0; i < instance.forElement.length; i++) {
      var ele = instance.forElement[i];

      if (forElement[0] === ele[0]) {
        match = true;
        break;
      }
    }

    return !match;
  }

  ZC.removeOpenListener = function (componentName, element) {
    componentName = 'z' + componentName; // No I18N

    for (var i = 0; i < element.length; i++) {
      var tempEle = $(element[i]);
      var openHandlerData = tempEle.data(componentName) && tempEle.data(componentName).openHandler; // component data will be undefined if removeOpenListener is called while removing the DOM element parallely. [ Faced in Ember Application ]

      if (openHandlerData) {
        for (var j = 0; j < openHandlerData.forElement.length; j++) {
          var ele = openHandlerData.forElement[j];
          ele.off('.' + componentName);
          ele.removeData(componentName);
        }
      }
    }
  };

  ZC.addOpenListener = function (componentName, bindingList) {
    componentName = 'z' + componentName; // No I18N

    for (var i = 0; i < bindingList.length; i++) {
      bindingList[i].options.componentName = componentName;

      _bindEvents(bindingList[i].element, bindingList[i].options);
    }
  };
})(ZComponents);

(function (ZC) {
  // Revisit - Can be put as a separate module in zgeneral and can be loaded based on the need. By doing so, we can avoid most of the arguments that is passed.
  var $ = ZC.DOMUtil,
      bindedElements = [],
      closeHandlerDatas = [],
      // Function to get the closehandler data associated with the component
  getHandlerData = function getHandlerData(element) {
    return closeHandlerDatas[bindedElements.indexOf(element)];
  },
      // Function to check whether the component should be closed
  isToBeClosed = function isToBeClosed(target, baseElement) {
    var handlerData = getHandlerData(baseElement);

    if (!handlerData || !document.documentElement.contains(baseElement)) {
      ZC.unBindDocumentEvents(baseElement);
      return false;
    }

    if (target.closest(handlerData.container.add(handlerData.forElement)).length) {
      return false;
    }

    var componentsInContext = handlerData.componentsInContext;

    for (var i = 0; i < componentsInContext.length; i++) {
      if (!isToBeClosed(target, componentsInContext[i])) {
        return false;
      }
    }

    return true;
  };

  var closeHandlerNamespace = '.zclosehandler'; // No I18N

  ZC.bindDocumentEvents = function (options) {
    var _eventSuffix = closeHandlerNamespace + '-' + Math.floor(Math.random() * 1000000); // No I18N


    var ctype = options.ctype;
    var element = $(options.element);
    var container = options.container && $(options.container) || element;
    var forElement = $(options.forElement);
    var closeFn = options.closeMethodName;
    var isCE = options.isCE || element.data(ctype).isCE;
    var eventPrefix = isCE ? 'z' : ctype; // No I18N

    var closeEvent = eventPrefix + (options.closeEvent || closeFn) + closeHandlerNamespace; // No I18N

    var destroyEvent = eventPrefix + 'beforedestroy' + closeHandlerNamespace; // No I18N

    var data = getHandlerData(element[0]);

    if (data && forElement.is(data.forElement)) {
      return;
    }

    ZC.unBindDocumentEvents(element);
    bindedElements.forEach(function (bindedEle) {
      var data = getHandlerData(bindedEle);
      var index = data.componentsInContext.indexOf(element[0]);

      if (forElement.closest(data.container).length) {
        if (index < 0) {
          data.componentsInContext.push(element[0]);
        }
      } else if (index > -1) {
        data.componentsInContext.splice(index, 1);
      }
    });
    bindedElements.push(element[0]);
    var eleOptions = {
      _eventSuffix: _eventSuffix,
      forElement: forElement,
      container: container,
      ctype: ctype,
      closeFn: closeFn,
      componentsInContext: []
    };
    closeHandlerDatas.push(eleOptions);
    element.on(closeEvent + ' ' + destroyEvent, function () {
      // No I18N
      ZC.unBindDocumentEvents(element);
    });
    eleOptions.timer = setTimeout(function () {
      ZC.$document.on('mousedown' + _eventSuffix + ' contextmenu' + _eventSuffix, function (origEvent) {
        // No I18N
        if (isToBeClosed($(origEvent.target), element[0])) {
          var customEvent = $.Event('zclosehandlerbeforehide', {
            // No I18N
            originalEvent: origEvent
          });
          element.trigger(customEvent);

          if (!customEvent.isDefaultPrevented()) {
            ZC.unBindDocumentEvents(element, true, origEvent); // ZC[ctype.substr(1)](element)[closeFn]();
          }
        }
      });
    }, 10);
  };

  ZC.unBindDocumentEvents = function (element, close, origEvent) {
    var index = bindedElements.indexOf(element[0]);

    if (index !== -1) {
      var data = closeHandlerDatas[index];
      clearTimeout(data.timer);
      element.off(closeHandlerNamespace);
      ZC.$document.off(data._eventSuffix);
      bindedElements.splice(index, 1);
      closeHandlerDatas.splice(index, 1);
      var contextEle = data.componentsInContext;

      for (var i = 0; i < contextEle.length; i++) {
        ZC.unBindDocumentEvents($(contextEle[i]), true, origEvent);
      }

      bindedElements.forEach(function (bindedEle) {
        var handlerData = getHandlerData(bindedEle);

        if (handlerData.componentsInContext.length) {
          var componentsInContext = handlerData.componentsInContext;
          var elementIndex = componentsInContext.indexOf(element[0]);

          if (elementIndex > -1) {
            componentsInContext.splice(elementIndex, 1);
          }
        }
      });

      if (close) {
        var instance = ZC[data.ctype.replace('z', '')](element); // No I18N

        instance[data.closeFn](undefined, origEvent); // No I18N
      }
    }
  };
})(ZComponents);

(function (ZC) {
  ZC.animationHandler = function (options) {
    var action = options.action,
        element = options.element,
        callback = options.callback,
        animation = options.animation || options["default"],
        effect,
        duration,
        _ANIMATION = {
      slide: {
        show: 'slideDown',
        // No I18N
        open: 'slideDown',
        // No I18N
        close: 'slideUp',
        // No I18N
        hide: 'slideUp' // No I18N

      },
      fade: {
        show: 'fadeIn',
        // No I18N
        open: 'fadeIn',
        // No I18N
        close: 'fadeOut',
        // No I18N
        hide: 'fadeOut' // No I18N

      }
    },
        isString = typeof animation === 'string'; // No I18N

    if (animation && (_typeof(animation) === 'object' || isString)) {
      // No I18N
      if (isString) {
        animation = {
          name: animation
        };
      }

      var actionInfo = animation[action];
      duration = actionInfo && actionInfo.duration ? actionInfo.duration : animation.duration;

      if (actionInfo) {
        animation = actionInfo;
      }

      if (typeof animation === 'string' || animation.name) {
        // No I18N
        effect = animation.name || animation;

        if (_ANIMATION[effect]) {
          effect = _ANIMATION[effect][action];
        }
      } else {
        effect = animation.className;
      }

      element.finish ? element.finish() : element.stop(true, true);

      if (effect) {
        if (_typeof(effect) === 'object') {
          // No I18N
          element.animate(effect, duration, callback);
        } else if (/^(fadeIn|fadeOut|slideDown|slideUp)$/.test(effect)) {
          element[effect](duration, callback);
        } else {
          element.removeClass(element.data('zanimationclass')) // No I18N
          .data('zanimationclass', effect) // No I18N
          .addClass(effect).off(ZC._animationEnd).on(ZC._animationEnd, function () {
            callback && callback();
            element.off(ZC._animationEnd);
          });
        }

        return;
      }
    }

    callback && callback();
  };

  ZC.clearAnimationData = function (element) {
    element.removeClass(element.data('zanimationclass')); // No I18N

    element.removeData('zanimationclass'); // No I18N

    element.off(ZC._animationEnd);
  };
})(ZComponents);
/* $Id$ */

/*
   Prevent TAB focus from moving outside of the container like components.
   Example: Contents inside Dialog Component.
   Components using this utility: Dialog, Alert Dialog and Popover.
*/

/* eslint-disable */


ZComponents.FocusHandler = function (ZC) {
  var $ = ZC.DOMUtil;
  'use strict'; // No I18N


  return {
    init: function init(container, excludeFocus) {
      // prevent focus from outside of the component. Example: contents inside dialog component.
      this._setInitialFocus(container, excludeFocus);

      this._bindEvents(container, excludeFocus);
    },
    _setInitialFocus: function _setInitialFocus(container) {
      var excludeFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var inputElements = container.find('input[autofocus],input[tabindex]:not([tabindex="-1"]):not([disabled]):not(' + excludeFocus + '),textarea[autofocus],textarea[tabindex]:not([tabindex="-1"]):not([disabled]):not(' + excludeFocus + '),button[tabindex]:not([tabindex="-1"]):not([disabled]):not(' + excludeFocus + '),z-button[tabindex]:not([tabindex="-1"]):not([disabled]):not(' + excludeFocus + '),.zselectbox[autofocus],.zselectbox[tabindex]:not([tabindex="-1"]):not([tabindex="0"]):not(' + excludeFocus + '),li[tabindex]:not([tabindex="-1"]):not([disabled]):not(' + excludeFocus + '),a[tabindex]:not([tabindex="-1"]):not([disabled]):not(' + excludeFocus + ')').filter(":visible");

      if (!inputElements.length) {
        inputElements = container.find('input:not([tabindex="-1"]):not([disabled]):not(' + excludeFocus + '),label[tabindex]:not([tabindex="-1"]):not([disabled]):not(' + excludeFocus + '),textarea:not([tabindex="-1"]):not([disabled]):not(' + excludeFocus + '),button:not([tabindex="-1"]):not([disabled]):not(' + excludeFocus + '),z-button:not([tabindex="-1"]):not([disabled]):not(' + excludeFocus + '),li[tabindex]:not([tabindex="-1"]):not([disabled]):not(' + excludeFocus + '),.zselectbox:not([tabindex="-1"]):not([disabled]):not(' + excludeFocus + '),a:not([tabindex="-1"]):not([disabled]):not(' + excludeFocus + ')').filter(":visible"); // No I18N

        if (!inputElements.length) {
          container.focus(); // making the container to have focus in the absence of focusable elements. Need: Dialog component's closeOnEsc feature works whenever the focus is present in the container. 

          return;
        }
      }

      var inputObj = $(inputElements.get(inputElements.length - 1)),
          tabIndex = inputObj.prop('tabindex'); // No I18N

      inputElements.toArray().forEach(function (inputEle) {
        if ($(inputEle).prop('tabindex') < tabIndex || $(inputEle).attr('autofocus')) {
          // No I18N
          inputObj = $(inputEle);
          tabIndex = $(inputEle).prop('tabindex');
        }
      });

      if (inputObj.hasClass('zselectbox') || inputObj.hasClass('zselectbox__textbox')) {
        // No I18N
        inputObj = inputObj.closest('.zselectbox'); // No I18N

        if (inputObj.hasClass('zcombobox')) {
          inputObj.prev().zcombobox('setFocus'); // No I18N
        } else {
          inputObj.prev().zselect('setFocus'); // No I18N
        }
      } else {
        inputObj.focus();
      }
    },
    _bindEvents: function _bindEvents(container) {
      var excludeFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var base = this,
          childElements = container.find('input:not([tabindex="-1"]):not(' + excludeFocus + '),label[tabindex]:not([tabindex="-1"]):not(' + excludeFocus + '),textarea:not([tabindex="-1"]):not(' + excludeFocus + '),li[tabindex]:not([tabindex="-1"]):not(' + excludeFocus + '),button:not([tabindex="-1"]):not(' + excludeFocus + '),z-button:not([tabindex="-1"]):not(' + excludeFocus + '),.zselectbox:not([tabindex="-1"]):not(' + excludeFocus + '),a:not([tabindex="-1"]):not(' + excludeFocus + '),div[contenteditable]:not([tabindex="-1"]):not(' + excludeFocus + ')').filter(":visible"); // No I18N

      container.off('keydown.zfocushandler').on('keydown.zfocushandler', function (event) {
        // No I18N
        if (event.which === ZC.keyCode.TAB) {
          var len = childElements.length,
              currIndex = childElements.index(event.target);
          currIndex += event.shiftKey ? -1 : 1;

          if (currIndex === len) {
            currIndex = 0;
          } else if (currIndex === -1) {
            currIndex = len - 1;
          }

          var nextEle = $(childElements[currIndex]);

          if (currIndex === 0 || currIndex === len - 1 || nextEle[0].disabled) {
            if (nextEle[0].disabled) {
              nextEle = base._findNextActiveElement(currIndex, childElements, event.shiftKey);
            }

            nextEle.focus();
            event.preventDefault();
            event.stopPropagation();
          }
        }
      });
    },
    _findNextActiveElement: function _findNextActiveElement(currIndex, arr, backward) {
      var i = currIndex + (backward ? -1 : 1),
          len = arr.length,
          toIndex = currIndex + (backward ? 1 : -1);

      while (backward ? i >= toIndex || i >= 0 : i <= toIndex || i < len) {
        if (!arr[i].disabled) {
          return $(arr[i]);
        }

        i = i === 0 && backward ? len - 1 : i === len - 1 && !backward ? 0 : backward ? i - 1 : i + 1;
      }
    },
    destroy: function destroy(container) {
      container.off('keydown.zfocushandler'); // No I18N
    },
    refresh: function refresh(container, excludeFocus, setFocus) {
      this._bindEvents(container, excludeFocus);

      setFocus && this._setInitialFocus(container, excludeFocus);
    }
  };
}(ZComponents);
/* $Id$ */

/* eslint-disable */


ZComponents.Position = function (ZC) {
  var $ = ZC.DOMUtil,
      $window = ZC.$window;
  var floatingElement, options, within, floatingElemDim, targetDim, availableHeight, availableWidth, win, callout, hiddenParents, prevStylesOfHiddenParents, correctionOffset, finalCorrectionOffset;
  var defaultOptions = {
    direction: 'bottom-left',
    // No I18N
    showWithinTarget: false,
    within: $window,
    computeElementDim: true,
    computeTargetDim: true,
    computeWithinDim: true,
    arrow: {
      minSpace: 0,
      margin: {
        left: 0,
        top: 0
      },
      callback: undefined
    },
    callbacks: {
      beforeComputingDir: {
        dimensionModifier: $.noop,
        directionModifier: $.noop
      },
      beforeComputingPos: {
        dimensionModifier: $.noop,
        directionModifier: $.noop
      }
    },
    withinPadding: 8,
    customDimensions: false,
    positionAlterable: 'flipallfit' // 'flipside'|flipsidefit'|flipall'|flipfit'|'fit'|false //No I18N

    /* newly added flipside, flipsideallfit */

  };
  var calloutPositions = {
    'top-right': 'bottom-right',
    // No I18N
    'top-left': 'bottom-left',
    // No I18N
    'bottom-right': 'top-right',
    // No I18N
    'bottom-left': 'top-left',
    // No I18N
    top: 'bottom',
    // No I18N
    bottom: 'top',
    // No I18N
    left: 'right',
    // No I18N
    right: 'left',
    // No I18N
    'left-top': 'right-bottom',
    // No I18N
    'left-bottom': 'right-top',
    // No I18N
    'right-top': 'left-bottom',
    // No I18N
    'right-bottom': 'left-top' // No I18N

  };
  var regex = {
    relDirections: /^(top|top-right|top-left|bottom|bottom-right|bottom-left|left|left-top|left-bottom|right|right-top|right-bottom|top-left-corner|top-right-corner|bottom-left-corner|bottom-right-corner)$/,
    withinDirections: /^(top|bottom|left|right|top-left|top-right|bottom-left|bottom-right|center)$/,
    fit: /^(fit|flipfit|flipallfit|flipsidefit|flipsideallfit|true)$/,
    flip: /^(flip|flipfit|flipall|flipallfit|flipside|flipsidefit|flipsideall|flipsideallfit|true)$/,
    flipside: /^(flipside|flipsidefit|flipsideall|flipsideallfit|flipsideonlyfit|true)$/,
    flipall: /^(flipall|flipallfit|flipsideall|flipsideallfit|true)$/
  };

  function getCorrectionOffset() {
    if (!correctionOffset) {
      correctionOffset = {
        left: 0,
        top: 0
      }; // Correction in mobile browsers. --> Issue : https://github.com/jquery/jquery/issues/3187

      if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        var $body = $('body'); // No I18N

        var temp = $('<span>').css({
          position: 'absolute',
          // No I18N
          height: '20px',
          // No I18N
          width: '20px',
          // NO I18N
          top: '0px',
          // No I18N
          left: '0px' // No I18N

        }).appendTo($body);
        correctionOffset = temp.offset();
        correctionOffset.left = correctionOffset.left - parseFloat($body.css('margin-left')) - parseFloat($body.css('border-left-width')); // No I18N

        correctionOffset.top = correctionOffset.top - parseFloat($body.css('margin-top')) - parseFloat($body.css('border-top-width')); // No I18N

        temp.remove();
      }
    }

    return correctionOffset;
  }

  function getDimensions(element) {
    if (element.preventDefault) {
      return {
        width: 0,
        height: 0,
        isEvent: true,
        offset: {
          left: element.pageX,
          top: element.pageY
        }
      };
    }

    element = $(element);

    if (element[0].nodeType === 9) {
      return {
        width: element.width(),
        height: element.height(),
        offset: {
          left: 0,
          top: 0
        }
      };
    }

    if (element[0] === window) {
      return {
        width: element.width(),
        height: element.height(),
        offset: {
          left: element.scrollLeft(),
          top: element.scrollTop()
        }
      };
    }

    var dimension = {
      width: getDimension(element[0], 'outerWidth'),
      // No I18N
      height: getDimension(element[0], 'outerHeight'),
      // No I18N
      offset: getOffset(element)
    };
    return dimension;
  }

  function getOffset(element) {
    var offset = element.offset();
    var excessoffset = getCorrectionOffset();
    offset.left -= excessoffset.left;
    offset.top -= excessoffset.top;
    return offset;
  }
  /* Direction if alterable is fixed based on within element */


  function fixDirection(direction) {
    var dir = direction.split('-'); // No I18N

    /* To filp in case of insufficient space
    	top-left =>  bottom-left
    	bottom-left => top-left
    	left-top => right-top
    	right-top => left-top
     */

    if (/^(top|bottom)$/.test(dir[0]) || /^corner$/.test(dir[2])) {
      callout && callout.callback.call(this, callout.element, calloutPositions[dir[0]]);
      var collisionWidth = floatingElemDim.width + (callout ? callout.width ? callout.width : callout.element.outerWidth() : 0);
      var collisionHeight = floatingElemDim.height + (callout ? callout.height ? callout.height : callout.element.outerHeight() : 0);
      var dirInfo = flip.top(direction, collisionHeight);
      direction = dirInfo.direction;

      if (dirInfo.overTop > 0 && regex.flipall.test(options.positionAlterable)) {
        var newDirInfo = flip.left('right', collisionWidth); // No I18N

        /* check - if space in top/bottom is inefficient left/right space is checked, if available left/right position is taken, else top/bottom position is fixed */

        if (newDirInfo.overLeft <= 0) {
          direction = newDirInfo.direction;
        }
      }
    }

    dir = direction.split('-'); // No I18N

    if (/^(left|right)$/.test(dir[0]) || /^corner$/.test(dir[2])) {
      callout && callout.callback.call(this, callout.element, calloutPositions[dir[0]]);
      var collisionWidth = floatingElemDim.width + (callout ? callout.width ? callout.width : callout.element.outerWidth() : 0);
      var collisionHeight = floatingElemDim.height + (callout ? callout.height ? callout.height : callout.element.outerHeight() : 0);
      var dirInfo = flip.left(direction, collisionWidth);
      direction = dirInfo.direction;

      if (dirInfo.overLeft > 0 && regex.flipall.test(options.positionAlterable)) {
        var newDirInfo = flip.top('bottom', collisionHeight); // No I18N

        /* check - if space in left or right is inefficient, element is displayed in top/bottom */

        direction = newDirInfo.direction;
      }
    }

    return direction;
  }
  /* To filp in case of insufficient space
  	top-left =>  top-right
  	bottom-left => bottom-right
  	left-top => left-bottom
  	right-top => right-bottom
   */


  function fixAlternateDirection(direction) {
    var dir = direction.split('-'),
        // No I18N
    calloutWidthLeft = 0,
        calloutHeightLeft = 0;

    if (targetDim.isEvent && callout) {
      /* If target is an event, callout must point the mouse pointer, so collisionWidth is reduced */
      calloutWidthLeft = 2 * callout.width + callout.width / 2;
      calloutHeightLeft = 2 * callout.height + callout.height / 2;
    }

    if (/^(left|right)$/.test(dir[1])) {
      // var dirInfo = flip.left(dir[1], floatingElemDim.width - targetDim.width - calloutHeightLeft);
      // Since top-left && top-right, bottom-left && bottom-right positions are inverted.
      var secondDir = dir[1] === 'left' ? 'right' : 'left'; // No I18N

      var dirInfo = flip.left(secondDir, floatingElemDim.width - (dir[0] === 'corner' ? 0 : targetDim.width) - calloutHeightLeft);
      direction = direction.replace(dir[1], dirInfo.direction === 'left' ? 'right' : 'left'); // No I18N
    } else if (/^(top|bottom)$/.test(dir[1])) {
      var dirInfo = flip.top(dir[1], floatingElemDim.height - targetDim.height - calloutWidthLeft);
      direction = direction.replace(dir[1], dirInfo.direction);
    }

    return direction;
  }
  /* To initiate callout element */


  function initCallout(elementDir) {
    if (options.arrow && options.arrow.element) {
      var callout = {};
      var element = options.arrow.element;

      if (typeof element === 'string' || element instanceof $ || element.nodeType) {
        // No I18N
        element = $(element);

        if (element.length) {
          callout.element = element;
        }
      }

      if (callout.element && callout.element.css('position') !== 'static') {
        // No I18N
        callout.centeredToTarget = !!(/^(center|undefined)$/.test(options.arrow.direction) && !targetDim.isEvent);
        callout.callback = typeof options.arrow.callback === 'function' ? options.arrow.callback : typeof options.arrowCallback === 'function' ? options.arrowCallback : $.noop; // No I18N

        callout.direction = calloutPositions[elementDir];
        callout.callback.call(this, callout.element, callout.direction.split('-')[0]); // No I18N

        callout.height = typeof options.arrow.height === 'number' ? options.arrow.height : 0; // No I18N

        callout.width = typeof options.arrow.height === 'number' ? options.arrow.width : 0; // No I18N

        callout.minSpace = options.arrow.minSpace;
        callout.margin = options.arrow.margin || {
          left: 0,
          top: 0
        };
        return callout;
      }

      options.arrow = undefined;
    }
  }

  function getElementHeight() {
    var direction = options.direction;

    if (floatingElemDim.height > getAvailableHeight(direction)) {
      return getAvailableHeight(direction);
    }

    return floatingElemDim.height;
  }

  function getElementWidth() {
    var direction = options.direction;

    if (floatingElemDim.width > getAvailableWidth(direction)) {
      return getAvailableWidth(direction);
    }

    return floatingElemDim.width;
  }

  function fitCalloutPosition(callout, calloutPosition) {
    var dir = callout.direction.split('-'); // No I18N

    var maxValue,
        tempDir = dir[1],
        minValue = 0;
    var elemWidth1 = getElementWidth();
    var elemHeight1 = getElementHeight();

    if (/^(left|right)$/.test(dir[1])) {
      maxValue = elemWidth1 - callout.width;
    } else if (/^(top|bottom)$/.test(dir[1])) {
      maxValue = elemHeight1 - callout.height;
    } else if (/^(top|bottom)$/.test(dir[0])) {
      maxValue = elemWidth1 - callout.width;
      tempDir = 'left'; // No I18N
    } else if (/^(left|right)$/.test(dir[0])) {
      maxValue = elemHeight1 - callout.height;
      tempDir = 'top'; // No I18N
    }

    if (calloutPosition[tempDir] > maxValue) {
      calloutPosition[tempDir] = maxValue;
    }

    if (calloutPosition[tempDir] < minValue) {
      calloutPosition[tempDir] = minValue;
    }
  }
  /* Function to get the callout position `for a given direction */


  function getCalloutPosition(callout, correctionPixel) {
    var pos = {};
    var dir = callout.direction.split('-'); // No I18N

    if (/^(top|bottom)$/.test(dir[0])) {
      pos[dir[0]] = -callout.height;

      if (!dir[1]) {
        pos.left = floatingElemDim.width / 2 - callout.width / 2 - correctionPixel.left;
      }
    } else if (/^(left|right)$/.test(dir[0])) {
      pos[dir[0]] = -callout.width;

      if (!dir[1]) {
        pos.top = floatingElemDim.height / 2 - callout.height / 2 - correctionPixel.top;
      }
    }

    if (/^(left|right)$/.test(dir[1])) {
      var cPix = correctionPixel.left;

      if (dir[1] === 'left') {
        // No I18N
        cPix = -cPix;
        pos.right = 'auto'; // No I18N
      } else {
        pos.left = 'auto'; // No I18N
      }

      if (targetDim.width && floatingElemDim.width > targetDim.width) {
        pos[dir[1]] = targetDim.width / 2 - callout.width / 2 + cPix;
      } else {
        pos.left = floatingElemDim.width / 2 - callout.width / 2;
      }
    } else if (/^(top|bottom)$/.test(dir[1])) {
      var cPix = correctionPixel.top;

      if (dir[1] === 'top') {
        // No I18N
        cPix = -cPix;
        pos.bottom = 'auto'; // No I18N
      } else {
        pos.top = 'auto'; // No I18N
      }

      if (targetDim.height && floatingElemDim.height > targetDim.height) {
        pos[dir[1]] = targetDim.height / 2 - callout.height / 2 + cPix;
      } else {
        pos.top = floatingElemDim.height / 2 - callout.height / 2;
      }
    }

    var doesHaveBoxShadow = floatingElement.css('box-shadow') !== 'none'; // No I18N

    /* This correction is done because the pointer always sits on the element rather than attached to the element */

    if (dir[0] === 'top') {
      // No I18N
      pos.top = pos.top + (parseFloat(floatingElement.css('border-top-width')) || doesHaveBoxShadow ? 1 : 0); // No I18N
    } else if (dir[0] === 'bottom') {
      // No I18N
      pos.bottom = pos.bottom + (parseFloat(floatingElement.css('border-bottom-width')) || doesHaveBoxShadow ? 1 : 0); // No I18N
    } else if (dir[0] === 'right') {
      // No I18N
      pos.right = pos.right + (parseFloat(floatingElement.css('border-right-width')) || doesHaveBoxShadow ? 1 : 0); // No I18N
    } else if (dir[0] === 'left') {
      // No I18N
      pos.left = pos.left + (parseFloat(floatingElement.css('border-left-width')) || doesHaveBoxShadow ? 1 : 0); // No I18N
    }

    if (/^(bottom|top)/.test(callout.direction)) {
      pos.top = pos.bottom = ''; // No I18N
    } else {
      pos.left = pos.right = ''; // No I18N
    }

    return pos;
  }

  var flip = {
    /* Filp north south position incase of insufficient height in the given direction */
    top: function top(direction, collisionHeight) {
      var dir = direction.split('-')[0],
          response = {
        direction: direction
      },
          availHeight = getAvailableHeight(direction);
      response.overTop = collisionHeight - availHeight;

      if (response.overTop > 0) {
        var newdir = dir === 'top' ? 'bottom' : 'top'; // No I18N

        var newAvailableHeight = getAvailableHeight(direction.replace(dir, newdir));

        if (newAvailableHeight > availHeight) {
          response.direction = direction.replace(dir, newdir);
          response.overTop = collisionHeight - newAvailableHeight;
        }
      }

      return response;
    },

    /* Flip the left right position incase of insufficient width in the given direction */
    left: function left(direction, collisionWidth) {
      var dir = direction.split('-'),
          response = {
        direction: direction
      },
          finalDir,
          newdir;
      var availWidth = getAvailableWidth(direction);
      response.overLeft = collisionWidth - availWidth;

      if (response.overLeft > 0) {
        finalDir = dir[0];

        if (dir[2] === 'corner') {
          finalDir = dir[1];
        }

        newdir = finalDir === 'left' ? 'right' : 'left'; // No I18N

        var newAvailableWidth = getAvailableWidth(direction.replace(finalDir, newdir));

        if (newAvailableWidth > availWidth) {
          response.direction = direction.replace(finalDir, newdir);
          response.overLeft = collisionWidth - newAvailableWidth;
        }
      }

      return response;
    }
  };
  /* Fit the element position based on the viewport */

  function fitPosition(position, direction) {
    var newPosition = $.extend({}, position),
        // collisionWidth = floatingElemDim.width + callout ? callout.width : 0,
    // collisionHeight = floatingElemDim.height + callout ? callout.height : 0,
    dir = direction.split('-'); // No I18N

    dir[1] = dir[1] === undefined ? /^(top|bottom)$/.test(dir[0]) ? 'left' : 'top' : dir[1]; // No I18N
    // var offset = within.isWindow ? {
    //     left: win.scrollLeft,
    //     top: win.scrollTop
    // } : within.offset;

    if (/^(top|bottom)$/.test(dir[1]) || targetDim.isEvent) {
      var overTop = within.scrollTop - newPosition.top;

      if (overTop > 0) {
        newPosition.top += overTop;
      }

      var overBottom = newPosition.top + floatingElemDim.height - (within.scrollTop + getAvailableHeight().complete);

      if (overBottom > 0) {
        newPosition.top -= overBottom;
      }
    }

    if (/^(left|right)$/.test(dir[1]) || targetDim.isEvent) {
      var overLeft = within.scrollLeft - newPosition.left;

      if (overLeft > 0) {
        newPosition.left += overLeft;
      }

      var overRight = newPosition.left + floatingElemDim.width - (within.scrollLeft + getAvailableWidth().complete) + 1;

      if (overRight > 0) {
        newPosition.left -= overRight;
      }
    }

    return newPosition;
  }

  function calculatePosition(newDirection) {
    var newPosition, position, recalculated;

    if (newDirection) {
      recalculated = true;
      options.direction = newDirection;
    }

    options.callbacks.beforeComputingDir.dimensionModifier(targetDim, floatingElemDim, within, options);

    if (!/corner/.test(options.direction)) {
      callout = initCallout(options.direction);
    }

    if (regex.flip.test(options.positionAlterable) && !recalculated) {
      options.direction = fixDirection(options.direction);
    }
    /* Setting Callout properties */


    if (callout) {
      callout.direction = calloutPositions[options.direction];
      callout.callback.call(this, callout.element, callout.direction.split('-')[0]); // No I18N

      if (!callout.height) {
        callout.height = callout.element.outerHeight();
      }

      if (!callout.width) {
        callout.width = callout.element.outerWidth();
      }
    }

    if (regex.flipside.test(options.positionAlterable)) {
      options.direction = fixAlternateDirection(options.direction);
    }

    options.callbacks.beforeComputingPos.dimensionModifier(targetDim, floatingElemDim, within, options);
    position = fixPosition(options.direction);
    newPosition = $.extend({}, position);

    if (regex.fit.test(options.positionAlterable)) {
      newPosition = fitPosition(position, options.direction);
    }

    if (newPosition.top < within.scrollTop) {
      newPosition.top = within.scrollTop;
    }

    if (newPosition.left < within.scrollLeft) {
      newPosition.left = within.scrollLeft;
    }

    if (callout && regex.flipall.test(options.positionAlterable) && !recalculated && !targetDim.isEvent) {
      /* Calculate whether calloutminspace is available */
      // CALLOUTMINSPACE
      if (callout.minSpace !== undefined) {
        var dir = options.direction.split('-'); // No I18N

        var minElemLeft, minElemTop, maxEleLeft, maxEleTop;
        var elemWidth1 = getElementWidth();
        var elemHeight1 = getElementHeight();
        var newdir;
        minElemLeft = targetDim.offset.left - elemWidth1 + callout.width;
        minElemTop = targetDim.offset.top - elemHeight1 + callout.height;
        maxEleLeft = targetDim.offset.left + targetDim.width - callout.width;
        maxEleTop = targetDim.offset.top + targetDim.height - callout.height;

        if (/^(top|bottom)$/.test(dir[0])) {
          if (newPosition.left < minElemLeft) {
            newdir = 'left'; // No I18N
          }

          if (newPosition.left > maxEleLeft) {
            newdir = 'right'; // No I18N
          }
        } else if (/^(left|right)$/.test(dir[0])) {
          if (newPosition.top < minElemTop) {
            newdir = 'top'; // No I18N
          }

          if (newPosition.top > maxEleTop) {
            newdir = 'bottom'; // No I18N
          }
        }

        if (newdir) {
          return calculatePosition(newdir);
        }
      }
    }

    var correctedPosition = {
      left: newPosition.left - finalCorrectionOffset.left,
      top: newPosition.top - finalCorrectionOffset.top
    };

    if (callout) {
      callout.direction = calloutPositions[options.direction];
      var correctionPixel = {
        left: newPosition.left - position.left,
        top: newPosition.top - position.top
      };
      callout.position = getCalloutPosition(callout, correctionPixel);
      fitCalloutPosition(callout, callout.position);
    }

    return correctedPosition;
  }
  /* Function to get the available height in the given direction */


  function getAvailableHeight(direction) {
    if (!availableHeight) {
      if (within.isWindow || within.isDocument) {
        availableHeight = {
          top: targetDim.offset.top - within.scrollTop,
          bottom: within.height - (targetDim.offset.top + targetDim.height - within.scrollTop),
          complete: within.height
        };
      } else {
        availableHeight = {};

        if (within.offset.top < win.scrollTop) {
          availableHeight.top = targetDim.offset.top - win.scrollTop;
        } else {
          availableHeight.top = targetDim.offset.top - within.scrollTop;
        }

        availableHeight.bottom = within.offset.top + within.height - (targetDim.offset.top + targetDim.height);
        var diffHeight = win.height + win.scrollTop - (within.offset.top + within.height);

        if (diffHeight < 0) {
          availableHeight.bottom += diffHeight;
        }

        availableHeight.complete = availableHeight.top + availableHeight.bottom + targetDim.height;
      }
    }

    if (!direction) {
      return availableHeight;
    }

    direction = direction.split('-')[0]; // No I18N

    if (direction === 'top') {
      // No I18N
      return availableHeight.top;
    } else if (direction === 'bottom') {
      // No I18N
      return availableHeight.bottom;
    }

    return availableHeight.complete;
  }
  /* Function to get the available width in the given direction */


  function getAvailableWidth(direction) {
    if (!availableWidth) {
      if (within.isWindow || within.isDocument) {
        availableWidth = {
          left: targetDim.offset.left - within.scrollLeft,
          right: within.width - (targetDim.offset.left + targetDim.width - within.scrollLeft),
          complete: within.width
        };
      } else {
        availableWidth = {};

        if (within.offset.left < win.scrollLeft) {
          availableWidth.left = targetDim.offset.left - win.scrollLeft;
        } else {
          availableWidth.left = targetDim.offset.left - within.scrollLeft;
        }

        availableWidth.right = within.offset.left + within.width - (targetDim.offset.left + targetDim.width);
        var diffWidth = win.width + win.scrollLeft - (within.offset.left + within.width);

        if (diffWidth < 0) {
          availableWidth.right += diffWidth;
        }

        availableWidth.complete = availableWidth.left + availableWidth.right + targetDim.width;
      }
    }

    if (!direction) {
      return availableWidth;
    }

    var dir = direction.split('-'),
        // No I18N
    finaldir = dir[2] === 'corner' ? dir[1] : dir[0];

    if (finaldir === 'left') {
      // No I18N
      return availableWidth.left;
    } else if (finaldir === 'right') {
      // No I18N
      return availableWidth.right;
    }

    return availableWidth.complete;
  }
  /* Function to get element position for the given direction */


  function fixPosition(direction) {
    var dir = direction.split('-'); // No I18N

    var basePosition = $.extend({}, targetDim.offset);

    if (dir[0] === 'top') {
      // No I18N
      basePosition.top -= floatingElemDim.height + (callout ? callout.height : 0);
    } else if (dir[0] === 'bottom') {
      // No I18N
      basePosition.top += targetDim.height + (callout ? callout.height : 0);
    } else if (dir[0] === 'left') {
      // No I18N
      basePosition.left -= floatingElemDim.width + (callout ? callout.width : 0);
    } else if (dir[0] === 'right') {
      // No I18N
      basePosition.left += targetDim.width + (callout ? callout.width : 0);
    }

    if (dir[1] === undefined) {
      if (dir[0].match(/^left|right$/)) {
        basePosition.top = basePosition.top - floatingElemDim.height / 2 + targetDim.height / 2;
      } else {
        basePosition.left = basePosition.left - floatingElemDim.width / 2 + targetDim.width / 2;
      }
    } else if (dir[1] === 'top') {
      // No I18N
      basePosition.top = basePosition.top + targetDim.height - floatingElemDim.height;
    } else if (dir[1] === 'right') {
      // No I18N
      basePosition.left = basePosition.left - floatingElemDim.width + (dir[2] === 'corner' ? 0 : targetDim.width); // No I18N
    } else if (dir[1] === 'left' && dir[2] === 'corner') {
      // No I18N
      basePosition.left = basePosition.left + targetDim.width;
    }

    return basePosition;
  }

  function showHiddenParent(element) {
    element = $(element);

    if (element.is(':hidden')) {
      // No I18N
      var i = 1;
      var parent = element;

      while (i && parent && !parent.is('body')) {
        // No I18N
        if (parent.css('display') === 'none') {
          // No I18N
          hiddenParents.push(parent);
          prevStylesOfHiddenParents.push(parent.attr('style') || ''); // No I18N

          parent.css({
            display: 'block',
            // No I18N
            position: 'absolute',
            // No I18N
            opacity: 1,
            visibility: 'hidden' // No I18N

          });
          i = parent.is(':hidden'); // No I18N
        }

        parent = parent.parent();
      }
    }
  }

  function resetParent() {
    if (hiddenParents && hiddenParents.length) {
      hiddenParents.forEach(function (parent, i) {
        parent.attr('style', prevStylesOfHiddenParents[i]); // No I18N
      });
      hiddenParents = [];
      prevStylesOfHiddenParents = [];
    }
  }
  /* Function to get the corrected element position based on the element positioning and relative parent positioning */


  function getCorrection(element) {
    // var offsetNew = $.extend({}, calculatedOffset);
    var position = element.css('position'); // No I18N

    var parent = element.parent()[0]; // Dummy element is used to find the correction pixel. Actual element is not used as the offset(), position(), offsetTop, offsetLeft are not relevant when the actual element is being transformed or when there is margin for the element.

    var temp = $('<span>').css({
      position: position,
      height: '20px',
      // No I18N
      width: '20px',
      // NO I18N
      top: '0px',
      // No I18N
      left: '0px',
      // No I18N
      transform: 'none',
      // No I18N
      margin: '0px',
      // No I18N
      display: '',
      // No I18N
      visibility: 'hidden' // No I18N

    });
    parent.appendChild(temp[0]);
    var curOffset = temp.offset();
    parent.removeChild(temp[0]); // offsetNew.top = offsetNew.top - curOffset.top;
    // offsetNew.left = offsetNew.left - curOffset.left;

    return curOffset;
  }

  function getScrollBarWidth() {
    var scrollEle = document.createElement('div');
    var styleProps = 'width:100px;height:100px;overflow:scroll;'; // No I18N

    var body = document.querySelector('body'); //No I18N

    body.appendChild(scrollEle); // No I18N

    scrollEle.style.cssText = styleProps;
    var scrollWidth = $(scrollEle).width() - scrollEle.scrollWidth;
    body.removeChild(scrollEle); // No I18N

    return scrollWidth || 0;
  }
  /* Function to get the dimensions of within container */


  function getWithinDimensions(element) {
    element = element.length ? element : $window;
    var isWindow = element[0] === window;
    var isDocument = !!element[0] && element[0].nodeType === 9;
    var offset = isWindow || isDocument ? {
      left: 0,
      top: 0
    } : getOffset(element) || {
      left: 0,
      top: 0
    };
    var scrollLeft = isWindow || isDocument ? win.scrollLeft : offset.left < win.scrollLeft ? win.scrollLeft : offset.left;
    var scrollTop = isWindow || isDocument ? win.scrollTop : offset.top < win.scrollTop ? win.scrollTop : offset.top;
    /* For window, documentElements.clienWidth is used instead of window.innerWidth ==> because
       When mouse is scrollBar is shown permanently, window.innerWidth gives (width + scrollbarwidth)
       documentElement.clientWidth gives width excluding scrollbar width.
    */

    var width, height, scrollEle;

    if (isWindow) {
      width = win.width;
      height = win.height;
      /* width = window.innerWidth;
      height = window.innerHeight; */
      // scrollEle = $('body'); //No I18N
    } else if (isDocument) {
      width = document.documentElement.scrollWidth;
      height = document.documentElement.scrollHeight;
    } else {
      width = element.outerWidth();
      height = element.outerHeight();
      scrollEle = element;
    }

    if (scrollEle) {
      var overflowX = scrollEle.css('overflow-x'); // No I18N

      var overflowY = scrollEle.css('overflow-y'); // No I18N

      var hasOverflowX = overflowX === 'scroll' || (overflowX === 'auto' || scrollEle.is('body') && overflowX === 'visible') && width < scrollEle[0].scrollWidth; // No I18N

      var hasOverflowY = overflowY === 'scroll' || (overflowY === 'auto' || scrollEle.is('body') && overflowY === 'visible') && height < scrollEle[0].scrollHeight; // No I18N

      var scrollWidth;

      if (hasOverflowY) {
        width -= scrollWidth = getScrollBarWidth();
      }

      if (hasOverflowX) {
        height -= scrollWidth === undefined ? getScrollBarWidth() : scrollWidth;
      }
    }
    /*
    	For window|document, to find with and height, javascript functions are used, becos jquery produces buggy results in some cases
    */


    return {
      element: element,
      isWindow: isWindow,
      isDocument: isDocument,
      offset: offset,
      scrollLeft: scrollLeft,
      scrollTop: scrollTop,
      width: width,
      height: height
    };
  }

  function getDimension(element, dimension) {
    var value; // When an element is on transformation,  Boundingrect gives the transformed width and height. So inorder to get actual width and ht inspite of transformation we use jquery which uses offsetWidth, offsetHeight to calculate height and width of the element.This gives the original size of the element.

    var transform = window.getComputedStyle(element).transform; // var methodName = "getBoundingClientRect"; //No I18N

    var isSVG;

    if (element instanceof SVGElement) {
      isSVG = true; // methodName = "getBBox"; //No I18N
    }

    if (
    /* element[methodName] &&  */
    isSVG || !transform || transform === 'none') {
      // No I18N
      var styles = element.getBoundingClientRect();

      if (styles) {
        switch (dimension) {
          case 'outerWidth':
            // No I18N
            value = styles.width;
            break;

          case 'outerHeight':
            // No I18N
            value = styles.height;
            break;
        }
      }
    }

    if (isNaN(value) || !value) {
      value = $(element)[dimension]();
    }

    return value;
  }

  function getPosition(targetElement, elementPositioned, opt) {
    options = $.extend(true, {}, defaultOptions, opt); // make a copy of options

    floatingElement = $(elementPositioned);

    if (!options.showWithinTarget) {
      var oldDirection = options.direction; // To retain its previous position

      var previousStyle = floatingElement.attr('style'); // No I18N
      // This is included becos the floatingElement that are at the edge of the window results in incorrect dimension calculation

      floatingElement.css({
        top: '-99999px',
        // No I18N
        left: '-99999px' // No I18N

      });
      /* Element Dimensions */

      floatingElemDim = options.computeElementDim ? getDimensions(floatingElement) : {};
      floatingElement[0].style.overflow = 'hidden'; // No I18N
      // If the floating floatingElement size exceeds the document size, it results in incorrect within dimension calculation hence the floating floatingElement is hidden and then the within dimension is calculated.
      // if (floatingElemDim.height > document.documentElement.clientHeight && regex.flip.test(options.positionAlterable)) {
      //     previousStyle.display = floatingElement[0].style.display;
      //     floatingElement[0].style.display = 'none'; //No I18N
      // } else {
      //     previousStyle.overflow = floatingElement[0].style.overflow;
      //     floatingElement[0].style.overflow = 'hidden'; //No I18N
      // }

      win = {
        scrollLeft: $window.scrollLeft() + options.withinPadding,
        scrollTop: $window.scrollTop() + options.withinPadding,
        height: document.documentElement.clientHeight - options.withinPadding * 2,
        width: document.documentElement.clientWidth - options.withinPadding * 2
      }; // Target Dimension

      targetDim = options.customDimensions ? targetElement : options.computeTargetDim ? getDimensions(targetElement) : {}; // Within Dimension

      within = options.computeWithinDim ? getWithinDimensions($(options.within)) : {};
      finalCorrectionOffset = getCorrection(floatingElement); // Revert the floatingElement to original position

      floatingElement.attr('style', previousStyle); // No I18N

      if (!regex.relDirections.test(options.direction)) {
        options.direction = 'bottom-left'; // No I18N
      }

      options.direction = ZC.getRTLBasedDir(options.direction, options.rtl);
      var position = calculatePosition();
      var response = {
        elementPosition: position || {
          left: 0,
          top: 0
        },
        oldDirection: oldDirection,
        actualDirection: options.direction,
        direction: ZC.getRTLBasedDir(options.direction, options.rtl),
        arrowPosition: callout ? callout.position : {
          left: 0,
          top: 0
        },
        arrowDirection: calloutPositions[options.direction] && calloutPositions[options.direction].split('-')[0] // No I18N

      };
      var dir = options.direction.split('-'); // No I18N

      if (/^(top|bottom)$/.test(dir[0])) {
        response.availableHeight = getAvailableHeight(dir[0]) - (callout ? callout.height : 0);
        response.availableWidth = getAvailableWidth(dir[0]);
      } else if (/^(left|right)$/.test(dir[0])) {
        response.availableHeight = getAvailableHeight(dir[0]);
        response.availableWidth = getAvailableWidth(dir[0]) - (callout ? callout.width : 0);
      }

      return response;
    }

    return getWithinTargetPosition(targetElement, elementPositioned);
  }

  function getWithinTargetPosition(targetElement) {
    /* Elements with position 'absolute'|'fixed' are preferred to be  */
    targetElement = $(targetElement);
    var isWindow,
        position = {};

    if (!targetElement.length || targetElement[0] === window || targetElement[0].nodeType === 9
    /* document */
    ) {
      targetElement = $(window);
      isWindow = true;
    }

    if (!regex.withinDirections.test(options.direction)) {
      options.direction = 'bottom-left'; // No I18N
    }

    var containerProps = {
      width: targetElement.outerWidth() - (isWindow ? 0 : parseFloat(targetElement.css('border-right-width')) + parseFloat(targetElement.css('border-left-width'))),
      // No I18N
      height: targetElement.outerHeight() - (isWindow ? 0 : parseFloat(targetElement.css('border-top-width')) - parseFloat(targetElement.css('border-bottom-width'))) // No I18N

    };
    /* Container Properties */

    containerProps.offset = isWindow ? {
      left: window.scrollX,
      top: window.scrollY
    } : getOffset(targetElement) || {
      left: 0,
      top: 0
    };
    /* Element Properties */

    var floatingEleProps = {
      width: floatingElement.outerWidth(),
      height: floatingElement.outerHeight()
    };
    var centerDirections = ['center', 'left', 'right', 'top', 'bottom']; // No I18N

    var directionPropertObj = {
      left: 'width',
      // No I18N
      top: 'height' // No I18N

    };

    for (var dir in directionPropertObj) {
      var oppDir = dir === 'left' ? 'right' : 'bottom'; // No I18N

      var prop = directionPropertObj[dir];

      if (options.direction.indexOf(dir) !== -1) {
        position[dir] = containerProps.offset[dir];
      } else if (options.direction.indexOf(oppDir) !== -1) {
        position[dir] = containerProps.offset[dir] + containerProps[prop] - floatingEleProps[prop];
      } else if (centerDirections.indexOf(options.direction) !== -1) {
        position[dir] = containerProps.offset[dir] + containerProps[prop] / 2 - floatingEleProps[prop] / 2;
      }
    } // position = getCorrection(position, element);


    return {
      elementPosition: position
    };
  }

  return {
    get: function get(targetElement, elementPositioned, opt) {
      if (targetElement && $(elementPositioned).length) {
        if (targetElement instanceof $) {
          targetElement = targetElement[0];
        }

        if (elementPositioned instanceof $) {
          elementPositioned = elementPositioned[0];
        }

        opt = opt || {};

        if (elementPositioned.nodeType === 1 && (targetElement.nodeType === 1 || opt.showWithinTarget && (targetElement === window || targetElement === document) || targetElement.preventDefault || opt.customDimensions)) {
          hiddenParents = [];
          prevStylesOfHiddenParents = [];
          !targetElement.preventDefault && showHiddenParent(targetElement);
          showHiddenParent(elementPositioned);
          var positionObject = getPosition(targetElement, elementPositioned, opt);
          resetParent();
          floatingElement = targetDim = callout = options = within = floatingElemDim = availableHeight = availableWidth = win = correctionOffset = finalCorrectionOffset = hiddenParents = prevStylesOfHiddenParents = undefined;
          return positionObject;
        }
      }
    }
  };
}(ZComponents);

(function (ZC) {
  var svgs = "<symbol viewBox=\"0 0 16 16\" width=\"100%\" height=\"100%\" id=\"zc__svg--add\"> <polygon points=\"13,7.3 8.7,7.3 8.7,3 7.3,3 7.3,7.3 3,7.3 3,8.7 7.3,8.7 7.3,13 8.7,13 8.7,8.7 13,8.7 \"></polygon> </symbol>" + "<symbol viewBox=\"0 0 16 16\" width=\"100%\" height=\"100%\" id=\"zc__svg--arrow\"> <polygon points=\"6.5,12.5 5.5,11.5 9,8 5.5,4.5 6.5,3.5 11,8\"></polygon> </symbol>" + "<symbol id=\"zc__svg--backward\" viewBox=\"0 0 12 12\" width=\"100%\" height=\"100%\"><polygon points=\"6.6,10.3 2.9,6.5 6.6,2.7 7.4,3.4 4.3,6.5 7.4,9.6\"></polygon></symbol>" + "<symbol viewBox=\"0 0 14 14\" width=\"100%\" height=\"100%\" id=\"zc__svg--calendaricon\"> <rect x=\"-22.5\" y=\"3.5\" width=\"13\" height=\"10\"></rect> <path d=\"M-10,4v9h-12V4H-10 M-9,3h-14v11h14V3L-9,3z\"></path> <rect x=\"-20.6\" y=\"1.4\" width=\"1.2\" height=\"3.2\"></rect> <path d=\"M-19.8,1.8v2.5h-0.5V1.8H-19.8 M-19,1h-2v4h2V1L-19,1z\"></path> <rect x=\"-20.6\" y=\"7.4\" width=\"1.2\" height=\"1.2\"></rect> <path d=\"M-19.8,7.8v0.5h-0.5V7.8H-19.8 M-19,7h-2v2h2V7L-19,7z\"></path> <rect x=\"-16.6\" y=\"1.4\" width=\"1.2\" height=\"3.2\"></rect> <path d=\"M-15.8,1.8v2.5h-0.5V1.8H-15.8 M-15,1h-2v4h2V1L-15,1z\"></path> <rect x=\"-12.6\" y=\"1.4\" width=\"1.2\" height=\"3.2\"></rect> <path d=\"M-11.8,1.8v2.5h-0.5V1.8H-11.8 M-11,1h-2v4h2V1L-11,1z\"></path> <rect x=\"-16.6\" y=\"7.4\" width=\"1.2\" height=\"1.2\"></rect> <path d=\"M-15.8,7.8v0.5h-0.5V7.8H-15.8 M-15,7h-2v2h2V7L-15,7z\"></path> <rect x=\"-12.6\" y=\"7.4\" width=\"1.2\" height=\"1.2\"></rect> <path d=\"M-11.8,7.8v0.5h-0.5V7.8H-11.8 M-11,7h-2v2h2V7L-11,7z\"></path> <rect x=\"-20.6\" y=\"10.4\" width=\"1.2\" height=\"1.2\"></rect> <path d=\"M-19.8,10.8v0.5h-0.5v-0.5H-19.8 M-19,10h-2v2h2V10L-19,10z\"></path> <rect x=\"-16.6\" y=\"10.4\" width=\"1.2\" height=\"1.2\"></rect> <path d=\"M-15.8,10.8v0.5h-0.5v-0.5H-15.8 M-15,10h-2v2h2V10L-15,10z\"></path> <rect x=\"-12.6\" y=\"10.4\" width=\"1.2\" height=\"1.2\"></rect> <path d=\"M-11.8,10.8v0.5h-0.5v-0.5H-11.8 M-11,10h-2v2h2V10L-11,10z\"></path> <path d=\"M4,3c0.6,0,1-0.4,1-1V1H3v1C3,2.6,3.4,3,4,3z\"></path> <rect x=\"2\" y=\"7\" width=\"2\" height=\"2\"></rect> <rect x=\"2\" y=\"10\" width=\"2\" height=\"2\"></rect> <rect x=\"6\" y=\"7\" width=\"2\" height=\"2\"></rect> <rect x=\"6\" y=\"10\" width=\"2\" height=\"2\"></rect> <rect x=\"10\" y=\"7\" width=\"2\" height=\"2\"></rect> <rect x=\"10\" y=\"10\" width=\"2\" height=\"2\"></rect> <path d=\"M12.8,2c0,1-0.8,1.8-1.8,1.8S9.2,3,9.2,2H5.8C5.8,3,5,3.8,4,3.8S2.2,3,2.2,2H0v3v9h14V5V2H12.8z M13,13H1V6h12V13z\"></path> <path d=\"M11,3c0.6,0,1-0.4,1-1V1h-2v1C10,2.6,10.4,3,11,3z\"></path> </symbol>" + "<symbol viewBox=\"0 0 21.9 21.9\" width=\"100%\" height=\"100%\" id=\"zc__svg--clear\"> <path d=\"M14.1,11.3c-0.2-0.2-0.2-0.5,0-0.7l7.5-7.5c0.2-0.2,0.3-0.5,0.3-0.7s-0.1-0.5-0.3-0.7l-1.4-1.4C20,0.1,19.7,0,19.5,0 c-0.3,0-0.5,0.1-0.7,0.3l-7.5,7.5c-0.2,0.2-0.5,0.2-0.7,0L3.1,0.3C2.9,0.1,2.6,0,2.4,0S1.9,0.1,1.7,0.3L0.3,1.7C0.1,1.9,0,2.2,0,2.4 s0.1,0.5,0.3,0.7l7.5,7.5c0.2,0.2,0.2,0.5,0,0.7l-7.5,7.5C0.1,19,0,19.3,0,19.5s0.1,0.5,0.3,0.7l1.4,1.4c0.2,0.2,0.5,0.3,0.7,0.3 s0.5-0.1,0.7-0.3l7.5-7.5c0.2-0.2,0.5-0.2,0.7,0l7.5,7.5c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l1.4-1.4c0.2-0.2,0.3-0.5,0.3-0.7 s-0.1-0.5-0.3-0.7L14.1,11.3z\"></path> </symbol>" + "<symbol viewBox=\"0 0 16 16\" width=\"100%\" height=\"100%\" id=\"zc__svg--close\"> <rect x=\"1.5\" y=\"7.4\" transform=\"matrix(0.7071 -0.7071 0.7071 0.7071 -3.3137 8)\" class=\"st0\" width=\"13\" height=\"1.1\"></rect> <rect x=\"1.5\" y=\"7.4\" transform=\"matrix(0.7071 0.7071 -0.7071 0.7071 8 -3.3137)\" class=\"st0\" width=\"13\" height=\"1.1\"></rect> </symbol>" + "<symbol viewBox=\"0 0 600 598\" width=\"100%\" height=\"100%\" id=\"zc__svg--zcolorpicker-advancedpicker\"> <path d=\"M299.7-0.2C128.3-0.2-7,134,0.2,305.2C7.4,476.9,138,577.3,259.7,595.9c88.2,13.4,107.8-45.1,87.3-67.3 c-35.5-38.3-22.6-68.6-7.3-82.5c17.4-15.7,50.3-17.3,77.3-13.8c65.5,8.5,175-40,182.2-144.8C611,116.5,471.1-0.2,299.7-0.2z M118.1,299.7c-27.7,0-50.1-22.4-50.1-50.1c0-27.7,22.4-50.1,50.1-50.1c27.7,0,50.1,22.4,50.1,50.1 C168.2,277.3,145.8,299.7,118.1,299.7z M217.6,166.6c-27.7,0-50.1-22.4-50.1-50.1c0-27.7,22.4-50.1,50.1-50.1 c27.7,0,50.1,22.4,50.1,50.1C267.7,144.1,245.2,166.6,217.6,166.6z M384.9,166.9c-27.7,0-50.1-22.4-50.1-50.1 c0-27.7,22.4-50.1,50.1-50.1c27.7,0,50.1,22.4,50.1,50.1C435,144.4,412.6,166.9,384.9,166.9z M485.2,299.9 c-27.7,0-50.1-22.4-50.1-50.1c0-27.7,22.4-50.1,50.1-50.1c27.7,0,50.1,22.4,50.1,50.1C535.2,277.5,512.8,299.9,485.2,299.9z\"> </path> </symbol>" + "<symbol viewBox=\"0 0 16 16\" width=\"100%\" height=\"100%\" id=\"zc__svg--zcolorpicker-nocolor\"> <path d=\"M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M8,1c1.8,0,3.3,0.7,4.6,1.7l-9.9,9.9C1.7,11.3,1,9.8,1,8 C1,4.1,4.1,1,8,1z M8,15c-1.8,0-3.3-0.7-4.6-1.7l9.9-9.9C14.3,4.7,15,6.2,15,8C15,11.9,11.9,15,8,15z\"></path> </symbol>" + "<symbol viewbox=\"0 0 48 48\" width=\"100%\" height=\"100%\" id=\"zc__svg--confirm\"> <g> <path d=\"M24,0C10.7,0,0,10.7,0,24s10.7,24,24,24s24-10.7,24-24C48,10.8,37.3,0,24,0z M24,44.1c-11,0-20-9-20-20s9-20,20-20s20,9,20,20C44,35.2,35,44.1,24,44.1z\"></path> <g> <path d=\"M22.8,31.9c-1.7,0-2.6,0.9-2.6,2.7c0,0.9,0.2,1.5,0.7,2c0.4,0.5,1.1,0.7,1.9,0.7c0.8,0,1.5-0.2,1.9-0.7c0.5-0.5,0.7-1.1,0.7-2c0-0.8-0.2-1.5-0.7-2C24.3,32.2,23.6,31.9,22.8,31.9z\"></path> <path d=\"M29.3,12.4c-1.3-1.1-3.2-1.7-5.5-1.7s-4.4,0.5-6.5,1.4c-1.1,0.5-0.6,1.7-0.6,1.7l0.5,1c0,0,0.5,0.9,1.7,0.5l0,0c0.5-0.2,1-0.4,1.5-0.6c0.9-0.3,2-0.5,3.1-0.5c1.2,0,2.2,0.3,2.8,0.8c0.7,0.5,1,1.3,1,2.3c0,0.8-0.2,1.6-0.6,2.2c-0.4,0.6-1.3,1.5-2.7,2.6c-1.2,0.9-2,1.8-2.5,2.7c-0.5,0.9-0.7,1.9-0.7,3.2c0,0.9,1.1,1.1,1.1,1.1h0.7c0,0,1.4,0,1.6-1.2l0,0c0-0.8,0.2-1.4,0.5-1.8c0.4-0.6,1.1-1.3,2.2-2.1c1.3-1,2.2-1.8,2.7-2.4s0.9-1.3,1.2-2s0.4-1.5,0.4-2.3C31.4,15.1,30.7,13.5,29.3,12.4z\"></path> </g> </g> </symbol>" + "<symbol viewBox=\"0 0 48 48\" width=\"100%\" height=\"100%\" id=\"zc__svg--decrement\"> <path class=\"cls-1\" d=\"M11.76,13L24,26.521,37.147,13,41,16.9,24,35,7,16.9Z\"></path> </symbol>" + "<symbol viewBox=\"0 0 16 16\" width=\"100%\" height=\"100%\" id=\"zc__svg--downarrow\"> <polygon points=\"3.5,6.5 4.5,5.5 8,9 11.5,5.5 12.5,6.5 8,11\"></polygon> </symbol>" + "<symbol viewBox=\"-3 -3 22 22\" width=\"100%\" height=\"100%\" id=\"zc__svg--downscroller\"> <path d=\"M16,4l-8,8L0,4H16z\"></path> </symbol>" + "<symbol viewbox=\"0 0 48 48\" width=\"100%\" height=\"100%\" id=\"zc__svg--error\"> <path d=\"M41.2,7.2C31.9-2.2,16.7-2.5,7.3,6.9c-9.5,9.3-9.7,24.5-0.4,33.9c9.3,9.5,24.5,9.7,33.9,0.4C50.3,31.9,50.4,16.8,41.2,7.2z M37.9,38.2C30,46,17.4,45.9,9.7,38S2.1,17.5,10,9.8S30.5,2.1,38.2,10C45.9,17.9,45.8,30.5,37.9,38.2z\"></path> <path d=\"M31.7,17.5l-1.1-1.1c-0.8-0.8-1.7-0.1-2,0.1L24,21l-4.6-4.7c-0.3-0.3-1.1-0.8-1.9,0l-1.1,1.1c-0.8,0.8-0.1,1.7,0.1,2L21,24l-4.7,4.6c-0.9,0.9-0.3,1.6-0.1,1.8l1.3,1.3c0.2,0.2,0.9,0.8,1.8-0.1L24,27l4.6,4.7c0.9,0.9,1.6,0.3,1.8,0.1l1.3-1.3c0.2-0.2,0.8-0.9-0.1-1.8L27,24l4.7-4.6C32,19.1,32.5,18.4,31.7,17.5z\"></path> </symbol>" + "<symbol viewBox=\"0 0 12 12\" id=\"zc__svg--fastbackward\" width=\"100%\" height=\"100%\"><polygon points=\"5.6,10.3 1.9,6.5 5.6,2.6 6.3,3.4 3.3,6.5 6.4,9.6\"></polygon><polygon points=\"9.6,10.3 5.9,6.5 9.6,2.6 10.3,3.4 7.3,6.5 10.4,9.6\"></polygon></symbol>" + "<symbol viewBox=\"1 0 12 12\" id=\"zc__svg--fastforward\" width=\"100%\" height=\"100%\"><polygon points=\"7.4,10.3 6.7,9.6 9.7,6.5 6.6,3.4 7.4,2.7 11.1,6.5\"></polygon><polygon points=\"3.4,10.3 2.7,9.6 5.7,6.5 2.6,3.4 3.4,2.7 7.1,6.5\"></polygon></symbol>" + "<symbol viewBox=\"1 0 12 12\" id=\"zc__svg--forward\" width=\"100%\" height=\"100%\"><polygon points=\"4.4,10.3 3.7,9.6 6.7,6.5 3.6,3.4 4.4,2.7 8.1,6.5\"></polygon></symbol>" + "<symbol viewBox=\"1 2 9 9\" width=\"100%\" height=\"100%\" id=\"zc__svg--horizontaldecrement\"> <polygon points=\"6.6,10.3 2.9,6.5 6.6,2.7 7.4,3.4 4.3,6.5 7.4,9.6\"></polygon> </symbol>" + "<symbol viewBox=\"1 2 9 9\" width=\"100%\" height=\"100%\" id=\"zc__svg--horizontalincrement\"> <polygon points=\"4.4,10.3 3.7,9.6 6.7,6.5 3.6,3.4 4.4,2.7 8.1,6.5\"></polygon> </symbol>" + "<symbol viewBox=\"0 0 48 48\" width=\"100%\" height=\"100%\" id=\"zc__svg--increment\"> <path class=\"cls-1\" d=\"M6,32l5,4L24,22,38,36l4-4L24,13Z\"></path> </symbol>" + "<symbol viewbox=\"0 0 48 48\" width=\"100%\" height=\"100%\" id=\"zc__svg--info\"> <g> <g> <path d=\"M23.9,17.4c1.5,0,2.5-1.1,2.4-2.3c0-1.3-0.9-2.4-2.3-2.4s-2.4,1.1-2.4,2.4C21.6,16.3,22.6,17.4,23.9,17.4z\"></path> <path d=\"M26.2,35.5V21.8c0-1.2-1.4-1.3-1.8-1.3h-0.7c0,0-1.7,0-1.7,1.1v14.3c0,0.3,0.2,0.9,1.3,0.9h1.6C25.3,36.7,26.2,36.5,26.2,35.5z\"></path> </g> <path d=\"M24,0C10.7,0,0,10.7,0,24s10.7,24,24,24s24-10.7,24-24S37.3,0,24,0z M24,44C13,44,4,35,4,24S13,4,24,4s20,9,20,20S35,44,24,44z\"></path> </g> </symbol>" + "<symbol viewBox=\"0 0 16 16\" width=\"100%\" height=\"100%\" id=\"zc__svg--maximize\"> <g transform=\"translate(0,-1036.3622)\"> <g> <path d=\"M13,1040.4v8H3v-8H13 M14,1039.4H2v10h12V1039.4L14,1039.4z\"></path> </g> </g> </symbol>" + "<symbol viewBox=\"0 0 16 16\" width=\"100%\" height=\"100%\" id=\"zc__svg--minimize\"> <rect x=\"2\" y=\"12\" width=\"12\" height=\"1\"></rect> </symbol>" + "<symbol viewBox=\"0 0 12 10\" width=\"100%\" height=\"100%\" id=\"zc__svg--minus\"> <rect x=\"2\" y=\"5\" width=\"9\" height=\"1\"></rect> </symbol>" + "<symbol viewBox=\"0 0 12 12\" width=\"100%\" height=\"100%\" id=\"zc__svg--plus\"> <polygon points=\"11,6 7,6 7,2 6,2 6,6 2,6 2,7 6,7 6,11 7,11 7,7 11,7 \"></polygon> </symbol>" + "<symbol viewBox=\"0 0 16 16\" width=\"100%\" height=\"100%\" id=\"zc__svg--restore\"> <g transform=\"translate(0,-1036.3622)\"> <path d=\"M2,1041.4v8h10v-8H2z M11,1048.4H3v-6h8V1048.4z\"></path> </g> <g transform=\"translate(0,-1036.3622)\"> <path d=\"M4,1039.4v3h1v-2h8v6h-2v1h3v-8H4z\"></path> </g> </symbol>" + "<symbol viewBox=\"0 0 5 12\" width=\"100%\" height=\"100%\" id=\"zc__svg--rightarrow\"> <polygon points=\"4.4,10.3 3.7,9.6 6.7,6.5 3.6,3.4 4.4,2.7 8.1,6.5\"></polygon> </symbol>" + "<symbol viewBox=\"-7 -7 64 64\" width=\"100%\" height=\"100%\" id=\"zc__svg--round\"> <circle cx=\"24.5\" cy=\"24.5\" r=\"15.5\"></circle> </symbol>" + "<symbol viewbox=\"0 0 48 48\" width=\"100%\" height=\"100%\" id=\"zc__svg--success\"> <g> <path d=\"M41.2,7.2C31.9-2.3,16.7-2.5,7.3,6.8c-9.5,9.3-9.7,24.5-0.4,33.9c9.3,9.5,24.5,9.7,33.9,0.4C50.3,31.9,50.4,16.7,41.2,7.2z M37.9,38.2c-7.9,7.7-20.5,7.6-28.2-0.3S2.1,17.4,10,9.7S30.5,2.1,38.2,10C45.9,17.8,45.8,30.5,37.9,38.2z\"></path> <path d=\"M36,19.3L23.1,32.2c-1.1,1.1-2.9,1.1-4,0l-1-1l-4.5-4.6c-0.2-0.2-1-1.1-0.1-2l1.1-1.1c0.8-0.8,1.6-0.3,1.9,0l4.6,4.7l12-11.8c0.2-0.2,1.1-1,2-0.1l1.1,1.1C36.8,18.2,36.3,18.9,36,19.3z\"></path> </g> </symbol>" + "<symbol viewBox=\"-2 -2 20 20\" width=\"100%\" height=\"100%\" id=\"zc__svg--tick\"> <polygon points=\"14.6,2.4 4.9,12.1 1.2,8.5 0.4,9.3 4.9,13.8 15.4,3.2 \"></polygon> </symbol>" + "<symbol viewBox=\"-3 -3 22 22\" width=\"100%\" height=\"100%\" id=\"zc__svg--upscroller\"> <path d=\"M0,12l8-8l8,8H0z\"></path> </symbol>" + "<symbol viewbox=\"0 0 48 48\" width=\"100%\" height=\"100%\" id=\"zc__svg--warning\"> <g> <path d=\"M47.3,36.6L27.7,2.5c-0.9-1.4-2.4-2.2-3.9-2.1c-1.6,0-2.9,0.9-3.7,2.2L0.7,36.5c-0.9,1.3-1,3-0.2,4.4c0.8,1.5,2.3,2.4,4,2.4h39c1.6,0,3.1-0.8,3.9-2.2C48.2,39.7,48.2,38,47.3,36.6z M43.9,39.2c-0.1,0.1-0.2,0.2-0.4,0.2h-39c-0.3,0-0.4-0.2-0.5-0.3c-0.1-0.2,0-0.3,0-0.4L23.5,4.6c0,0,0.1-0.2,0.3-0.2c0,0,0,0,0,0c0.1,0,0.3,0,0.4,0.2l19.6,34C44,38.8,44,39,43.9,39.2z\"></path> </g> <path d=\"M24.1,28.4L24.1,28.4c-0.8,0-1.3-0.4-1.4-1l-1-10c-0.1-1.1,1-2,2.4-2l0,0c1.4,0,2.5,0.9,2.4,2l-1,10C25.4,27.9,24.9,28.4,24.1,28.4z\"></path> <circle cx=\"24\" cy=\"33.4\" r=\"2\"></circle> </symbol>";

  var id = 'zohocomponents__svg',
      addSvg = function addSvg() {
    var _svgSprite = document.getElementById(id);

    if (!_svgSprite) {
      _svgSprite = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

      _svgSprite.setAttribute('id', id);

      _svgSprite.setAttribute('class', 'zh-dnone');
    }

    if ('innerHTML' in _svgSprite) {
      _svgSprite.innerHTML = svgs;
    } else {
      /* fallback - https://jsfiddle.net/microbians/8ztNU/ Ref - https://stackoverflow.com/questions/9723422/is-there-some-innerhtml-replacement-in-svg-xml https://stackoverflow.com/questions/28129956/get-innerhtml-of-svg-tag-result-in-undefined-in-ie */
      var tempDiv = document.createElement('div');
      tempDiv.innerHTML = '<svg>' + svgs + '</svg>';
      var children = tempDiv.childNodes[0].childNodes;

      while (children[0]) {
        _svgSprite.appendChild(children[0]);
      }
    }

    document.body.appendChild(_svgSprite);
  };
  /*If scripts loaded dynamically after document is loaded, then eventListener won't be working. Hence, the check is added.*/


  if (document.readyState !== 'complete') {
    document.addEventListener('DOMContentLoaded', addSvg);
  } else {
    addSvg();
  }
})(ZComponents);

(function (ZC) {
  var template = ZC.Templates.Utilities;

  template.icon = function (data) {
    return ZT.html(_templateObject(), data.iconClassName, ZT.customHTML(data.SVGIconId ? "<svg class='".concat(data.SVGIconClassName, "' focusable=false > <use xlink:href='").concat(data.SVGIconId, "'></use></svg> </svg>") : ''));
  };

  template.commandBar = function (data) {
    return ZT.html(_templateObject2(), data.colClass ? data.colClass : '', data.cols && data.cols.length ? data.cols.map(function (col) {
      return ZT.html(_templateObject3(), template.commandBarCol(col));
    }) : template.commandBarCol(data));
  };

  template.commandBarCol = function (data) {
    return ZT.html(_templateObject4(), data.left && data.left.length ? ZT.html(_templateObject5(), data.left.map(function (value) {
      return template.button(value);
    })) : '', data.center && data.center.length ? ZT.html(_templateObject6(), data.center.map(function (value) {
      return template.button(value);
    })) : '', data.right && data.right.length ? ZT.html(_templateObject7(), data.right.map(function (value) {
      return template.button(value);
    })) : '');
  };

  template.button = function (data) {
    return ZT.html(_templateObject8(), data.name === 'todayButton' ? ZT.html(_templateObject9(), data.className, data.text, data.text) : ZC.createButton(data));
  };
})(ZComponents);

(function (ZC, $) {
  var ZButton =
  /*#__PURE__*/
  function (_ZC$CoreComponent) {
    _inherits(ZButton, _ZC$CoreComponent);

    function ZButton() {
      _classCallCheck(this, ZButton);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZButton).apply(this, arguments));
    }

    _createClass(ZButton, [{
      key: "_init",
      value: function _init(ele, opts) {
        opts.isCE = this.isCE;
        opts.disabled = opts.disabled || ele[0].disabled;
        this._data = ZButton.getBtnProps(opts, ele);
        this._prevTabIndex = this._data._prevTabIndex; // save the tabindex while disabling for the first time.

        this._skipParent = !this._data.hasInput;
      }
    }, {
      key: "_initialRender",
      value: function _initialRender() {
        var ele = this.element;

        if (this._opts.contentType === 'custom' && !this._data.innerHTML) {
          // No I18N
          // HTML content is provided in the element itself.
          this.container = ele;

          this._postRender(ele, this._opts);

          this._postEachRender(ele, this._data);
        } else {
          this._render();
        }
      }
    }, {
      key: "_postRender",
      value: function _postRender(ele) {
        var data = this._data;
        data.className += ' ' + this._opts.cls; // No I18N

        this._container = data.hasInput ? this.container : ele; // assigning this.container equal to this.element produces issue in color picker component because of templating. So, using _container

        this._container[0].type = data.type; // type attribute is set explicitly since jquery 1.8.0 produces error.
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender() {
        // update zbutton--icononly class here
        var data = this._data,
            iconExists = data.icon && !data.text,
            iconOnlyCls = 'zbutton--icononly'; // No I18N

        this._updateClass(iconExists ? iconOnlyCls : '', iconExists ? null : iconOnlyCls);
      }
    }, {
      key: "_handleStates",
      value: function _handleStates() {
        var disable = this._opts.disabled,
            data = this._data;
        data.attrs.disabled = disable;

        this._disable(disable);

        if (!this.isCE) {
          // setting disabled for custom button will invoke set method recursively.
          this._disable(disable, this.element);
        }

        if (data.hasInput) {
          this.container.attr('tabindex', disable ? -1 : this._prevTabIndex); // No I18N

          data.attrs.tabIndex = disable ? -1 : this._prevTabIndex;
        } // state change event is triggered in order to use in tooltip JS


        this._dispatchEvent('statechange', {}, {
          // No I18N
          button: this.element,
          // No I18N
          disabled: disable // No I18N

        });
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        var _this7 = this;

        var componentName = this.name,
            ele = this.getElement();

        this._handleFocus(this._container);

        ele.on('click.' + componentName, function (event) {
          // No I18N
          if (!ele.hasClass('is-disabled')) {
            // ele.focus(); // focusing the element explicitly as firefox/safari doesnot set focus automatically.
            if (_this7._opts.actionInProgress && _this7.showProgressIndicator) {
              _this7.showProgressIndicator();
            }

            _this7._dispatchEvent('click', event, {
              // No I18N
              button: _this7.element // No I18N

            });
          }
        }).on('mousedown.' + componentName, function (event) {
          // mousedown event is binded inorder to prevent focus event from happening whenever the button is in disabled state.
          if (ele.hasClass('is-disabled')) {
            event.stopImmediatePropagation();
            return false;
          }
        });

        if (window.ZShortCut) {
          ZShortCut.register(this.element);
        }
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        var container = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.getElement();
        var _opts = this._opts,
            data = this._data,
            oldValue = _opts[optionName];
        _opts[optionName] = value;

        if (optionName === 'appearance' || optionName === 'size') {
          // No I18N
          this._updateClass('zbutton--' + value, 'zbutton--' + oldValue); // No I18N


          if (optionName === 'size' && _opts.actionInProgress) {
            // No I18N
            value = value.trim() === '' || value === 'default' ? 'medium' : value; // No I18N

            container.find('.zbutton__loader circle').attr({
              cx: this._CIRCLEX[value],
              // No I18N
              cy: this._CIRCLEY[value],
              // No I18N
              r: this._CIRCLER[value] // No I18N

            });
          }
        } else if (optionName === 'disabled') {
          // No I18N
          this._handleStates();
        } else if (optionName === 'text') {
          this._domChanged = true;
          data[optionName] = value;
        } else if (['iconClassName', 'iconClass', 'SVGIconId', 'defaultSVGIconId'].indexOf(optionName) > -1) {
          // No I18N
          !_opts.actionInProgress && ZButton.getIconInfo(_opts, true, data);
          this._domChanged = true;
        } else if (optionName === 'actionInProgress' || optionName === 'progressIndicator') {
          // No I18N
          this._setProgressAttribute(optionName, value);
        } else if (optionName === 'title') {
          // No I18N
          var attrs = data.attrs || {};
          attrs.title = value;
          data.attrs = attrs;
          this._domChanged = true;
        }

        if (this._domChanged && data.hasInput) {
          // ##revisit - Aishwarya
          this._render(data, undefined, this.container[0], this._skipParent);

          this._domChanged = false;
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // will be revisited
        var cont = this.getElement(),
            data = this._data;
        data.className = ' '; // No I18N

        _get(_getPrototypeOf(ZButton.prototype), "destroy", this).call(this);

        cont.text(data.text);
      }
    }, {
      key: "setProgressValue",
      value: function setProgressValue(value, whileCreating) {
        if (value > 100) {
          value = 100;
        }

        this._data.progressInfo.value = this._opts.progressIndicator.value = value;
        !whileCreating && this._render();
      }
    }, {
      key: "getProgressValue",
      value: function getProgressValue() {
        // return  100 * parseFloat( this._progressBar.outerWidth(true) / (this.element.outerWidth(true) - parseInt(this.element.css('border')) * 2 ) ); // No I18N
        return this._opts.progressIndicator.value;
      }
    }, {
      key: "showProgressIndicator",
      value: function showProgressIndicator(options) {
        options = options || {};
        var loaderInfo = this._opts.progressIndicator,
            btnText = options.loadingText || loaderInfo.loadingText,
            data = this._data;
        data.showProgress = true;

        if (btnText !== '') {
          // No I18N
          this._prevText = data.text;
          data.text = btnText;
        }

        if (!data.progressInfo) {
          this._setProgressData(options, true);

          this._opts.actionInProgress = true;
        }

        this._updateClass('is-disabled zbutton--loading zh-transition'); // No I18N


        this._render();
      }
    }, {
      key: "_setProgressData",
      value: function _setProgressData(options, dontRender) {
        var loaderInfo = this._opts.progressIndicator,
            position = options.position || loaderInfo.position,
            direction = options.direction || loaderInfo.direction,
            type = options.type || loaderInfo.type,
            SVGIconId = options.SVGIconId || loaderInfo.SVGIconId,
            percentage = options.value || loaderInfo.value,
            iconClassName = options.iconClassName || loaderInfo.iconClassName;
        var size = this._opts.size,
            cy = this._CIRCLEY,
            cx = this._CIRCLEX,
            _options = {
          trackCX: cy[size],
          trackCY: cy[size],
          trackRadius: cy[size],
          progressCX: cx[size],
          progressCY: cx[size],
          progressRadius: cx[size]
        };

        if (SVGIconId || iconClassName) {
          _options.progressIcon = ZC._getIconInfo(iconClassName, SVGIconId, null, 'zbutton__icon zbutton--loader'); // No I18N
        }

        if (type === 'circular') {
          // No I18N
          _options['circular' + position[0].toUpperCase() + position.slice(1)] = true;
        } else {
          _options[type === 'linear-bar' ? 'linearBar' : 'linearFill'] = true; // No I18N

          _options.direction = direction === 'right-to-left' ? 'fromright' : 'fromleft'; // No I18N
        }

        _options.position = type === 'linear-bar' ? position === 'top' || position === 'bottom' ? position : 'bottom' : position === 'left' || position === 'right' ? position : 'left'; // No I18N

        _options.className = _options.circularRight && !this._container.is('.zbutton--icononly') ? 'zh-floatright ' : ''; // No I18N

        this._data.progressInfo = _options;

        if (type !== 'circular') {
          // No I18N
          this.setProgressValue(percentage, true);
        }

        !dontRender && this._render();
      }
    }, {
      key: "hideProgressIndicator",
      value: function hideProgressIndicator() {
        var data = this._data;
        data.showProgress = this._opts.actionInProgress = false;
        data.text = this._prevText || data.text;

        this._updateClass('', 'zbutton--loading zh-transition'); // No I18N


        if (!this._opts.disabled) {
          this._container.removeAttr(this.compoundAttrs.disabled);

          this._updateClass('', 'is-disabled'); // No I18N

        }

        this._render();
      }
    }, {
      key: "_setProgressAttribute",
      value: function _setProgressAttribute(optionName, value) {
        var opts = this._opts;

        if (optionName === 'actionInProgress') {
          // No I18N
          this[(value ? 'show' : 'hide') + 'ProgressIndicator'](); // No I18N
        } else if (optionName === 'progressIndicator') {
          // No I18N
          value = $.extend({}, opts[optionName], value);

          this._setProgressData(value);
        }

        opts[optionName] = value;
      }
    }, {
      key: "name",
      get: function get() {
        return "zbutton";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          type: 'button',
          // No I18N
          appearance: 'normal',
          // No I18N
          action: null,
          actionInProgress: false,
          size: 'medium',
          // No I18N
          text: null,
          iconClass: null,
          SVGIconId: null,
          disabled: false,
          isCustomHTMLEncoded: true,
          contentType: '',
          // No I18N
          // Added for internal button construction
          defaultIconClassName: '',
          defaultSVGIconId: null
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          iconClassName: null,
          // Removed null present in inner objects as it has no significance
          progressIndicator: {
            type: 'circular',
            // No I18N
            position: 'left',
            // No I18N
            direction: 'left-to-right',
            // No I18N
            loadingText: '',
            // No I18N
            value: 5 // No I18N

          }
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['click', 'change', 'statechange']; // No I18N
      }
    }, {
      key: "compoundAttrs",
      get: function get() {
        return {
          disabled: 'disabled aria-disabled' // No I18N

        };
      }
    }, {
      key: "_CIRCLEX",
      get: function get() {
        return {
          medium: '8px',
          // No I18N
          large: '10.5px',
          // No I18N
          small: '7.5px',
          // No I18N
          mini: '7px' // No I18N

        };
      }
    }, {
      key: "_CIRCLEY",
      get: function get() {
        return {
          medium: '8px',
          // No I18N
          large: '10.5px',
          // No I18N
          small: '7.5px',
          // No I18N
          mini: '7px' // No I18N

        };
      }
    }, {
      key: "_CIRCLER",
      get: function get() {
        return {
          medium: '6.5',
          // No I18N
          large: '9px',
          // No I18N
          small: '6px',
          // No I18N
          mini: '5.5px' // No I18N

        };
      }
    }], [{
      key: "getBtnProps",
      value: function getBtnProps(_opts, element, update) {
        var options = Object.create(_opts),
            // memory reference problem occurs if we assign directly
        btnLabel,
            _element = element[0],
            attrs = options.customAttributes || {};
        btnLabel = options.text || options.label || '';

        if (!btnLabel && !update) {
          // text passed in options is given preference over text present in the element.
          btnLabel = _element.innerText.trim();
        }

        if (btnLabel) {
          attrs['aria-label'] = _opts.text = options.text = btnLabel; // No I18N
        }

        var isInput = _element.tagName === 'INPUT'; // No I18N

        if (isInput) {
          attrs["for"] = _element.id; // options.className = _element.className,

          options.title = options.title || _element.title;
          options.type = _element.type;
          element.addClass('zh-dnone'); // No I18N

          options.hasInput = true;
          options.alwaysSetAttrs = true;
        } // tabindex is set since custom buttons didn't receive tab focus automatically.
        // tab index is set inorder to make the element focusable.


        attrs.tabIndex = _element.tabIndex || 0; // tabIndex prop is always set as -1 for web component element.

        if (_opts.isCE && !_element.getAttribute('tabindex')) {
          // No I18N
          attrs.tabIndex = 0;
        }

        options = ZButton.getIconInfo(options);
        var custHTML = _opts.innerHTML;

        if (_opts.contentType === 'custom' && custHTML) {
          // No I18N
          options.innerHTML = _opts.isCustomHTMLEncoded ? custHTML : ZC.encodeHTML(custHTML);
        }

        var className = "zbutton  ".concat(options.size ? " zbutton--".concat(options.size, " ") : '').concat(options.appearance ? " zbutton--".concat(options.appearance) : '');

        if (options.title) {
          attrs.title = options.title;
        }

        options._prevTabIndex = attrs.tabIndex;

        if (options.disabled) {
          // No I18N
          className += ' is-disabled'; // No I18N

          attrs.disabled = true;

          if (options.hasInput) {
            attrs.tabIndex = -1;
          }
        }

        if (ZC.Browser.isFirefox && ZC.Browser.getFirefoxVersion() <= 52) {
          // since display:flex is not supported for button elements in firefox browser, setting display as inline-block.
          className += ' zbutton--ffsupport'; // No I18N
        }

        _opts.cls = className;
        attrs.role = options.role || 'button'; // No I18N

        if (options.name && _element.name) {
          attrs.name = options.name;
        } // type attribute is set as property since jquery 1.8.0 version produces error when we use attr() method for type.
        // Button can be present inside the form element. So assigning the type attribute as button.


        options.type = options.type || 'button'; // No I18N

        options.attrs = attrs;
        return options;
      }
    }, {
      key: "getIconInfo",
      value: function getIconInfo(_opts, update, data) {
        var haveIcon = _opts.iconClassName || _opts.iconClass || _opts.SVGIconId || _opts.defaultSVGIconId,
            defIconCls = ''; // No I18N

        if (haveIcon) {
          defIconCls = _opts.defaultIconClassName + ' zbutton__icon'; // No I18N
        }

        _opts.defaultIconClassName = defIconCls;

        var props = ZC._getIconInfo(_opts.iconClassName || _opts.iconClass, _opts.SVGIconId, _opts.defaultSVGIconId, _opts.defaultIconClassName, !update && _opts);

        if (update) {
          var options = ['icon', 'iconClass', 'SVGIconId', 'iconClassName', 'SVGIconClassName'],
              // No I18N
          len = options.length,
              opt;

          for (var i = 0; i < len; i++) {
            opt = options[i];
            data[opt] = props[opt];
          }
        } else {
          return props;
        }
      }
    }]);

    return ZButton;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZButton', ZButton);

  (function (ZC) {
    var template = ZC.zbutton.Templates,
        utilities = ZC.Templates.Utilities;

    template.container = function (data) {
      return ZT.html(_templateObject10(), data.text, data.id, data.role, data.type, data.title, data.className, data.children && template.children(data));
    };

    template.children = function (data) {
      return ZT.html(_templateObject11(), data.innerHTML ? ZT.html(_templateObject12(), ZT.customHTML(data.innerHTML)) : template.defaultChild(data));
    };

    template.defaultChild = function (data) {
      return ZT.html(_templateObject13(), data.showProgress && data.progressInfo.circularLeft ? ZT.html(_templateObject14(), template.loader(data.progressInfo)) : data.icon && ZT.html(_templateObject15(), utilities.icon(data)), data.text && ZT.html(_templateObject16(), data.text), data.showProgress && !data.progressInfo.circularLeft && ZT.html(_templateObject17(), template.loader(data.progressInfo)));
    };

    template.loader = function (data) {
      return ZT.html(_templateObject18(), data.linearBar && ZT.html(_templateObject19(), data.position, data.value), data.linearFill && ZT.html(_templateObject20(), data.direction, data.value), (data.circularLeft || data.circularRight) && (data.progressIcon ? icon(data.progressIcon) : ZT.customHTML("<i class=\"zbutton__icon zbutton--loader ".concat(data.className, "\"><svg class=\"zbutton__svg zbutton__loader zeffects--rotate\" width=\"100%\" height=\"100%\"> <circle class=\"circle__track\" cx=\"").concat(data.trackCX, "\" cy=\"").concat(data.trackCY, "\" r=\"").concat(data.trackRadius, "\"></circle> <circle class=\"circle__load\" cx=\"").concat(data.progressCX, "\" cy=\"").concat(data.progressCY, "\" r=\"").concat(data.progressRadius, "\"></circle> </svg></i>"))));
    };
  })(ZComponents);
  /* mx - mouse x, my - mouse y */


  var ZDraggable =
  /*#__PURE__*/
  function (_ZC$CoreComponent2) {
    _inherits(ZDraggable, _ZC$CoreComponent2);

    function ZDraggable() {
      _classCallCheck(this, ZDraggable);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZDraggable).apply(this, arguments));
    }

    _createClass(ZDraggable, [{
      key: "_create",
      value: function _create(ele, opts) {
        ele.addClass('zh-draggable'); // No I18N

        this._handle = opts.handle ? ele.find(opts.handle) : ele;

        this._handle.addClass('zdraggable ' + (opts.disabled ? 'is-disabled' : '')); // No I18N


        this._bindEvents();

        this._prevCursor = this._handle.css('cursor'); // No I18N

        this._setCursor();

        if (opts.disabled) {
          this._disable();
        }
      }
    }, {
      key: "_setCursor",
      value: function _setCursor(prev) {
        this._handle.css('cursor', prev ? this._prevCursor : this._opts.cursor); // No I18N

      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        this._addEvents({
          mouseDown: 'mousedown',
          // No I18N
          docMouseUp: 'mouseup contextmenu' // No I18N

        }, this._handle);
      }
    }, {
      key: "_mouseDownHandler",
      value: function _mouseDownHandler(event) {
        var _this8 = this;

        var opts = this._opts;

        if (!$(event.target).closest(opts.ignoreAsHandle).length && !opts.disabled) {
          var x = event.pageX,
              y = event.pageY;
          this._delay = window.setTimeout(function () {
            if (x === event.pageX && y === event.pageY) {
              _this8._md = true; // md - mousedown

              _this8._mx = event.pageX;
              _this8._my = event.pageY;
              _this8._scrollPar = _this8._getScrollPar(_this8.element);
              _this8._scrollOff = _this8._scrollPar[0] === document ? undefined : _this8._scrollPar.offset();
              _this8._prevPos = _this8.element[opts.region === 'parent' ? 'position' : 'offset'](); // No I18N

              _this8._addEvents({
                drag: 'mousemove',
                // No I18N
                docKeydown: 'keydown',
                // No I18N
                docMouseUp: 'mouseup contextmenu' // No I18N

              }, ZC.$document);
            }

            clearTimeout(_this8._delay);
            _this8._delay = undefined;
          }, opts.dragStartDelay);
          $('body').addClass('zh-userselectnone');
        }
      }
    }, {
      key: "_dragHandler",
      value: function _dragHandler(event) {
        var ele = this._dragEle || this.element,
            opts = this._opts;

        if (this._md && !opts.disabled) {
          // dragstart will be dispatched while started dragging the object.
          if (!this._stDispatched) {
            if (opts.showGhostOnDrag && !this._dragEle) {
              var orgEle = ele,
                  parent = orgEle[0].parentNode;
              this._dragEle = ele = $(ele[0].cloneNode(true));
              parent.appendChild(ele[0]);
              ele.css('position', 'absolute'); // No I18N

              var pos = orgEle[opts.region === 'parent' ? 'position' : 'offset'](); // No I18N

              ele.css({
                top: pos.top,
                left: pos.left
              });
            }

            ele.addClass(opts.classNameOnDrag); // previously h-drag class was added.

            this._dispatchEvent('start', event); // No I18N


            this._stDispatched = true;
          }

          var scrollPar = this._scrollPar[0],
              eveX = event.pageX,
              eveY = event.pageY,
              eHeight = ele.outerHeight(),
              eWidth = ele.outerWidth();

          if (opts.autoScrollRegion && this._opts.region !== 'viewport') {
            // No I18N
            var doc = ZC.$document;

            if (scrollPar !== doc[0] && scrollPar.tagName !== 'HTML') {
              // No I18N
              this._checkScroll('Top', eveY, eHeight, ele); // No I18N


              this._checkScroll('Left', eveX, eWidth, ele); // No I18N

            } else {
              var win = ZC.$window,
                  distance = opts.scrollSensitivity,
                  speed = this._prevX ? Math.max(Math.abs(this._prevY - eveY), Math.abs(this._prevX - eveX)) : opts.scrollSpeed,
                  docTop = doc.scrollTop(),
                  docLeft = doc.scrollLeft(),
                  yVal = eveY - docTop < distance ? docTop - speed : win.height() - (eveY - docTop) < distance ? docTop + speed : undefined,
                  xVal = eveX - docLeft < distance ? docLeft - speed : win.width() - (eveX - docLeft) < distance ? docLeft + speed : undefined;

              if (yVal !== undefined) {
                doc.scrollTop(yVal);
              }

              if (xVal !== undefined) {
                doc.scrollLeft(xVal);
              }

              this._prevX = eveX;
              this._prevY = eveY;
            }
          }

          var objectOffset = ele.offset(),
              region;

          if (opts.region) {
            if (typeof opts.region === 'string') {
              // No I18N
              if (opts.region === 'viewport') {
                // No I18N
                region = [0, 0, $(window).width(), $(window).height()];
              } else if (opts.region === 'page') {
                // No I18N
                region = ZC.$document;
              } else if (opts.region === 'parent') {
                // No I18N
                var isBody = ele.parent().is('body'); // No I18N

                region = isBody ? ZC.$document : ele.parent(); // No I18N

                if (!isBody) {
                  objectOffset = ele.position();
                }
              }
            } else if (_typeof(opts.region) === 'object') {
              // No I18N
              region = opts.region;
              objectOffset = ele.position();
            } else {
              region = opts.region;
            }
          }

          var isUp = !(eveY - this._my >= 0),
              isRight = eveX - this._mx >= 0,
              top = objectOffset.top + (scrollPar.scrollTop || 0) + eveY + opts.cursorOffset.top - this._my,
              left = objectOffset.left + (scrollPar.scrollLeft || 0) + eveX + opts.cursorOffset.left - this._mx;
          top = top < 0 ? 0 : top; // needed otherwise element moves out of view port

          left = left < 0 ? 0 : left;
          var winWidth, winHeight;

          if (region && region instanceof Array) {
            top = top < region[1] ? region[1] : top;
            left = left < region[0] ? region[0] : left;
            winWidth = region[2];
            winHeight = region[3];
          } else {
            winWidth = region && region[0].scrollWidth || ZC.$document.width();
            winHeight = region && region[0].scrollHeight || ZC.$document.height();
          }

          if (top + eHeight > winHeight) {
            top = winHeight - eHeight; // No I18N
          }

          if (left + eWidth > winWidth) {
            left = winWidth - eWidth; // No I18N
          }

          var obj = {};

          if (opts.axis !== 'y' && eveX >= 0) {
            // No I18N
            obj.left = left;
          }

          if (opts.axis !== 'x' && eveY >= 0) {
            // No I18N
            obj.top = top;
          }

          ele[opts.region === 'parent' ? 'css' : 'offset'](obj); // No I18N
          // resetting the right and bottom values after setting the top and left values as the draggable element might have right and bottom set on them previously.

          ele.css({
            right: '',
            // No I18N
            bottom: '' // No I18N

          });

          this._dispatchEvent('drag', event, {
            // No I18N
            isUp: isUp,
            isRight: isRight
          });

          this._mx = eveX + opts.cursorOffset.left;
          this._my = eveY + opts.cursorOffset.top;
          event.preventDefault(); // preventing the default behavior to avoid text selection while dragging.
        }
      }
    }, {
      key: "_checkScroll",
      value: function _checkScroll(prop, eveVal, eSize, dragEle) {
        var scrollPar = this._scrollPar[0],
            offVal = this._scrollOff[prop.toLowerCase()],
            currVal = scrollPar['scroll' + prop],
            // No I18N
        size = prop === 'Top' ? 'Height' : 'Width',
            // No I18N
        scSize = scrollPar['scroll' + size],
            // No I18N
        scOffVal = scrollPar['offset' + size],
            // No I18N
        calcVal,
            distance = this._opts.scrollSensitivity,
            scSpeed = this._opts.scrollSpeed,
            forward = false;

        if (offVal + scOffVal - eveVal < distance) {
          calcVal = currVal + scSpeed;
          forward = true;
        } else if (eveVal - offVal < distance) {
          calcVal = currVal - scSpeed;
        }

        var compSize = eSize + (calcVal === undefined ? 0 : calcVal);

        if (calcVal !== undefined && calcVal >= 0 && (forward ? compSize <= scSize : compSize >= 0)) {
          this._updateProp(prop, calcVal, eSize, scSize, dragEle, forward, scSpeed);
        }
      }
    }, {
      key: "_updateProp",
      value: function _updateProp(prop, value, elemSize, threshold, dragEle, forward, scSpeed) {
        this._scrollPar[0]['scroll' + prop] = value;
        var curr = dragEle[0]['offset' + prop],
            mod = forward ? curr + scSpeed : curr - scSpeed;

        if (forward ? mod + elemSize <= threshold : mod + elemSize >= 0) {
          dragEle.css(_defineProperty({}, prop.toLowerCase(), mod));
        }
      }
    }, {
      key: "_getScrollPar",
      value: function _getScrollPar(element, includeHidden) {
        var position = element.css('position'),
            // No I18N
        isParBound = this._opts.region === 'parent',
            // No I18N
        excludeStaticParent = isParBound !== 'parent' && position === 'absolute',
            // No I18N
        overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
            scrollPar = element.parents().filter(function () {
          var parent = $(this);

          if (excludeStaticParent && parent.css('position') === 'static' || isParBound && parent[0] !== element[0].parentNode) {
            // No I18N
            return false;
          }

          return overflowRegex.test(parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x')); // No I18N
        }).eq(0);
        return position === 'fixed' || !scrollPar.length ? $(element[0].ownerDocument || document) : scrollPar; // No I18N
      }
    }, {
      key: "_docMouseUpHandler",
      value: function _docMouseUpHandler(event) {
        if (this._md && !this._opts.disabled) {
          this._resetValues(event);
        }

        clearTimeout(this._delay);
        this._delay = undefined;
      }
    }, {
      key: "_docKeydownHandler",
      value: function _docKeydownHandler(event) {
        /* Binded the events to document since activeElement will be body only on mousemove */
        if (this._md && this._opts.cancelOnEscKey && event.keyCode === ZC.keyCode.ESCAPE) {
          this._revertPos();

          this._dispatchEvent('cancel', event); // No I18N

        }
      }
    }, {
      key: "_resetValues",
      value: function _resetValues(eve, reverted) {
        this._md = this._stDispatched = false;
        var opts = this._opts;
        opts.classNameOnDrag && (this._dragEle || this.element).removeClass(opts.classNameOnDrag);

        if (eve) {
          // because event has to triggered while dragging alone.
          this._dispatchEvent('end', eve); // No I18N

        }

        opts.showGhostOnDrag && this._removeGhost(reverted);
        $('body').removeClass('zh-userselectnone');

        this._removeEvents('mousemove mouseup contextmenu keydown', ZC.$document); // No I18N

      }
    }, {
      key: "_removeGhost",
      value: function _removeGhost(reverted) {
        if (this._dragEle) {
          if (!reverted) {
            var hasPar = this._opts.region === 'parent',
                // No I18N
            offset = this._dragEle[hasPar ? 'position' : 'offset'](); // No I18N


            this.element[hasPar ? 'css' : 'offset']({
              // No I18N
              top: offset.top,
              left: offset.left
            });
          }

          this._dragEle[0].parentNode.removeChild(this._dragEle[0]);

          this._dragEle = undefined;
        }
      }
    }, {
      key: "_revertPos",
      value: function _revertPos() {
        // revert the position to started state.
        this.element.css({
          left: this._prevPos.left,
          top: this._prevPos.top
        });

        this._resetValues(undefined, true);
      }
    }, {
      key: "_dispatchEvent",
      value: function _dispatchEvent(type, event) {
        var obj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var ele = this.element;
        obj.offset = ele.offset();
        obj.position = ele.position();

        _get(_getPrototypeOf(ZDraggable.prototype), "_dispatchEvent", this).call(this, type, event, obj);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var name = this.name;
        this._md = this._stDispatched = this._mx = this._my = undefined;

        this._handle.off('.' + name).removeClass('zdraggable'); // No I18N


        this.element.removeClass('zh-draggable'); // No I18N
        // ZC.$document.off('.' + name); // No I18N - event should not be removed since all draggables will have single document listener

        this.element.removeData('zdraggable'); // No I18N

        this._setCursor(true);
      }
    }, {
      key: "_disable",
      value: function _disable(value) {
        _get(_getPrototypeOf(ZDraggable.prototype), "_disable", this).call(this, value, this._handle);

        this._handle[value ? 'removeClass' : 'addClass']('zdraggable'); // No I18N


        this.element[value ? 'removeClass' : 'addClass']('zh-draggable'); // No I18N

        this._setCursor(value);
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        if (optionName === 'handle') {
          // No I18N
          this._handle.off('.' + this.name).removeClass('zdraggable'); // No I18N


          this._setCursor(true);

          this._resetValues();

          this._handle = value ? this.element.find(value) : this.element;

          this._handle.addClass('zdraggable'); // No I18N


          this._setCursor();

          this._bindEvents();
        }

        this._opts[optionName] = value;
      }
    }, {
      key: "name",
      get: function get() {
        return "zdraggable";
      }
    }, {
      key: "props",
      get: function get() {
        return {
          cursor: 'move',
          // No I18N
          handle: null,
          ignoreAsHandle: 'input,textarea,button,select,option',
          // No I18N
          axis: 'both',
          // No I18N
          region: false,
          showGhostOnDrag: false,
          cursorOffset: {
            top: 0,
            left: 0
          },
          // classNameOnDrag can contain cursor, opacity and zIndex like props
          classNameOnDrag: '',
          // No I18N
          disabled: false,
          dragStartDelay: 0,
          autoScrollRegion: true,
          cancelOnEscKey: true,
          // No I18N
          scrollSpeed: 5,
          scrollSensitivity: 20
          /* future enhancements -> snap: false, snapToElement: null, snapToElementMode: 'outer', snapToGrid: null, */

        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['start', 'drag', 'end', 'cancel']; // No I18N
      }
    }]);

    return ZDraggable;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZDraggable', ZDraggable);
  ZC.$document.on('scroll.zpopover', function (orgEvent) {
    // No I18N
    if (ZC.openedPopover && ZC.openedPopover._opts.closeOnScroll && ZC.openedPopover.element.is(':visible')) {
      ZC.openedPopover.close(orgEvent);
    }
  });

  var ZPopover =
  /*#__PURE__*/
  function (_ZC$CoreComponent3) {
    _inherits(ZPopover, _ZC$CoreComponent3);

    function ZPopover() {
      _classCallCheck(this, ZPopover);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZPopover).apply(this, arguments));
    }

    _createClass(ZPopover, [{
      key: "_init",
      value: function _init(element, opts) {
        var content = opts.content || '',
            isCallout = opts.displayType === 'callout'; // No I18N

        this._forElement = $(opts.forElement);
        element.attr({
          'aria-haspopup': 'true',
          // No I18N
          'aria-expanded': 'false',
          // No I18N
          tabindex: element.attr('tabindex') || 0 // No I18N

        });

        if (!/^(top|bottom|right|left|top-left|top-right|bottom-left|bottom-right|auto)$/.test(opts.position)) {
          opts.position = 'bottom'; // No I18N
        }

        this._correctPosition(); // No I18N


        var data = this._data;
        data.closeButton = opts.closeButton || opts.type === 'modal'; // No I18N

        if (opts.title || this.isCE || data.closeButton || opts.detachable) {
          // No I18N
          this._setTitleBar();
        }

        this._data.callout = isCallout; // No I18N

        this._isAjaxContent = opts.progressIndicator = content.URL;
        data.closeButton && this._handleClose();

        this._setContent(content);

        var appendedTo = $(opts.appendTo);

        if (appendedTo.length) {
          element.appendTo(appendedTo);
        }
      }
    }, {
      key: "_setContent",
      value: function _setContent(content, doNotCheckChild) {
        var opts = this._opts,
            data = this._data,
            element = this.element;

        if (!this._isAjaxContent && content) {
          opts.content = opts.isContentHTMLEncoded ? content : ZC.encodeHTML(content); // No I18N
        }

        if (!doNotCheckChild) {
          var contentEle = this.isCE ? element.find('z-pocontent').addClass('zpopover__content') : element[0].childNodes;

          if (contentEle.length) {
            if (this.isCE) {
              data.contentEle = contentEle[0];
            } else {
              data.content = _toConsumableArray(contentEle);
            }
          }
        }

        if (!data.content && !data.contentEle || doNotCheckChild) {
          data.content = opts.content;
        }

        data.isContentString = typeof data.content === 'string'; // No I18N
      }
    }, {
      key: "_postRender",
      value: function _postRender(element, opts) {
        opts.detachable && this._handleDrag(true);
        var find = element.find.bind(element);
        this._titleBar = find('.zpopover__title'); // No I18N

        this._contentEle = find('.zpopover__content'); // No I18N

        this._data.className += ' zpopover'; // No I18N

        if (opts.type === 'modal') {
          // No I18N
          this._createOverlay();
        }

        this._data.closeButton && this._handleClose(null, true);
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        if (this._opts.closeOnEsc) {
          this._addEvents({
            keydown: 'keydown' // No I18N

          });
        }
      }
    }, {
      key: "_keydownHandler",
      value: function _keydownHandler(orgEvent) {
        if (orgEvent.keyCode === ZC.keyCode.ESCAPE) {
          this.close(orgEvent);
        } else if (this._opts.wrapAroundKeyboardNavigation && orgEvent.keyCode === ZC.keyCode.TAB) {
          orgEvent.stopPropagation(); // default tab behavior should not be prevented since focushandler will not handle inbetween elements tab flow now.
        }
      }
    }, {
      key: "open",
      value: function open(options) {
        var _this9 = this;

        var opts = this._opts,
            element = this.element,
            data = this._data;

        if (this._overlay) {
          this._overlay.show();

          this._forElement.addClass('zpopover--target'); // No I18N

        }

        ZC.openedPopover = this;

        if (opts.detachable) {
          data.closeButton = opts.closeButton || opts.type === 'modal';
          data.callout = opts.displayType === 'callout'; // No I18N

          this._setTitleBar(true);
        }

        if (opts.type !== 'modal' && ZC.bindDocumentEvents && opts.closeOnBodyClick) {
          // No I18N
          ZC.bindDocumentEvents({
            element: element,
            forElement: this._forElement,
            ctype: this.name,
            closeMethodName: 'close',
            // No I18N
            closeEvent: 'close' // No I18N

          });
        }

        if (this._dispatchEvent('beforeopen')) {
          // No I18N
          var delay = opts.delay;

          if (delay) {
            if (delay.openAfter) {
              clearTimeout(this._openTimer);
              this._openTimer = setTimeout(function () {
                return _this9._preprocessEle(options);
              }, delay.openAfter);
            }

            if (delay.closeAfter) {
              this._autoCloseEle();
            }
          } else {
            this._preprocessEle(options);

            ZC.animationHandler({
              action: 'open',
              // No I18N
              animation: opts.animation,
              callback: this._openHandler.bind(this),
              element: element,
              ctype: this.name
            });
          }
        }

        if (this._isAjaxContent) {
          this._makeRequest();
        }
      }
    }, {
      key: "_autoCloseEle",
      value: function _autoCloseEle() {
        var _this10 = this;

        var delay = this._opts.delay;
        var duration = delay.openAfter ? delay.openAfter + delay.closeAfter : delay.closeAfter;
        clearTimeout(this._closeTimer);
        this._closeTimer = setTimeout(function () {
          return _this10.close();
        }, duration);
      }
    }, {
      key: "_preprocessEle",
      value: function _preprocessEle(options) {
        this._display().attr('aria-expanded', true); // No I18N


        this._fixDimensions();

        this._positionEle(options);
      }
    }, {
      key: "_openHandler",
      value: function _openHandler() {
        var _this11 = this;

        !this._opts.animation && this._display().attr('aria-expanded', 'true'); // No I18N

        if (this._opts.wrapAroundKeyboardNavigation && ZC.FocusHandler) {
          ZC.FocusHandler.init(this.element, '.zpopover__close'); // No I18N
        } else if (this._dispatchEvent('beforefocus', {}, this.element)) {
          // No I18N
          clearTimeout(this._openTimeout);
          this._openTimeout = setTimeout(function () {
            return _this11.element.focus();
          }, 100);
        }

        this._dispatchEvent('open'); // No I18N

      }
    }, {
      key: "_fixDimensions",
      value: function _fixDimensions() {
        var opts = this._opts;

        if (opts.width) {
          this.element.css('width', opts.width + 'px'); // No I18N
        }

        var contentEle = this._contentEle,
            element = this.element,
            value,
            titleEle = element.find('.zpopover__title');

        if (opts.height && contentEle) {
          // Computes height for content based on title and content children
          value = opts.height - (titleEle.length ? titleEle.outerHeight(true) : 0) - (parseInt(contentEle.css('padding-top')) + parseInt(contentEle.css('padding-bottom'))) - (parseInt(element.css('border-top-width')) + parseInt(element.css('border-bottom-width'))); // No I18N

          contentEle.height(value);
        }

        return value;
      }
    }, {
      key: "close",
      value: function close(orgEvent) {
        if (this.element.is(':visible') && this._dispatchEvent('beforeclose', orgEvent)) {
          // No I18N
          if (this._opts.delay) {
            this._closeHandler();
          } else {
            ZC.animationHandler({
              action: 'close',
              // No I18N
              callback: this._closeHandler.bind(this),
              element: this.element,
              animation: this._opts.animation,
              ctype: this.name
            });
          }
        }
      }
    }, {
      key: "_closeHandler",
      value: function _closeHandler() {
        ZC.openedPopover = undefined;

        this._display(true).attr('aria-expanded', 'false'); // No I18N


        if (this._overlay) {
          this._overlay.hide();

          this._forElement.removeClass('zpopover--target'); // No I18N

        }

        this._dispatchEvent('close'); // No I18N

      }
    }, {
      key: "_arrowCallback",
      value: function _arrowCallback(element, direction) {
        this.element.removeClass('zpopover--top zpopover--bottom zpopover--left zpopover--right').addClass('zpopover--' + direction); // No I18N
      } // Need to handle it commonly for all components - Revisit.

    }, {
      key: "_positionEle",
      value: function _positionEle() {
        var opts = this._opts;

        if (opts.offset) {
          this.element.css(opts.offset);
        } else if (opts.position !== 'page-center') {
          // No I18N
          this._setPosition.apply(this, arguments);
        }
      }
    }, {
      key: "_correctPosition",
      value: function _correctPosition() {
        var displayType = this._opts.displayType,
            position = this._opts.position;
        this._position = displayType === 'box' ? position.indexOf('-') > -1 ? position : position === 'top' || position === 'bottom' ? position + '-left' : position === 'auto' ? 'bottom-left' : position : position === 'auto' ? 'bottom' : position; // No I18N
      }
    }, {
      key: "repositionPopover",
      value: function repositionPopover() {
        var container = this.element;

        if (container) {
          !container.is(':visible') && this._display(); // No I18N

          this._positionEle();
        }
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        clearTimeout(this._openTimeout);
        clearTimeout(this._openTimer);
        clearTimeout(this._closeTimer);
        this._titleBar = this._forElement = this._contentEle = null;
        this._overlay && this._overlay.remove();
        this._overlay = undefined;
      }
    }, {
      key: "_setTitleBar",
      value: function _setTitleBar(isUpdate) {
        var tmpOpts = this._opts,
            data = this._data;
        data.closeButton && this._handleClose();
        var title = tmpOpts.title || ''; // No I18N

        if (this.isCE) {
          var titleEle = this.element.find('z-potitle');
          data.titleEle = titleEle.length ? titleEle.addClass('zpopover__text')[0] : undefined;
        }

        if (!data.titleEle) {
          title = title instanceof $ || title[0] === '#' || title[0] === '.' ? $(title)[0] : this._opts.isTitleHTMLEncoded ? title : ZC.encodeHTML(title);
        }

        if (typeof title === 'string') {
          // No I18N
          data.title = title;
        } else {
          data.titleEle = title;
        }

        var hasTitle = !!data.titleEle || !!title,
            headingClassName = ''; // No I18N

        if (!hasTitle && !data.closeButton && tmpOpts.detachable) {
          hasTitle = false;
          headingClassName = 'zpopover__draggablearea'; // No I18N
        }

        data.titleBar = hasTitle || data.closeButton || tmpOpts.detachable;
        data.headingClassName = headingClassName;

        if (isUpdate) {
          this._render();

          this._titleBar = this.element.find('.zpopover__title'); // No I18N

          this._handleDrag && this._handleDrag(tmpOpts.detachable); // To bind event

          data.closeButton && this._handleClose(true, true);
        }
      }
    }, {
      key: "_getPosition",
      value: function _getPosition(options) {
        var base = this,
            arrowElement = this.element.find('.zpopover__pointer'),
            // No I18N
        arrowPointer;
        arrowPointer = arrowElement.length ? arrowElement : false;

        if (ZC.Position) {
          return ZC.Position.get(options && options.forElement ? options.forElement : this._forElement, this.element, {
            rtl: this._opts.rtl,
            direction: this._position,
            positionAlterable: this._opts.positionAlterable,
            arrow: {
              element: arrowPointer,
              callback: this._arrowCallback.bind(base),
              margin: {
                left: -1,
                top: -1
              }
            }
          });
        }
      }
    }, {
      key: "_setPosition",
      value: function _setPosition(options) {
        var opts = this._opts,
            pointer = this.element.find('.zpopover__pointer'),
            position = this._getPosition(options),
            margin = opts.margin;

        if (position) {
          if (margin) {
            position.elementPosition = this._getCorrectedPosition(position.elementPosition);

            if (pointer.length) {
              position.arrowPosition = this._getCorrectedPosition(position.arrowPosition, true);
            }
          }

          this.element.css(position.elementPosition);
          pointer.length && pointer.css(position.arrowPosition);
        }
      }
    }, {
      key: "_getCorrectedPosition",
      value: function _getCorrectedPosition(position, isCallout) {
        var margin = this._opts.margin,
            offset = isCallout ? -1 : 1,
            top,
            left;

        if (typeof margin === 'number') {
          // No I18N
          top = position.top + offset * margin;
          left = position.left + offset * margin;
        } else {
          var marginLeft = margin.left;
          left = marginLeft ? position.left + offset * marginLeft * (this._opts.rtl ? -1 : 1) : position.left;
          top = margin.top ? position.top + offset * margin.top : position.top;
        }

        position.top = top < 0 ? position.top : top;
        position.left = left < 0 ? position.left : left;
        return position;
      }
    }, {
      key: "_handleClose",
      value: function _handleClose() {
        var _this12 = this;

        var updateConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var initEvent = arguments.length > 1 ? arguments[1] : undefined;
        var closeEle = this.element.find('.zpopover__close');

        if (updateConfig) {
          var opts = this._opts;
          this._data.closeButton = {
            title: opts.closeButtonLabel || this._getI18NText('close'),
            // No I18N
            className: 'zpopover__close',
            // No I18N
            defaultIconClassName: 'zpopover__icon',
            // No I18N
            iconClassName: opts.closeIconClassName,
            SVGIconId: opts.closeSVGIconId,
            templateRender: true,
            mainElement: closeEle[0],
            defaultSVGIconId: 'zc__svg--close zbutton__svg',
            // No I18N
            customAttributes: {
              tabindex: -1
            }
          };
        }

        if (initEvent) {
          closeEle.on('click.' + this.name, function (orgEvent) {
            // No I18N
            _this12.close(orgEvent);
          });
        }
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        var element = this.element;
        var opts = this._opts,
            data = this._data,
            titleOpts = ['title', 'closeButton', 'type', 'detachable', 'isTitleHTMLEncoded']; // No I18N

        opts[optionName] = value;

        if (optionName === 'height') {
          // No I18N
          element.height(opts.height);

          this._fixDimensions();
        } else if (optionName === 'width') {
          // No I18N
          element.width(opts.width);
        } else if (optionName === 'position') {
          // No I18N
          this._correctPosition();

          if (element.is(':visible')) {
            // No I18N
            this._positionEle();
          }
        } else if (optionName === 'closeSVGIconId' || optionName === 'closeIconClassName') {
          // No I18N
          this._handleClose();

          this._setBtnValue(this._data.closeButton, this._data.closeButton); // No I18N

        } else if (optionName === 'content') {
          // No I18N
          this._setContent(value, true);

          if (this.isCE && element.find('z-pocontent').length) {
            element.find('z-pocontent').html(this._data.content);
            return;
          }

          this._isAjaxContent = _typeof(value) === 'object' && !(value instanceof $); // No I18N

          this._domChanged = true;
        } else if (titleOpts.indexOf(optionName) > -1) {
          // No I18N
          if (optionName === 'title' && this.isCE && element.find('z-potitle').length) {
            // No I18N
            return;
          }

          if (optionName === 'closeButton' || optionName === 'type') {
            // No I18N
            this._data.closeButton = opts.closeButton || value === 'modal'; // No I18N

            if (optionName === 'type') {
              this._createOverlay();
            }
          }

          if (optionName === 'detachable') {
            // No I18N
            this._handleDrag(value);
          }

          this._setTitleBar(true);
        } else if (optionName === 'displayType') {
          // No I18N
          this._correctPosition();

          data.callout = value === 'callout'; // No I18N

          this._domChanged = true;
        } else if (optionName === 'margin' && element.is(':visible')) {
          // No I18N
          var ele = element[0];

          var position = this._getCorrectedPosition({
            left: +ele.offsetLeft,
            top: +ele.offsetTop
          });

          element.css(position);
          var arrow = this.element.find('.zpopover__pointer');

          if (arrow.length) {
            position = this._getCorrectedPosition({
              left: +arrow[0].offsetLeft,
              // No I18N
              top: +arrow[0].offsetTop // No I18N

            }, true);
            arrow.css(position);
          }
        } else if (optionName === 'closeOnEsc') {
          // No I18N
          if (value) {
            this._bindEvents();
          } else {
            element.off('keydown.' + this.name); // No I18N
          }
        } else if (optionName === 'forElement') {
          // No I18N
          this._forElement = $(value);
        } else if (optionName === 'closeOnBodyClick') {
          // No I18N
          !value && ZC.unBindDocumentEvents(element);
        } else if (optionName === 'offset') {
          this.element.css(value);
        }
      }
    }, {
      key: "name",
      get: function get() {
        return "zpopover";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          type: 'modeless',
          // No I18N
          title: '',
          // No I18N
          displayType: 'callout',
          // No I18N
          position: 'auto',
          // No I18N
          closeButton: false,
          closeOnBodyClick: true,
          closeOnEsc: true,
          closeOnScroll: false,
          positionAlterable: true,
          removeOnClose: false,
          detachable: false,
          height: null,
          width: null,
          closeSVGIconId: null,
          closeIconClass: null,
          progressIndicatorIconClass: null,
          progressIndicatorSVGIconId: null,
          wrapAroundKeyboardNavigation: false,
          forElement: null,
          content: null,
          appendTo: null,
          isContentHTMLEncoded: false,
          isTitleHTMLEncoded: false
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          closeIconClassName: null,
          progressIndicatorIconClassName: null,
          innerHTML: null,
          margin: null,
          offset: null,
          delay: null,
          animation: null,
          messages: {
            close: 'Close' // No I18N

          }
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['beforeopen', 'open', 'beforeclose', 'close', 'dragstart', 'drag', 'dragend', 'beforefocus', 'contentload']; // No I18N
      }
    }]);

    return ZPopover;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZPopover', ZPopover);

  (function (ZC) {
    var template = ZC.zpopover.Templates;

    template.children = function (data) {
      return ZT.html(_templateObject21(), data.titleBar && ZT.html(_templateObject22(), data.headingClassName, data.titleEle || data.title && ZT.html(_templateObject23(), ZT.customHTML(data.title)), data.closeButton && ZT.html(_templateObject24(), ZC.createButton(data.closeButton))), data.contentEle || ZT.html(_templateObject25(), data.progressIndicator ? ZT.html(_templateObject26()) : data.isContentString ? ZT.customHTML(data.content) : data.content), data.callout && ZT.html(_templateObject27()));
    };
  })(ZComponents);
  /* $Id$ */


  var ZTabPanel =
  /*#__PURE__*/
  function (_ZC$CoreComponent4) {
    _inherits(ZTabPanel, _ZC$CoreComponent4);

    function ZTabPanel() {
      _classCallCheck(this, ZTabPanel);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZTabPanel).apply(this, arguments));
    }

    _createClass(ZTabPanel, [{
      key: "_init",
      value: function _init(element, options) {
        this._fromInit = true;
        this._useParent = true;
        var data = this._data;
        this._id = element[0].id || this._getID();

        var tabHeadDOM = data.tabHeadDOM = this._getTabHead();

        var tabBodyDOM = data.tabBodyDOM = this._getTabBody();

        var tabHeadClass = data.tabHeadClass = 'ztab__head'; // No I18N

        var tabBodyClass = data.tabBodyClass = 'ztab__body'; // No I18N

        if (tabHeadDOM) {
          $(tabHeadDOM).addClass(tabHeadClass).attr('role', 'tablist'); // No I18N
        }

        if (tabBodyDOM) {
          $(tabBodyDOM).addClass(tabBodyClass).children(this._SELECTORS.TABCONTENT).addClass('ztab__content') // No I18N
          .attr('role', 'panel') // No I18N
          .hide();
        }

        this._setContentType(data, options);

        this._initTabs(data, options);

        data.widgetRender = true;
      }
    }, {
      key: "_preRender",
      value: function _preRender(data) {
        this._addedByComponent = true;

        if (this._data.widgetRender) {
          data = this._data;
          data.widgetRender = true;

          this._setRenderData(data, this._opts);
        }

        return data;
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        if (this._keydownHandler) {
          this._addEvents({
            keydown: 'keydown' // No I18N

          }, this.element);
        }
      }
    }, {
      key: "_bindTabHead",
      value: function _bindTabHead() {
        var tabHeadDOM = $(this._data.tabHeadDOM);
        var tabs = tabHeadDOM.children();

        this._removeEvents('', tabs); // No I18N


        this._addEvents({
          'switch': this._opts.openOn === 'hover' ? 'mouseenter' : 'click' // No I18N

        }, tabs);
      }
    }, {
      key: "_switchHandler",
      value: function _switchHandler(orgEvent) {
        var tab = $(orgEvent.currentTarget);
        orgEvent.preventDefault();

        this._selectTab(tab, orgEvent);
      }
    }, {
      key: "_deselectTab",
      value: function _deselectTab(tab) {
        var tabData = this._getTabData(tab || this._activeTab);

        if (tabData) {
          var actualTabData = tabData.actualData;

          if (this._activeTab === tabData.element) {
            this._activeTab = false;
            this._opts.activeTab = 'none'; // No I18N
          }

          this._updateSelection(actualTabData, false);

          this._display(this._getPanel(actualTabData), false);
        }
      }
    }, {
      key: "_getPanel",
      value: function _getPanel(actualData) {
        return $('#' + actualData.panelId, this.element)[0]; // No I18N
      }
    }, {
      key: "_updateSelection",
      value: function _updateSelection(actualTabData) {
        var activate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var tabEle = $(actualTabData.element);
        activate = activate || null;
        actualTabData.active = activate;
        tabEle[activate ? 'addClass' : 'removeClass']('is-selected'); // No I18N

        tabEle.attr({
          'aria-selected': activate,
          // No I18N
          'data-selected': activate // No I18N

        });
      }
    }, {
      key: "_selectTab",
      value: function _selectTab(tab, orgEvent) {
        if (tab === 'none') {
          // No I18N
          return this._deselectTab();
        }

        var tabData = this._getTabData(tab);

        if (tabData) {
          if (this._trigger('beforeswitch', tabData, orgEvent)) {
            // No I18N
            var actualTabData = tabData.actualData;

            if (!actualTabData.hidden && !actualTabData.disabled) {
              this._deselectTab(null, orgEvent);

              actualTabData.element.querySelector('a').focus(); // No I18N

              this._opts.activeTab = this._activeTab = actualTabData.element;

              this._updateSelection(actualTabData, true);

              var panel = this._loadPane(tabData);

              this._display(panel, true); // Commented because last scrollTop must be maintained.
              // panel.scrollTop = 0;


              this._trigger('switch', tabData, orgEvent); // No I18N

            }
          }
        }
      }
    }, {
      key: "_toArr",
      value: function _toArr(datas) {
        return Array.isArray(datas) ? datas : [datas];
      }
    }, {
      key: "_trigger",
      value: function _trigger(customevent, tabData, orgEvent, data) {
        if (!this._fromInit) {
          data = data || {};
          data.activeTab = this._opts.activeTab;

          if (tabData) {
            data.tab = tabData.element;
            data.tabData = $.extend(true, {}, tabData.actualData);
            data.tabData.element = null;
          }

          return this._dispatchEvent(customevent, orgEvent, data, undefined, !!orgEvent);
        }

        return true;
      }
    }, {
      key: "_animate",
      value: function _animate(element, animation, action, callback) {
        var _this13 = this;

        var completeFn = function completeFn() {
          _this13._display(element[0], action !== 'hide'); // No I18N


          callback && callback();
        };

        if (animation && ZC.animationHandler && !$.isEmptyObject(animation)) {
          var animationObject = {
            element: element,
            action: action,
            animation: animation,
            callback: completeFn,
            ctype: this.name
          };
          ZC.animationHandler(animationObject);
        } else {
          completeFn();
        }
      }
    }, {
      key: "_setRenderData",
      value: function _setRenderData(data, options) {
        data.alwaysSetAttrs = true;
        var position = data.position = options.tabPosition;
        data.isVertical = /^(left|right)$/.test(position);
        data.isBottom = /^(right|bottom)$/.test(position);
        var alignment = options.tabAlignment;

        if (data.isVertical) {
          if (!/^(top|bottom|middle)$/.test(alignment)) {
            alignment = 'top'; // No I18N
          }
        } else if (!/^(left|right|center)$/.test(alignment)) {
          alignment = 'left'; // No I18N
        }

        data.alignment = alignment;

        this._setWdHt(data, options);
      }
    }, {
      key: "_renderTabs",
      value: function _renderTabs() {
        var data = this._data;
        this._addedByComponent = true;

        if (data.tabHeadDOM) {
          data.tabs.forEach(function (tabData) {
            if (!tabData.actualData.userEle) {
              tabData.element = null;
            }
          });

          this._render(data.tabs, 'tabs', data.tabHeadDOM, true); // No I18N

        }

        this._addedByComponent = false;

        this._setTabEle(data.tabs);

        this._bindTabHead();
      }
    }, {
      key: "_setTabEle",
      value: function _setTabEle(tabs) {
        tabs.forEach(function (tabData) {
          var tabEle = tabData.element;
          var actualData = tabData.actualData;

          if (!tabEle) {
            tabEle = $('#' + tabData.id); // No I18N

            var customAttrs = tabData.customAttrs;

            if (customAttrs) {
              tabEle.attr(customAttrs);
            }

            tabData.element = actualData.element = tabEle[0];
          }
        });
      }
    }, {
      key: "_setInitial",
      value: function _setInitial() {
        var activeTab = this._opts.activeTab;

        if (activeTab !== 'none') {
          // No I18N
          activeTab = activeTab || this._initialTab || this._data.tabs.find(function (tabData) {
            return !tabData.hidden && !tabData.disabled;
          });

          if (activeTab) {
            this._selectTab(activeTab);
          } else {
            this._opts.activeTab = 'none'; // No I18N
          }
        }
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender() {
        var data = this._data;

        if (data.widgetRender) {
          data.widgetRender = false;
          data.tabHeadDOM = this._getTabHead();
          data.tabBodyDOM = this._getTabBody();

          this._renderTabs();

          this._setClassName(data, this._opts);

          this._setPanelListHt();

          if (this._fromInit) {
            this._setInitial();

            this._fromInit = false;

            this._trigger('init'); // No I18N

          }
        }

        this._addedByComponent = false;
      }
    }, {
      key: "_getTabHead",
      value: function _getTabHead() {
        return this._data.tabHeadDOM || this.element[0].querySelector(this._SELECTORS.TABHEAD);
      }
    }, {
      key: "_getTabBody",
      value: function _getTabBody() {
        return this._data.tabBodyDOM || this.element[0].querySelector(this._SELECTORS.TABBODY);
      }
    }, {
      key: "_setPanelListHt",
      value: function _setPanelListHt() {
        var tabBodyDOM = this._getTabBody();

        tabBodyDOM.style.height = ''; // No I18N

        if (!this._data.isVertical) {
          tabBodyDOM.style.height = 'calc(100% - ' + $(this._getTabHead()).outerHeight(true) + 'px'; // No I18N
        }
      }
    }, {
      key: "_setWdHt",
      value: function _setWdHt(data, options) {
        var element = this.element;

        var height = this._getValidSize(options.height);

        var width = this._getValidSize(options.width);

        var style = element.attr('style'); // No I18N

        var styleObj = {};

        if (style) {
          style.split(';').forEach(function (s) {
            s = s.replace(/;/g, '').split(':'); // No I18N

            styleObj[s[0]] = s[1];
          });
        }

        if (height) {
          styleObj.height = height;
        }

        if (width) {
          styleObj.width = width;
        }

        data.attrs = {
          style: this._getStyle(styleObj)
        };
      }
    }, {
      key: "_setClassName",
      value: function _setClassName(data, options) {
        var className = 'ztabpanel ' + (options.className || options.zclassName || '') + (options.rtl ? ' zh-rtl' : '') + (options.tabLabelType === 'icon' ? ' ztabpanel--icononly' : '') + (data.isVertical ? ' ztabpanel--vertical' : ''); // No I18N

        var positionClassName = ' ztabpanel--' + data.position + data.alignment; // No I18N

        data.className = className + positionClassName;
      }
    }, {
      key: "_setContentType",
      value: function _setContentType(data, options) {
        var labelType = options.tabLabelType;
        data.hasIcon = data.hasText = false;

        if (labelType.indexOf('icon') > -1) {
          // No I18N
          data.hasIcon = true;
        }

        if (!data.hasIcon || labelType.indexOf('text') > -1) {
          // No I18N
          data.hasText = true;
        }
      }
    }, {
      key: "_initTabs",
      value: function _initTabs(data, options, onlyDS) {
        var _this14 = this;

        var tabDatas = [];
        var selectors = this._SELECTORS;

        if (data.tabHeadDOM && !onlyDS) {
          var _tabs = _toConsumableArray(data.tabHeadDOM.querySelectorAll(selectors.TABITEM + ':not([data-custom=true]):not([data-zadded-by-template=true])')); // No I18N


          tabDatas = _tabs.map(function (tab) {
            return _this14._getTabEleData(tab, data, options);
          });
        }

        var tabs = options.tabs;

        if (tabs && tabs.length) {
          var _tabDatas;

          tabs = JSON.parse(JSON.stringify(tabs));

          (_tabDatas = tabDatas).push.apply(_tabDatas, _toConsumableArray(tabs.map(function (actualData) {
            return _this14._setTabData(actualData);
          })));
        }

        if (!options.lazyLoadContent) {
          tabDatas.forEach(function (tabData) {
            return _this14._loadPane(tabData);
          });
        }

        data.tabs = tabDatas;
      }
    }, {
      key: "_getValidSize",
      value: function _getValidSize(size) {
        return size && size + (isNaN(size) ? '' : 'px'); // No I18N
      }
    }, {
      key: "_setTabData",
      value: function _setTabData(actualTabData, tabData) {
        var data = this._data;
        var options = this._opts;
        actualTabData = this._getCompleteTabData(actualTabData);
        var tabEle = actualTabData.element;
        var label, icon;
        var hidden = actualTabData.hidden || null;
        var disabled = actualTabData.disabled || null;

        if (actualTabData.active && !hidden && !disabled) {
          this._initialTab = actualTabData;
        }

        if (this._fromInit) {
          actualTabData.active = false;
        }

        if (data.hasText) {
          label = this._encodeLabel(actualTabData.label) || actualTabData.innerHTML || this._getI18NText('untitledTab'); // No I18N
        }

        if (data.hasIcon) {
          this._setIconData(actualTabData, icon = {});
        }

        var style = actualTabData.style || ''; // No I18N

        if (hidden) {
          style += ';display:none'; // No I18N
        }

        var width = this._getValidSize(actualTabData.width);

        if (width) {
          style += ';width:' + width; // No I18N
        }

        var newTabData = {
          id: actualTabData.id,
          role: 'tab',
          // No I18N
          tabindex: -1,
          className: 'ztab ' + (disabled ? ' is-disabled' : '') + (actualTabData.active ? 'is-selected' : '') + (actualTabData.zclassName || actualTabData.className || ''),
          // No I18N
          label: label,
          icon: icon,
          panelId: actualTabData.panelId,
          hidden: hidden || null,
          disabled: disabled || null,
          active: actualTabData.active || null,
          customAttrs: actualTabData.customAttributes,
          element: tabEle,
          linkTag: actualTabData.linkTag,
          style: style,
          actualData: actualTabData,
          title: options.tabLabelType === 'icon' ? actualTabData.label : null // No I18N

        };

        if (tabData) {
          Object.assign(tabData, newTabData);
        } else {
          tabData = newTabData;
        }

        this._updateTabEleAttrs(tabData);

        return tabData;
      }
    }, {
      key: "_encodeLabel",
      value: function _encodeLabel(label) {
        return label && (this._opts.isTabLabelHTMLEncoded ? label : ZC.encodeHTML(label));
      }
    }, {
      key: "_getCompleteTabData",
      value: function _getCompleteTabData(actualTabData) {
        if (!actualTabData.zdone) {
          if (typeof actualTabData === 'string') {
            // No I18N
            actualTabData = {
              label: actualTabData
            };
          }

          var id = actualTabData.id;

          if (!id) {
            id = this._getID(null, this._id + '-tab'); // No I18N
          }

          actualTabData.id = id;
          var panelId = actualTabData.panelId;

          if (!panelId) {
            panelId = this._getID(null, this._id + '-tabcontent'); // No I18N
          }

          panelId = actualTabData.panelId = panelId.replace(/^#/, ''); // No I18N
        }

        actualTabData.zdone = true;
        return actualTabData;
      }
    }, {
      key: "_getTabEleData",
      value: function _getTabEleData(tab) {
        var optData = ZC._getOpts(tab);

        var linkTag = tab.querySelector('a'); // No I18N

        var label = optData.label;
        var innerHTML = !label && (linkTag && linkTag.innerHTML || tab.innerHTML);

        if (linkTag) {
          linkTag.textContent = ''; // No I18N

          optData.panelId = optData.panelId || linkTag.getAttribute('href'); // No I18N
        }

        return this._setTabData(Object.assign(optData, {
          id: tab.id,
          element: tab,
          label: label,
          hidden: optData.hidden || tab.style.display === 'none',
          // No I18N
          innerHTML: innerHTML,
          linkTag: linkTag,
          userEle: true
        }));
      }
    }, {
      key: "_display",
      value: function _display(element) {
        var show = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        element.style.display = show ? '' : 'none'; // No I18N
      }
    }, {
      key: "_updateTabEleAttrs",
      value: function _updateTabEleAttrs(tabData) {
        this._addedByComponent = true;
        var tab = tabData.element;

        if (tab) {
          var hidden = tabData.hidden;
          var disabled = tabData.disabled;
          var attrs = {};
          Object.assign(attrs, {
            title: tabData.title,
            id: tabData.id,
            role: 'tab',
            // No I18N
            tabindex: -1,
            'class': tabData.className,
            // No I18N
            'data-panel-id': tabData.panelId,
            // No I18N
            'data-hidden': hidden,
            // No I18N
            'aria-hidden': hidden,
            // No I18N
            'data-disabled': disabled,
            // No I18N
            'aria-disabled': disabled,
            // No I18N
            style: tabData.style
          });
          $(tab).attr(Object.assign(attrs, tabData.customAttrs || {}));

          this._updateTabContent(tabData);
        }

        this._addedByComponent = false;
      }
    }, {
      key: "_updateTabContent",
      value: function _updateTabContent(tabData) {
        var linkTag = tabData.linkTag;

        if (linkTag) {
          this._render(tabData, 'anchorContent', linkTag, true); // No I18N

        }

        this._render(tabData, 'tabContent', tabData.element, true); // No I18N

      }
    }, {
      key: "_getTabData",
      value: function _getTabData(tab) {
        if (tab) {
          var matchedTabData;

          var dataType = _typeof(tab);

          if (dataType === 'string' || dataType === 'number') {
            // No I18N
            if (!isNaN(tab)) {
              matchedTabData = this._data.tabs[tab];
              return matchedTabData;
            }

            tab = $(tab, this.element);
          }

          if (tab instanceof $) {
            tab = tab[0];
          }

          if (tab) {
            if (tab.nodeType) {
              matchedTabData = this._data.tabs.find(function (tabData) {
                return tab.id === tabData.id;
              });
            } else if (_typeof(tab) === 'object') {
              // No I18N
              return tab;
            }

            return matchedTabData;
          }
        }
      }
      /* Function to select next or previous tab */

    }, {
      key: "_navNextPrevTab",
      value: function _navNextPrevTab(isPrevious, startIndex) {
        var tabs = this._data.tabs;

        if (tabs.length) {
          var tabData;
          var factor = isPrevious ? -1 : 1;

          if (startIndex === undefined) {
            tabData = this._getTabData(this._activeTab);

            if (tabData) {
              startIndex = tabs.indexOf(tabData);
            } else {
              startIndex = -1;
            }
          } else {
            startIndex -= 1 * factor;
          }

          var maxIndex = tabs.length - 1;
          var currentIndex = startIndex;
          var actualData;

          do {
            currentIndex = currentIndex + 1 * factor;

            if (currentIndex < 0) {
              currentIndex = maxIndex;
            }

            if (currentIndex > maxIndex) {
              currentIndex = 0;
            }

            tabData = tabs[currentIndex];
            actualData = tabData.actualData;
          } while (currentIndex !== startIndex && (actualData.disabled || actualData.hidden));

          if (currentIndex !== startIndex) {
            this._selectTab(tabData);
          }
        }
      }
    }, {
      key: "_getNextPreviousTab",
      value: function _getNextPreviousTab(isPrevious) {
        var tabs = this._getTabs();

        var selectedIndex = tabs.index(this._opts.activeTab);
        var nextTab = $(tabs[selectedIndex])[isPrevious ? 'prevAll' : 'nextAll']("".concat(this._SELECTORS.TABITEM, ":not(.").concat(this._CLASSES.DISABLED, "):visible:first")); // No I18N

        nextTab = nextTab.length ? nextTab : tabs.filter(':not(.' + this._CLASSES.DISABLED + '):visible'); // No I18N

        return nextTab.filter(isPrevious ? ':last' : ':first'); // No I18N
      }
    }, {
      key: "_loadPane",
      value: function _loadPane(tabData) {
        if (tabData) {
          var actualTabData = tabData.actualData;

          var pane = this._getPanel(actualTabData);

          var append = false;

          if (!pane) {
            pane = $('<div></div>')[0]; // No I18N;

            pane.id = actualTabData.panelId;
            append = true;
          }

          var content = actualTabData.panelContent;

          if (content && (!actualTabData.contentLoaded || !this._opts.cacheContent && content.URL)) {
            actualTabData.contentLoaded = true;

            if (content instanceof $) {
              content = content[0];
            }

            if (content) {
              if (content.nodeType) {
                pane.innerHTML = content.outerHTML;
              } else if (typeof content === 'string') {
                // No I18N
                pane.innerHTML = actualTabData.isPanelContentHTMLEncoded ? content : ZC.encodeHTML(content);
              } else if (content.URL) {
                this._initAjaxLoad(actualTabData, content.URL, content.queryParam, pane, content.success, content.errorMessage, content.fail);
              }
            }
          }

          if (append) {
            this._data.tabBodyDOM.appendChild(pane);
          }

          return pane;
        }
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        if (optionName === 'activeTab') {
          // No I18N
          this._selectTab(value);
        } else {
          this._setAdvAttribute(optionName, value);
        }
      }
    }, {
      key: "openTab",
      value: function openTab(tab) {
        this._selectTab(tab);

        return this.getActiveTab();
      }
    }, {
      key: "openNextTab",
      value: function openNextTab() {
        this._navNextPrevTab();

        return this.getActiveTab();
      }
    }, {
      key: "openPreviousTab",
      value: function openPreviousTab() {
        this._navNextPrevTab(true);

        return this.getActiveTab();
      }
    }, {
      key: "getActiveTab",
      value: function getActiveTab() {
        return this._opts.activeTab;
      }
    }, {
      key: "deselectAllTabs",
      value: function deselectAllTabs() {
        this._deselectTab();
      }
    }, {
      key: "_setIconData",
      value: function _setIconData(actualTabData, icon) {
        ZC._getIconInfo(actualTabData.iconClassName || actualTabData.iconClass, actualTabData.SVGIconId, null, 'ztabpanel__icon', icon); // No I18N

      }
    }, {
      key: "_setAdvAttribute",
      value: function _setAdvAttribute(optionName, value) {
        var _this15 = this;

        var data = this._data;
        var options = this._opts;
        this._addedByComponent = true;

        switch (optionName) {
          case 'openOn':
            // No I18N
            options[optionName] = value;

            this._bindTabHead();

            break;

          case 'tabPosition':
            // No I18N
            options[optionName] = value;
            this._domChanged = data.widgetRender = true;
            break;

          case 'tabAlignment':
            // No I18N
            options[optionName] = value;

            this._setRenderData(data, options);

            this._setClassName(data, options);

            break;

          case 'tabLabelType':
            // No I18N
            options[optionName] = value;

            this._setContentType(data, options);

            data.tabs.forEach(function (tabData) {
              return _this15._setTabData(tabData.actualData, tabData);
            });

            this._setClassName(data, options);

            break;

          case 'tabs':
            // No I18N
            options[optionName] = value;

            this._initTabs(data, options, true);

            this._domChanged = data.widgetRender = true;
            break;

          case 'width': // No I18N

          case 'height': // No I18N

          case 'className': // No I18N

          case 'zclassName':
            // No I18N
            options[optionName] = value;
            this._domChanged = data.widgetRender = true;
            break;

          case 'cacheData': // No I18N

          case 'lazyLoadContent': // No I18N

          case 'tabAnimation':
            // No I18N
            options[optionName] = value;
            break;
        }

        this._addedByComponent = false;
      }
    }, {
      key: "name",
      get: function get() {
        return "ztabpanel";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          tabAlignment: 'left',
          // No I18N
          tabPosition: 'top',
          // No I18N
          tabLabelType: 'text',
          // "icon"|"icon-text" //No I18N
          openOn: 'click',
          // No I18N
          activeTab: null,
          lazyLoadContent: true,
          cacheContent: true,
          isTabLabelHTMLEncoded: false
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          tabAnimation: {},
          tabs: null,
          messages: {
            serverError: 'Server Request Failed.',
            // No I18N
            untitledTab: 'UntitledTab' // No I18N

          }
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['tabadd', // No I18N
        'tabremove', // No I18N
        'beforeswitch', // No I18N
        'switch', // No I18N
        'tabshow', // No I18N
        'tabhide', // No I18N
        'init' // No I18N
        ];
      }
    }, {
      key: "SELECTORS",
      get: function get() {
        return {
          TABPANEL: this.isCE ? 'z-tabpanel' : 'div',
          // No I18N
          TABHEAD: this.isCE ? 'z-tabhead' : 'ul',
          // No I18N
          TABITEM: this.isCE ? 'z-tab' : 'li',
          // No I18N
          TABBODY: this.isCE ? 'z-tabbody' : 'div',
          // No I18N
          TABCONTENT: this.isCE ? 'z-tabcontent' : 'div' // No I18N

        };
      }
    }]);

    return ZTabPanel;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZTabPanel', ZTabPanel);

  (function (ZC) {
    var template = ZC.ztabpanel.Templates,
        utilities = ZC.Templates.Utilities;

    template.children = function (data) {
      var responseTemplate = ZT.html(_templateObject28(), !data.isBottom && template.tabHead(data), data.tabBodyDOM || ZT.html(_templateObject29(), data.tabBodyClass), data.isBottom && template.tabHead(data));
      return responseTemplate;
    };

    template.tabHead = function (data) {
      var responseTemplate = data.tabHeadDOM || ZT.html(_templateObject30(), data.tabHeadClass, template.tabs(data.tabs));
      return responseTemplate;
    };

    template.tabs = function (data) {
      var responseTemplate = data.map(function (tab) {
        return template.tab(tab);
      });
      return responseTemplate;
    };

    template.tab = function (data) {
      var responseTemplate = data.element || ZT.html(_templateObject31(), data.title, data.id, data.className, data.style, data.panelId, data.disabled ? 'true' : '', data.disabled ? 'true' : '', data.hidden ? 'true' : '', data.hidden ? 'true' : '', template.tabContent(data));
      return responseTemplate;
    };

    template.tabContent = function (data) {
      var responseTemplate = data.linkTag || ZT.html(_templateObject32(), data.panelId, template.anchorContent(data));
      return responseTemplate;
    };

    template.anchorContent = function (data) {
      var responseTemplate = ZT.html(_templateObject33(), ZT.customHTML(''), data.icon && utilities.icon(data.icon), data.label && ZT.html(_templateObject34(), ZT.customHTML(data.label)));
      return responseTemplate;
    };
  })(ZComponents);
  /* eslint-disable no-unused-expressions */


  var ZDialog =
  /*#__PURE__*/
  function (_ZC$CoreComponent5) {
    _inherits(ZDialog, _ZC$CoreComponent5);

    function ZDialog() {
      _classCallCheck(this, ZDialog);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZDialog).apply(this, arguments));
    }

    _createClass(ZDialog, [{
      key: "_init",
      value: function _init(element) {
        var data = this._data,
            opts = this._opts,
            content = opts.content || '',
            // No I18N
        isCE = this.isCE;
        this._isComponentInited = false;
        var excludeSel = data.excludeFocus;
        data.excludeFocus = (excludeSel ? excludeSel + ',' : '') + ' .zbutton--action'; // No I18N

        if (isCE) {
          var title = element.find('z-dialogtitle').addClass('zdialog__title zdialog__text'); // No I18N

          if (title.length) {
            data.titleEle = title[0];
          }

          data.contentEle = element.find('z-dialogcontent').addClass('zdialog__content')[0]; // No I18N

          data.actionBar = element.find('z-dialogactionbar').addClass('zdialog__commandbar zdialog__footer')[0]; // No I18N
        } else if (content && _typeof(content) === 'object') {
          // No I18N
          this._fetchAjaxCon(content);
        } else {
          this._setContent();
        }

        opts.id = this._getID(element); // to use in minimize/maximize creation

        this._setTitleBarBtns && this._setTitleBarBtns(); // titlebar module func

        opts.buttons && this._createButtonPanel();
        opts.footer && this._setFootnote();
        this._skipParent = true;
      }
    }, {
      key: "_setContent",
      value: function _setContent() {
        var data = this._data,
            opts = this._opts,
            content = opts.content;

        if (content) {
          data.content = opts.isContentHTMLEncoded ? content : ZC.encodeHTML(content);
        } else {
          content = _toConsumableArray(this.element[0].childNodes);

          if (content.length) {
            data.content = content;
          }
        }
      }
    }, {
      key: "_postRender",
      value: function _postRender() {
        var data = this._data;
        data.className += ' zdialog'; // No I18N

        this.element.attr({
          'aria-modal': data.type === 'modal',
          // No I18N
          tabIndex: -1,
          role: 'dialog' // No I18N

        });
        $('body').append(this.element);
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender() {
        var elem = this.element,
            opts = this._opts;
        this._content = elem.find('.zdialog__content');
        this._titleBar = elem.find('.zdialog__titlebar'); // No I18N

        this._footer = elem.find('.zdialog__footnote'); // No I18N

        this._actionGroup = elem.find('.zdialog__actiongroup'); // No I18N

        var resizable = opts.resizable;
        this._minimizeButton = $('#' + opts.id + 'minimize'); // No I18N

        this._maximizeButton = $('#' + opts.id + 'maximize'); // No I18N

        if (resizable && ZC.resizable) {
          opts.resizable = _typeof(resizable) === 'object' ? resizable : {}; // No I18N

          this._initResize();
        }

        if (opts.draggable && ZC.draggable) {
          this._initDrag();
        }

        (opts.minimizable || opts.maximizable) && this._titleBar.off('dblclick.zdialog').on('dblclick.zdialog', this._titleBarClickHandler.bind(this)); // No I18N

        opts.autoOpen && this.open();
      }
    }, {
      key: "_findPosition",
      value: function _findPosition() {
        var elem = this.element;
        this.actualPosition = elem.position(); // store the position only when the dialog is in its actual state.

        this.bottomRightPosition = {
          bottom: elem[0].style.bottom,
          // No I18N
          right: elem[0].style.right // No I18N

        };
      }
    }, {
      key: "_findHeightWidth",
      value: function _findHeightWidth() {
        this.actualWidth = parseFloat(this.element.css('width')); // No I18N

        this.actualHeight = this._content.height();
      }
    }, {
      key: "open",
      value: function open(options) {
        this._open(options);
      }
    }, {
      key: "close",
      value: function close(data) {
        this._closeDialog({}, data, undefined);
      }
    }, {
      key: "isMinimized",
      value: function isMinimized() {
        return this.element.is('.zdialog--minimized'); // No I18N
      }
    }, {
      key: "isMaximized",
      value: function isMaximized() {
        return this.element.is('.zdialog--maximized'); // No I18N
      }
    }, {
      key: "refreshContent",
      value: function refreshContent(setFocus) {
        /* Method to enable TAB Key Handling for the contents which is dynamically added. */
        if (this._opts.handleFocusNavigation) {
          return ZC.FocusHandler.refresh(this.element, this._opts.excludeFocus, setFocus);
        }
      }
    }, {
      key: "_triggerEvent",
      value: function _triggerEvent(ename, event) {
        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        data.dialog = this.element;
        return this._dispatchEvent(ename, event, data);
      }
    }, {
      key: "_open",
      value: function _open(options) {
        /* If dialog container element has width property set on it, same width will be used.(considering the case that width might be set by performing resize operation) */
        if (this.isMinimized() || this.isMaximized()) {
          this._toggleRestore();
        }

        var ele = this.element,
            styleInfo = ele.attr('style'); // No I18N

        if (!styleInfo || styleInfo && styleInfo.indexOf('width') === -1) {
          // No I18N
          ele.css({
            width: this._opts.width || 'auto' // No I18N

          });
        }

        var returnValue = this._triggerEvent('beforeopen'); // No I18N


        if (returnValue) {
          var dOpacity = ele.css('opacity'); // No I18N

          ele.css('opacity', 0); // No I18N

          ele.show();

          if (!this._isComponentInited && ZC.init) {
            this._isComponentInited = true;
            ZC.init(ele);
          }

          ele.hide();
          ele.css('opacity', dOpacity); // No I18N

          this._display(true);

          this._positionDialog(options);

          if (this._opts.type !== 'modeless' && !this._overlay) {
            // No I18N
            this._createOverlay();
          }

          options = options || {};
          var animation = this._opts.animation || options.animation,
              base = this;

          if (animation) {
            this._animateAction(animation, 'open', function () {
              // No I18N
              base._handleDialogOpen();
            }, true);
          } else {
            this._handleDialogOpen();
          }
        }
      }
    }, {
      key: "_handleDialogOpen",
      value: function _handleDialogOpen() {
        var _this16 = this;

        this._display();

        var zIndex = this._opts.zIndex,
            element = this.element,
            componentName = this.name;
        ZC.zIndex = zIndex ? ZC.zIndex : ZC.zIndex + 1; // setting the zIndex for the dialog

        element.css({
          zIndex: zIndex ? parseInt(zIndex) : ZC.zIndex
        });
        this._opts.handleFocusNavigation && ZC.FocusHandler.init(element, this._opts.excludeFocus);

        this._findPosition();

        this._findHeightWidth();

        element.attr('aria-expanded', true); // No I18N

        this._triggerEvent('open', {}, {
          // No I18N
          position: this.actualPosition
        });

        ZC.activeDialog = element;
        var doIEHandle = !!(ZC.Browser.isIE && ZC.Browser.getIEVersion() <= 10);
        ZC.$window.off('resize.' + componentName).on('resize.' + componentName, function (event) {
          // No I18N
          // compute the top and left for the dialog whenever window resize occurs.
          if (_this16._opts.position === 'center' && event.originalEvent.type === 'resize' && !_this16.isMinimized() && !_this16.isMaximized()) {
            // No I18N
            _this16._positionDialog();
          }

          if (_this16.isMaximized() && doIEHandle) {
            // If dialog is in maximized state and browser is internet explorer, then we have to adjust width and height for content elements since flex-grow is not working there.
            _this16._adjustContentSize();
          }
        });
      }
    }, {
      key: "_closeDialog",
      value: function _closeDialog() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var data = arguments.length > 1 ? arguments[1] : undefined;
        var triggerEvent = arguments.length > 2 ? arguments[2] : undefined;
        // removing the restoring functionality because closing the dialog has fadeOut effect.
        event = event || {}; // Don't close the dialog if beforeClose event returns false

        var retVal = triggerEvent ? true : this._triggerEvent('beforeclose', event, data); // No I18N

        if (retVal) {
          if (this._opts.animation && (!data || data.animation === undefined || data.animation !== false)) {
            var base = this;

            this._animateAction(this._opts.animation, 'close', function () {
              base._handleDlgClose(event, data, triggerEvent); // hiding the dialog on animation complete function

            });
          } else {
            this._handleDlgClose(event, data, triggerEvent);
          }
        }
      }
    }, {
      key: "_handleDlgClose",
      value: function _handleDlgClose(event, data, triggerEve) {
        this._display(true); // hiding the dialog


        var ele = this.element;
        ele.attr('aria-expanded', false); // No I18N
        // removing the focus related classes here since dialog close might take up time if dialog close has animation effects.

        ele.find('.zdialog__commandbar .has-focus').removeClass('has-focus'); // No I18N

        this.restore(false); // restore event is called here inorder to restore the dialog from minimize/maximize state since on next open, it should open correctly.

        if (this._opts.type === 'modal' && this._overlay) {
          // No I18N
          this._closeModalDlg(event, data, triggerEve);
        } else if (!triggerEve) {
          this._triggerEvent('close', event, data); // No I18N

        }

        ZC.zIndex = ZC.zIndex > 1000 ? ZC.zIndex - 1 : 1000;

        if (ZC.activeDialog && ele && ZC.activeDialog[0] === ele[0]) {
          ZC.activeDialog = undefined;
        }

        ZC.$window.off("resize.".concat(this.name));
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        this._addEvents({
          keydown: 'keydown',
          // No I18N
          focus: 'focus' // No I18N

        });

        if (this._opts.type === 'modal') {
          // No I18N
          this._preventModalDlgClick();
        }

        if (this._data.titleBarButtons.length) {
          this._handleTBarActions();
        }
      }
    }, {
      key: "_keydownHandler",
      value: function _keydownHandler(event) {
        var activeDlg = ZC.activeDialog,
            ele = this.element;

        if (activeDlg && activeDlg[0] !== ele[0]) {
          ZC.activeDialog = ele;
        }

        if (event.keyCode === ZC.keyCode.ESCAPE && this._opts.closeOnEscKey) {
          var cancelBtn = ele.find('.zdialog__footer .zbutton'); // No I18N

          cancelBtn = cancelBtn.filter(function (index, item) {
            // retrieving the cancel button from the set of buttons.
            if ($(item).data('handleClose')) {
              // handleClose data will be stored in button construction utility.
              return $(item);
            }
          });

          if (cancelBtn.length) {
            // Pressing Escape should trigger the click event on cancel button.
            cancelBtn.focus();
            cancelBtn.trigger('click'); // No I18N
          } else {
            this._closeDialog(event);
          }

          event.stopPropagation();
        } else if (event.keyCode === ZC.keyCode.ENTER && this._opts.submitOnEnter && ele.find('form').length) {
          // excludedList: "textarea, label, span, .ztokenfield, .zsuggestfield-element, .zselectbox, .zaccordion, .zcollapsiblepanel, .zbutton--menu"; // No I18N
          var includedList = '.zbutton:not(.zbutton--menu),input:not(.ztokenfield__textbox):not(.zsuggestfield-element)'; // No I18N
          // Dialog ENTER will trigger the primary action button click.

          var target = $(event.target);

          if (target.closest(includedList).length && !target.closest('.zdialog__commandbar').length) {
            var primaryBtn = ele.find('.zdialog__footer').find(this._opts.defaultActionButton)[0]; // No I18N

            if (primaryBtn && target.closest('button')[0] !== primaryBtn) {
              $(primaryBtn).focus().trigger('click'); // No I18N

              return false;
            }
          }
        }
      }
    }, {
      key: "_focusHandler",
      value: function _focusHandler() {
        var activeDlg = ZC.activeDialog;

        if (activeDlg && activeDlg[0] !== this.element[0]) {
          ZC.activeDialog = this.element;
        }
      }
    }, {
      key: "_positionDialog",
      value: function _positionDialog(options) {
        var top = 0,
            left = 0,
            ele = this.element,
            opts = this._opts,
            content = ele.find('.zdialog__content'),
            // No I18N
        isVisible = ele.is(':visible'); // No I18N

        if (!isVisible) {
          this._display();
        }
        /* fixing the dialog height */


        if (opts.height) {
          ele.height(opts.height);
          var dlgHeight = ele.outerHeight(true),
              contHeight = parseInt(content.height()),
              padTop = parseInt(content.css('padding-top').split('px')[0]),
              // No I18N
          padBottom = parseInt(content.css('padding-bottom').split('px')[0]),
              // No I18N
          titleBarHeight = this._titleBar === undefined ? 0 : parseInt(this._titleBar.outerHeight(true)),
              btnPanel = ele.find('.zdialog__footer'),
              // No I18N
          btnPanelHeight = btnPanel.length ? btnPanel.outerHeight(true) : 0,
              footNote = ele.find('.zdialog__footnote'),
              // No I18N
          footNoteHeight = footNote.length ? footNote.outerHeight(true) : 0; // No I18N

          contHeight = dlgHeight - (padTop + padBottom + titleBarHeight + btnPanelHeight + footNoteHeight + parseInt(ele.css('border-top-width')) + parseInt(ele.css('border-bottom-width')) + parseInt(content.css('margin-top')) + parseInt(content.css('margin-bottom'))); // No I18N

          content.height(contHeight);
          ele.css('height', 'auto'); // No I18N
        }

        options = options || {};
        var elemWidth = ele.outerWidth(true),
            elemHeight = ele.outerHeight(true),
            winWidth = ZC.windowObject.width,
            winHeight = ZC.windowObject.height,
            position = opts.position,
            hasBottom = false;
        opts.position = position = options.position || position; // center align the dialog

        top = winHeight / 2 - elemHeight / 2 + (opts.type === 'modeless' ? window.pageYOffset : 0); // Adding the scrollY and scrollX values in modeless dialog otherwise it will be aligned to the top

        left = winWidth / 2 - elemWidth / 2 + (opts.type === 'modeless' ? window.pageXOffset : 0);
        var tar = options.target;

        if (tar) {
          // display the dialog nearer to target if target is specified.
          var off = $(tar).offset();
          top = off.top + $(tar).outerHeight(true);
          left = off.left;
        } else if (position === 'golden-mean') {
          // No I18N
          var halfWin = winHeight / 2,
              smallerPart = halfWin - halfWin / 1.618;
          top = smallerPart - parseFloat(elemHeight / 2) + window.pageYOffset; // scroll height is added.

          left = winWidth / 2 + window.pageXOffset - parseFloat(elemWidth / 2); // scroll width is added.
        } else if (typeof position === 'string' && position !== 'center') {
          // No I18N
          var values = position.split(','); // No I18N

          top = values[1] ? values[1] : top; // Position can also be given as "left,top"

          left = values[0] ? values[0] : left;
        }

        if (_typeof(position) === 'object') {
          // No I18N
          // If custom position contains right and bottom values, top-left can be ignored and the given object can be placed as such.
          if (!position.right && !position.bottom) {
            top = position.top || top; // position as {left: offsetLeft, top : offsetTop}

            left = position.left || left;
          } else {
            hasBottom = true;
          }
        } else {
          var docObj = ZC.documentObject; // handling the cases where left and top values are out of document boundaries.

          if (top < 0) {
            // if top value is negative,then dialog portion is hidden and can't be viewed even by scrolling
            top = 0;
          } else if (top >= docObj.height) {
            top = docObj.height - elemHeight;
          }

          if (left < 0) {
            left = 0;
          } else if (left > docObj.width) {
            left = docObj.width - elemWidth;
          }
        }

        if (!isVisible) {
          this._display(true);
        }

        this._hasBottom = hasBottom;
        var pos = hasBottom ? position : {
          top: top,
          left: left
        };
        ele.css(pos);
      }
    }, {
      key: "_setTitleBarBtns",
      value: function _setTitleBarBtns() {
        var opts = this._opts,
            btns = [],
            titleVal = opts.title,
            btnInfo = this._updateBtnInfo.bind(this);

        if (titleVal) {
          this._data.title = opts.isTitleHTMLEncoded ? titleVal : ZC.encodeHTML(titleVal);
        }

        if (opts.minimizable && opts.type !== 'modal') {
          // No I18N
          btns.push(btnInfo('minimize')); // No I18N
        }

        opts.maximizable && btns.push(btnInfo('maximize'));
        opts.closeButton && btns.push(btnInfo('close'));
        this._data.titleBarButtons = btns;
      }
    }, {
      key: "disableButton",
      value: function disableButton(keyword) {
        this._toggleButton(keyword, true);
      }
    }, {
      key: "enableButton",
      value: function enableButton(keyword) {
        this._toggleButton(keyword, false);
      }
    }, {
      key: "_toggleButton",
      value: function _toggleButton(keyword, attrValue) {
        var btn = this['_' + (keyword || 'close') + 'Button']; // No I18N

        if (btn) {
          this._disable(attrValue, btn);
        }
      }
    }, {
      key: "_updateBtnInfo",
      value: function _updateBtnInfo(actionName, mainEle) {
        var _opts = this._opts,
            elem = $('#' + _opts.id + actionName);
        return {
          id: _opts.id + actionName,
          // No I18N
          title: _opts[actionName + 'ButtonLabel'] || this._getI18NText(actionName),
          // No I18N
          className: 'zbutton--action zdialog__' + actionName,
          // No I18N
          SVGIconId: _opts[actionName + 'SVGIconId'],
          // No I18N
          SVGIconClassName: 'zbutton__svg',
          // No I18N
          iconClassName: _opts[actionName + 'IconClassName'] || _opts[actionName + 'IconClass'],
          // No I18N
          defaultSVGIconId: 'zc__svg--' + actionName + ' zbutton__svg',
          // No I18N
          templateRender: true,
          // isCE: _opts.isCE, If we render buttons as z-button, then while emptying the element via template rendering produces incorrect results since disconnected and connected callbacks will be invoked with loss in data.
          mainElement: mainEle || (elem.length ? elem[0] : null),
          customAttributes: {
            'data-zdaction': actionName,
            // No I18N
            tabindex: -1 // No I18N

          }
        };
      }
    }, {
      key: "_handleTBarActions",
      value: function _handleTBarActions() {
        var _this17 = this;

        var name = '.' + this.name,
            // No I18N
        code;
        var btnContainer = this.element.find('.zdialog__actiongroup'); // Revisit - use bindEleEvents

        btnContainer.on('click' + name + ' keydown' + name, function (event) {
          // No I18N

          /*
              Shortcuts for Minimize Button
              MAC OS: Cmd+M
              Windows & Ubuntu OS: No direct shortcuts
          */
          code = event.keyCode;

          if (event.type === 'click' || code === ZC.keyCode.ENTER || code === ZC.keyCode.SPACE) {
            var btn = $(event.target).closest('.zbutton--action:not(.is-disabled)'),
                // No I18N
            zdaction = btn.attr('data-zdaction'); // No I18N

            if (['maximize', 'minimize', 'restore'].indexOf(zdaction) > -1) {
              return _this17._minMaxClick(zdaction, event, btn);
            } else if (zdaction === 'close') {
              return _this17._closeClickHandler(event);
            }
          }
        }).on('mousedown' + name, function () {
          // activeElement is stored to use while restoring from minimize state.
          _this17._activeElement = _this17._activeElement || $(document.activeElement);
        });
      }
    }, {
      key: "_createButtonPanel",
      value: function _createButtonPanel() {
        if (ZC.isEmpty(this._opts.commandBar)) {
          var buttons = this._opts.buttons,
              commands = [],
              buttonObj,
              len = buttons.length;

          for (var i = 0; i < len; i++) {
            buttonObj = buttons[i];
            _typeof(buttonObj) === 'object' && commands.push(this._createButton(buttonObj)); // No I18N
          }

          this._data.commands = commands;
        } else {
          this._createCommandBar();
        }

        var btnAlign = this._opts.buttonsAlignment;
        this._data.alignClassName = btnAlign === 'right' ? '' : this._getAlignCls(btnAlign); // No I18N
      }
    }, {
      key: "_createButton",
      value: function _createButton(buttonObj) {
        var btnid = buttonObj.id = buttonObj.id || this._getID(buttonObj, 'dlgbutton'),
            // No I18N
        elem = btnid && $('#' + btnid);

        buttonObj.templateRender = true;
        var action = buttonObj.action,
            isActFunc = typeof action === 'function'; // No I18N

        buttonObj.click = isActFunc ? action : this._clickHandler.bind(this);
        buttonObj.mainElement = elem ? elem[0] : null;

        if (!isActFunc) {
          var custAttrs = buttonObj.customAttributes || {};
          custAttrs['data-action'] = action; // No I18N

          buttonObj.customAttributes = custAttrs;
        }

        return buttonObj;
      }
    }, {
      key: "_clickHandler",
      value: function _clickHandler(event) {
        var buttonEle = $(event.target).closest('.zbutton'); // No I18N

        if (!buttonEle.hasClass('is-disabled') || buttonEle.find('.zbutton__loader').length) {
          // If there is no action, don't close the dialog.
          var action = buttonEle.attr('data-action'); // No I18N

          if (action) {
            // string type actions will only be present here
            if (action === 'CANCEL' || action === 'CLOSE') {
              // No I18N
              this._closeDialog(event, {
                button: buttonEle
              });
            } else {
              ZC._triggerFunction(action, buttonEle, [event, {
                button: buttonEle,
                options: ZC._getOpts(buttonEle)
              }]);
            }
          }

          this._triggerEvent('actionbuttonclick', event, {
            // No I18N
            button: buttonEle
          });
        }
      }
    }, {
      key: "_initDrag",
      value: function _initDrag() {
        var base = this;
        ZC.draggable(this.element, {
          ignoreAsHandle: '.zdialog__actiongroup,.zresizable__handle',
          // No I18N
          handle: '.zdialog__header',
          // No I18N
          region: 'viewport',
          // No I18N
          cursor: 'default',
          // No I18N
          start: function start(event, ui) {
            base._triggerEvent('dragstart', event, ui); // No I18N

          },
          end: function end(event, ui) {
            base._triggerEvent('dragend', event, ui); // No I18N

          },
          drag: function drag(event, ui) {
            base._triggerEvent('drag', event, ui); // No I18N

          }
        });
      }
    }, {
      key: "_createOverlay",
      value: function _createOverlay() {
        ZC.zIndex += 1; // setting zindex for overlay to have the modal behavior

        var opts = this._opts,
            overlay = $("<div class='zdialog--overlay ".concat(opts.overlayClassName, "' ></div>")).css('zIndex', ZC.zIndex); // No I18N

        this._addedByComponent = true;
        $('body').append(overlay.append(this.element)); // appending the dialog element to the overlay in order to correct the scroll behavior.

        this._addedByComponent = false;

        this._hideDocumentScroll(true); //  Here tabindex is set in order to make the div element receive keydown event.


        overlay.attr('tabindex', 1); // No I18N

        this._overlay = overlay;

        this._bindOverlayEvents();
      }
    }, {
      key: "_bindOverlayEvents",
      value: function _bindOverlayEvents() {
        this._addEvents({
          overlayKey: 'keydown',
          // No I18N
          overlayEveStop: 'click mousedown' // No I18N

        }, this._overlay);
      }
    }, {
      key: "_overlayKeyHandler",
      value: function _overlayKeyHandler(event) {
        if (event.keyCode === ZC.keyCode.ESCAPE && this._opts.closeOnEscKey) {
          // Closing the model dialog when escape key is pressed.
          this._closeDialog(event, {
            overlay: true
          });
        }
      }
    }, {
      key: "_overlayEveStopHandler",
      value: function _overlayEveStopHandler(event) {
        // preventing the propagation of mousedown/click because document mousedown handlers might close the already opened menu/popover.
        if (!$(event.target).closest('.zdialog').length) {
          // No I18N
          event.stopPropagation();

          if (event.type === 'click' && this._opts.closeOnOverlayClick) {
            // No I18N
            this._closeDialog(event, {
              overlay: true
            });
          }
        }
      }
    }, {
      key: "_unbindOverlayEvents",
      value: function _unbindOverlayEvents() {
        this._removeEvents('keydown click mousedown', this._overlay); // No I18N

      }
    }, {
      key: "_hideDocumentScroll",
      value: function _hideDocumentScroll(hide) {
        $('body')[hide ? 'addClass' : 'removeClass']('zh-overflowhidden'); // No I18N
      }
    }, {
      key: "_closeModalDlg",
      value: function _closeModalDlg(event, data, triggerEve) {
        var over = this._overlay,
            isVisible = over.is(':visible'); // No I18N

        $('body').append(this.element); // Appending the dialog element to body before removing the overlay.

        if (isVisible && (!data || data.animation === undefined || data.animation !== false)) {
          // No I18N
          var base = this;
          over.fadeOut(50, this._triggerCloseEvent.bind(base, event, data, triggerEve));
        } else {
          isVisible && over.hide();

          this._triggerCloseEvent(event, data, triggerEve);
        }
      }
    }, {
      key: "_triggerCloseEvent",
      value: function _triggerCloseEvent(event, data, triggerEvent) {
        var over = this._overlay;
        over && over.length && over.remove();
        this._overlay = undefined;

        if (!$('body').find('.zdialog--overlay').length) {
          this._hideDocumentScroll(false);
        }

        if (!triggerEvent) {
          this._triggerEvent('close', event, data); // No I18N

        }
      }
    }, {
      key: "_preventModalDlgClick",
      value: function _preventModalDlgClick() {
        this._addEvents({
          overlayClk: 'click' // No I18N

        });
      }
    }, {
      key: "_overlayClkHandler",
      value: function _overlayClkHandler(event) {
        // propagation of click event is prevented since overlay click will close the dialog.
        event.stopPropagation();
      }
    }, {
      key: "_getAlignCls",
      value: function _getAlignCls(btnAlign) {
        return this._ALIGNMENTS[btnAlign];
      }
    }, {
      key: "_closeClickHandler",
      value: function _closeClickHandler(event) {
        this._resetPosition(this.element, true);

        this._closeDialog(event, {
          closeButton: true
        });

        return event.type !== 'keydown'; // No I18N
      }
      /* eslint-disable no-unused-expressions */

    }, {
      key: "_setAttribute",
      value: function _setAttribute(optName, value) {
        var opts = this._opts,
            data = this._data,
            isCE = opts.isCE;

        if (optName === 'title') {
          // No I18N
          if (value) {
            data.title = data.isTitleHTMLEncoded ? value : ZC.encodeHTML(value);
            isCE && this._titleBar.find('.zdialog__title').text(data.title); // No I18N
          } else {
            data.title = data.titleEle = null;
          }
        } else if (optName === 'content') {
          // No I18N
          opts[optName] = value;

          if (value) {
            if (_typeof(value) === 'object') {
              // No I18N
              $.ajax(value).success(function (data) {
                value = data;
              });
            }

            data.content = data.isContentHTMLEncoded ? value : ZC.encodeHTML(value); // No I18N

            isCE && this._content.html(data.content);
          } else {
            data.content = data.contentEle = null;
          }
        } else if (optName === 'closeOnEscKey') {
          // No I18N
          value ? this._bindEvents() : this.element.off(".".concat(this.name));
        } else if (optName === 'closeButton' || optName === 'closeSVGIconId' || optName === 'closeIconClassName' || optName === 'closeIconClass' || opts.closeButton && (optName === 'minimizable' || optName === 'maximizable')) {
          // No I18N
          opts[optName] = value;

          this._setTitleBarBtns();
        } else if (optName === 'className') {
          // No I18N
          this._updateClass(value, opts.className);
        } else if (optName === 'width') {
          // No I18N
          this.element.css({
            width: value
          });
          this.actualWidth = parseInt(value);
        } else if (optName === 'height') {
          // No I18N
          this._content.css('height', value); // No I18N


          this.actualHeight = parseInt(value);
        } else if (optName === 'type' && this.element.is(':visible')) {
          // No I18N
          // opts[optName] = value;
          if (value === 'modal') {
            // No I18N
            this._createOverlay(); // if dialog is a modal dialog, create the overlay


            this._preventModalDlgClick();
          } else {
            $('body').append(this.element); // Appending the dialog element to the body.

            this._overlay.remove();

            this._overlay = undefined;
            this.element.off('click.zdialog'); // No I18N

            this._setTitleBarBtns();
          }

          this.element.attr('aria-modal', value === 'modal'); // No I18N
        } else if (optName === 'overlayClassName' && this._overlay) {
          // No I18N
          this._overlay.removeClass(opts.overlayClassName).addClass(value);
        } else if (optName === 'resizable' && ZC.resizable) {
          // No I18N
          opts.resizable = value;

          if (this.element.data('zresizable') && value && _typeof(value) === 'object') {
            // No I18N
            if (Object.keys(value).length) {
              ZC.resizable(this.element).setAttributes(value);
            }
          } else {
            value ? this._initResize() : ZC.resizable(this.element).destroy();
          }
        } else if (optName === 'draggable') {
          // No I18N
          value ? this._initDrag() : ZC.draggable(this.element).destroy();
        } else if (optName === 'buttons' || optName === 'commandBar') {
          // No I18N
          opts[optName] = value;

          this._createButtonPanel();
        } else if (optName === 'position') {
          // No I18N
          opts.position = value;

          this._positionDialog();
        } else if (optName === 'footer') {
          // No I18N
          this._setFootnote(value);
        } else if (optName === 'buttonsAlignment') {
          // No I18N
          this.element.find('.zdialog__footer').removeClass(this._ALIGNMENTS[opts.buttonsAlignment]).addClass(this._ALIGNMENTS[value]);
        } else if (optName === 'closeOnOverlayClick' && this._overlay && this._overlay.length) {
          // No I18N
          value ? this._bindOverlayClick() : this._overlay.off('click.zdialog'); // No I18N
        } else if (optName === 'rtl' && opts.resizable) {
          // No I18N
          this.element.zresizable('setAttribute', 'rtl', value); // No I18N
        }

        if (optName !== 'className') {
          opts[optName] = data[optName] = value;
        }

        var noRenderItems = ['closeOnEscKey', 'className', 'closeOnOverlayClick', 'width', 'height', 'resizable', 'draggable', 'position', 'animation']; // No I18N

        if (noRenderItems.indexOf(optName) < 0) {
          this._domChanged = true;
        }
      }
    }, {
      key: "restore",
      value: function restore(triggerEvent) {
        this._performMinMax('Minimize', true, triggerEvent); // No I18N


        this._performMinMax('Maximize', true, triggerEvent); // No I18N

      }
    }, {
      key: "_performMinMax",
      value: function _performMinMax(action, restore, triggerEvent) {
        var isActive = this['is' + action + 'd'](),
            // No I18N
        alower = action.toLowerCase(),
            optName = alower.replace('e', 'able'),
            // No I18N
        btnName = '_' + alower + 'Button',
            // No I18N
        val = -1;

        if (!isActive && !restore && this._opts[optName]) {
          val = false;
        } else if (isActive && restore) {
          val = triggerEvent;
        }

        if (val !== -1) {
          this['_toggle' + action]({}, this[btnName], val); // No I18N
        }
      }
    }, {
      key: "_toggleReverse",
      value: function _toggleReverse(type, value, className, triggerEvent, callback, event) {
        var restore = value + 'Restore',
            // No I18N
        content = this._content,
            // No I18N
        base = this;

        var completeFunction = function completeFunction() {
          if (value === 'minimize') {
            // No I18N
            if (!type) {
              base.actualWidth = parseFloat(base.element.css('width')); // No I18N

              base.actualHeight = base.element.height();
            }

            base._footer[type ? 'removeClass' : 'addClass']('zh-dnone'); // No I18N


            content[type ? 'removeClass' : 'addClass']('zh-dnone'); // No I18N
          }

          base._updateClass(className, type);

          if (ZC.draggable && base._opts.draggable) {
            ZC.draggable(base.element).setAttribute('disabled', !type);
          }

          var titleText = base._opts[type ? value + 'ButtonLabel' : value + 'RestoreButtonLabel'] || base._getI18NText(type ? value : restore, base._opts.labels); // No I18N


          base._changeIcon(titleText, type ? value : restore);

          if (type) {
            base.element.css(base._hasBottom ? base.bottomRightPosition : base.actualPosition).css({
              width: base.actualWidth
            });

            if (value === 'maximize') {
              // No I18N
              content.height(base.actualHeight);
              content.css('width', ''); // No I18N
            } else if (value === 'minimize') {
              // No I18N
              base.enableButton('maximize'); // No I18N
            }
          } else if (value === 'maximize') {
            // No I18N
            base._adjustContentSize();
          } else if (value === 'minimize') {
            // No I18N
            base.element.css({
              width: ''
            });
            base.disableButton('maximize'); // No I18N
          }

          if (value === 'minimize') {
            // No I18N
            if (base._overlay) {
              base._overlay[type ? 'addClass' : 'removeClass']('zh-dnone'); // No I18N

            }

            var appendedElement = base._overlay ? base._overlay : $('body');

            if (base._overlay && type) {
              // resetting the z-index because on restoring the modal dialog from its minimized state, some other modeless dialogs can be opened.
              ZC.zIndex += 1;
              appendedElement.css('zIndex', ZC.zIndex); // No I18N

              base.element.appendTo(appendedElement); // Revisit - appendTo
            }

            base.element[type ? 'removeClass' : 'addClass']('zdialog--minimized'); // No I18N

            type || base._resetPosition(base.element);
            base._overlay && base._hideDocumentScroll(!!type);

            if (type) {
              // while restoring from the minimize state, active element stored while minimizing will be set focus.
              base._triggerActiveElement();
            }
          }

          if (triggerEvent) {
            // triggering the maximize, minimize or restore event.
            base._triggerEvent(type ? 'restore' : value, event, {
              // No I18N
              from: value
            });
          } // ZC.FocusHandler.init(base.element);


          if (value === 'maximize') {
            // No I18N
            base._triggerActiveElement();
          }

          callback && callback();
        };

        if (!type) {
          this._findPosition();

          this._findHeightWidth();
        }

        var props = {
          top: '',
          left: '',
          right: ''
        };

        if (value === 'maximize') {
          // No I18N
          props.width = '';
          props.height = '';
        }

        this.element.css(props);

        this._buttonAnimateHandler(type, value, completeFunction);
      }
    }, {
      key: "_adjustContentSize",
      value: function _adjustContentSize() {
        var content = this._content,
            element = this.element,
            header = element.find('.zdialog__header'),
            // No I18N
        footer = element.find('.zdialog__footer'),
            // No I18N
        headerHeight = header.length ? header.outerHeight(true) : 0,
            footerHeight = footer.length ? footer.outerHeight(true) : 0,
            footnoteHeight = this._footer.length ? this._footer.outerHeight(true) : 0,
            // No I18N
        computed = Math.abs(ZC.windowObject.height - (headerHeight + footerHeight + footnoteHeight + parseInt(content.css('padding-top')) + parseInt(content.css('padding-bottom')) + parseInt(element.css('border-top-width')) + parseInt(element.css('border-bottom-width')))),
            // No I18N
        computedWidth = ZC.windowObject.width - parseInt(content.css('padding-left')) - parseInt(content.css('padding-right')) - parseInt(content.css('margin-right')) - parseInt(content.css('margin-left')) - parseInt(element.css('border-left-width')) - parseInt(element.css('border-right-width')); // No I18N
        // padding top and padding bottom of dialog is added & padding left and right of the dialog is subtracted to have the dialog in view port

        content.width(computedWidth); // width and height is set individually in order to consider different box-sizing values for zdialog__content.

        content.height(computed);
      }
    }, {
      key: "_triggerActiveElement",
      value: function _triggerActiveElement() {
        var _activeElement = this._activeElement || '';

        if (!_activeElement.length) {
          _activeElement = this.element.find('.zdialog__header'); // No I18N
        }

        _activeElement.trigger('focus'); // No I18N


        this._activeElement = undefined;
      }
    }, {
      key: "_toggleRestore",
      value: function _toggleRestore(event, button, triggerEvent, value) {
        var isMaximized = this.isMaximized(),
            isMinimized = this.isMinimized();

        if (isMaximized || value === 'maximize') {
          // No I18N
          this._toggleReverse(isMaximized, 'maximize', 'zdialog--maximized', triggerEvent, undefined, event); // No I18N

        } else if (isMinimized || value === 'minimize') {
          // No I18N
          this._toggleReverse(isMinimized, 'minimize', 'zdialog--minimized', triggerEvent, undefined, event); // No I18N

        }

        if (button && button.length && button[0].id === this._opts.id + 'minimize' && isMaximized) {
          // No I18N
          this._toggleReverse(isMinimized, 'minimize', 'zdialog--minimized', triggerEvent, undefined, event); // No I18N

        }
      }
    }, {
      key: "_changeIcon",
      value: function _changeIcon(title, iconName) {
        var btns = this._data.titleBarButtons,
            relement = 'restore',
            // No I18N
        nele = iconName === 'minimize' || iconName === 'maximize' ? iconName : 'restore',
            // No I18N
        baseObj = this;

        if (iconName === 'minimizeRestore') {
          // No I18N
          relement = 'minimize'; // No I18N
        } else if (iconName === 'maximizeRestore') {
          // No I18N
          relement = 'maximize'; // No I18N
        }

        relement = this._opts.id + relement;
        var i = 0,
            info,
            mainEle;
        btns.forEach(function (element) {
          btns[i].mainElement = baseObj._actionGroup.find('#' + element.id); // No I18N

          if (element.id === relement) {
            mainEle = baseObj._actionGroup.find('#' + relement); // No I18N

            btns[i] = baseObj._updateBtnInfo(nele, mainEle.length && mainEle);
            info = btns[i];
            info.title = title;
            info.actionName = nele;
            info.zdaction = nele === 'restore' ? 'maximize' : nele; // No I18N
          }

          i++;
        });

        this._setBtnValue(info, info);

        if (info.mainElement) {
          $(info.mainElement).attr('data-zdaction', info.actionName); // No I18N
        }
      }
    }, {
      key: "_buttonAnimateHandler",
      value: function _buttonAnimateHandler(type, value, callback) {
        var animInfo = this._opts.animation;

        if (animInfo[value]) {
          this._animateAction(animInfo, type ? value + 'Restore' : value, callback); // No I18N

        } else {
          callback();
        }
      }
    }, {
      key: "_minMaxClick",
      value: function _minMaxClick(zdaction, event, btn) {
        this['_toggle' + zdaction[0].toUpperCase() + zdaction.substring(1)](event, btn, true); // No I18N

        if (zdaction === 'restore') {
          this._resetPosition(this.element, true);
        }

        if (event.type === 'keydown') {
          // No I18N
          // preventing the event propagation since keydown event triggers click event further.
          return false;
        }
      }
    }, {
      key: "_resetPosition",
      value: function _resetPosition(element, remove) {
        ZC._minArr = ZC._minArr || [];

        var index = ZC._minArr.indexOf(element);

        if (remove) {
          if (index > -1) {
            ZC._minArr.splice(index, 1);
          }
        } else {
          ZC._minArr.push(element);
        } // have to adjust all dialogs position


        var len = ZC._minArr.length,
            right,
            curr,
            prev,
            propName = this._opts.rtl ? 'left' : 'right'; // No I18N

        for (var i = len - 1; i > 0; i--) {
          curr = $(ZC._minArr[i]);
          prev = $(ZC._minArr[i - 1]);
          right = parseFloat(prev.css(propName)) + prev.outerWidth();
          curr.css(propName, right);
        }

        $(ZC._minArr[0]).css(propName, 0);
      }
    }, {
      key: "_titleBarClickHandler",
      value: function _titleBarClickHandler(event) {
        // dblclick
        // Perform Minimize, Maximize or Restore Operation while double clicking the titleBar
        if (!$(event.target).closest('.zdialog__actiongroup').length) {
          var action = this.isMaximized() || this.isMinimized() ? 'restore' : this._opts.maximizable ? 'maximize' : this._opts.minimizable ? 'minimize' : undefined; // No I18N

          action && this._toggleRestore(event, undefined, true, action); // No I18N

          if (action === 'restore') {
            // No I18N
            this._resetPosition(this.element, true);
          }
        }
      }
    }, {
      key: "minimize",
      value: function minimize() {
        this._performMinMax('Minimize'); // No I18N

      }
    }, {
      key: "_toggleMinimize",
      value: function _toggleMinimize(event, button, triggerEvent) {
        this._toggleRestore(event, button, triggerEvent, 'minimize'); // No I18N

      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        var ele = this.element,
            opts = this._opts,
            content = this._content;
        opts.handleFocusNavigation && ZC.FocusHandler.destroy(ele);
        !this.isCE && $('body').append(ele.removeClass('zdialog zdialog--minimized zdialog--maximized')); // No I18N

        var over = this._overlay;

        if (over && over.length) {
          over.remove();
          this._overlay = undefined;
        }

        if (opts.title) {
          ele.attr('title', opts.title); // No I18N
        }

        var eSuf = '.' + this.name; // No I18N

        ele.off(eSuf).css({
          width: 'auto',
          // No I18N
          right: '' // No I18N

        });
        opts.resizable && ZC.resizable(ele).destroy();
        opts.draggable && ZC.draggable(ele).destroy();

        if (this.isCE) {
          ele.off(eSuf);
          ele.find('.zdialog__title').removeClass('zdialog__title').unwrap('.zdialog__header'); // No I18N

          ele.find('.zdialog__content, .zdialog__commandbar, .zdialog__footer, .zdialog__footnote').removeClass('zdialog__content zdialog__commandbar zdialog__footer zdialog__footnote'); // No I18N

          ele.find('.zdialog__actiongroup, .zresizable__handle').remove(); // No I18N

          ele.find('.zbutton').off(eSuf + ' .zbutton').removeClass('zbutton zbutton--primary is-disabled'); // No I18N
        } else {
          ele.removeAttr('role aria-modal aria-expanded'); // No I18N

          ele[0].innerHTML = content[0].innerHTML;
        }

        this.element = this._footer = this._titleBar = this._content = undefined;
        this._useParent = true;
      }
    }, {
      key: "name",
      get: function get() {
        return "zdialog";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          buttonsAlignment: 'right',
          // No I18N
          closeButton: true,
          // No I18N
          closeOnEscKey: true,
          // No I18N
          closeSVGIconId: null,
          // No I18N
          closeButtonLabel: null,
          // No I18N
          closeOnOverlayClick: false,
          // No I18N
          content: null,
          // No I18N
          draggable: true,
          // No I18N
          height: null,
          // No I18N
          isContentHTMLEncoded: false,
          // No I18N
          isFooterHTMLEncoded: false,
          // No I18N
          isTitleHTMLEncoded: false,
          // No I18N
          overlayClassName: '',
          // No I18N
          maximizable: false,
          // No I18N
          maximizeIconClass: null,
          // No I18N
          maximizeButtonLabel: null,
          // No I18N
          maximizeRestoreIconClass: null,
          // No I18N
          maximizeRestoreButtonLabel: null,
          // No I18N
          maximizeRestoreSVGIconId: null,
          // No I18N
          maximizeSVGIconId: null,
          // No I18N
          minimizable: false,
          // No I18N
          minimizeIconClass: null,
          // No I18N
          minimizeButtonLabel: null,
          // No I18N
          minimizeRestoreIconClass: null,
          // No I18N
          minimizeRestoreButtonLabel: null,
          // No I18N
          minimizeRestoreSVGIconId: null,
          // No I18N
          minimizeSVGIconId: null,
          // No I18N
          position: 'center',
          // No I18N
          restoreIconClass: null,
          // No I18N
          restoreSVGIconId: null,
          // No I18N
          title: null,
          // No I18N
          type: 'modal',
          // No I18N
          autoOpen: false,
          // No I18N
          width: null,
          // No I18N
          defaultActionButton: '.zbutton--primary',
          // No I18N
          excludeFocus: null,
          // No I18N
          handleFocusNavigation: true,
          // No I18N
          submitOnEnter: false // No I18N

        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          closeIconClassName: null,
          // No I18N
          maximizeIconClassName: null,
          // No I18N
          minimizeIconClassName: null,
          // No I18N
          minimizeRestoreIconClassName: null,
          // No I18N
          maximizeRestoreIconClassName: null,
          // No I18N
          restoreIconClassName: null,
          // No I18N
          animation: false,
          // No I18N
          buttons: null,
          // No I18N
          footer: '',
          // No I18N
          resizable: {},
          // No I18N
          labels: {
            // No I18N
            minimize: 'Minimize',
            // No I18N
            maximize: 'Maximize',
            // No I18N
            minimizeRestore: 'Restore',
            // No I18N
            maximizeRestore: 'Restore',
            // No I18N
            close: 'Close' // No I18N

          },
          commandBar: {}
        };
      }
    }, {
      key: "_ALIGNMENTS",
      get: function get() {
        return {
          left: 'zdialogfooter--invert',
          // No I18N
          right: '',
          // No I18N
          center: 'zh-center' // No I18N

        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['drag', 'dragstart', 'dragend', 'resize', 'resizestart', 'resizeend', 'minimize', 'maximize', 'close', 'open', 'beforeclose', 'beforeopen', 'restore', 'actionbuttonclick']; // No I18N
      }
    }]);

    return ZDialog;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZDialog', ZDialog);

  (function (ZC) {
    var template = ZC.zdialog.Templates,
        button = ZC.createButton;

    template.container = function (data) {
      return ZT.html(_templateObject35(), data.text, data.id, data.role, data.className, data.children && template.children(data));
    };

    template.children = function (data) {
      return ZT.html(_templateObject36(), data.titleEle || data.title && ZT.html(_templateObject37(), ZT.customHTML(data.title)), data.titleBarButtons && ZT.html(_templateObject38(), data.titleBarButtons.map(function (value) {
        return button(value);
      })), data.contentEle || ZT.html(_templateObject39(), data.content), data.actionBar || data.buttons && ZT.html(_templateObject40(), data.alignClassName, data.cols && template.commandBarCol(data.cols), data.commands && data.commands.map(function (value) {
        return button(value);
      })), data.footerEle || data.footer && ZT.html(_templateObject41(), ZT.customHTML(data.footer)));
    };

    template.commandBarCol = function (data) {
      return ZT.html(_templateObject42(), data.left && ZT.html(_templateObject43(), data.cname, data.left.className || '', data.left.buttons.map(function (value) {
        return button(value);
      })), data.center && ZT.html(_templateObject44(), data.cname, data.center.className || '', data.center.buttons.map(function (value) {
        return button(value);
      })), data.right && ZT.html(_templateObject45(), data.cname, data.right.className || '', data.right.buttons.map(function (value) {
        return button(value);
      })));
    };
  })(ZComponents);

  var ZSlider =
  /*#__PURE__*/
  function (_ZC$CoreComponent6) {
    _inherits(ZSlider, _ZC$CoreComponent6);

    function ZSlider() {
      _classCallCheck(this, ZSlider);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZSlider).apply(this, arguments));
    }

    _createClass(ZSlider, [{
      key: "_init",
      value: function _init(element, options) {
        this._frominit = true;
        ['min', 'max', 'step', 'value', 'title', 'tabIndex'].forEach(function (attr) {
          // No I18N
          var value = element[0][attr];

          if (value || value === 0) {
            options[attr] = value;
          }
        });
        /* Property check */

        if (element[0].disabled) {
          options.disabled = true;
        }

        this._cacheMeasurements();

        this._buildData();
      }
    }, {
      key: "_buildData",
      value: function _buildData() {
        // No I18N
        var options = this._opts;
        var data = this._data;
        data.rangeLabels = undefined;
        this.vertical = options.orientation === 'vertical'; // No I18N

        var _isFixed = options.valuesType === 'fixed'; // No I18N


        this._tip = options.showTooltip !== 'never' && !_isFixed; // No I18N

        this._isRange = options.valuesType === 'range'; // No I18N

        this._hasRangeGroups = this._isRange && options.rangeGroups.groups.length;
        options.locale = options.locale || ZC.locale;
        this._ticks = options.showTicks || _isFixed;
        data.ticksList = [];
        data.labels = [];
        this._isFixed = _isFixed;

        if (_isFixed) {
          this._setFixedValues();
        }

        this._validateProperty();

        if (!this.isCE) {
          this.element.addClass('zh-dnone'); // No I18N

          data.style = this.element.attr('style'); // No I18N

          data.title = this._opts.title;
        }

        data.thumbs = [this._setThumb()];
        this._ticks && this._handleTicks();
        this._hasRangeGroups && this._setRangeLabels();
        this._tip && this._setTooltip();

        this._setSelectedLimit();
      }
    }, {
      key: "_getFromLocale",
      value: function _getFromLocale(prop, currency) {
        var localeInfo = ZC.localeInfo;

        if (localeInfo) {
          var locale = this._opts.locale || ZC.locale;
          localeInfo = localeInfo[locale][currency ? 'currency' : 'numberFormat']; // No I18N

          return localeInfo[prop] || '';
        }
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender() {
        if (!this._reStoreRef) {
          this._setDim(this.vertical ? 'height' : 'width'); // No I18N


          this._showParent();

          this._storeRef.apply(this, arguments);

          this._hideParent();
        }
      }
    }, {
      key: "_setDim",
      value: function _setDim(param) {
        var dimension = this._opts[param] || !this._useParent && this.element[0].style[param];

        if (dimension) {
          this.container[0].style[param] = isNaN(dimension) ? dimension : dimension + 'px'; // No I18N
        }
      }
    }, {
      key: "_storeRef",
      value: function _storeRef(element) {
        element = this.container;
        this._shadowTrack = element.find('.zslider__shadowtrack'); // No I18N

        this._innerSlider = element.find('.zslider__track'); // No I18N

        this._range = this._innerSlider.find('.zslider__selection'); // No I18N

        this._setClassName();

        this._setDimensions();

        this.container.find('.zslider__thumb').removeAttr('style'); // No I18N

        this._opts.disabled && this._disable(true, false); // let childselector = '.' + this.vertical ? "zslider__text" : "zslider__rangelabel";  // No I18N

        /* if (this.vertical) {For range Label Htmls
            //let labelStyle = "max-" + this.innerDim + ":" + (this.sliderDim[this.outerDim] * (curPer - lastPer) / 100) + "px"; //No I18N
        }
        */

        this._tip && this._handleTip();

        this._setHandlePosition();

        this._ticks && this._setTicksPosition();
        this._ticksLabel && this._setLabelsPosition();
        this._hasRangeGroups && this._setRangeLabelsPosition();

        this._setCurrentValues();

        this._handleSelectedLimit();
      }
    }, {
      key: "_setClassName",
      value: function _setClassName() {
        var options = this._opts;
        var className = 'zslider ' + (options.className || options.zclassName || ''); // No I18N

        if (options.rtl) {
          className += ' zh-rtl'; // No I18N
        }

        if (options.disabled) {
          className += ' is-disabled'; // No I18N
        }

        if (this.vertical) {
          className += ' zslider--vertical'; // No I18N
        }

        this.container.attr('class', className); // No I18N
      }
    }, {
      key: "_setThumb",
      value: function _setThumb() {
        var o = this._opts,
            iconHTML = '',
            tabIndex,
            iconClass = '',
            // No I18N
        thumbIconClassName = o.thumbIconClassName;

        if (o.disabled) {
          iconClass = ' is-disabled'; // No I18N
        } else {
          tabIndex = o.tabIndex || 0;
        }

        if (o.thumbSVGIconId) {
          var thumbIconInfo = ZC._getIconInfo(thumbIconClassName, o.thumbSVGIconId);
        } else if (thumbIconClassName) {
          iconClass += thumbIconClassName;
        } else if (o.thumbIconStyle === 'pointer') {
          // No I18N
          iconClass += ' zslider__pointerthumb '; // No I18N
          // Here RTL is not considered as it is handled in CSS.

          var thumbDir = this._getRTLBasedDir(this._getCorrectDir(o.ticks.position));

          if ((this._opts.rtl ? /^(right|top)$/ : /^(left|top)$/).test(thumbDir)) {
            // No I18N
            iconClass += ' zh-inverted'; // No I18N
          }

          var width = 21,
              height = 32;

          if (/^(right|left)$/.test(thumbDir)) {
            width = 32;
            height = 21;
          }

          iconHTML = '<svg class="zslider__pointerthumbsvg" viewBox="0 0 ' + width + ' ' + height + '" width="' + width + '" height="' + height + '">' + this['_pointer' + thumbDir[0].toUpperCase() + thumbDir.substr(1)]() + '</svg>'; // No I18N
        } else {
          iconClass += ' zslider__circlethumb'; // No I18N
        }

        return {
          iconClass: iconClass,
          tabIndex: tabIndex,
          iconHTML: iconHTML
        };
      }
    }, {
      key: "_getCorrectDir",
      value: function _getCorrectDir(dir) {
        if (dir === 'left' || dir === 'top') {
          // No I18N
          dir = this.vertical ? 'left' : 'top'; // No I18N
        } else {
          dir = this.vertical ? 'right' : 'bottom'; // No I18N
        }

        return dir;
      }
    }, {
      key: "_setDimensions",
      value: function _setDimensions() {
        this._handles = this.container.find('.zslider__thumb').toArray(); // No I18N

        var innerDim = 'width',
            // No I18N
        outerDim = 'outerWidth',
            // No I18N
        marginDir = this._getRTLBasedDir('left'),
            // No I18N
        oppOuterDim = 'outerHeight',
            // No I18N
        oppMargin = 'top'; // No I18N


        if (this.vertical) {
          innerDim = 'height'; // No I18N

          outerDim = 'outerHeight'; // No I18N

          marginDir = 'bottom'; // No I18N
          // used only in this func

          oppOuterDim = 'outerWidth'; // No I18N

          oppMargin = 'left'; // No I18N
        }

        var _ticksLayout = this._ticksLayout;

        if (_ticksLayout && _ticksLayout.length) {
          var css = {};
          css['margin-' + this.marginDir] = css[this.marginDir] = 'auto'; // No I18N

          _ticksLayout.children().css(css);
        }

        this.innerDim = innerDim;
        this.outerDim = outerDim;
        this.marginDir = marginDir; // used only in this func

        this.oppOuterDim = oppOuterDim;
        this.oppMargin = oppMargin;
        var handle = $(this._handles[0]),
            _innerSlider = this._innerSlider;
        this.sliderDim = {
          height: _innerSlider.height(),
          width: _innerSlider.width(),
          outerHeight: _innerSlider.outerHeight(),
          outerWidth: _innerSlider.outerWidth()
        };
        this.handleDim = {
          outerHeight: handle.outerHeight(),
          outerWidth: handle.outerWidth()
        };
      }
    }, {
      key: "_setHandlePosition",
      value: function _setHandlePosition() {
        var innersliderOffset = this._innerSlider.position();

        var trackTop = parseInt(innersliderOffset[this.oppMargin]);
        var trackHalfHt = this.sliderDim[this.oppOuterDim] / 2;
        var handleHalfHt = this.handleDim[this.oppOuterDim] / 2;
        var shadowTrackHalfHt = this._shadowTrack[this.oppOuterDim]() / 2;
        $(this._handles).css(this.oppMargin, trackTop - (handleHalfHt - trackHalfHt) + 'px') // No I18N
        .css('margin-' + this.marginDir, -this.handleDim[this.outerDim] / 2 + 'px'); // No I18N

        this._shadowTrack.css(this.oppMargin, trackTop - (shadowTrackHalfHt - trackHalfHt) + 'px'); // No I18N


        this._tip && this._updateTip();
      }
    }, {
      key: "_setCurrentValues",
      value: function _setCurrentValues() {
        this.setValue(this._opts.value);

        this._updateLayout();
      }
    }, {
      key: "_setSelectedLimit",
      value: function _setSelectedLimit() {
        var o = this._opts,
            notAllowedRanges = [];
        this._data.selectedTrack = false;

        if (o.minValueAllowed !== o.min) {
          this._data.selectedTrack = true;
        }

        if (o.maxValueAllowed !== o.max) {
          notAllowedRanges.push('1');
        }

        this._data.notAllowedRanges = notAllowedRanges;
      }
    }, {
      key: "_handleSelectedLimit",
      value: function _handleSelectedLimit() {
        var o = this._opts;
        this.container.find('.zslider__labels .is-disabled, .zslider__scale .is-disabled').removeClass('is-disabled'); // No I18N

        if (this._data.selectedTrack) {
          this._setLimitPosition(o.min, o.minValueAllowed, 'zslider__selected'); // No I18N

        }

        if (o.maxValueAllowed !== o.max) {
          this._setLimitPosition(o.maxValueAllowed, o.max, 'zslider__notallowedrange'); // No I18N

        }
      }
    }, {
      key: "_setLimitPosition",
      value: function _setLimitPosition(min, max, className) {
        var _opts = this._opts;
        var minPercent = parseFloat(min) === _opts.min ? 0 : this._getPercent(min);
        var maxPercent = parseFloat(max) === _opts.max ? 100 : this._getPercent(max);
        var track = $('.zslider__track .' + className, this.container),
            // No I18N
        style = track.attr('style') + ';'; // No I18N

        track.attr('style', style + this.marginDir + ':' + minPercent + '%;' + this.innerDim + ':' + (maxPercent - minPercent) + '%'); // No I18N
        // Fading ticks & labels

        var nodes = this.container.find('.zslider__tick, .zslider__label'); // No I18N

        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          var val = +node.getAttribute('data-val'); // No I18N

          if (val < min || val > max || val === min && min !== _opts.min || val === max && max !== _opts.max) {
            continue;
          }

          $(node).addClass('is-disabled'); // No I18N
        }
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        var _namespace = '.' + this.name,
            // No I18N
        thumbClass = '.zslider__thumb'; // No I18N


        this.container.on('mousedown' + _namespace + ' touchstart' + _namespace, '.zslider__shadowtrack,.zslider__track,' + thumbClass + ',.zslider__tick,.zslider__label', this._onMouseDown.bind(this)) // No I18N
        .on('keydown' + _namespace, thumbClass, this._onSlide.bind(this)) // No I18N
        .on('keyup' + _namespace, thumbClass, this._onSlideEnd.bind(this)) // No I18N
        .on('mouseup' + _namespace, this._onSlideEnd.bind(this)) // No I18N
        .on('mouseenter' + _namespace, thumbClass, this._onThumbEnter.bind(this)) // No I18N
        .on('mouseleave' + _namespace, thumbClass, this._onThumbLeave.bind(this)) // No I18N
        .on('focusin' + _namespace, this._onFocus.bind(this)).on('focusout' + _namespace, this._onFocusout.bind(this));

        this._setCurrentValues();

        this._frominit = false;

        this._trigger('init'); // No I18N

      }
    }, {
      key: "_onFocus",
      value: function _onFocus(origEvent) {
        this.container.addClass('has-focus' + (this._mouseActive ? '' : ' on-tabfocus')); // No I18N

        this._trigger('focus', origEvent); // No I18N

      }
    }, {
      key: "_onFocusout",
      value: function _onFocusout(origEvent) {
        var _this18 = this;

        clearTimeout(this.blurtimer);
        this.blurtimer = setTimeout(function () {
          if (!$(_this18._handles).is(':focus') && !$(document.activeElement).closest('.zslider').length) {
            // No I18N
            _this18.container.removeClass('is-active has-focus on-tabfocus'); // No I18N


            _this18._activeHandle && _this18._activeHandle.removeClass('is-active');
            _this18._mouseActive = _this18._animate = false;

            _this18._trigger('blur', origEvent); // No I18N

          }
        }, 1);
      }
    }, {
      key: "_onThumbEnter",
      value: function _onThumbEnter(origEvent) {
        if (this._opts.disabled) {
          var target = $(origEvent.target).closest('.zslider__thumb'); // No I18N

          target.addClass('on-mouseover'); // No I18N

          this._tip && this._showTip(origEvent);
        }
      }
    }, {
      key: "_onThumbLeave",
      value: function _onThumbLeave(origEvent) {
        if (this._opts.disabled) {
          var target = $(origEvent.target).closest('.zslider__thumb'); // No I18N

          target.removeClass('on-mouseover'); // No I18N

          this._tip && !this._dragStarted && !this._dragSelectionStarted && this._hideTip();
        }
      }
    }, {
      key: "_keyPress",
      value: function _keyPress(origEvent) {
        var keyCode = origEvent.keyCode,
            keyCodes = ZC.keyCode,
            _opts = this._opts,
            value = _opts.value,
            invert = this._opts.rtl && !this.vertical;

        if ([keyCodes.RIGHT, keyCodes.UP, keyCodes.PAGE_UP].indexOf(keyCode) > -1) {
          value = this._increase(!invert);
        } else if ([keyCodes.LEFT, keyCodes.DOWN, keyCodes.PAGE_DOWN].indexOf(keyCode) > -1) {
          value = this._increase(invert);
        } else if (keyCode === keyCodes.HOME) {
          value = _opts.minValueAllowed;
        } else if (keyCode === keyCodes.END) {
          value = _opts.maxValueAllowed;
        } else {
          return;
        }

        this._tip && this._showTip(origEvent);
        origEvent.preventDefault();
        return value;
      }
    }, {
      key: "_getActiveHandle",
      value: function _getActiveHandle(origEvent) {
        return this._handles[0];
      }
    }, {
      key: "_onMouseDown",
      value: function _onMouseDown(origEvent) {
        var activeClass = 'is-active'; // No I18N

        origEvent.type = 'mousedown'; // No I18N

        if (!origEvent.button && !this._opts.disabled) {
          this._mouseActive = true;
          this.container.removeClass('on-tabfocus').addClass(activeClass); // No I18N

          var _activeHandle = this._activeHandle;
          _activeHandle && _activeHandle.removeClass(activeClass);
          _activeHandle = $(this._getActiveHandle(origEvent));

          _activeHandle.addClass(activeClass);

          if (_activeHandle.length) {
            _activeHandle[0][this._opts.blurOnMouseRelease ? 'blur' : 'focus'](); // No I18N

          }

          this._activeHandle = _activeHandle;
          this.container.addClass(activeClass);

          if (!$(origEvent.target).closest('.zslider__thumb').length && !this._dragSelectionStarted) {
            // No I18N
            this._onSlide(origEvent);
          }

          this._bindDocumentEvent(origEvent);
        }
      }
    }, {
      key: "_bindDocumentEvent",
      value: function _bindDocumentEvent(origEvent) {
        var _this19 = this;

        var _namespace = '.' + this.name;

        ZC.$document.off(_namespace).on('mousemove' + _namespace + ' touchmove' + _namespace, function (origEvent) {
          origEvent.type = 'mousemove'; // No I18N

          _this19._onSlide(origEvent);
        }).on('mouseup' + _namespace + ' touchend' + _namespace + ' touchcancel' + _namespace, function (origEvent) {
          origEvent.type = 'mouseup'; // No I18N

          _this19._onSlideEnd(origEvent);
        });
        origEvent.preventDefault();
      }
    }, {
      key: "_onSlide",
      value: function _onSlide(origEvent) {
        if (!this._opts.disabled) {
          var value = this._getValueFromEvent(origEvent);

          origEvent.type !== 'keydown' && this._tip && this._showTip(origEvent); // No I18N

          if (this._isNotNull(value)) {
            this._animate = origEvent.type !== 'mousemove'; // No I18N

            if (!this._dragStarted) {
              this._storeInitialValue();

              this._dragStarted = true;

              this._trigger('slidestart', origEvent); // No I18N

            }

            this._setValue(value, origEvent);

            this._trigger('slide', origEvent); // No I18N


            origEvent.preventDefault();
          }
        }
      }
    }, {
      key: "_onSlideEnd",
      value: function _onSlideEnd(origEvent) {
        if (!this._opts.disabled) {
          ZC.$document.off('.' + this.name);

          if (this._dragStarted) {
            this._trigger('slideend', origEvent); // No I18N


            if (this._isValueChanged()) {
              this._animate = true;
              /* ONCHANGE */

              this._updateLayout(origEvent);
            }
          }

          this._tip && (!this._activeHandle || !this._activeHandle.hasClass('on-mouseover')) && this._hideTip(); // No I18N

          this.container.removeClass('is-active'); // No I18N

          this._animate = this._mouseActive = this._dragStarted = false;
        }
      }
    }, {
      key: "_storeInitialValue",
      value: function _storeInitialValue() {
        this._startValue = this.getValue();
      }
    }, {
      key: "_isValueChanged",
      value: function _isValueChanged() {
        return this._startValue !== this.getValue();
      }
    }, {
      key: "_getTipText",
      value: function _getTipText() {
        var o = this._opts;
        return this._getLabel(o.tooltip.text, o.value, o.tooltip.isHTMLEncoded);
      }
    }, {
      key: "_getLabel",
      value: function _getLabel(template, label, encode) {
        if (this._isRange && this._formatLabel) {
          label = this._formatLabel(label);
        }

        if (typeof template === 'string' && template.trim() !== '') {
          // No I18N
          label = template.replace(/#value#/gi, label); // No I18N
        }

        return encode ? label : ZC.encodeHTML(label);
      }
    }, {
      key: "_getValueFromEvent",
      value: function _getValueFromEvent(origEvent) {
        var target = $(origEvent.target);

        if (origEvent.type === 'mousedown' &&
        /* target.hasClass("zslider__tick") || */
        target.hasClass('zslider__label')) {
          // No I18N
          if (target.hasClass('is-disabled')) {
            return;
          }

          return this._getInnerVal(target.attr('data-val')); // No I18N
        } else if (origEvent.type === 'keydown') {
          // No I18N
          return this._keyPress(origEvent);
        }

        var sliderLength = this.sliderDim[this.innerDim];
        var handleLength = this.handleDim[this.outerDim];
        var totalpixel = sliderLength - handleLength;
        var offset;
        var cursorPercent;

        var slideroffset = this._innerSlider.offset();

        var getCustomVal;
        var _opts = this._opts;

        if (typeof _opts.getCustomValue === 'function') {
          // No I18N
          getCustomVal = _opts.getCustomValue;
          handleLength = 0;
        }

        var coords = origEvent.touches && origEvent.touches[0] || origEvent;

        if (this.vertical) {
          offset = coords.pageY - (slideroffset.top + handleLength / 2);
          cursorPercent = 1 - offset / totalpixel;
        } else {
          offset = coords.pageX - (slideroffset.left + handleLength / 2
          /* + 1 */

          /* border width */
          );
          cursorPercent = offset / totalpixel;

          if (_opts.rtl) {
            cursorPercent = 1 - cursorPercent;
          }
        }

        if (cursorPercent < 0) {
          cursorPercent = 0;
        } else if (cursorPercent > 1) {
          cursorPercent = 1;
        }

        if (getCustomVal) {
          return getCustomVal(cursorPercent * 100, _opts.min, _opts.max, this._handles.indexOf(this._activeHandle[0]));
        }

        var value = this._trimDecimal(_opts.min, _opts.step, _opts.min + cursorPercent * (_opts.max - _opts.min));

        if (_opts.snapToTicks && this._dragStarted && this._ticksLayout) {
          value = this._trimForSnap(value, offset + handleLength / 2);
        }

        return value;
      }
    }, {
      key: "_trimValue",
      value: function _trimValue(value) {
        var o = this._opts;
        var step = o.step;
        var mod = (parseFloat(value) - o.min) % step;

        if (mod !== 0) {
          var adjustedVal = parseFloat(value) - mod;

          if (Math.abs(mod) * 2 > step) {
            adjustedVal = adjustedVal + (mod > 0 ? step : -step);
          }

          value = adjustedVal;
        }

        return this._trimDecimal(o.min, step, value);
      } // Function to round off the value incase of decimal value as in some case, addition of decimal numbers leads to unexpected result : Ex: 13.3 + 13.3 + 13.3 gives 39.9000000000006.

    }, {
      key: "_trimDecimal",
      value: function _trimDecimal(min, step, value) {
        var minDecimal = String(min).split('.')[1] || ''; // No I18N

        var stepDecimal = String(step).split('.')[1] || ''; // No I18N

        return +(+value).toFixed(Math.max(minDecimal.length, stepDecimal.length));
      }
    }, {
      key: "_setValue",
      value: function _setValue(value, origEvent) {
        // if( value !== undefined ){
        var _opts = this._opts;
        _opts.value = this._getActualVal(this._getCorrectedValue(value, _opts.minValueAllowed, _opts.maxValueAllowed));

        if (this._prevValue !== _opts.value) {
          /* ONCHANGE */
          this._updateLayout(origEvent);
        }

        this._prevValue = _opts.value; // this.element[0]._addedByComponent = true;
        // this.isCE && this.element.attr("value", this._opts.value); //No I18N
        // }
      }
    }, {
      key: "_getCorrectedValue",
      value: function _getCorrectedValue(value, min, max) {
        value = +value;
        var o = this._opts;

        if (o.valuesType === 'fixed') {
          // No I18N
          min = o.min;
          max = o.max;
        } else {
          if (min < o.min) {
            min = o.min;
          }

          if (max > o.max) {
            max = o.max;
          }
        }
        /* Force edges implementation */


        if (o.stepBehavior === 'default' && (value <= min || value >= max || isNaN(value))) {
          // No I18N
          if (value < min || isNaN(value)) {
            value = min;
          } else if (value > max) {
            value = max;
          }
        } else {
          value = this._trimValue(value);

          if (value < min || isNaN(value)) {
            //* **** BEHAVIOR This implementation is temporarily commented as ionRangeSlider does"nt take it to account when edge is reached
            var mod = (min - o.min) % o.step || o.step;
            value = min + o.step - mod;
          } else if (value > max) {
            value = max - (max - o.min) % o.step;
          }

          value = this._trimDecimal(o.min, o.step, value);
        }

        return value;
      }
    }, {
      key: "_getInnerVal",
      value: function _getInnerVal(value) {
        return this._isFixed ? this._values.indexOf(String(value)) : value;
      }
    }, {
      key: "_getActualVal",
      value: function _getActualVal(value) {
        // Value is given as number
        return this._isFixed ? this._values[value] : value;
      }
    }, {
      key: "_updateLayout",
      value: function _updateLayout(origEvent) {
        var _this20 = this;

        var handleObj = {};
        var o = this._opts;

        var valPer = this._getPercent(o.value);

        handleObj[this.marginDir] = valPer + '%'; // No I18N

        var rangeObj = {};
        var left = 0;
        var width = valPer;
        var selectionStartValue = o.selectionStartValue;
        var progressFrom = parseFloat(selectionStartValue);

        if (!isNaN(progressFrom) && progressFrom > o.min && progressFrom <= o.max) {
          left = progressFrom === o.max ? 100 : this._getPercent(selectionStartValue);

          if (selectionStartValue >= o.value) {
            /* swapping */
            width = [left, left = width][0];
          }
        }

        rangeObj[this.marginDir] = left + '%'; // No I18N

        rangeObj[this.innerDim] = width - left + '%'; // No I18N

        var value = this._getInnerVal(o.value);

        this._handleAnimation($(this._handles[0]), handleObj, value, o.value);

        this._handleAnimation(this._range, rangeObj, false, false, function () {
          _this20._animate = false; // Change Should be called

          if (!_this20._frominit && (!origEvent || !/(keydown|mousedown|mousemove)/.test(origEvent.type))) {
            _this20._trigger('change', origEvent); // No I18N

          }
        });

        this._tip && this._updateTip(handleObj);
      }
    }, {
      key: "_handleAnimation",
      value: function _handleAnimation(element, object, value, title, callback) {
        if (value !== false) {
          element.attr({
            'data-val': value,
            // No I18N
            'aria-valuenow': value,
            // No I18N
            'aria-valuetext': title // No I18N

          });
        }

        this.container[this._animate ? 'addClass' : 'removeClass']('zslider--transition'); // No I18N

        element.css(object);
        callback && callback();
      }
    }, {
      key: "_getPercent",
      value: function _getPercent(value) {
        var opts = this._opts,
            getCustomPosition = opts.getCustomPosition;
        value = this._getInnerVal(value);

        if (getCustomPosition) {
          return getCustomPosition(value, opts.min, opts.max);
        }

        var percent = (parseFloat(value) - opts.min) / (opts.max - opts.min);
        var sliderLength = this.sliderDim[this.innerDim];
        var handleLength = this.handleDim[this.outerDim]; // Handle should not exceed the track.Consider slider is 100px length and min=0, max=100, handlewidth =10. If value =100, it is 100% but the handle exceeds the track. Handle left must be 90% for 100% value.
        // For value = 0 ===> 0 * x = 0%
        // For value = 100 ===>  100 * x = 90% => x = 90/100 = 9/10

        percent = (percent * (1 - handleLength / sliderLength) + handleLength * 0.5 / sliderLength) * 100;
        return percent;
      }
    }, {
      key: "_increase",
      value: function _increase() {
        var increase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var value = arguments.length > 1 ? arguments[1] : undefined;
        var step = arguments.length > 2 ? arguments[2] : undefined;
        var options = this._opts;
        step = step || options.step;
        value = this._getInnerVal(value || options.value);
        var newValue = step - (value - options.min) % step;
        return increase ? value + newValue : value - newValue;
      }
    }, {
      key: "_trigger",
      value: function _trigger(customEvent, origEvent, data) {
        data = data || {};
        data.slider = this.getElement();
        data.value = this.getValue();
        return this._dispatchEvent(customEvent, origEvent, data, undefined, !!origEvent);
      }
    }, {
      key: "_restoreMeasurements",
      value: function _restoreMeasurements() {
        var _this21 = this;

        this._MEASUREMENTS.forEach(function (opt) {
          _this21._opts[opt] = _this21.actualProps[opt];
        });
      }
    }, {
      key: "_parseArray",
      value: function _parseArray(value) {
        if (typeof value === 'string') {
          // No I18N
          try {
            value = JSON.parse(value);
          } catch (e) {}
        }

        return value;
      }
    }, {
      key: "increase",
      value: function increase(origEvent) {
        this._setValue(this._increase(), origEvent);
      }
    }, {
      key: "decrease",
      value: function decrease(origEvent) {
        this._setValue(this._increase(false), origEvent);
      }
    }, {
      key: "setValue",
      value: function setValue(value, origEvent) {
        if (this._isNotNull(value)) {
          this._setValue(this._getInnerVal(value), origEvent);
        }
      }
    }, {
      key: "getValue",
      value: function getValue() {
        return this._opts.value;
      }
    }, {
      key: "_validateProperty",
      value: function _validateProperty() {
        var o = this._opts,
            step = o.step,
            min = o.min,
            max = o.max,
            minValueAllowed = o.minValueAllowed,
            maxValueAllowed = o.maxValueAllowed,
            value = o.value;

        if (o.valuesType === 'fixed') {
          // No I18N
          step = 1;
          min = minValueAllowed = 0;
          max = maxValueAllowed = o.values.length - 1;

          if (this._getInnerVal(value) < 0) {
            value = this._getInnerVal(0);
          }
        } else {
          step = parseFloat(step);
          min = parseFloat(min);
          max = parseFloat(max);
          value = parseFloat(value);
          minValueAllowed = parseFloat(minValueAllowed);
          maxValueAllowed = parseFloat(maxValueAllowed);

          if (isNaN(step) || step < 1) {
            step = 1;
          }

          min = isNaN(min) ? 0 : min;
          max = isNaN(max) ? 100 : max;

          if (max <= min) {
            max = min + step;
          }

          if (max - min < step) {
            step = max - min;
          }
          /* Validating min and max allowed value */


          if (isNaN(minValueAllowed) || minValueAllowed < min || max - minValueAllowed < step) {
            minValueAllowed = min;
          }

          if (isNaN(maxValueAllowed) || maxValueAllowed > max || maxValueAllowed < minValueAllowed || maxValueAllowed - minValueAllowed < step) {
            maxValueAllowed = max;
          }

          if (isNaN(value) || value < minValueAllowed) {
            value = minValueAllowed;
          } else if (value > maxValueAllowed) {
            value = maxValueAllowed;
          }
        }

        o.step = step;
        o.min = min;
        o.max = max;
        o.minValueAllowed = minValueAllowed;
        o.maxValueAllowed = maxValueAllowed;
        o.value = value;
      }
    }, {
      key: "_cacheMeasurements",
      value: function _cacheMeasurements() {
        var _this22 = this;

        this.actualProps = {};

        this._MEASUREMENTS.forEach(function (opt) {
          _this22.actualProps[opt] = _this22._opts[opt];
        });
      }
    }, {
      key: "_showParent",
      value: function _showParent() {
        if (document.body.contains(this.container[0]) && this.container.is(':hidden')) {
          // No I18N
          var i = 1;
          this._hiddenParents = [];
          var parent = this.container;

          while (i && parent && !parent.is('body')) {
            // No I18N
            if (parent.css('display') === 'none') {
              // No I18N
              this._hiddenParents.push(parent);

              parent.addClass('zslider__parent'); // No I18N

              i = parent.is(':hidden'); // No I18N
            }

            parent = parent.parent();
          }
        }
      }
    }, {
      key: "_hideParent",
      value: function _hideParent() {
        if (this._hiddenParents) {
          this._hiddenParents.forEach(function (parent) {
            parent.removeClass('zslider__parent'); // No I18N
          });

          this._hiddenParents = [];
        }
      }
    }, {
      key: "refresh",
      value: function refresh() {
        this._reInit = true;

        this._renderAttrChange();
      }
    }, {
      key: "_setFixedValues",
      value: function _setFixedValues() {
        var _this23 = this;

        this._values = [];
        this._labels = [];

        this._opts.values.forEach(function (obj) {
          var value = obj,
              label = obj;

          if (_typeof(obj) === 'object') {
            // No I18N
            value = obj.value;
            label = obj.label || value;
          }

          if (value || value === 0) {
            _this23._values.push(String(value));

            _this23._labels.push(label);
          }
        });
      }
    }, {
      key: "_disable",
      value: function _disable() {
        var _this24 = this;

        var disable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var resetTip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        this._opts.disabled = disable; // this._showHiddenParent();

        this._handles.forEach(function (handle) {
          _get(_getPrototypeOf(ZSlider.prototype), "_disable", _this24).call(_this24, disable, $(handle));
        });

        _get(_getPrototypeOf(ZSlider.prototype), "_disable", this).call(this, disable);

        var tabIndex = disable ? null : this._opts.tabIndex || 0;

        if (this._tip && !disable && resetTip) {
          this._resetTip();
        }

        $(this._handles).attr('tabIndex', tabIndex); // No I18N
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        // this._showHiddenParent();
        var o = this._opts,
            canRender = false;

        switch (optionName) {
          case 'min': // No I18N

          case 'max': // No I18N

          case 'minValueAllowed': // No I18N

          case 'maxValueAllowed': // No I18N

          case 'step':
            // No I18N
            this._restoreMeasurements();

            o[optionName] = value;

            this._cacheMeasurements();

            this._validateProperty();

            canRender = true;
            break;

          case 'selectionStartValue':
            // No I18N
            o[optionName] = value;

            this._updateLayout();

            break;

          case 'value':
            // No I18N
            this.setValue(value);
            break;

          case 'valuesType':
            // No I18N
            o[optionName] = value;

            if (value === 'range') {
              // No I18N
              o.ticksStep = this.actualProps.ticksStep;
            } else {
              this.actualProps.ticksStep = o.ticksStep;
            }

            canRender = true;
            break;

          case 'values':
            // No I18N
            if (Array.isArray(value)) {
              o[optionName] = value;
              canRender = true;
            }

            break;

          case 'showTooltip':
            // No I18N
            o[optionName] = value;
            this._tip = value !== 'never'; // No I18N

            this._resetTip();

            break;

          case 'tooltip':
            // No I18N
            if (this._handleObjUpdate(optionName, value)) {
              this._resetTip();
            }

            break;

          case 'rangeGroups': // No I18N

          case 'ticks': // No I18N

          case 'valueDisplayFormat':
            // No I18N
            this._reStoreRef = false;
            canRender = this._handleObjUpdate(optionName, value);
            break;

          case 'animation':
            // No I18N
            o[optionName] = value;
            break;

          case 'rtl': // No I18N

          case 'orientation': // No I18N

          case 'showTicks': // No I18N

          case 'locale': // No I18N

          case 'thumbIconStyle': // No I18N

          case 'thumbSVGIconId': // No I18N

          case 'thumbIconClassName':
            // No I18N
            this._reStoreRef = false;
            o[optionName] = value;

            if (optionName === 'width') {
              // No I18N
              this.container.width(value);
            } else if (optionName === 'orientation') {
              // No I18N
              o[optionName] = value; // this.vertical = (value === 'vertical'); // No I18N
              // this.container[this.vertical ? 'addClass' : 'removeClass']('zslider--vertical'); // No I18N

              $('.ztooltip, .ztooltip__pointer, .zslider__labels .zslider__label, .zslider__selected, .zslider__notallowedrange', this.container).removeAttr('style'); // No I18N

              this._range.removeAttr('style'); // No I18N


              $(this._handles).removeAttr('style'); // No I18N

              $(this._ticks).removeAttr('style'); // No I18N

              this._shadowTrack.css({
                left: 'auto',
                // No I18N
                top: 'auto' // No I18N

              });
            }

            canRender = true;
            break;
        }

        if (canRender) {
          this._reRender();
        } // this._resetParent();

      }
    }, {
      key: "_reRender",
      value: function _reRender() {
        this._values = this._labels = undefined;
        this._reInit = true;
      }
    }, {
      key: "_handleObjUpdate",
      value: function _handleObjUpdate(optionName, value) {
        var _this25 = this;

        var update;
        Object.keys(value).forEach(function (key) {
          _this25._opts[optionName][key] = value[key];
          update = true;
        });
        return update;
      }
    }, {
      key: "name",
      get: function get() {
        return "zslider";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          orientation: 'horizontal',
          // No I18N
          locale: null,
          thumbIconStyle: 'circle',
          // No I18N
          thumbIconClass: null,
          thumbSVGIconId: null,
          min: 0,
          max: 100,
          step: 1,
          valuesType: 'range',
          // No I18N
          value: 0,
          minValueAllowed: null,
          maxValueAllowed: null,
          values: [],
          showTooltip: 'never',
          // No I18N
          showTicks: false,
          snapToTicks: true,
          stepBehavior: 'w3',
          // No I18N
          selectionStartValue: null,
          blurOnMouseRelease: false,
          disabled: false
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          thumbIconClassName: null,
          tooltip: {
            position: 'top',
            // No I18N
            displayType: 'callout',
            // No I18N
            text: '#value#',
            // No I18N
            isHTMLEncoded: false
          },
          ticks: {
            splitBy: 'count',
            // No I18N
            count: 4,
            step: null,
            randomValues: null,
            position: 'bottom',
            // No I18N
            showLabels: true,
            showLabelsFor: null,
            labelPattern: '#value#',
            // No I18N
            customLabels: null,
            isLabelHTMLEncoded: false
          },
          valueDisplayFormat: {
            type: 'number',
            // No I18N
            currencyCode: null,
            prefix: null,
            suffix: null,
            decimalPlaces: null,
            thousandSeparator: false
          },
          rangeGroups: {
            groups: [],
            isLabelHTMLEncoded: false,
            labelPosition: 'top' // No I18N

          }
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['init', // No I18N
        'focus', // No I18N
        'blur', // No I18N
        'change', // No I18N
        'slidestart', // No I18N
        'slide', // No I18N
        'slideend' // No I18N
        ];
      }
    }, {
      key: "_MEASUREMENTS",
      get: function get() {
        return ['minValueAllowed', 'maxValueAllowed']; // No I18N
      }
    }]);

    return ZSlider;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZSlider', ZSlider);

  (function (ZC) {
    var template = ZC.zslider.Templates;

    template.container = function (data) {
      return ZT.html(_templateObject46(), data.children && template.children(data));
    };

    template.children = function (data) {
      var responseTemplate = ZT.html(_templateObject47(), data.shadowCSSStyle, data.showRangeLabelsInTop && template.rangeLabels(data), data.showTicksInTop && template.ticks(data), data.ranges && data.ranges.map(function (range) {
        return ZT.html(_templateObject48(), range.className, range.CSSStyle, range.text);
      }), data.selectionPosition, data.selectedTrack && ZT.html(_templateObject49()), data.notAllowedRanges.map(function (data) {
        return ZT.html(_templateObject50(), data);
      }), !data.showTicksInTop && template.ticks(data), !data.showRangeLabelsInTop && template.rangeLabels(data), data.thumbs.map(function (thumb) {
        return ZT.html(_templateObject51(), thumb.iconClass, data.disabled, data.orientation, data.min, data.min, thumb.tabIndex, data.min, data.min, data.min, ZT.customHTML(thumb.iconHTML));
      }), data.tooltip && template.tooltip(data.tooltip));
      return responseTemplate;
    };

    template.rangeLabels = function (data) {
      var returnTemplate = data.rangeLabels && ZT.html(_templateObject52(), data.rangeLabelsClass, data.rangeLabels.map(function (label) {
        return ZT.html(_templateObject53(), label.label);
      }));
      return returnTemplate;
    };

    template.ticks = function (data) {
      return data.ticksList.length && ZT.html(_templateObject54(), !data.showTicksInTop && ZT.html(_templateObject55(), data.ticksClass, data.ticksList.map(function (tick) {
        return ZT.html(_templateObject56(), tick.value);
      })), data.labels && ZT.html(_templateObject57(), data.labelsClass, data.labels.map(function (label) {
        return ZT.html(_templateObject58(), label.value, label.label);
      })), data.showTicksInTop && ZT.html(_templateObject59(), data.ticksClass, data.ticksList.map(function (tick) {
        return ZT.html(_templateObject60(), tick.value);
      })));
    };

    template.tooltip = function (data) {
      return ZT.html(_templateObject61(), data["class"], data.callout && ZT.html(_templateObject62(), data.pointerClass));
    };
  })(ZComponents);

  window.ZAlertBanner = ZC.AlertBanner = {
    show: function show(options) {
      if (typeof options === 'string') {
        // No I18N
        options = {
          message: options
        };
      }

      options.createdByShowMethod = true; // ZC.createAlertBanner(options);

      var alertbanner = ZC.createAlertBanner(options);

      if (options.isCE) {
        alertbanner[0].show();
      } else {
        ZC.alertbanner(alertbanner).show();
      }

      var id = $(alertbanner).attr('id'),
          eleID = id ? id + '-banner' : ZC.getID('zalertbanner', alertbanner); // No I18N

      $(alertbanner).attr('id', eleID); // No I18N

      return eleID;
    },
    hide: function hide(alertbanner, immediate) {
      $(alertbanner).toArray().forEach(function (alertbanner) {
        if (alertbanner.tagName === 'Z-ALERTBANNER') {
          // No I18N
          alertbanner[0].hide(immediate);
        } else {
          ZC.alertbanner(alertbanner).hide(immediate);
        }
      });
    }
  };

  var ZAlertBanner =
  /*#__PURE__*/
  function (_ZC$CoreComponent7) {
    _inherits(ZAlertBanner, _ZC$CoreComponent7);

    function ZAlertBanner() {
      _classCallCheck(this, ZAlertBanner);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZAlertBanner).apply(this, arguments));
    }

    _createClass(ZAlertBanner, [{
      key: "_init",
      value: function _init() {
        clearTimeout(this._autoHideTimer);
        var IEVerison = ZC.Browser.getIEVersion(),
            childNodes = this.element[0].childNodes;

        if (this.isCE && !this._opts.message && childNodes.length) {
          this._data.messageDOM = _toConsumableArray(childNodes);
        }

        this._data.isIE = IEVerison !== -1 && IEVerison < 10;

        this._validate();
      }
    }, {
      key: "_validate",
      value: function _validate(oldValue) {
        var options = this._opts,
            _data = this._data,
            margin = options.margin || {},
            methodName = '_getIcon',
            // No I18N
        type = options.type,
            delay = options.hideDelay,
            closeButton = options.closeButton;
        options.hideOnClick = closeButton ? false : options.hideOnClick;
        options.hideDelay = this._hideDelay = parseInt(/(undefined|null)/.test(delay) ? closeButton ? 0 : 5000 : delay);
        var pixel = options.display === 'inline' ? 0 : 10;

        if (typeof margin === 'number' || typeof margin === 'string') {
          // No I18N
          pixel = parseInt(margin);
          pixel = Number.isNaN(margin) ? 0 : margin;
          margin = {};
        }

        ['left', 'right', 'top', 'bottom'].forEach(function (dir) {
          // No I18N
          if (/(undefined|null)/.test(margin[dir])) {
            margin[dir] = pixel;
          }
        });
        options.margin = margin;
        _data.closeButton = false;

        if (closeButton) {
          _data.closeButton = ZC._getIconInfo(options.closeIconClass || options.closeIconClassName, options.closeSVGIconId, 'zc__svg--close zalertbanner__svg', 'zalertbanner__icon'); // No I18N

          _data.closeText = this._getI18NText('close'); // No I18N
        }

        _data.icon = options.icon;
        _data.type = type;
        _data.IconClassName = _data.IconClass = _data.SVGIconId = _data.SVGIconClassName = null; // No I18N

        if (options.icon) {
          if (type === 'custom') {
            methodName = '_customIcon'; // No I18N
          }

          var iconInfo = this[methodName](options, type);

          ZC._getIconInfo(iconInfo.iconClass, iconInfo.SVGIconId, 'zc__svg--' + type + ' zalertbanner__svg', ' zalertbanner__icon', _data); // No I18N

        }

        var message = options.message;

        if (message) {
          message = options.isMessageHTMLEncoded ? message : ZC.encodeHTML(message);
          _data.messageDOM = '';
        }

        if (!message && _data.messageDOM) {
          message = null;
        }

        _data.message = message;
      }
    }, {
      key: "_postRender",
      value: function _postRender() {
        this.container.attr('role', 'status').hide(); // No I18N

        if (this._opts.createdByShowMethod) {
          this._handleOpen();
        }
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender() {
        var _this26 = this;

        var options = this._opts,
            eventName = 'click.' + this.name; // No I18N

        options.closeButton && this.container.find('.zalertbanner__close').off(eventName).on(eventName, function (origEvent) {
          return _this26.hide(false, origEvent);
        }); // No I18N

        this._data.className = 'zalertbanner ' + (options.type === 'custom' ? '' : 'zalertbanner--' + options.type) + ' ' + (options.className || options.zclassName || '') + ' ' + (options.rtl ? 'zh-rtl' : ''); // No I18N
      }
    }, {
      key: "_setStyles",
      value: function _setStyles() {
        this.container.css({
          width: '',
          // No I18N
          display: '' // No I18N

        });
        /* FIXING WIDTH FOR INLINE BANNER, FIX FOR ANIMATION[] */

        var styleObj = this.container[0].style;

        if (this._opts.display === 'inline') {
          // No I18N
          styleObj.width = this.container.outerWidth() + 1 + 'px'; // No I18N
        } else {
          styleObj.position = (this._target || this.container.parent()).is('body') ? 'fixed' : 'absolute'; // No I18N
        }
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        var options = this._opts;
        var eventName = 'click.' + this.name; // No I18N

        options.hideOnClick && this.container.off(eventName).on(eventName, this.hide.bind(this));
        options.pauseOnMouseOver && options.hideDelay && this._pauseOnHover();
      }
    }, {
      key: "_setHideTimer",
      value: function _setHideTimer() {
        var delay = this._opts.hideDelay;

        if (delay) {
          clearTimeout(this._autoHideTimer);
          this._startTimer = new Date().getTime();
          this._autoHideTimer = setTimeout(this.hide.bind(this), delay);
        }
      }
    }, {
      key: "_showHandler",
      value: function _showHandler() {
        // if(!this._autoHideTimer){
        this._trigger('show'); // No I18N


        this._setHideTimer(); // }

      }
    }, {
      key: "_closeHandler",
      value: function _closeHandler(origEvent) {
        this._trigger('hide', origEvent); // No I18N

      }
    }, {
      key: "_trigger",
      value: function _trigger(customEvent, origEvent) {
        return this._dispatchEvent(customEvent, origEvent);
      }
    }, {
      key: "show",
      value: function show() {
        if (this._trigger('beforeshow')) {
          // No I18N
          clearTimeout(this._autoHideTimer);

          this._setStyles();

          this._position();

          this.container.hide();

          this._showHide();
        }
      }
    }, {
      key: "_showHide",
      value: function _showHide(closeImmediate, isClose, origEvent) {
        var _this27 = this;

        var animate = closeImmediate ? undefined : this._opts.animation,
            animateCallBack = function animateCallBack() {
          _this27._display(isClose, _this27.container);

          if (isClose) {
            _this27._closeHandler(origEvent);
          } else {
            _this27._showHandler();
          }
        };

        if (_typeof(animate) === 'object' && !ZC.isEmpty(animate) && ZC.animationHandler) {
          // No I18N
          this._animate(this.container, animate, isClose ? 'hide' : 'show', animateCallBack); // No I18N

        } else {
          animateCallBack();
        }
      }
    }, {
      key: "hide",
      value: function hide(closeImmediate, origEvent) {
        if (this._trigger('beforehide')) {
          // No I18N
          clearTimeout(this._autoHideTimer);

          this._showHide(closeImmediate, true);
        }
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        this.container.empty();
        clearTimeout(this._autoHideTimer);
        clearTimeout(this._startTimer);
        this._animate = this._target = this._opts = undefined;
      }
    }, {
      key: "_handleOpen",
      value: function _handleOpen() {
        var options = this._opts,
            info = {},
            showInline = options.display === 'inline'; // No I18N

        if (showInline) {
          info = this._getTarget(options);
        }

        var action = info.action || "appendTo",
            // No I18N
        target = $(info.target || options.target);
        this.container[action](target);
        this._target = target; // Previous Banner is removed.

        var previousID = target.data('previous-bannerId'); // No I18N

        if (previousID) {
          var animation = options.animation,
              banner = $('#' + previousID); // No I18N

          banner.finish ? banner.finish() : banner.stop(true, true);

          if (banner.is(':visible') && banner.length) {
            // No I18N
            if (banner.is('z-alertbanner')) {
              // No I18N
              banner[0].hide(true);
            } else {
              ZC.alertbanner(banner).hide(true);
            }

            if (showInline && animation && animation.show) {
              animation.show = false;
            }
          }
        }

        target.data('previous-bannerId', this.container[0].id); // No I18N
      }
    }, {
      key: "_closeHandler",
      value: function _closeHandler(origEvent) {
        var container = this.container,
            target = this._target,
            base = this;

        if (this._opts && this._opts.createdByShowMethod) {
          if (target.data('previous-bannerId') === container.attr('id')) {
            // No I18N
            target.removeData('previous-bannerId'); // No I18N
          }

          this._trigger('hide', origEvent); // No I18N


          container && container.remove();

          base._destroy();

          base.element.remove();
        } else {
          this._trigger('hide', origEvent); // No I18N

        }
      }
    }, {
      key: "_position",
      value: function _position() {
        var options = this._opts,
            positions = {
          left: '',
          // No I18N
          right: '',
          // No I18N
          top: '',
          // No I18N
          bottom: '' // No I18N

        };
        this.container.css(positions);

        var position = this._getPosition();

        for (var prop in positions) {
          options[prop] && (position[prop] = options[prop]);
        }

        this.container.css(position);
      }
    }, {
      key: "_getDimension",
      value: function _getDimension(height) {
        var value = this.container[height ? 'outerHeight' : 'outerWidth'](); // No I18N

        this.container.css({
          left: 'auto',
          // No I18N
          top: 'auto' // No I18N

        });
        return value;
      }
    }, {
      key: "_getPosition",
      value: function _getPosition() {
        var options = this._opts,
            margin = options.margin,
            align = this._getRTLBasedDir(options.align),
            cssPos = {},
            marginRight = parseInt(margin[this._getRTLBasedDir(align)]);

        cssPos = this["_" + options.display + "Position"](align, marginRight);
        /* Alignment is common for inline and fixed */

        if (align === "left") {
          //No I18N
          cssPos.left = marginRight;
        } else if (align === "right") {
          //No I18N
          if (options.display !== "fixed") {
            //No I18N
            cssPos.left = "calc(100% - ".concat(this._getDimension() + marginRight, "px)");
          } else {
            cssPos.right = marginRight;
          }
        } else {
          cssPos.left = "calc(50% - ".concat(this._getDimension() / 2, "px)");
        }

        return cssPos;
      }
    }, {
      key: "_fixedPosition",
      value: function _fixedPosition(align, marginRight) {
        var options = this._opts,
            margin = options.margin,
            position = options.position,
            cssPos = {};

        if (/^(top|bottom)$/.test(position)) {
          cssPos[position] = parseInt(margin[position]);
        } else {
          /* Middle positioning */
          cssPos.top = 'calc(50% - ' + this._getDimension(true) / 2 + 'px)'; // No I18N
        }

        this.container.attr('data-position', position + '-' + align); // No I18N

        return cssPos;
      }
    }, {
      key: "_getIcon",
      value: function _getIcon(options, iconType) {
        return {
          iconClass: options[iconType + 'IconClass'] || options[iconType + 'IconClassName'],
          // No I18N
          SVGIconId: options[iconType + 'SVGIconId'] // No I18N

        };
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        // if (!this._opts.createdByShowMethod) {
        var container = this.container,
            isBannerVisible = container.is(':visible'),
            options = this._opts,
            reset = true,
            oldValue = options[optionName]; // No I18N

        if (/(target)$/.test(optionName)) {
          if (optionName === 'target') {
            $(this._target).removeData('previous-bannerId');
          }

          this._target = undefined;
          options[optionName] = value;
          reset = false; // this._init();
        } else if (/(icon|closeButton|type|closeIconClassName|closeSVGIconId|IconClassName|SVGIconId|message|isMessageHTMLEncoded)$/.test(optionName)) {
          options[optionName] = value;

          this._validate(oldValue);
        } else if (/(display)/.test(optionName)) {
          options[optionName] = value;
          reset = false;
          container.css('position', ''); // No I18N

          if (isBannerVisible) {
            this._setStyles();

            this._position();
          }
        } else if (/(margin|left|right|top|bottom)/.test(optionName)) {
          options[optionName] = value;
          reset = false;

          this._validate();

          if (isBannerVisible) {
            this._position();
          }
        } else if (/(hideDelay|hideOnClick|pauseOnMouseOver)/.test(optionName) && oldValue !== value) {
          options[optionName] = value;
          reset = false;

          this._validate();

          container.off("." + this.name); // No I18N

          this._bindEvents();
        } else if (/(className|zclassName)/.test(optionName)) {
          this._updateClass(value, oldValue);

          options[optionName] = value;
        } else if (optionName === 'animation') {
          if (_typeof(options.animation) === 'object' && value === 'object') {
            $.extend(true, options.animation, value);
          } else {
            options[optionName] = value;
          }
        } else {
          options[optionName] = value;
        }

        if (optionName === 'message') {
          // No I18N
          this._position();
        }

        reset && (this._domChanged = true); // }
      }
    }, {
      key: "_animate",
      value: function _animate(element, animation, action, callback) {
        ZC.animationHandler({
          element: element,
          action: action === 'none' ? 'hide' : 'show',
          // No I18N
          callback: callback,
          ctype: this.name,
          animation: animation
        });
      }
    }, {
      key: "_inlinePosition",
      value: function _inlinePosition(align, marginRight) {
        var options = this._opts,
            margin = options.margin,
            position = options.position,
            cssPos = {};

        if (margin.top) {
          cssPos['margin-top'] = margin.top; // No I18N
        }

        if (margin.bottom) {
          cssPos['margin-bottom'] = margin.bottom; // No I18N
        }

        return cssPos;
      }
    }, {
      key: "_getTarget",
      value: function _getTarget(options) {
        var target = options.displayAfter || options.displayBefore,
            action;

        if (target) {
          action = options.displayAfter ? "insertAfter" : "insertBefore"; // No I18N
        }

        return {
          target: target || options.displayInside,
          action: action
        };
      }
    }, {
      key: "name",
      get: function get() {
        return "zalertbanner";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          type: 'info',
          // (info|success|error|warning) // No I18N
          icon: null,
          iconClass: null,
          SVGIconId: null,
          errorIconClass: null,
          errorSVGIconId: null,
          successIconClass: null,
          successSVGIconId: null,
          warningIconClass: null,
          warningSVGIconId: null,
          infoIconClass: null,
          infoSVGIconId: null,
          message: null,
          isMessageHTMLEncoded: false,
          position: 'top',
          // No I18N
          align: 'center',
          // No I18N
          hideDelay: null,
          closeButton: false,
          closeSVGIconId: null,
          closeIconClass: null,
          display: 'fixed',
          // No I18N
          target: 'body',
          // No I18N
          displayAfter: null,
          displayBefore: null,
          displayInside: null,
          hideOnClick: false,
          left: null,
          right: null,
          bottom: null,
          top: null,
          pauseOnMouseOver: false
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          margin: null,
          errorIconClassName: null,
          successIconClassName: null,
          warningIconClassName: null,
          infoIconClassName: null,
          closeIconClassName: null,
          iconClassName: null,
          animation: {},
          labels: {
            close: 'Close' // No I18N

          }
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['show', // No I18N
        'hide', // No I18N
        'beforeshow', // No I18N
        'beforehide' // No I18N
        ];
      }
    }]);

    return ZAlertBanner;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZAlertBanner', ZAlertBanner);

  (function (ZC) {
    var template = ZC.zalertbanner.Templates;
    var utilities = ZC.Templates.Utilities;

    template.container = function (data) {
      return ZT.html(_templateObject63(), data.className, data.children && template.children(data));
    };

    template.children = function (data) {
      return ZT.html(_templateObject64(), data.isIE && ZT.html(_templateObject65()), data.icon && utilities.icon(data), data.isIE && template.closeButton(data), data.type && ZT.html(_templateObject66(), data.messageDOM, ZT.customHTML(data.message)), !data.isIE && template.closeButton(data));
    };

    template.closeButton = function (data) {
      return ZT.html(_templateObject67(), data.closeButton && ZT.html(_templateObject68(), data.closeText, utilities.icon(data.closeButton)));
    };
  })(ZComponents);

  var ZAlertDialog =
  /*#__PURE__*/
  function (_ZC$CoreComponent8) {
    _inherits(ZAlertDialog, _ZC$CoreComponent8);

    function ZAlertDialog() {
      _classCallCheck(this, ZAlertDialog);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZAlertDialog).apply(this, arguments));
    }

    _createClass(ZAlertDialog, [{
      key: "name",
      get: function get() {
        return "zalertdialog";
      }
    }], [{
      key: "open",
      value: function open(opts) {
        this._opts = $.extend(true, {}, this.DEFAULTS, opts);
        var baseObj = this;
        this.close({}, {}, function () {
          baseObj._init(opts);
        }); // closing the previously opened alert dialog before opening a new one.
      }
    }, {
      key: "_init",
      value: function _init(options) {
        var _this28 = this;

        var opts = this._opts,
            sId = 'zalert-' + (opts.name || opts.customAttributes && opts.customAttributes.id || '') + '-suppressed',
            // No I18N
        cookieVals = document.cookie.split(';'),
            // No I18N
        cfound = cookieVals.filter(function (item) {
          if (item.trim().indexOf(sId + '=true') === 0) {
            // No I18N
            return item;
          }
        });

        if (cfound.length) {
          opts.suppressed && opts.suppressed();
          return;
        }

        this._construct();

        this._bindEvents();

        this._positionDialog();

        this._createOverlay();

        if (this._opts.animation && this._opts.animation.open) {
          this._openAnimate();
        } else {
          this._display();

          this._handleOpen();
        }

        ZC.$window.off('resize.zalertdialog').on('resize.zalertdialog', function (event) {
          // No I18N
          // compute the top and left for the centered aligned alert dialog or golden mean positioned alert dialog whenever window resize occurs.
          var position = _this28._opts.position;

          if (_this28.container && _this28.container.is(':visible') && (position && !position.length || position === 'center') && event.originalEvent.type === 'resize') {
            // No I18N
            _this28._positionDialog();
          }
        });
      }
      /* Constructs the dialog by creating titlebar,content div and button panel */

    }, {
      key: "_construct",
      value: function _construct() {
        var _opts = this._opts;
        this._data = _opts;
        this._data.className = "".concat(_opts.className, " ").concat(_opts.rtl ? 'zh-rtl' : ''); // No I18N

        var showTitleBar = _opts.title || _opts.closeButton;

        if (showTitleBar) {
          this._updateTitleInfo();
        } else {
          this._data.titleBar = false;
        }

        var isHTMLEncoded = _opts.isHTMLEncoded || _opts.isMessageHTMLEncoded;

        if (_opts.primaryMessage && _opts.primaryMessage.trim() !== '') {
          // No I18N
          this._data.primaryMessage = isHTMLEncoded ? _opts.primaryMessage : ZC.encodeHTML(_opts.primaryMessage);
        }

        if (_opts.secondaryMessage && _opts.secondaryMessage.trim() !== '') {
          // No I18N
          this._data.secondaryMessage = isHTMLEncoded ? _opts.secondaryMessage : ZC.encodeHTML(_opts.secondaryMessage);
        }

        if (_opts.suppressionDecisionBox) {
          this._data.suppressionDecisionBoxLabel = _opts.suppressionDecisionBoxLabel || this._getString('suppressionMessage'); // No I18N
        }

        this._setIcon();

        this._createFooter();

        this.container = $(ZC._render(this._data, 'zalertdialog', null, null, document.body, {})); // No I18N

        this.container.addClass(this._data.className);

        if (_opts.customAttributes) {
          this.container.attr(_opts.customAttributes);
        }

        this.container.find('.zbutton:not(.zbutton--help)').on('click.zalertdialog', this._clickHandler.bind(this)); // No I18N

        if (_opts.suppressionDecisionBox) {
          this._handleSuppression();
        }

        showTitleBar && this._handleTitleBar();
      }
    }, {
      key: "_clickHandler",
      value: function _clickHandler(event) {
        var targetBtn = $(event.target).closest('.zbutton'),
            // No I18N
        btnOpts = ZC.button(targetBtn).getAttributes(),
            args = {
          button: targetBtn,
          properties: btnOpts,
          buttonOptions: btnOpts
        };

        if (btnOpts.action && typeof btnOpts.action !== 'string') {
          // No I18N
          btnOpts.action(event, args);
        } else {
          this.close(event, args);
        }

        event.stopPropagation(); // event is preventing to avoid alert dialog event triggering.

        event.preventDefault();
      }
    }, {
      key: "_createFooter",
      value: function _createFooter() {
        var buttons = this._getButtons(),
            buttonObj = {},
            text;

        for (var property in buttons) {
          if (buttons.hasOwnProperty(property)) {
            buttonObj = buttons[property];
            text = buttonObj.text;
            buttonObj.contentType = text === '' || text === undefined || text === null ? 'icon' : 'text'; // No I18N

            buttonObj.isCE = this._data.isCE;
          }
        }

        this._data.buttons = buttons;
        var commandBar = this._opts.commandBar || {};
        commandBar.componentName = this.name; // Below statement is added since zalertdialog__footer class is not available and alert dialog uses zdialog__footer.

        var btnAlign = this._opts.buttonsAlignment;
        commandBar.className = "zdialog__footer ".concat(btnAlign === 'right' ? '' : this._getAlignCls(btnAlign));
        this._data.commandBar = commandBar;

        if (this._opts.helpButton) {
          this._setHelpButton();
        }
      }
    }, {
      key: "_getString",
      value: function _getString(label) {
        return ZC.getI18NText('zalertdialog', label, this._opts.labels, []); // No I18N
      }
      /* Returns the buttons object corresponding to the type of the dialog */

    }, {
      key: "_getButtons",
      value: function _getButtons() {
        var _opts = this._opts;
        var buttons = {
          CANCEL: {
            actionType: 'CANCEL',
            // No I18N
            id: 'zc-zdialog-cancel',
            // No I18N
            text: _opts.cancelButtonLabel || this._getString('cancel'),
            // No I18N
            action: 'CANCEL',
            // No I18N
            name: 'cancel',
            // No I18N
            isCancel: true,
            templateRender: true
          },
          OK: {
            actionType: 'OK',
            // No I18N
            id: 'zc-zdialog-ok',
            // No I18N
            text: _opts.OKButtonLabel || this._getString('ok'),
            // No I18N
            appearance: 'primary',
            // No I18N
            templateRender: true,
            name: 'ok' // No I18N

          },
          NO: {
            actionType: 'NO',
            // No I18N
            id: 'zc-zdialog-no',
            // No I18N
            text: _opts.noButtonLabel || this._getString('no'),
            // No I18N
            action: 'CANCEL',
            // No I18N
            isCancel: true,
            templateRender: true,
            name: 'no' // No I18N

          },
          YES: {
            actionType: 'YES',
            // No I18N
            id: 'zc-zdialog-yes',
            // No I18N
            text: _opts.yesButtonLabel || this._getString('yes'),
            // No I18N
            appearance: 'primary',
            // No I18N
            templateRender: true,
            name: 'yes' // No I18N

          }
        };
        var buttonsOrder = _opts.buttonsOrder || (ZC.OS.isWindows() ? 'windows' : 'mac'); // No I18N
        // if the platform is windows, use windows style order for action buttons.

        buttons = {
          OK: buttons.OK,
          CANCEL: buttons.CANCEL,
          YES: buttons.YES,
          NO: buttons.NO
        };

        if (buttonsOrder === 'mac') {
          buttons = {
            CANCEL: buttons.CANCEL,
            OK: buttons.OK,
            NO: buttons.NO,
            YES: buttons.YES
          };
        }

        var btns = _opts.buttons;

        if (!btns) {
          return _opts.type === 'custom' || _opts.type === 'confirm' ? [buttons.CANCEL, buttons.OK] : [buttons.OK];
        } else if (_typeof(btns) === 'object') {
          // No I18N
          for (var i = 0; i < btns.length; i++) {
            _opts.buttons[i].templateRender = true;
          }

          return _opts.buttons;
        } else if (typeof btns === 'string') {
          // No I18N
          var newArray = [],
              _i3 = 0,
              splitArr = btns.split('-');

          for (var key in buttons) {
            if (splitArr.indexOf(key.toLowerCase()) !== -1) {
              newArray[_i3] = buttons[key];
              _i3++;
            }
          } // $.each(buttons, (key) => {
          // if (splitArr.indexOf(key.toLowerCase()) !== -1) {
          //     newArray[i] = buttons[key];
          //     i++;
          // }
          // });
          // for(let i = 0; i < splitArr.length; i++){
          //     newArray[i] = buttons[splitArr[i].toUpperCase()];
          // }


          return newArray;
        }
      }
    }, {
      key: "_display",
      value: function _display(hide) {
        var isGTIE11 = ZC.Browser.isIE ? ZC.Browser.getIEVersion() >= 11 : true;
        return this.container.css('display', hide ? 'none' : isGTIE11 ? 'flex' : 'block'); // No I18N
      }
    }, {
      key: "_handleOpen",
      value: function _handleOpen() {
        var _this29 = this;

        var _opts = this._opts;
        _opts.open && _opts.open({
          dialog: this.container,
          element: this.container,
          options: _opts
        });

        if (_opts.closeTimeout !== undefined && _opts.closeTimeout !== '') {
          // No I18N
          window.setTimeout(function () {
            _this29.close({}, {});
          }, parseInt(_opts.closeTimeout));
        }

        this.container.attr('aria-expanded', true); // No I18N

        ZC.FocusHandler && ZC.FocusHandler.init(this.container, _opts.excludeFocus);

        this._focusActionButton();
      }
    }, {
      key: "_focusActionButton",
      value: function _focusActionButton() {
        var buttonSelector = this._opts.defaultActionButton;

        if (buttonSelector && buttonSelector.indexOf('#') !== 0) {
          // No I18N
          // retrieve based on the button text.
          buttonSelector = "button[data-text='".concat(buttonSelector.toLowerCase(), "']"); // No I18N
        } else {
          buttonSelector = '.zbutton--primary'; // No I18N
        }

        var buttonTobeFocused = this.container.find(buttonSelector);

        if (!buttonTobeFocused.length) {
          buttonTobeFocused = this.container.find('button:last'); // No I18N
        }

        buttonTobeFocused.focus();
      }
      /* Creates an overlay to achieve the "modal" behavior */

    }, {
      key: "_createOverlay",
      value: function _createOverlay() {
        // Here tabindex is set in order to make the div element receive keydown events.
        this._overlay = $("<div class='zdialog--overlay " + this._opts.overlayClassName + "' ></div>").attr('tabindex', 1);

        this._hideBodyScroll(true);

        ZC.zIndex += 2; // setting the maximum zIndex of the dialog.
        // Overlay element is placed before the dialog element in order to have the elements in correct order.For Ex: If same z-index value is set for both dialog and overlay, overlay has to precede the dialog element.

        document.body.insertBefore(this._overlay[0], this.container[0]);

        this._overlay.css('z-index', ZC.zIndex - 1); // No I18N


        this.container.css('z-index', ZC.zIndex); // No I18N

        var eventSuffix = '.' + this.name; // No I18N

        this._overlay.on("keydown.".concat(eventSuffix), function (event) {
          event.stopPropagation(); // preventing the default behavior since shortcut keys behaviors are executed.

          event.preventDefault();
        }).on("mousedown.".concat(eventSuffix), function (event) {
          // mousedown event propagation is prevented inorder to avoid document mousedown(mainly close handler) handlers being executed (which might close the opened menu/popover).
          event.stopPropagation();
        });
      }
    }, {
      key: "_hideBodyScroll",
      value: function _hideBodyScroll(hide) {
        $('body')[hide ? 'addClass' : 'removeClass']('zh-overflowhidden'); // No I18N
      }
    }, {
      key: "close",
      value: function close(event, data, callback) {
        if (this.container && this.container.is(':visible')) {
          // No I18N
          data = data || {
            actionType: 'CLOSE',
            // No I18N
            isCancel: true
          };
          data.element = this.container;
          data.options = this._opts;
          data.isSuppressed = this._opts.suppressionDecisionBox && $('#zalert__suppression--box').prop('checked'); // No I18N

          if (this._opts.beforeclose) {
            if (this._opts.beforeclose(event, data) !== false) {
              this._handleClose(event, data, callback);
            }
          } else {
            this._handleClose(event, data, callback);
          }
        } else {
          callback && callback.apply(this);
        }
      }
    }, {
      key: "_handleClose",
      value: function _handleClose(event, data, callback) {
        if (this._opts.animation) {
          this._closeAnimate(event, data, callback);
        } else {
          this._display(true);

          this._close(event, data, callback);
        }
      }
    }, {
      key: "_close",
      value: function _close(event, data, callback) {
        this.container.remove();
        this._overlay && this._overlay.remove();

        if (!$('body').find('.zdialog--overlay').length) {
          this._hideBodyScroll(false);
        }

        ZC.zIndex = ZC.zIndex - 2; // one for overlay and other for alert dialog.

        /* setTimeout is used because event triggered before dialog and overlay are removed from the document. */
        // window.setTimeout(function(){

        event = event || {};
        $.extend(true, data, {
          options: this._opts,
          button: $(event.target),
          event: event,
          element: this.container
        });
        this._opts.close && this._opts.close(event, data);
        this._overlay = this.container = undefined;
        callback && callback.apply(this);
      }
      /* Bind the events to the dialogs */

    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        var _this30 = this;

        var eventSuffix = ".".concat(this.name),
            _opts = this._opts; // After taking focus outside of the dialog via mouse and if we click the dialog once again, dialog buttons should get focus. (Reference : predefined alert dialogs)

        this.container.on("keydown".concat(eventSuffix), function (event) {
          if (event.keyCode === ZC.keyCode.ESCAPE) {
            // Pressing Escape should trigger the click event on button which has CANCEL action set on it otherwise don't close the dialog - referred from native system alerts.
            var cancelBtn = _this30.container.find('.zh--clickonescape:first');

            if (cancelBtn.length) {
              // setting focus is removed since we have separate focus for keyboard and mouse.
              window.setTimeout(function () {
                return cancelBtn.trigger('click');
              }, 150); // No I18N
              // timer is used since click triggers immediately before focus effect applies to the button.
            } else if (_opts.closeButton) {
              _this30.container.find('.zdialog__actiongroup .zbutton').trigger('click'); // No I18N

            } else {
              _this30.close(event, {
                ESCAPE_PRESSED: true
              });
            }
          } else if (event.keyCode === ZC.keyCode.ENTER) {
            var buttonElement = _this30.container.find(_opts.defaultActionButton || '.zbutton--primary'),
                // No I18N
            includedList = '.zbutton:not(.zbutton--menu), input:not(.ztokenfield):not(.zsuggestfield-element):not([type=checkbox]), div.zdialog__header'; // No I18N


            if ($(event.target).closest(includedList).length && buttonElement.length && !$(event.target).closest('.zdialog__footer').length) {
              buttonElement.trigger('click'); // No I18N
            }
          } // if (event.keyCode === ZC.keyCode.TAB) {
          //     event.preventDefault(); // preventing default in all scenarios prevents the editing of text inside the textboxes present in the alert dialog.
          // }

        }).on("click".concat(eventSuffix), function (event) {
          // Click event propagation is prevented inorder to avoid document click handlers being executed (which might close the opened menu/popover).
          event.stopPropagation();
        });
        this.container.find('.zdialog__header').length && this.container.find('.zdialog__header').on("mouseup".concat(eventSuffix), function () {
          return _this30._focusActionButton();
        }); // No I18N

        _opts.helpButton && _opts.helpButton.action && $('#zalertbutton--help').on('click', function () {
          return _opts.helpButton.action();
        }); // No I18N
      }
    }, {
      key: "_updateTitleInfo",
      value: function _updateTitleInfo() {
        var _opts = this._opts;
        this._data.title = _opts.isHTMLEncoded || _opts.isTitleHTMLEncoded ? _opts.title : ZC.encodeHTML(_opts.title);
        this._data.titleBar = true;

        if (_opts.closeButton) {
          this._closeButton();
        }
      }
    }, {
      key: "_handleTitleBar",
      value: function _handleTitleBar() {
        var baseObj = this;
        this.container.find('#zalertbutton--close').on('click', function (event) {
          // No I18N
          baseObj.close(event, {
            button: $(event.target),
            buttonType: 'CLOSE',
            // No I18N
            closeButton: true
          });
        });

        if (this._opts.draggable && ZC.draggable) {
          this._draggable();
        }
      }
    }, {
      key: "_setIcon",
      value: function _setIcon() {
        var _opts = this._opts,
            type = _opts.type,
            iconClassName,
            SVGIconId,
            iconInfo,
            icon = true,
            defaultID = type === 'custom' ? 'zdialog__svg' : "zc__svg--".concat(type, " zdialog__svg ").concat(type, "color"); // No I18N

        if (_opts.iconClassName || _opts.SVGIconId) {
          iconClassName = _opts.iconClassName;
          SVGIconId = _opts.SVGIconId;
        } else if (type !== 'custom') {
          // No I18N
          iconClassName = _opts["".concat(type, "IconClassName")]; // No I18N

          SVGIconId = _opts["".concat(type, "SVGIconId")]; // No I18N
        } else {
          icon = false;
        }

        if (icon) {
          iconInfo = ZC._getIconInfo(iconClassName, SVGIconId, defaultID, 'zdialog__icon'); // No I18N

          this._data.iconClassName = iconInfo.iconClassName;
          this._data.SVGIconClassName = iconInfo.SVGIconClassName || _opts.SVGIconClassName;
          this._data.SVGIconId = iconInfo.SVGIconId;
        }

        this._data.alertIcon = icon;
      }
      /* Sets the position of the dialog to the given position or golden mean position  */

    }, {
      key: "_positionDialog",
      value: function _positionDialog() {
        var wrapper = this.container,
            _opts = this._opts,
            position = _opts.position;
        _opts.width && wrapper.outerWidth(_opts.width);
        _opts.height && wrapper.outerHeight(_opts.height);

        var elemWidth = wrapper.outerWidth(true) + parseInt(wrapper.css('border-left-width')) + parseInt(wrapper.css('border-right-width')),
            // No I18N
        elemHeight = wrapper.outerHeight(true) + parseInt(wrapper.css('border-bottom-width')) + parseInt(wrapper.css('border-top-width')),
            // No I18N
        positionObject = this._getGoldenMeanPosition(wrapper); // default position will be golden-mean position.


        if (_typeof(position) === 'object' && (position.left || position.top)) {
          positionObject = $.extend({}, positionObject, position);
          positionObject.left = parseInt(positionObject.left) + window.pageXOffset;
          positionObject.top = parseInt(positionObject.top) + window.pageYOffset;
        } else if (position === 'center') {
          // No I18N
          positionObject.top = ZC.windowObject.height / 2 - elemHeight / 2 + window.pageYOffset; // Adding the scrollY and scrollX values

          positionObject.left = ZC.windowObject.width / 2 - elemWidth / 2 + window.pageXOffset;
        }

        wrapper.css(positionObject);
      }
    }, {
      key: "_getGoldenMeanPosition",
      value: function _getGoldenMeanPosition(dialog) {
        var phi = 1.618,
            // used to find the golden mean position (a+b/a = a/b)
        // windowHeight = ZC.windowObject.height,
        // windowWidth = ZC.windowObject.width,
        windowHeight = document.documentElement.clientHeight,
            // document object is taken into account instead of window object inorder to position the alert dialog in correct position.
        windowWidth = document.documentElement.clientWidth,
            halfWindow = windowHeight / 2,
            smallerPortion = halfWindow - halfWindow / phi,
            topPosition = smallerPortion - parseFloat(dialog.height() / 2),
            // scroll height is added.
        leftPosition = windowWidth / 2 - parseFloat(dialog.width() / 2); // scroll width is added.

        /*
            Above Calculation: Golden-Mean by taking half window height.
                TopValue: 137
            golden-mean by taking full window height into account
                smallerPortion = windowHeight - (windowHeight/phi),
                Top Value: 277
        */

        /*
                1/3 of window height calculation
                    smallerPortion = windowHeight/3,
                    Top Value: 244
            */

        if (topPosition < 0) {
          topPosition = 0;
        }

        if (leftPosition < 0) {
          leftPosition = 0;
        }

        return {
          top: topPosition + window.pageYOffset,
          left: leftPosition + window.pageXOffset
        };
      }
    }, {
      key: "DEFAULTS",
      get: function get() {
        return {
          rtl: false,
          // No I18N
          type: 'custom',
          // No I18N
          buttonsAlignment: 'right',
          // No I18N
          isHTMLEncoded: false,
          // No I18N
          isTitleHTMLEncoded: false,
          // No I18N
          isMessageHTMLEncoded: false,
          // No I18N
          className: '',
          // No I18N
          closeButton: false,
          icon: undefined,
          // No I18N
          draggable: true,
          // No I18N
          labels: {
            // No I18N
            cancel: 'Cancel',
            // No I18N
            no: 'No',
            // No I18N
            ok: 'OK',
            // No I18N
            yes: 'Yes',
            // No I18N
            close: 'Close',
            // No I18N
            help: 'Help',
            // No I18N
            suppressionMessage: 'Do not show this message again.' // No I18N

          },
          // suppressAlert option will be considered only if an alert dialog is already suppressed.
          suppressAlert: true,
          // No I18N
          overlayClassName: '',
          // No I18N
          closeIcon: undefined,
          // No I18N
          helpIcon: undefined,
          // No I18N
          helpIconClassName: '',
          // No I18N
          OKButtonLabel: undefined,
          // No I18N
          cancelButtonLabel: undefined,
          // No I18N
          yesButtonLabel: undefined,
          // No I18N
          noButtonLabel: undefined,
          // No I18N
          closeButtonLabel: undefined,
          // No I18N
          helpButtonLabel: undefined,
          // No I18N
          suppressionDecisionBoxLabel: undefined // No I18N

        };
      }
    }]);

    return ZAlertDialog;
  }(ZC.CoreComponent);

  ZC.AlertDialog = window.ZAlertDialog = ZAlertDialog;
  ZC.zalertdialog = {
    Templates: {}
  };

  (function (ZC) {
    var button = ZC.createButton,
        template = ZC.zalertdialog.Templates,
        utilities = ZC.Templates.Utilities;

    template.container = function (data) {
      return ZT.html(_templateObject69(), data.children && template.children(data));
    };

    template.children = function (data) {
      return ZT.html(_templateObject70(), data.titleBar && ZT.html(_templateObject71(), data.title && ZT.html(_templateObject72(), ZT.customHTML(data.title)), data.closeButton && ZT.html(_templateObject73(), button(data.closeButton))), data.alertIcon && ZT.html(_templateObject74(), utilities.icon(data)), data.primaryMessage && ZT.html(_templateObject75(), ZT.customHTML(data.primaryMessage)), data.secondaryMessage && ZT.html(_templateObject76(), ZT.customHTML(data.secondaryMessage)), data.suppressionDecisionBoxLabel && ZT.html(_templateObject77(), data.suppressionDecisionBoxLabel), data.commandBar && ZT.html(_templateObject78(), data.commandBar.className, data.helpButton && button(data.helpButton), data.buttons.map(function (value) {
        return button(value);
      })));
    };
  })(ZComponents);
  /*  DataSource utility to ease the use of ajax / normal datasource.
      inputField( optional ) - The dataSource is filtered and "change" event is triggered  based on the input of this element.
      menu( optional ) - The menu that is to be populated whenever there is "change" in datasource.
      //ContentTypes =
          already supported - text, text-desc, image-text, image-text-desc.
          handling to be changed - for multiple selection, everything needs to be custom.
  */


  var ZDatasourceHandler =
  /*#__PURE__*/
  function (_ZC$CoreComponent9) {
    _inherits(ZDatasourceHandler, _ZC$CoreComponent9);

    function ZDatasourceHandler() {
      _classCallCheck(this, ZDatasourceHandler);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZDatasourceHandler).apply(this, arguments));
    }

    _createClass(ZDatasourceHandler, [{
      key: "_create",
      value: function _create() {
        var options = this._opts;
        this._dataMapping = options.dataMapping;
        this._maxResults = options.maxResults;
        var dataSource = options.dataSource;
        this.params = {};
        this._cachedData = {};
        this._filterFn = this._filterStaticSource;

        if (dataSource && _typeof(dataSource) === 'object') {
          // No I18N
          this._initAjaxSource(dataSource);
        }
      }
    }, {
      key: "_setDataSource",
      value: function _setDataSource(dataSource) {
        this._sorted = false;
        this._dataSource = dataSource;

        if (dataSource.length) {
          this._isJSONSource = _typeof(dataSource[0]) === 'object'; // No I18N
          // DataSource is sorted even before filtering. So that it need not be sorted each and every time.

          if (this._opts.inPlaceSorting) {
            this._dataSource = this._organizeResults(dataSource);
          }
        }
      }
    }, {
      key: "_organizeResults",
      value: function _organizeResults(dataSource) {
        if (dataSource && dataSource.length) {
          if (!this._sorted) {
            this._sorted = true;

            if (this._opts.sort) {
              return this._sortResults(dataSource);
            } else if (this._isGrouped()) {
              return this._organizeGroupedData(dataSource);
            }
          }
        }

        return dataSource;
      }
    }, {
      key: "_getTotalPages",
      value: function _getTotalPages() {
        return this._maxResults ? Math.ceil(this._totalFilteredData.length / this._maxResults) : this._totalFilteredData.length ? 1 : 0;
      }
    }, {
      key: "_clone",
      value: function _clone(data) {
        return JSON.parse(JSON.stringify(data));
      }
    }, {
      key: "_getFilteredData",
      value: function _getFilteredData() {
        var _this31 = this;

        var query = this.params.query;
        var dataSource = this._dataSource || [];

        if (dataSource.length) {
          if (this._isFunc(this._opts.matcher)) {
            return dataSource.filter(function (data) {
              return _this31._opts.matcher(query, data);
            });
          }

          return query ? this._filterData(query, dataSource) : dataSource.filter(function (data) {
            return !data.hidden;
          });
        }

        return dataSource;
      }
    }, {
      key: "_isGrouped",
      value: function _isGrouped() {
        return this._dataMapping.groupLabel && this._isJSONSource;
      }
    }, {
      key: "_trigger",
      value: function _trigger(customEvent, data) {
        var callback = this._opts.callbacks[customEvent];
        return !callback || callback(data);
      }
    }, {
      key: "_fetch",
      value: function _fetch() {
        var _this32 = this;

        var queryParam = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var successCallback = arguments.length > 1 ? arguments[1] : undefined;
        var failureCallback = arguments.length > 2 ? arguments[2] : undefined;
        var params = this.params;
        queryParam.query = queryParam.query ? queryParam.query : ''; // No I18N

        params.previousQuery = params.query;
        params.query = queryParam.query;
        this._serverPageIndex = queryParam.serverPageIndex || 1;
        this._pageIndex = queryParam.pageIndex;
        return new Promise(function (resolve, reject) {
          _this32._resolvePromise = function (response) {
            if (_this32._ajaxSource) {
              response.serverPageIndex = params.pages;
              response.moreServerPages = _this32._moreServerPages;
            }

            successCallback && successCallback(response);
            resolve(response);
          };

          _this32._rejectPromise = function (exception) {
            failureCallback && failureCallback(exception);
            reject(exception);
          };

          _this32._filterFn();
        })["catch"](function (e) {
          /* Empty catch is included to avoid error being thrown when promise is not used by the user */
          if (e !== 'abort') {
            // No I18N
            throw e;
          }
        });
      }
    }, {
      key: "_filterStaticSource",
      value: function _filterStaticSource() {
        // If datasource is not set for the first time, It is set.
        if (!this._dataSource) {
          this._setDataSource(this._opts.data);
        }

        this._totalFilteredData = this._filteredData = this._organizeResults(this._getFilteredData());
        this._totalPages = this._getTotalPages();

        this._sendDataToUser();
      } // Function to resolve the promise passed to the user while fetching the data.

    }, {
      key: "_sendDataToUser",
      value: function _sendDataToUser() {
        if (this._maxResults) {
          return this._resolvePageData();
        }

        this._resolvePromise({
          query: this.params.query,
          results: this._clone(this._filteredData)
        });
      }
    }, {
      key: "fetch",
      value: function fetch() {
        return this._fetch.apply(this, arguments);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this._ajaxRequest) {
          this._ajaxRequest.abort();
        }
      }
    }, {
      key: "_initAjaxSource",
      value: function _initAjaxSource() {
        this._ajaxSource = true;
        this._filterFn = this._filterAjaxSource;

        if (this._opts.serverSearch) {
          this._serverSearch = true; // ServerPaging is true only when server searching is true - becos - search cannot be completely performed since the data is not available completely.
        } else {
          this._opts.isResponseFiltered = false;
        }

        this._serverPaging = this._opts.dataSource.paginated;
      }
    }, {
      key: "_filterAjaxSource",
      value: function _filterAjaxSource() {
        var _this33 = this;

        var onSuccess = function onSuccess() {
          _this33._filterCurrentAjaxData();

          _this33._sendDataToUser();
        };

        var onFailure = function onFailure(exception) {
          _this33._rejectPromise(exception);
        };

        var params = this.params;
        var isSameQuery = this._dataSource && params.query === params.previousQuery && params.pages === this._serverPageIndex;

        if (isSameQuery) {
          // Current data is already filtered for the given query
          this._sendDataToUser();

          return;
        } // Check for cached data


        var cachedData = this._getDataFromCache(params.query);

        if (cachedData) {
          this._setDataSource(cachedData);
        } else if (this._serverSearch || this._serverPaging || !this._dataSource) {
          // Make ajax request if the data is not present in cache
          return this._initAjaxCall(onSuccess, onFailure);
        }

        onSuccess();
      }
    }, {
      key: "_filterCurrentAjaxData",
      value: function _filterCurrentAjaxData() {
        var options = this._opts;
        var cachedData = this._cachedData[this.params.query];
        this._filteredData = this._dataSource;

        if (!cachedData) {
          if (!options.isResponseFiltered) {
            this._filteredData = this._getFilteredData(this.params.query);
          }

          this._filteredData = this._organizeResults(this._filteredData);

          this._cacheResponse(this._filteredData);
        }

        this._totalFilteredData = this._filteredData;
        this._totalPages = this._getTotalPages();
      }
    }, {
      key: "_initAjaxCall",
      value: function _initAjaxCall(successCallback, failureCallback) {
        var _this34 = this;

        if (this._ajaxRequest) {
          this._ajaxRequest.abort();
        }

        var dataSource = this._opts.dataSource;

        if (this._serverPaging) {
          this.params.pages = this._serverPageIndex;
        }

        var params = this._getParams();

        var queryParam = dataSource.queryParam;
        dataSource.sourceURL = this._isFunc(dataSource.URL) ? dataSource.URL(params) : dataSource.URL;
        dataSource.data = this._isFunc(queryParam) ? queryParam(params) : queryParam;

        this._trigger('requeststart', {
          // No I18N
          params: params
        });

        var onSuccess = function onSuccess(data) {
          _this34._ajaxRequest = undefined;

          _this34._onAjaxSucess(data);

          successCallback && successCallback(data);
        };

        var onFail = function onFail(jqXHR, exception) {
          _this34._ajaxRequest = undefined;

          _this34._onAjaxFail(jqXHR, exception);

          failureCallback && failureCallback(exception);
        }; // this._ajaxRequest = ZC.AJAX.transport(dataSource, onSuccess, onFail).always(()=> { // always is passed as thrid argument temporarily
        //     this._ajaxRequest = undefined;
        // });


        this._ajaxRequest = ZC.AJAX.transport(dataSource, onSuccess, onFail); // always callback is passed as third argument since JS promise will return only finally hook but jquery named it as always. Inorder to avoid such discrepency, passed it as argument.
      }
    }, {
      key: "_getParams",
      value: function _getParams() {
        return $.extend({}, this.params);
      }
    }, {
      key: "_onAjaxSucess",
      value: function _onAjaxSucess(data) {
        var options = this._opts;
        var dsObject = options.dataSource;
        var response; // success callback given by the user is called.

        if (dsObject.success) {
          response = dsObject.success(data, this._getParams());
          data = response.results;
        } else if (data.results) {
          response = data;
          data = response.results;
        }

        this._moreServerPages = this._serverPaging && response.more;

        this._setDataSource(data);

        this._trigger('requestend', {
          // No I18N
          response: data
        });
      }
    }, {
      key: "_onAjaxFail",
      value: function _onAjaxFail(jqXHR, exception) {
        if (jqXHR.statusText !== 'abort') {
          // No I18N
          var failCallback = this._opts.dataSource.error;

          if (failCallback) {
            failCallback.apply(void 0, arguments);
          }

          this._trigger('requesterror', {
            // No I18N
            params: this._getParams(),
            jqXHR: jqXHR,
            exception: exception
          });
        }
      }
    }, {
      key: "_cacheResponse",
      value: function _cacheResponse(response) {
        // Currently caching is not supported for pagination
        if (this._serverSearch && this._opts.cacheData && !this._serverPaging) {
          this._cachedData[this.params.query] = response;
        }
      }
    }, {
      key: "_getDataFromCache",
      value: function _getDataFromCache(query) {
        if (query in this._cachedData) {
          return this._cachedData[query];
        } else if (query.length > 1 && this._opts.searchIncrementsInCache) {
          return this._getDataFromCache(query.slice(0, -1));
        }
      }
    }, {
      key: "_resolvePageData",
      value: function _resolvePageData() {
        var pageIndex = this._pageIndex;

        if (!pageIndex || !this._totalPages || pageIndex <= this._totalPages) {
          return this._resolvePromise({
            query: this.params.query,
            pageIndex: pageIndex,
            results: this._clone(this._getPageData(pageIndex, this._totalFilteredData)),
            totalPages: this._totalPages
          });
        }

        this._rejectPromise(this._opts.messages.pageIndexExceed);
      }
    }, {
      key: "_getPageData",
      value: function _getPageData(pageIndex, totalFilteredData) {
        var maxResults = this._maxResults;

        if (pageIndex) {
          var startingIndex = maxResults * (pageIndex - 1);
          return totalFilteredData.slice(startingIndex, startingIndex + maxResults);
        }

        return totalFilteredData;
      }
    }, {
      key: "_sortResults",
      value: function _sortResults(dataSource) {
        var options = this._opts; // It is copied since we dont work with the original datasource reference.

        dataSource = dataSource.slice();

        if (this._isFunc(options.customSorter)) {
          return options.customSorter(dataSource);
        }

        this._offset = options.sortOrder === 'desc' ? -1 : 1; // No I18N

        if (this._isJSONSource) {
          var dataMapping = this._dataMapping;
          this._sortField = options.sortBy ? String(options.sortBy).split(',') : [dataMapping.label]; // No I18N

          if (this._isGrouped() && this._sortField.indexOf(dataMapping.groupLabel) === -1) {
            dataSource = this._sortGroupedData(dataSource);
          } else {
            dataSource.sort(this._sortJSONData.bind(this));
          }
        } else {
          dataSource.sort(this._sortFn.bind(this));
        }

        this._offset = this._sortField = undefined;
        return dataSource;
      }
    }, {
      key: "_toLC",
      value: function _toLC(text) {
        if (typeof text === 'string') {
          // No I18N
          return text.toLowerCase();
        }

        return text;
      } // Sort function for simple data

    }, {
      key: "_sortFn",
      value: function _sortFn(textA, textB) {
        var returnData;
        var isTextANull = !this._isNotNull(textA);
        var isTextBNull = !this._isNotNull(textB);

        if (isTextANull && isTextBNull) {
          returnData = 0;
        } else if (isTextANull) {
          returnData = -1;
        } else if (isTextBNull) {
          returnData = 1;
        } else if (textA.localeCompare) {
          returnData = textA.localeCompare(textB);
        } else {
          textA = this._toLC(textA);
          textB = this._toLC(textB);
          returnData = textA > textB ? 1 : textA < textB ? -1 : 0;
        }

        return returnData * this._offset;
      } // Sort function for JSON data

    }, {
      key: "_sortJSONData",
      value: function _sortJSONData(dataA, dataB) {
        // Looping is done to sort by more than one field.
        for (var i = 0; i < this._sortField.length; i++) {
          var field = this._sortField[i];

          var result = this._sortFn(this._mapJSONToData(dataA, field), this._mapJSONToData(dataB, field));

          if (result) {
            return result;
          }
        }
      }
    }, {
      key: "_sortGroupedData",
      value: function _sortGroupedData(dataSource) {
        // Only the data within the respective groups are sorted separately. This reduces time complexity and also maintains the group order as given by the user.
        var groupedData = this._getGroupedData(dataSource);

        dataSource = [];

        for (var key in groupedData) {
          var _dataSource;

          (_dataSource = dataSource).push.apply(_dataSource, _toConsumableArray(groupedData[key].sort(this._sortJSONData.bind(this))));
        }

        return dataSource;
      }
    }, {
      key: "_filterData",
      value: function _filterData(query, dataSource) {
        var _this35 = this;

        var customSearch = this._opts.customSearch;

        if (this._isFunc(customSearch)) {
          return customSearch.apply(void 0, arguments);
        }

        var filter = this._opts.filter;

        var regEx = this._getMatchingRegex(query, filter);

        if (this._isJSONSource) {
          var filterBy = this._getSearchBy(filter.by);

          var filterByLength = filterBy.length;
          var addedKeys = [];
          return dataSource.filter(function (data) {
            if (!data.hidden) {
              var valueKey = _this35._mapJSONToData(data, _this35._dataMapping.value);

              if (_this35._opts.allowDuplicateValues || addedKeys.indexOf(valueKey) === -1) {
                for (var j = 0; j < filterByLength; j++) {
                  var value = _this35._mapJSONToData(data, filterBy[j]);

                  regEx.lastIndex = 0;

                  if (regEx.test(value)) {
                    addedKeys.push(valueKey);
                    return true;
                  }
                }
              }
            }
          });
        }

        return dataSource.filter(function (item) {
          regEx.lastIndex = 0;
          return regEx.test(item);
        });
      }
    }, {
      key: "_organizeGroupedData",
      value: function _organizeGroupedData(dataSource) {
        // To maintain the group order given by the user, even when filtered.
        var groupedData = this._getGroupedData(dataSource);

        var newDS = [];

        for (var key in groupedData) {
          newDS.push.apply(newDS, _toConsumableArray(groupedData[key]));
        }

        return newDS;
      } // Function to group records with group label as key

    }, {
      key: "_getGroupedData",
      value: function _getGroupedData(datasource) {
        var _this36 = this;

        var groupedData = {};
        datasource.forEach(function (data) {
          var label = _this36._mapJSONToData(data, _this36._dataMapping.groupLabel);

          if (!groupedData[label]) {
            groupedData[label] = [];
          }

          groupedData[label].push(data);
        });
        return groupedData;
      }
    }, {
      key: "name",
      get: function get() {
        return "zdatasourcehandler";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          id: null,
          data: [],
          dataSource: null,
          allowDuplicateValues: true,
          cacheData: true,
          searchIncrementsInCache: false,
          isResponseFiltered: true,
          maxResults: null,
          inPlaceSorting: true,
          matcher: null,
          dataMapping: {},
          sort: true,
          sortBy: null,
          sortOrder: 'asc',
          // No I18N
          customSorter: null,
          callbacks: {},
          filter: {
            criteria: 'contains' // No I18N

          },
          messages: {
            pageIndexExceed: 'PageIndex exceeds the total pages.' // No I18N

          }
        };
      }
    }]);

    return ZDatasourceHandler;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZDatasourceHandler', ZDatasourceHandler);

  ZC.createMenu = function (menuId, menuItems) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    // Menu created via JSON
    if (menuId && _typeof(menuId) === 'object') {
      // No I18N
      menuItems = menuId.items;
      options = menuId;
      menuId = menuId.id;
    } // If menu is already initialized for the element, return here.


    var menuEle = $('#' + menuId); // No I18N

    if (menuEle.data('zmenu')) {
      return menuEle;
    }

    options.id = menuId;
    options.usingJSON = true;

    if (menuItems.body || menuItems.header || menuItems.footer) {
      $.extend(true, options, menuItems); // ##revisit - try to remove $.extend

      options.items = menuItems.body;
      delete options.body;
    } else {
      options.items = menuItems;
    }

    options.allowReplace = true;
    return ZC.createElement(options, 'menu'); // assigning the ID and customAttributes is handled in createElement method itself.
  };

  var ZMenu =
  /*#__PURE__*/
  function (_ZC$CoreComponent10) {
    _inherits(ZMenu, _ZC$CoreComponent10);

    function ZMenu() {
      _classCallCheck(this, ZMenu);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZMenu).apply(this, arguments));
    }

    _createClass(ZMenu, [{
      key: "_getItemDetails",
      value: function _getItemDetails(itemObj, opts, item, retainHover) {
        var dItemType = itemObj.itemType || 'default',
            // No I18N
        itemType = itemObj.itemType = opts.isCE && item ? item.tagName === 'Z-MENUSEPARATOR' ? 'separator' : item.tagName === 'Z-MENUITEMHEADING' ? 'itemgroup' : dItemType : dItemType,
            // No I18N
        contentType = itemObj.contentType || opts.contentType || 'text',
            // No I18N
        hoverCls = 'on-hover',
            // No I18N
        hasShortcut = false,
            isElement = false,
            itemCls = ZMenu._ITEM_TYPES[itemType === 'radio' || itemType === 'checkbox' ? 'default' : itemType],
            // No I18N
        // regexp = new RegExp(itemCls + '|' + hoverCls, 'g'); // No I18N
        regexp = new RegExp(retainHover ? itemCls : itemCls + '|' + hoverCls, 'g'); // No I18N

        itemObj.className = (itemObj.className ? itemObj.className.replace(regexp, '') + ' ' : '') + itemCls; // No I18N
        // Since for separator type, we don't have to fetch other details.

        if (!opts.allowReplace && item) {
          itemObj.element = item;
        }

        if (itemType === 'separator') {
          // No I18N
          itemObj.isSeparator = true; // contentType is set to avoid rendering icons inside separator item.

          itemObj.contentType = 'text'; // No I18N

          if (item) {
            item = $(item);
          }
        } else {
          if (!itemObj.label && item) {
            // custom check added to support itemgroup with custom HTML
            var label = $(item)[itemObj.custom ? 'html' : 'text'](); // No I18N

            if (!itemObj.custom && (label.indexOf('<') > -1 || label.indexOf('>') > -1)) {
              // No I18N
              label = ZC.encodeHTML(label); // encoding here since label might contain special characters
            }

            itemObj.label = label;
          }

          if (itemType === 'itemgroup') {
            // No I18N
            // contentType is changed here since itemgroup header element will contain text alone irrespective of the declared content type for menu.
            contentType = 'text'; // No I18N
          } else {
            if (itemType === 'custom' || itemObj.custom) {
              // No I18N
              this._getCustItemInfo(itemObj, item);
            } else {
              var action = itemObj.action,
                  _hasShortcut;

              if (typeof action === 'string' && action.indexOf('URL:') !== -1) {
                // No I18N
                itemObj.target = itemObj.target || '_blank'; // No I18N

                itemObj.className += ' zmenu--withlink'; // No I18N

                itemObj.url = action.replace('URL:', ''); // No I18N

                if (itemObj.target === '_blank') {
                  // No I18N
                  itemObj.rel = 'noopener noreferrer'; // No I18N
                }
              }

              if (itemObj.ellipsis) {
                itemObj.label = itemObj.label + '...'; // No I18N
              }

              itemObj.shortcutKey = _hasShortcut = window.ZShortCut ? ZShortCut.getInfo(action, item, true) : itemObj.shortcutKey; // need revisit

              this._data.hasShortcut = !!_hasShortcut;
            }

            if (itemObj.menuItems) {
              // contains submenu
              var submenuId = itemObj.id + 'submenu'; // No I18N

              itemObj.menuId = submenuId;
              ZC.createMenu(submenuId, itemObj.menuItems, _defineProperty({
                type: itemObj.type,
                isCE: opts.isCE,
                contentType: itemObj.contentType,
                appendTo: itemObj.appendTo
              }, opts.isCE ? 'zclassName' : 'className', itemObj.submenuClassName));
            }
          }

          itemObj.hasSubmenu = itemObj.menuId || itemType === 'splitmenu' || itemType === 'submenu'; // No I18N

          if (itemObj.hasSubmenu) {
            itemObj.className += itemType !== 'splitmenu' && !itemObj.splitmenu ? ' zmenu--submenu' : ''; // No I18N

            itemObj.arrowIcon = ZC._getIconInfo(opts.arrowIconClassName || opts.arrowIconClass, opts.arrowSVGIconId, 'zc__svg--arrow zmenu__arrow zh-arrowicon', 'zmenu__icon zh-alignright'); // No I18N

            if (itemObj.customType) {
              itemObj.iconAsSuffix = true;
            }

            this._hasSMenu = true;
          }

          var dIconCls = "".concat(opts.type === 'grid' ? 'zmenu__image' : 'zmenu__icon'); // No I18N
          // replacing to avoid duplicate class name additions while updating via setMenuItemsAttribute

          itemObj.iconClassName = (itemObj.iconClassName || '').replace(new RegExp(itemObj.iconClass + '|' + dIconCls, 'g'), ''); // No I18N

          if (itemObj.SVGIconId) {
            itemObj.SVGIconId += ' zmenu__svg'; // No I18N
          }

          itemObj = ZC._getIconInfo(itemObj.iconClass || itemObj.iconClassName, itemObj.SVGIconId, undefined, dIconCls, itemObj);
          itemObj.contentType = contentType; // No I18N

          if (item) {
            item = $(item);
            var stateAttrs = ['disabled', 'checked', 'hidden', 'name'],
                // No I18N
            aName;

            for (var k = 0; k < 4; k++) {
              aName = stateAttrs[k];
              itemObj[aName] = itemObj[aName] || item.attr(aName);
            }

            if (opts.allowReplace) {
              var attrs = item[0].attributes,
                  cAttrs = {};

              for (var a = 0; a < attrs.length; a++) {
                if (attrs[a].name === 'class') {
                  // No I18N
                  itemObj.className = attrs[a].value + ' ' + itemObj.className; // No I18N
                  // class should be merged with existing class
                } else {
                  cAttrs[attrs[a].name] = attrs[a].value;
                }
              }

              itemObj.attrs = cAttrs;
            } else {
              isElement = true;
            }
          } else if (itemObj.customAttributes) {
            // itemObj.attrs = Object.create(itemObj.customAttributes); Object.keys returns null if we assign like this
            itemObj.attrs = _objectSpread({}, itemObj.customAttributes);
          }

          if (itemType === 'radio' || itemType === 'checkbox') {
            // No I18N
            itemObj = this._getIconDetails(itemObj, opts, itemObj.checked);
          }

          if (opts.isCE && itemType === 'itemgroup') {
            // No I18N
            itemObj.isHeading = true;
          }
        }

        if (!itemObj.isSeparator && !itemObj.isHeading) {
          itemObj.isDefault = true;
        }

        var cls = itemObj.className; // replace is needed if disabled option is updated for a menu item using setMenuItemsAttribute.

        cls = itemObj.disabled ? cls + ' is-disabled' : cls.indexOf('is-disabled') >= 0 ? cls.replace(/is-disabled/g, '') : cls; // No I18N

        cls = itemObj.hidden ? cls + ' zh-dnone' : cls.indexOf('zh-dnone') >= 0 ? cls.replace(/zh-dnone/g, '') : cls; // No I18N

        itemObj.className = cls;
        itemObj.uniqueKey = itemObj.uniqueKey || (itemObj.id || 'mitem') + Math.round(Math.random() * 100000000); // No I18N

        itemObj.id = item && item.attr('id') || itemObj.id || itemObj.attrs && itemObj.attrs.id || itemObj.uniqueKey; // ID is assigned mandatory for performance improvement reasons like querying using the ID.

        itemObj.role = ZMenu.ARIA_ROLES[itemType];

        if (itemObj.element) {
          // all attrs like class,role, id, uniquekey has to be set
          itemObj.defaultClass = itemObj.defaultClass === undefined ? itemObj.element.className : itemObj.defaultClass;
          itemObj.attrs = $.extend(true, {}, itemObj.attrs, {
            // itemObj.attrs might be undefined. So, using assignment statements
            id: itemObj.id,
            'class': itemObj.defaultClass + ' ' + itemObj.className,
            // No I18N
            role: itemObj.role,
            'data-unique-key': itemObj.uniqueKey // No I18N

          });
        }

        if (hasShortcut) {
          this._data.shortcutItems.push(itemObj.id);
        }

        if (itemObj.attrs && !ZC.isEmpty(itemObj.attrs) || itemObj.checked) {
          this._itemsHavingAttrs.push(itemObj.id);
        }

        itemObj.layoutName = this._getLayout("".concat(itemObj.customType ? 'custom' : itemObj.url ? 'anchor' : 'default', "Layout")); // No I18N

        itemObj.className = itemObj.className.trim();

        if (isElement) {
          itemObj.element.itemData = itemObj;
        }

        if (opts.addItemCallback) {
          opts.addItemCallback(item, itemObj, opts);
        }

        return itemObj;
      }
    }, {
      key: "_init",
      value: function _init(ele, opts) {
        // getData is changed to .itemData to improve performance.
        var data = this._data;
        this.scrollWidth = ZMenu._scrollWidth || ZMenu.getScrollWidth();
        this._itemsHavingAttrs = [];
        this._labelList = [];
        this._namespace = '.zmenu'; // No I18N

        this._data.shortcutItems = []; // ##revisit - create via json
        // $.extend(true, data, opts); // _opts.data will be passed from createMenu method.

        data.callout = opts.displayType === 'callout'; // No I18N

        this._skipParent = data.alwaysSetAttrs = true; // always container template execution should be prevented.

        data.attrs = data.attrs || {};
        data.attrs.role = 'menu'; // No I18N

        data.attrs.tabindex = ele[0].getAttribute('tabindex') || 0; // No I18N

        data.items = [];
        var sel = this._SELECTORS;
        this._isContainer = ele[0].tagName.toLowerCase() === sel.container && (this.isCE ? !ele.children(sel.item).length : true); // first element child

        this._lastOverlayedMenu = ele;

        if (opts.constructMenu) {
          this[this._isContainer ? '_storeAllPortionItems' : '_storeMenuItemDetails'](); // No I18N

          data.simple = !this._isContainer;
        }

        if (!this._isContainer) {
          // slider type scroll will be shown for container type menus alone
          opts.scroll = 'default'; // No I18N
        }

        if (this.isCE && opts.allowReplace) {
          this._addedByComponent = true;
        }

        this._useParent = !opts.usingJSON;
      }
    }, {
      key: "_storeMenuItemDetails",
      value: function _storeMenuItemDetails(section) {
        var ele = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.element;
        var sel = this._SELECTORS,
            data = this._data,
            elePassed = ele[0] !== this.element[0],
            itemsArr = [],
            opts = this._opts,
            secName = section ? section + 'Items' : 'items',
            // No I18N
        items = opts[section] || opts[secName] || ele[0].querySelectorAll("".concat(sel.item, ", ").concat(sel.separator, ", ").concat(sel.group)),
            // No I18N
        len = items.length,
            iData;

        for (var i = 0; i < len; i++) {
          if (!opts.usingJSON) {
            iData = ZC._getOpts(items[i]);
            iData.contentType = elePassed && ZC._getOpts(ele).contentType;
          }

          itemsArr.push(this._getItemDetails(opts.usingJSON ? items[i] : iData, opts, !opts.usingJSON && items[i])); // collecting the items related data to store in this._data.items
        }

        if (itemsArr.length) {
          data[secName] = itemsArr; // No I18N
        }
      }
    }, {
      key: "_postRender",
      value: function _postRender(ele) {
        // below code will be executed for first render alone
        var opts = this._opts,
            data = this._data;
        data.className += " ".concat(ele ? ele[0].className : '', " zmenu ").concat(opts.contentType ? ZMenu._CONTENT_TYPES[opts.contentType] : '', " ").concat(this._isContainer === false && opts.type === 'grid' ? 'zmenu--thumbnail' : '', " ").concat(opts.menuClass || ''); // No I18N

        if (!opts.allowReplace) {
          data.rendered = true;
          data.isInitial = true; // will be revisited

          this['_setCustomAttrsForItem' + (this._isContainer ? 's' : '')](data, true); // No I18N
        }

        if (opts.renderInPlace) {
          this._resetLabels(ele);
        }

        if (this.isCE && opts.allowReplace) {
          this._addedByComponent = false;
        }
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender() {
        var data = this._data;

        if (data.rendered && !data.isInitial && this._itemsHavingAttrs.length || this._opts.allowReplace && (!data.rendered || this._itemsHavingAttrs.length)) {
          // element attrs has to be added like this for nested elements
          this['_setCustomAttrsForItem' + (this._isContainer ? 's' : '')](data, false); // No I18N
        } // Why have we assigned it everytime and this statement will return true instead of the pointer element - Revisit


        this._pointerElement = data.callout && this.element.find('.zmenu__pointer'); // No I18N

        this._addedByComponent = false;
      }
    }, {
      key: "_setCustomAttrsForItem",
      value: function _setCustomAttrsForItem(itemsObj, isInitial, customPortion) {
        // serves dual purpose - setting custom attributes for menu items and fetching only the newly added items using the passed data.
        if (this.isCE) {
          this._addedByComponent = true;
        }

        var menuItems = [],
            portionData = itemsObj[customPortion || 'items'],
            j,
            attrs,
            menuItem,
            itemData; // No I18N

        if (portionData) {
          for (j = 0; j < portionData.length; j++) {
            itemData = portionData[j];
            attrs = itemData.attrs;
            menuItem = $('#' + itemData.id)[0];

            if (!this._opts.allowReplace) {
              // run template for each and every LI elements separately
              this._data.isInitial = true;
              menuItem = itemData.element || menuItem;

              this._render(itemData, itemData.layoutName, menuItem, true);

              this._data.isInitial = false;

              if (itemData.className) {
                $(itemData.element).attr('class', itemData.className); // No I18N
              }

              attrs && delete attrs["class"]; // updating the class attribute behaves erroneous if not deleted here.
            }

            menuItem = $('#' + itemData.id);

            if (!menuItem.length) {
              continue;
            }

            if (this._itemsHavingAttrs.indexOf(itemData.id) !== -1) {
              if (attrs) {
                attrs["class"] && menuItem.attr('class', attrs["class"] + ' ' + menuItem.attr('class')); // No I18N

                delete attrs["class"];
                menuItem.attr(attrs);
              } // Initially item prop should be set.


              menuItem.prop('checked', itemData.checked); // No I18N
            }

            menuItems.push(menuItem);
          }
        }

        if (this.isCE) {
          this._addedByComponent = false;
        }

        return menuItems; // return values are used in addMenuItems method.
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        var _this37 = this;

        if (!this._opts.allowReplace) {
          this._data.isInitial = false;
        }

        var ele = this.element,
            cname = this._namespace,
            itemSel = '.zmenu__item'; // No I18N

        this._addEvents({
          mouseup: 'mouseup' // No I18N

        }); // cannot use _addEvents for the mouseenter event. Also, mouseover event cannot be used. So, using on method.


        ele.on('mouseenter.' + cname, itemSel, function (event, actualEvent) {
          return _this37._mouseenterHandler(event, actualEvent);
        }).on('mouseleave.' + cname, itemSel, function (event) {
          return _this37._mouseleaveHandler(event);
        });
      } // Revisit - Why do we bind event everytime on open

    }, {
      key: "_bindRuntimeEvents",
      value: function _bindRuntimeEvents() {
        // keydown should be binded only to the main menu element and not for submenus. So having a separate method to call during menu show.
        this._addEvents({
          keydown: 'keydown' // No I18N

        });
      }
    }, {
      key: "_unbindRuntimeEvents",
      value: function _unbindRuntimeEvents() {
        this._removeEvents('keydown'); // No I18N

      }
    }, {
      key: "_keydownHandler",
      value: function _keydownHandler(event) {
        return this.handleKeyCode(event);
      }
    }, {
      key: "_mouseenterHandler",
      value: function _mouseenterHandler(event, actualEvent) {
        // Revisit - shorten second function name
        this[this._hasSMenu ? '_checkSubmenuEnter' : '_handleMouseEnterOnMenuItems'](event, !event.originalEvent, actualEvent); // No I18N
      }
    }, {
      key: "_handleMouseEnterOnMenuItems",
      value: function _handleMouseEnterOnMenuItems(event) {
        var scrollToView = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !event.originalEvent;
        var actualEvent = arguments.length > 2 ? arguments[2] : undefined;

        var menuItem = $(event.target).closest('.zmenu__item'),
            // No I18N
        data = this._getData(menuItem),
            mBodyCls = '.zmenu__body',
            // No I18N
        menu = menuItem.closest('.zmenu'),
            // No I18N
        bodyEle = menu.find(mBodyCls).length && menu.find(mBodyCls),
            hideSubmenu = this._hideOpenedSubmenu.bind(this),
            hoverCls = 'on-hover'; // No I18N


        bodyEle && bodyEle.stop();

        if (data.disabled || data.itemType === 'itemgroup') {
          // No I18N
          hideSubmenu(menu); // if submenuitem is hovered previously, it's submenu should be closed. [ Behavior is referred in MAC XCode]

          var item = this._lastOverlayedMenuItem;
          item && this._updateHoverState(item, false);
          return;
        }

        var storeHoverItem = this._setLastOverlayedMenuItem.bind(this); // Revisit - Shorten name


        if (data.hasSubmenu && menuItem.hasClass(hoverCls) && this._isMenuOfMenuItemShown(menuItem)) {
          // No I18N
          storeHoverItem(menuItem);
          return;
        }

        var mainMenu = menu.data('parent'); // No I18N

        if (mainMenu) {
          mainMenu = mainMenu.closest('.zmenu'); // No I18N

          clearTimeout(ZC._getOpts(mainMenu).mouseOverTimeout);
        }

        if (actualEvent) {
          // inorder to find whether the mouseenter is triggered on key events or not in selectbox component.
          event = actualEvent;
        }

        if (this._triggerEvent('itemhover', event, this._lastOverlayedMenu, menuItem, data)) {
          // No I18N
          if (scrollToView !== false) {
            this._scrollToView(menuItem, bodyEle || menu); // No I18N

          }

          hideSubmenu(menu);
          storeHoverItem(menuItem);

          this._updateHoverState(menuItem, true, data);

          if (data.hasSubmenu) {
            // Revisit - Shorten name
            this._handleMouseEnterOnSubmenuItem(menuItem, event, data);
          }
        }
      }
    }, {
      key: "_setLastOverlayedMenuItem",
      value: function _setLastOverlayedMenuItem(menuItem) {
        var hoveredItem = this._lastOverlayedMenuItem,
            hasMItem = menuItem && menuItem.length;

        if (hoveredItem && hasMItem && hoveredItem[0] === menuItem[0]) {
          return;
        }

        var lastMenu = this._lastOverlayedMenu,
            par;

        if (hoveredItem && hasMItem && !lastMenu[0].contains(menuItem[0]).length) {
          // Split menu case
          var iData = this._getData(menuItem),
              submenu = iData.submenu;

          if (!submenu || submenu[0] !== lastMenu[0]) {
            par = lastMenu.data('parent'); // No I18N

            if (par && par.parent().has(menuItem[0]).length) {
              menuItem.trigger('mouseleave'); // No I18N
            }
          }
        }

        if (hoveredItem) {
          hoveredItem.trigger('mouseleave', menuItem); // No I18N
        }

        this._lastOverlayedMenuItem = menuItem;

        if (hasMItem) {
          // Revisit - Avoid using closest. Use parent based on conditions
          var __menu = menuItem.closest('.zmenu'),
              // No I18N
          currentMenu = this.element,
              _par,
              currData = currentMenu.data('parent'); // No I18N


          this.setLastOverlayedMenu(__menu);

          while (currData) {
            // No I18N
            _par = currentMenu.data('parent'); // No I18N

            currentMenu = _par.closest('.zmenu'); // No I18N

            currData = currentMenu.data('parent'); // No I18N
          }

          ZC.menu(currentMenu)._lastOverlayedMenuItem = menuItem; // No I18N
        }
      }
    }, {
      key: "_hideOpenedSubmenu",
      value: function _hideOpenedSubmenu(menu) {
        this._hasSMenu && this._hideAllSubmenus && this._hideAllSubmenus(menu);
      }
    }, {
      key: "_hideParentMenu",
      value: function _hideParentMenu(menu, callback) {
        menu = this._findMain(menu);

        if (menu[0] === this.element[0]) {
          // Revisit - SHorten function name
          this._hideOpenedSubmenu(menu, true, callback);
        } else {
          ZC.menu(menu).hide(undefined, callback);
        }
      }
    }, {
      key: "_scrollToView",
      value: function _scrollToView(item, menu) {
        var iTop = item.offset().top - menu.offset().top,
            prevTop = menu[0].scrollTop,
            topValue,
            sBar = ZC.menu(menu.closest('.zmenu')).getData().scroller,
            // No I18N
        bar = iTop >= 0 ? 'downEle' : 'upEle'; // No I18N

        if (sBar && sBar[bar].is(':visible')) {
          // considering the scrollbar presence while navigating
          var sBarHeight = sBar[bar].outerHeight(true);
          iTop += bar === 'upEle' ? -sBarHeight : sBarHeight; // No I18N
        } // iTop < 0 means scrolling backward


        topValue = iTop < 0 ? prevTop + iTop : Math.max(prevTop, iTop + prevTop + item.outerHeight(true) - menu.outerHeight());
        menu.scrollTop(topValue); // animation is removed because in fast repeat keyboards animation produces incorrect results.

        if (sBar && prevTop !== topValue) {
          this._showScrollEle(menu); // showing and hiding the scrollbars similar to MAC OS menubar's menu.

        }
      }
    }, {
      key: "_mouseleaveHandler",
      value: function _mouseleaveHandler(event) {
        this[this._hasSMenu ? '_checkSubmenuLeave' : '_handleMouseLeaveOnMenuItems'](event); // No I18N
      }
    }, {
      key: "_handleMouseLeaveOnMenuItems",
      value: function _handleMouseLeaveOnMenuItems(event) {
        var menuItem = $(event.target).closest('.zmenu__item'),
            // No I18N
        // data = menuItem[0].itemData;
        data = this._getData(menuItem);

        if (data.hasSubmenu && !this._handleMouseLeaveOnSubmenuItem(menuItem, event)) {
          return;
        }

        var lastOver = this._lastOverlayedMenuItem; // fix for the combination of mouse and key alternative usages

        if (!menuItem.hasClass('on-hover') && lastOver && lastOver[0] !== menuItem[0]) {
          // No I18N
          menuItem = lastOver;
        }

        this._updateHoverState(menuItem, false, data);

        this._lastOverlayedMenuItem = undefined;
      }
    }, {
      key: "_mouseupHandler",
      value: function _mouseupHandler(event) {
        if (event.which === 3 && !$(event.target).closest('.zmenu--withlink').length) {
          // No I18N
          // context menu event bubbles up mouseup event for menu items if enough space is not present for the contextual menu. Issue faced in sheet & code team.
          return;
        }

        var menuItem = $(event.target).closest('.zmenu__item'); // No I18N

        if (!menuItem.length) {
          return;
        } // let data = menuItem[0].itemData,


        var data = this._getData(menuItem),
            iType = data.itemType;

        if (data.disabled || iType === 'itemgroup' || iType === 'separator') {
          // No I18N
          return;
        }

        var click = data.action;

        if (click) {
          var args = [menuItem, event, {
            menuitem: menuItem,
            options: data
          }];

          if (typeof click === 'string' && click.indexOf('URL:') === -1) {
            // No I18N
            ZC._triggerFunction(click, args[0], args.splice(1)); // function names given as strings will be handled here

          } else if (typeof click === 'function') {
            // No I18N
            click.call(args[0], args[1], args[2]);
          }
        }

        var triggerFunc = this._triggerEvent.bind(this);

        if (iType === 'radio' || iType === 'checkbox') {
          // No I18N
          if (triggerFunc('beforeitemchecked', event, undefined, menuItem, data)) {
            this._checkMenuItem(menuItem, iType === 'checkbox' ? !data.checked : true, data); // No I18N

          }
        }

        var menu = menuItem.closest('.zmenu'); // No I18N

        if (triggerFunc((menu.data('parent') ? 'submenu' : '') + 'itemclick', event, menu, menuItem, data)) {
          // No I18N
          (!data.hasSubmenu || data.itemType === 'splitmenu') && this.hide(undefined, event); // No I18N
        }
      }
    }, {
      key: "handleKeyCode",
      value: function handleKeyCode(event) {
        // This method is made public to use in other dependency components like menubutton, selectbox & etc.
        this._lastOverlayedMenu = this._lastOverlayedMenu || this.element;
        var key = ZC.keyCode,
            code = event.keyCode,
            navigationKeys = [key.UP, key.DOWN, key.RIGHT, key.LEFT],
            prevHover = this._lastOverlayedMenuItem,
            action;

        if (code === key.ENTER || code === key.SPACE) {
          event.target = $(this._lastOverlayedMenuItem); // target is modified since actual target will be menu element.

          this._mouseupHandler(event);
        } else if (code === key.ESCAPE && !this._opts.renderInPlace) {
          if (this._lastOverlayedMenu[0] === this.element[0]) {
            this.hide();
          } else {
            this._hideLastShownMenu();
          }
        } else if (navigationKeys.indexOf(code) > -1 || code === key.PAGE_UP || code === key.PAGE_DOWN) {
          action = Object.keys(key).find(function (lhs) {
            return key[lhs] === code;
          }).replace('_', '').toLowerCase(); // No I18N
        } else if (this._labelList.length && this._opts.handleAccessKeyNavigation) {
          this._callMenuitemSearch(String.fromCharCode(code), +new Date());
        }

        if (action) {
          this._navigate(action, event); // No I18N

        } // Keydown event triggering is added inorder to implement MAC menu bar like behavior.


        var hoveredItem = this._lastOverlayedMenu.find('.on-hover'),
            containsSubmenu = false;

        if (hoveredItem.length && (!prevHover || prevHover && prevHover[0] !== hoveredItem[0])) {
          // let submenu = hoveredItem[0].itemData.submenu; // No I18N
          var submenu = this._getData(hoveredItem).submenu; // No I18N


          containsSubmenu = submenu && submenu.length;

          if (!containsSubmenu && prevHover) {
            containsSubmenu = this._lastOverlayedMenu.data('parent') && this._lastOverlayedMenu.data('forElement')[0] === prevHover[0];
          }
        }

        event && event.type === 'keydown' && !containsSubmenu && this._triggerEvent('KEYDOWN', event, this.element); // No I18N

        if (this._isNonModifier(event) && navigationKeys.indexOf(code) > -1) {
          // checking whether the key pressed is a short cut key or not. Shortcutkey events should not be prevented.
          return false; // preventing default and stopping propagation.
        }
      }
    }, {
      key: "_isNonModifier",
      value: function _isNonModifier(event) {
        return !event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey;
      }
    }, {
      key: "_navigate",
      value: function _navigate(key, event) {
        var menu = this._lastOverlayedMenu || this.element,
            list = menu.find(this._SELECTORS.visibleItems),
            nextItem,
            mEvent = 'mouseenter',
            // No I18N
        length = list.length,
            isGridMenu = this._isGridMenu(menu),
            // No I18N
        isRightLeft = key === 'right' || key === 'left',
            // No I18N
        item = this._lastOverlayedMenuItem || menu.find('.on-hover'); // No I18N


        if (key === 'pageup') {
          // No I18N
          nextItem = list[0];
        } else if (key === 'pagedown') {
          // No I18N
          nextItem = list[length - 1];
        } else if (key === 'down' || key === 'up' || isRightLeft && menu[0] === this.element[0] && !item.find('.zmenu__icon.zh-alignright').length) {
          // No I18N
          if (!item || !item.length) {
            // first item has to be hovered if there is no hovered item.
            $(list[key === 'down' || key === 'right' ? 0 : list.length - 1]).trigger(mEvent, [event]); // No I18N

            return;
          }

          var pName = item.closest('.zmenu__header').length ? 'header' : item.closest('.zmenu__footer').length ? 'footer' : 'body'; // No I18N

          nextItem = this[isGridMenu ? '_gridNavigation' : '_navigation'](key, pName); // No I18N
        } else if (isRightLeft && this._openCloseSubmenu) {
          // No I18N
          return this._openCloseSubmenu(key, event);
        }

        $(nextItem).length && $(nextItem).trigger(mEvent, [event]);
      }
    }, {
      key: "_navigation",
      value: function _navigation(key, portion) {
        var menu = this._lastOverlayedMenu || this.element,
            itemSel = this._SELECTORS.visibleItems,
            mPre = '.zmenu__',
            // No I18N
        list = menu.find("".concat(portion !== 'body' || menu.find(mPre + 'body').length ? mPre + portion + ' ' : '').concat(itemSel)),
            // No I18N
        item = this._lastOverlayedMenuItem || menu.find('.on-hover'),
            // No I18N
        index = list.index(item),
            prevSec,
            nextSec,
            parts = this.parts,
            // No I18N
        pIndex = parts.indexOf(portion),
            isUp = key === 'up',
            // No I18N
        isDown = key === 'down',
            // No I18N
        sectionOrder = [];
        prevSec = parts[pIndex === 0 ? pIndex + 2 : pIndex - 1];
        nextSec = parts[pIndex === 2 ? pIndex - 2 : pIndex + 1];

        if (isUp && index === 0) {
          // item to focus is present in prev section or next section
          sectionOrder.push(prevSec, nextSec);
        } else if (isDown && index >= list.length - 1) {
          // item to focus is present in next section or prev section
          sectionOrder.push(nextSec, prevSec);
        }

        if (isUp || isDown) {
          if (sectionOrder.length) {
            nextSec = menu.children(mPre + sectionOrder[0]).length ? sectionOrder[0] : menu.children(mPre + sectionOrder[1]).length ? sectionOrder[1] : null;

            if (nextSec) {
              list = menu.find("".concat(mPre).concat(nextSec, " ").concat(itemSel));
            }

            index = isUp ? list.length - 1 : 0;
          } else {
            index += isUp ? -1 : 1;
          }
        } else {
          return;
        }

        return list[index];
      }
    }, {
      key: "getData",
      value: function getData() {
        // having this as public method to fetch the data of submenu in main menu
        return this._data;
      }
    }, {
      key: "_getData",
      value: function _getData(item, remove) {
        // No I18N
        if (!item.length) {
          return {};
        }

        var uKey = item.attr('data-unique-key'),
            // No I18N
        itemParent = item.parent(),
            // itemParent length is added since removeMenuItem might be called after removing the element from the DOM - web component case.
        sectionName = !itemParent.length || itemParent.hasClass('zmenu__body') || itemParent.hasClass('zmenu') ? 'items' : itemParent.hasClass('zmenu__footer') ? 'footerItems' : 'headerItems',
            // No I18N
        // closest zmenu will not be present for custom element removal case.
        cMenu = itemParent.closest('.zmenu'),
            // No I18N
        pMenu = cMenu.length ? cMenu : this.element,
            items = ZC.menu(pMenu).getData()[sectionName],
            // Submenu Items Datas might also be needed.
        len = items.length;

        for (var j = 0; j <= len - 1; j++) {
          if (items[j].uniqueKey === uKey) {
            if (remove) {
              delete items[j];
              items.splice(j, 1);
              len = len - 1;
            } else {
              return items[j];
            }
          }
        }
      }
    }, {
      key: "_removeData",
      value: function _removeData(item) {
        this._getData(item, true);
      }
    }, {
      key: "_fixMenuUI",
      value: function _fixMenuUI(menu, options, isSubMenu) {
        if (!menu.is(':visible')) {
          return;
        }

        this._fixMenuHeight(menu, options || {}, isSubMenu);
      }
    }, {
      key: "_fixMenuHeight",
      value: function _fixMenuHeight(menu) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var isSubMenu = arguments.length > 2 ? arguments[2] : undefined;
        var menuHeight = 'auto',
            // No I18N
        menuOpts = isSubMenu ? ZC.menu(menu).getAttributes() : this._opts,
            opts = this._opts,
            menuBody = menu.find('.zmenu__body'),
            actualMenu = menuBody.length ? menuBody : undefined;
        menu.height(menuHeight);
        actualMenu && actualMenu.height(menuHeight);
        var positionAlterable = opts.direction === 'auto' || opts.direction === 'at-cursor',
            // No I18N
        height = menu.outerHeight(),
            top = parseInt(menu.css('top').split('px')[0] * 1 - $(window).scrollTop()) || 0,
            // No I18N
        windowHeight = ZC.windowObject ? ZC.windowObject.height : $(window).height(),
            // window object stored on the ZC is undefined sometimes while trying to show the menu on load events.So included $(window).height()
        openingDirection = options.direction,
            // menuOpts direction value remains auto
        availableHeight = options.availableHeight,
            isContextMenu = options.isRightClick,
            limit = openingDirection && (openingDirection.indexOf('bottom') === 0 || openingDirection.indexOf('top') === 0) ? isContextMenu ? windowHeight : availableHeight : windowHeight,
            // No I18N
        space = limit - height;

        if (isContextMenu) {
          // 2px is added since in show method, 2px will be added for the right click menu.
          top += 2;
        }

        if (top + height >= limit && space < 0 || !positionAlterable) {
          menuHeight = isContextMenu ? windowHeight - top : availableHeight;
        }

        var specHeight = parseInt(menuOpts.height);

        if (specHeight) {
          menuHeight = specHeight >= availableHeight ? availableHeight : specHeight;
        } else if (space > 0 && positionAlterable) {
          menuHeight = height;
        } // slider type scroll is applicable only to container type elements.


        var sliderType = opts.scroll === 'slider' && actualMenu,
            // No I18N
        scrollCls = sliderType ? 'zh-overflowhidden' : 'zh-scroll_y',
            // No I18N
        isGreater = false;

        if (height > menuHeight) {
          isGreater = true;

          if (actualMenu) {
            var headerEle = menu.find('.zmenu__header'),
                footerEle = menu.find('.zmenu__footer'),
                // No I18N
            headerHeight = headerEle.length ? parseInt(headerEle.outerHeight(true)) : 0,
                footerHeight = footerEle.length ? parseInt(footerEle.outerHeight(true)) : 0,
                menuPadding = parseInt(menu.css('padding-top')) + parseInt(menu.css('padding-bottom')),
                // No I18N
            menuBorder = parseInt(menu.css('border-top-width')) + parseInt(menu.css('border-bottom-width')),
                // No I18N
            // menu padding is included since padding top and padding bottom is set as 5px each for list type menus.
            remaining = menuBorder + headerHeight + menuPadding + (footerEle.length > 1 ? footerEle.length * footerHeight : footerHeight); // No I18N
            // we might have two footer containers if the menu containing search box opens at the top position

            actualMenu.innerHeight(menuHeight - remaining);
          }

          menu.outerHeight(menuHeight); // setting height after menu body's height calculation because retrieving the footer/header elements height after setting the height returns incorrect values.
        }

        sliderType && this[(isGreater ? '_' : '_un') + 'initSliders'](menu);
        (actualMenu || menu)[isGreater ? 'addClass' : 'removeClass'](scrollCls); // No I18N
      }
    }, {
      key: "_resetLabels",
      value: function _resetLabels(menu) {
        // used for access key navigation
        this._opts.handleAccessKeyNavigation && this._refreshLabelArray(menu);
      }
    }, {
      key: "setLastOverlayedMenu",
      value: function setLastOverlayedMenu(menu, isExternal) {
        this._lastOverlayedMenu = menu;

        if (!isExternal && menu[0] !== this.element[0]) {
          this._setLastOverlayedSubMenu(menu);
        }
      }
    }, {
      key: "_findMain",
      value: function _findMain() {
        var menu = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.element;
        return (menu.data('parent') ? this._findParentMenu(menu) : menu).closest('.zmenu'); // No I18N
      }
    }, {
      key: "show",
      value: function show(options, menu) {
        // submenu will be passed as the second argument
        options = options ? Object.create(options) : {};
        var opts = this._opts,
            appendedTo = $(options.appendTo || opts.appendTo),
            forElement = $(options.forElement || opts.forElement),
            isSubMenu = options.isSubMenu = !!menu,
            inPlace = opts.renderInPlace,
            pos = options.position;
        menu = menu || this.element; // If menu is undefined, then it means it is the base menu.
        // forElement is set before itself to make it available in beforeshow events.

        menu.data('forElement', forElement); // No I18N
        // getAttributes is taking longer time. Since it is not needed for main menu included this check.

        var menuOpts = isSubMenu ? ZC.menu(menu).getAttributes() : this._opts,
            isGrid = this._isGridMenu(menu),
            offsetValue = options.offset || opts.offset || undefined,
            existingForElement = menu.data('forElement') || '',
            // No I18N
        isSameForElement = forElement && existingForElement[0] === forElement[0],
            isVisible = menu.is(':visible'),
            // No I18N
        retainFocus = isVisible && options.mustBeShown;

        if (isSameForElement && isVisible && !options.mustBeShown) {
          if (opts.toggle && !isSubMenu) {
            // toggling the menu whenever toggle option is set to true.
            this.hide();
          }

          return;
        }

        var dataProps = {};

        if (isSubMenu) {
          dataProps.parent = forElement;
        } else if (opts.handleAccessKeyNavigation) {
          this._bindRuntimeEvents();
        } // Revisit - Reason for appending menu everytime on show ?


        if ((!inPlace || isSubMenu) && !options.mustBeShown) {
          (appendedTo && appendedTo.length ? appendedTo : $('body'))[0].appendChild(menu[0]); // No I18N
        }

        var vp = opts.viewport;

        if (vp) {
          vp = vp === 'window' ? ZC.$window : vp === 'document' ? ZC.$document : $(vp); // No I18N

          options.within = vp;
        }

        options.within = options.within || (appendedTo.length ? appendedTo : undefined);
        this.setLastOverlayedMenu(menu);
        options.withinPadding = 8; // 8px gap should be maintained between the menu element and the window similar to OS right click menu's.

        if (!isGrid && !inPlace) {
          menu.width('auto'); // No I18N
        }

        if (inPlace) {
          menu.addClass('zmenu--inline'); // No I18N

          this._display(undefined, menu);

          this._handleMenuOpen(menu, isSubMenu, options);
        } else {
          var dirPassed = options.direction,
              dir = opts.direction,
              isContextMenu = options.isRightClick,
              minW = 0,
              actualWidth = 0;
          ZC.bindDocumentEvents && ZC.bindDocumentEvents({
            element: menu,
            forElement: isContextMenu ? undefined : forElement,
            ctype: this.name,
            closeMethodName: 'hide',
            // No I18N
            closeEvent: 'hide' // No I18N

          });
          var originalEvent = options.event || {};
          isContextMenu = isContextMenu || (dirPassed || dir) === 'at-cursor'; // No I18N

          if (!this._triggerEvent(isSubMenu ? 'beforesubmenushow' : 'beforeshow', originalEvent, menu, undefined, {
            currentTarget: isContextMenu ? originalEvent.target : forElement
          })) {
            // No I18N
            return;
          }

          !retainFocus && this._display(undefined, menu).css('opacity', '0'); // No I18N

          actualWidth = menu.outerWidth();
          var sel = this._SELECTORS; // Revisit - Ask sheik whether anything could be done with CSS

          if (menuOpts.width) {
            // No I18N
            minW = parseInt(menuOpts.width); // No I18N

            if (actualWidth > minW) {
              // finding the maximum shortcut key's width
              var shortcutCls = '.zmenu__shortcut',
                  // No I18N
              maxWidth; // No I18N
              // Revisit - Add shortkey check & change the below selector - By Raju

              if (this._data.hasShortcut) {
                // Iterating over each item is costlier hence items with shortcut keys alone are iterated.
                maxWidth = this._data.shortcutItems.forEach(function (id) {
                  return $('#' + id).find(shortcutCls).outerWidth(true) || 0;
                });
              } // maxWidth = menu.find(sel.item).toArray().map((item) => parseInt($(item).find(shortcutCls).outerWidth(true)) || 0); // returns array


              maxWidth = Math.max.apply(null, maxWidth);

              if (maxWidth) {
                // should not set 100% to text span
                menu.find("".concat(sel.item, ":not(.zmenu__title) .zmenu__text")).css('width', "calc(100% - ".concat(maxWidth, "px)")); // No I18N
              }
            }

            menu.width(minW);
          } else if (actualWidth < parseInt(menuOpts.minWidth) && menuOpts.contentType !== 'icon' || options.minWidth && actualWidth < parseInt(options.minWidth)) {
            // No I18N
            // min-width for menu.
            // Subtract border width if box-sizing is menu's box-sizing is border-box. 1px is added extra by default while setting width. So subtracted 1px.
            minW = options.minWidth && actualWidth < parseInt(options.minWidth) ? options.minWidth : menuOpts.minWidth; // providing minWidth option in show method inorder to use in selectbox component's icon only menu.

            menu.outerWidth(parseInt(minW) - 1); // outerWidth should be set since for calculation, we are considering only outerWidth.
          } // To consider width in floating numbers, added 1px to innerWidth value.


          menu.width(menu.innerWidth() + 1);
          var hasScroll = false;

          if (isGrid) {
            this._fixGridMenuWidth(menu); // Fixing the width of grid type menu.

          }

          menu.css('height', 'auto'); // No I18N

          var bodyEle = menu.find(sel.menu);
          bodyEle.length && bodyEle.css('height', 'auto'); // No I18N

          if (menuOpts.height && parseFloat(menuOpts.height) <= menu.outerHeight()) {
            // No I18N
            // Fixing the menu height,which is provided in the option only if it is less than actual height of the menu
            menu.outerHeight(parseInt(menuOpts.height)); // No I18N

            hasScroll = true;
          }

          options.rtl = menuOpts.rtl;
          var utilRes;

          if (!pos) {
            var dirMap = this._DIRECTIONS,
                defaultDir = isContextMenu ? opts.displayType === 'callout' ? dirMap.pointer : dirMap.menu : dirPassed || dir; // No I18N

            options.direction = dirPassed ? dirPassed === 'auto' ? defaultDir : dirPassed : isSubMenu ? dirMap.submenu : dir === 'auto' ? defaultDir : dir; // No I18N

            /* if direction is at-cursor, we should not place the menu to the left or right of the target */

            options.positionAlterable = (dir === 'at-cursor' || isContextMenu) && !isSubMenu ? 'fit' : options.positionAlterable || opts.positionAlterable || (isSubMenu ? 'flipfit' : dir === 'auto' || dir === 'at-cursor'); // No I18N

            if (_typeof(pos) !== 'object') {
              // No I18N
              if ((opts.pointer || opts.displayType === 'callout') && !isSubMenu) {
                // No I18N
                // Revisit - Could be _getCalloutData
                options = this._getCalloutDetails(options);
              }

              dataProps.isRightClick = options.isRightClick = isContextMenu;
              options.withinPadding = 8; // 8px gap should be maintained between the menu element and the window similar to OS right click menu's.
              // Revisit - If arrow is the only object that is included, it can be put straight as such.

              utilRes = ZC.Position.get(isContextMenu && !isSubMenu ? originalEvent : forElement, menu, $.extend({}, {
                arrow: {
                  element: isSubMenu ? null : this._pointerElement,
                  callback: options.arrowCallback
                }
              }, options), this._pointerElement || undefined); // No I18N

              options.availableHeight = utilRes.availableHeight; // used in fixmenuUI method

              pos = utilRes.elementPosition;
              pos.direction = dataProps.direction = utilRes.actualDirection;

              if (this._pointerElement && !isSubMenu) {
                var arrowPos = utilRes.arrowPosition;

                if (offsetValue) {
                  // There are only 2 conditions, hence regeex is remvoed.
                  var arrowDirection = utilRes.arrowDirection;

                  if (arrowDirection === 'top' || arrowDirection === 'bottom') {
                    // adjust left position.
                    arrowPos.left -= offsetValue.left;
                  } else {
                    // adjust top position.
                    arrowPos.top -= offsetValue.top;
                  }
                } // Revisit - Could be this._callout. Smaller names can be preferred


                this._pointerElement.css(arrowPos);
              } else {
                pos = this._alterBorderRadius({
                  element: menu,
                  forElement: forElement,
                  hasSideAlignment: isSubMenu,
                  offset: pos,
                  direction: utilRes.actualDirection
                });
              }
            }

            if (offsetValue) {
              pos.top += parseInt(offsetValue.top) || 0;
              pos.left += parseInt(offsetValue.left) || 0; // parseInt(undefined) will be NaN
            }
          }

          dataProps.positionOpts = Object.create(options); // Passed a third argument to ensure whether it is a submenu

          this._fixMenuUI(menu, options, isSubMenu);

          hasScroll = (hasScroll || menu.hasClass('zh-scroll_y') || menu.find('.zh-scroll_y').length) && opts.scroll !== 'slider'; // No I18N

          if (hasScroll) {
            // fixing the width of list type menu/grid menu whose height doesn't fit into viewport.
            var incValue = 0,
                sWidth = this.scrollWidth;

            if (minW) {
              /* Fix for having ellipsis in select boxes due to minWidth provided by them. */
              if (minW - actualWidth < sWidth + 1) {
                // 1px is included in the calculation to include default scrollbar border. If scrollbar is present within the menu, scroll border width has to be added.
                incValue = actualWidth + sWidth + 1 - minW;
              }
            } else {
              incValue = sWidth;
            }

            var actualDirection = utilRes.actualDirection;

            if (pos && (actualDirection === 'bottom-right' || actualDirection === 'top-right')) {
              // since position utility calculates the left value based on the previously set width, we have to adjust the left value by the newly incremented width value.
              pos.left -= incValue;
            }

            menu.width(menu.innerWidth() + incValue);
          }

          if (pos) {
            if (isContextMenu) {
              /* Adjusting two pixel for right click menu's since mouseup events will not be triggered for the clicked portions if we open the menu in the same location as that of cursor. */
              var isRtl = options.rtl;
              pos.top += isRtl ? -2 : 2;
              pos.left += isRtl ? -2 : 2;
            } // Since offset is recalculating the style, saved its value.


            this._offset = pos;
            menu.css(pos);
          }

          if (!retainFocus) {
            this._display(true, menu); // hiding the menu


            menu.css('opacity', ''); // No I18N
            // resetting the opacity
          }
        }

        menu.data(dataProps);
        options.position = pos;
        this._pointerElement && this._pointerElement.hide(); // setFocus is called after setting menu's position to retrieve its value (this._offset) in the triggerEvent that is called inside _setFocus method

        this._setFocus();

        if (ZC.isEmpty(opts.animation) || !opts.animation.open) {
          !retainFocus && this._display(undefined, menu);
          this._pointerElement && this._pointerElement.show();

          this._handleMenuOpen(menu, isSubMenu, options);
        } else {
          this._openWithAnimation(menu, options);
        }

        return options;
      }
    }, {
      key: "_handleMenuOpen",
      value: function _handleMenuOpen(menu, isSubMenu, options) {
        this._resetLabels(menu);

        this._triggerEvent((isSubMenu ? 'submenu' : '') + 'show', options.event, menu, undefined, {}); // No I18N

      }
    }, {
      key: "selectHoveredMenuItem",
      value: function selectHoveredMenuItem() {
        var item = this._lastOverlayedMenuItem;
        item && $(item).trigger('mouseup'); // Trigger method is used since event object is not present. Event object is mandatory in this case to use event.preventDefault and event.stopPropagation methods.
        // Hiding the menu is not needed here because menu hide can be prevented using itemclick event.

        return item;
      }
    }, {
      key: "hoverMenuItem",
      value: function hoverMenuItem(item) {
        item = $(item);

        if (!item.length) {
          item = this._lastOverlayedMenuItem;
          item && this._updateHoverState(item, false);
          this._lastOverlayedMenuItem = undefined;
          return;
        }

        this._mouseenterHandler({
          target: item[0]
        });
      }
    }, {
      key: "_updateHoverState",
      value: function _updateHoverState(item, setHover) {
        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._getData(item);
        // hoverClass addition and removal should be updated in data object too
        var hoverCls = 'on-hover'; // No I18N

        item[(setHover ? 'add' : 'remove') + 'Class'](hoverCls); // No I18N

        data.className = setHover ? data.className + ' ' + hoverCls : data.className.replace(/on-hover/g, ''); // No I18N
      }
    }, {
      key: "_isGridMenu",
      value: function _isGridMenu() {
        var menuOrMenuItem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.element;
        var isMenuItem = arguments.length > 1 ? arguments[1] : undefined;
        var menu = isMenuItem ? menuOrMenuItem.closest('.zmenu') : menuOrMenuItem; // No I18N

        if (menu.length) {
          var thumbCls = 'zmenu--thumbnail'; // No I18N

          return this.getMenuType(menu) === 'grid' || menu.hasClass(thumbCls) || menu.find('.' + thumbCls).length; // No I18N
        }
      }
    }, {
      key: "getMenuType",
      value: function getMenuType(menu) {
        return menu && menu.data('isExternalSubmenu') ? menu.zmenu('getMenuType') : this._opts.type; // No I18N
      }
    }, {
      key: "getMenuItemAt",
      value: function getMenuItemAt(index) {
        var menu = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.element;
        var returnAsObj = arguments.length > 2 ? arguments[2] : undefined;
        var item = menu.find(".zmenu__item:eq(".concat(index, ")"));
        return returnAsObj ? this._getData(item) : item;
      }
    }, {
      key: "_setFocus",
      value: function _setFocus() {
        var _this38 = this;

        clearTimeout(this._focusTimer);

        if (this._triggerEvent('beforefocus', {})) {
          // No I18N
          this._focusTimer = setTimeout(function () {
            return _this38.element.focus();
          }, 100);
        }
      }
    }, {
      key: "callRender",
      value: function callRender() {
        this._render();
      }
    }, {
      key: "hide",
      value: function hide() {
        var menu = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.element;
        var event = arguments.length > 1 ? arguments[1] : undefined;
        var opts = this._opts;

        if (opts.renderInPlace || menu.is(':hidden')) {
          // No I18N
          return;
        }

        var ele = this.element,
            menuPar = menu.data('parent'),
            // No I18N
        isSubMenu = !!(menu[0] !== ele[0] || menuPar && menuPar.is('.zmenu__item') && !event); // No I18N

        if (this._triggerEvent((isSubMenu ? 'beforesubmenu' : 'before') + 'hide', event, menu)) {
          // No I18N
          // closing the main menu whenever hide method for submenu is called from close handler should be prevented. So, event & parent check is included - fix for annotator.
          if (!isSubMenu) {
            this._hideParentMenu(menu);

            this._unbindRuntimeEvents();
          }

          var hoverCls = 'on-hover',
              // No I18N
          items = $("".concat(this._SELECTORS.item, ".").concat(hoverCls), menu),
              item;

          for (var i = 0; i < items.length; i++) {
            item = $(items[i]);

            if (item.is('.zmenu--split')) {
              // No I18N
              item.find('.zmenu__icon.zh-alignright').removeClass(hoverCls);
            }

            this._updateHoverState(item, false);
          }

          if (menu[0] === ele[0]) {
            this._lastOverlayedMenuItem = undefined;
          } else {
            this.setLastOverlayedMenu(menuPar.parent()); // No I18N
          }

          if (ZC.isEmpty(opts.animation)) {
            this._display(true, menu);

            this._handleMenuClose(menu, isSubMenu, event);
          } else {
            this._closeWithAnimation(menu, isSubMenu, event);
          }

          this._isToBeDelayed = false;
        }
      }
    }, {
      key: "_handleMenuClose",
      value: function _handleMenuClose(menu, isSubMenu, event) {
        !isSubMenu && this._isContainer && this._opts.scroll === 'slider' && this._uninitSliders(menu); // No I18N
        // If h-scroll_y class presents, retrieving width returns value with scrollbar width. So, removing the classes here.

        var scrollCls = 'zh-scroll_y'; // No I18N

        menu.removeClass(scrollCls).find('.' + scrollCls).removeClass(scrollCls); // No I18N

        this._alterBorderRadius({
          element: menu,
          forElement: menu.data('forElement') // No I18N

        }, true); // true is passed to clear the already changed border-radius


        this._resetLabels(menu);

        this._triggerEvent((isSubMenu ? 'submenu' : '') + 'hide', event, menu); // No I18N

      }
    }, {
      key: "_triggerEvent",
      value: function _triggerEvent(type) {
        var event = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var menu = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.element;
        var item = arguments.length > 3 ? arguments[3] : undefined;
        var dataObj = arguments.length > 4 ? arguments[4] : undefined;
        item = item || $(event.target).closest('.zmenu__item');
        var hasItem = item.length,
            isBase = menu[0] === this.element[0],
            data = {
          originalEvent: event,
          forElement: menu.data('forElement'),
          // No I18N
          // Need to remove target option
          target: menu.data('forElement'),
          // No I18N
          // offset is re-calculating style
          offset: this._offset || menu.offset(),
          menu: menu,
          isBaseMenu: isBase,
          menuitem: item,
          data: hasItem ? dataObj : undefined,
          itemValue: hasItem && dataObj && dataObj.itemValue // No I18N

        };

        if (dataObj) {
          data = $.extend(true, {}, dataObj, data);
        }

        if (type.indexOf('submenu') !== -1) {
          // No I18N
          return this._triggerEventToSubmenu(type, event, data, menu);
        }

        return this._dispatchEvent(type, event, data, menu);
      }
    }, {
      key: "triggerEvent",
      value: function triggerEvent() {
        // used by submenu to trigger event to main menu
        return this._dispatchEvent.apply(this, arguments);
      }
    }, {
      key: "_getLayout",
      value: function _getLayout(layoutName) {
        return this.isCE ? 'WC' + layoutName.replace(/./, function ($0) {
          return $0.toUpperCase();
        }) : layoutName; // No I18N
      }
    }, {
      key: "setMenuItemsAttribute",
      value: function setMenuItemsAttribute(menuItems, optionName, value, skipRender) {
        // ## optionName can support array of options to avoid multiple renders.
        this._addedByComponent = true;
        var unparsedProps = ['itemValue', 'action', 'disabled', 'checked', 'hidden', 'className', 'menuId', 'description', 'label', 'SVGIconId', 'iconClassName'],
            // No I18N
        itemData,
            opts = this._opts;

        for (var i = 0, menuItem; i < menuItems.length; i++) {
          menuItem = $(menuItems[i], this.element);

          if (menuItem.length) {
            itemData = this._getData(menuItem); // returns data found in this._data
            // Revisit - itemData[optionName] is assigned at multiple places, assign once by doing the necessary processing

            if (itemData.itemType === 'itemgroup' && optionName !== 'itemgroup') {
              // No I18N
              var groupItems = $("[name=".concat(menuItem.attr('name'), "]:not(.zmenu__title)"), this.element); // No I18N

              groupItems.length && this.setMenuItemsAttribute(groupItems, optionName, value);
            }

            if (unparsedProps.indexOf(optionName) !== -1) {
              if (optionName === 'checked' && itemData.checked && value === '') {
                // No I18N
                // Fix for Web Component case attributeChangedCallback triggers if checked attribute is set on the z-menuitem element.
                value = 'checked'; // No I18N
              }

              itemData[optionName] = value;
            }

            if (optionName === 'customAttributes') {
              // No I18N
              // custom attributes added for select box requirement.
              itemData.attrs = $.extend(true, {}, itemData.attrs || {}, value);
            } else if ((optionName === 'innerHTML' || optionName === 'zinnerHTML') && (itemData.itemType === 'custom' || itemData.custom)) {
              // No I18N
              itemData.innerHTML = opts.isCustomHTMLEncoded ? value : ZC.encodeHTML(value); // should be used only in custom menu item;
            } else if (optionName === 'shortcutKey') {
              // No I18N
              value = window.ZShortCut ? ZShortCut.getInfo(itemData.action, menuItem, true) : value;
              itemData[optionName] = value;
            } else if (optionName === 'itemType') {
              // No I18N
              var iType = itemData.itemType;
              itemData.className = itemData.className.replace(ZMenu._ITEM_TYPES[iType === 'radio' || iType === 'checkbox' ? 'default' : iType], ''); // No I18N;

              if (iType === 'radio' || iType === 'checkbox') {
                // No I18N
                this._clearRadioCheckboxData(itemData);
              }

              itemData[optionName] = value;
            } else if (optionName === 'checked') {
              // No I18N
              // Other radio item's data has to be updated as well as prop set on that item should be updated.
              this._handleRadioItem(menuItem, itemData.checked, itemData, true);
            } else if (optionName === 'menuId' && itemData.submenu) {
              itemData.submenu = null;
            }

            itemData = this._getItemDetails(itemData, opts, undefined, true); // skipRender added for performance reasons.

            if ((optionName !== 'itemValue' || optionName !== 'action') && !skipRender) {
              // No I18N
              this._addedByComponent = this.isCE;

              this._render();
            }
          }
        }

        this._addedByComponent = false;
      }
    }, {
      key: "addMenuItems",
      value: function addMenuItems(menuItemArray, itemCallback, skipHeightFix) {
        // menuItem details are given as json object.
        // skipHeightFix - added for selectbox component since addMenuItems will be called during scroll.
        return this._fetchAndRender(menuItemArray, itemCallback, true, skipHeightFix);
      }
    }, {
      key: "replaceMenuItems",
      value: function replaceMenuItems(menuItemArray, replaceCallback, skipHeightFix) {
        var data = this._data;

        this._removeCustomAttrs(menuItemArray);

        data.headerItems = data.footerItems = data.items = [];
        var lastOverlayed = this._lastOverlayedMenuItem;

        if (lastOverlayed && lastOverlayed.length) {
          lastOverlayed.removeClass('on-hover'); // No I18N
        }

        this._lastOverlayedMenuItem = null;
        this._itemsHavingAttrs = [];
        return this._fetchAndRender(menuItemArray, replaceCallback, undefined, skipHeightFix);
      }
    }, {
      key: "_fetchAndRender",
      value: function _fetchAndRender(menuItemArray, callback, concat, skipHeightFix) {
        // concat denotes whether concating the data is needed or not
        var itemsObj = this._fetchItemDetails(menuItemArray, concat);

        return this._invokeRender(callback, itemsObj, undefined, undefined, skipHeightFix); // rendered items will be returned from here.
      }
    }, {
      key: "_removeCustomAttrs",
      value: function _removeCustomAttrs(itemsObj) {
        var portions = this.parts,
            pName,
            data,
            newData;

        for (var k = 0; k < 3; k++) {
          pName = portions[k];
          data = this._data[k === 1 ? 'items' : pName + 'Items']; // No I18N

          newData = itemsObj[pName];

          if (newData && data && data.length) {
            this._removeCustomAttrsOf(data, newData);
          }
        }
      }
    }, {
      key: "_removeCustomAttrsOf",
      value: function _removeCustomAttrsOf(items, itemsObj) {
        if (!items || !items.length) {
          return;
        }

        var iData, attrs;

        for (var i = 0; i < items.length && i < itemsObj.length; i++) {
          iData = items[i];

          if (this._itemsHavingAttrs.indexOf(iData.id) !== -1) {
            attrs = iData.customAttributes;

            if (attrs) {
              // checkbox items will also be present in the array to update their checked prop.
              Object.keys(attrs).forEach(function (key) {
                attrs[key] = null;
              });
              itemsObj[i].customAttributes = $.extend(true, {}, attrs, itemsObj[i].customAttributes);
            }
          }
        }

        this._itemsHavingAttrs = [];
      }
    }, {
      key: "_invokeRender",
      value: function _invokeRender(callback, itemsObj, viaAddMenuItem, viaRemoveMenuItems, skipHeightFix) {
        var ele = this.element,
            isCE = this.isCE;

        if (isCE) {
          this._addedByComponent = true;
        }

        this._isContainer && this._updateSectionCls(this._opts.type === 'grid', this._data); // No I18N

        if (this._opts.allowReplace || viaRemoveMenuItems) {
          this._render();
        } else {
          // we have to iterate over all items in each section.
          var parts = this.parts,
              pName,
              section,
              secEle; // No I18N

          for (var i = 0; i < 3; i++) {
            pName = i === 1 ? 'items' : parts[i] + 'Items'; // No I18N

            if (this._data[pName]) {
              section = this._data[pName];
              secEle = this.element.find('.zmenu__' + parts[i]);
              secEle = !secEle.length && i === 1 ? this.element : secEle;

              if (secEle.length) {
                this._render(section, 'items', this.element.find('.zmenu__' + parts[i])[0]);
              } else {
                this._render();
              }
            }
          }
        }

        if (isCE) {
          this._addedByComponent = false;
        }

        var menuItems = [];

        if (itemsObj) {
          menuItems = viaAddMenuItem ? $('#' + itemsObj.id) : this[this._isContainer ? '_setCustomAttrsForItems' : '_setCustomAttrsForItem'](itemsObj); // No I18N
        }

        if (callback) {
          callback(menuItems, itemsObj); // need to decide the arguments.
        }

        if (!skipHeightFix) {
          this._fixMenuUI(ele, ele.data('positionOpts')); // No I18N

        }

        this._resetLabels(ele);

        return menuItems;
      }
    }, {
      key: "_fetchItemDetails",
      value: function _fetchItemDetails(menuItemArray, concatNeeded) {
        // menuItemArr can be Array of Objects/ a single object containing header, footer and body keys
        var itemsObj = {
          items: [],
          headerItems: [],
          footerItems: []
        },
            data = this._data,
            menuItemArr = menuItemArray instanceof $ ? menuItemArray : Object.create(menuItemArray),
            itemData,
            len = menuItemArr.length,
            i,
            opts = this._opts,
            secName;

        if (menuItemArr instanceof Array) {
          for (i = 0; i < len; i++) {
            itemData = this._getItemDetails(menuItemArr[i], opts);
            secName = itemData.isHeader ? 'headerItems' : itemData.isFooter ? 'footerItems' : 'items'; // No I18N

            itemsObj[secName].push(itemData);

            if (concatNeeded) {
              data[secName].push(itemData);
            }
          }
        } else {
          var parts = this.parts,
              portionData,
              j,
              sectionName;

          for (i = 0; i < 3; i++) {
            portionData = menuItemArr[parts[i]];

            if (portionData) {
              sectionName = i === 1 ? 'items' : parts[i] + 'Items'; // No I18N

              for (j = 0; j < portionData.length; j++) {
                itemData = this._getItemDetails(portionData[j], opts);
                itemsObj[sectionName].push(itemData); // No I18N
              }

              if (concatNeeded) {
                data[sectionName] = (data[sectionName] || []).concat(itemsObj[sectionName]);
              }
            }
          }
        }

        if (!concatNeeded) {
          // invoked from replaceMenuItems
          data.headerItems = itemsObj.headerItems;
          data.footerItems = itemsObj.footerItems;
          data.items = itemsObj.items;
        }

        return itemsObj;
      }
    }, {
      key: "addCustomMenuItem",
      value: function addCustomMenuItem(item, callback) {
        if (!item[0]._constructed && item.attr('_constructed') !== 'true') {
          // No I18N
          this.addMenuItem(item, callback);
        }
      }
    }, {
      key: "removeMenuItems",
      value: function removeMenuItems(menuItems) {
        // menuItems can be an array of id's or selector containing elements.
        if (menuItems) {
          for (var i = 0; i < menuItems.length; i++) {
            this.removeMenuItem(menuItems[i], true);
          }
        } else {
          var data = this._data;
          data.headerItems = data.footerItems = data.items = []; // all sections are made empty

          data.headerElement = data.bodyElement = data.footerElement = this._lastOverlayedMenuItem = null;
        }

        this._invokeRender(undefined, undefined, undefined, true);
      }
    }, {
      key: "removeMenuItem",
      value: function removeMenuItem(menuItem, isInternal) {
        var ele = this.element;
        menuItem = $(menuItem, ele);

        if (!menuItem.length || !this._data.rendered || !menuItem.attr('role')) {
          // temporary fix for custom elements case. ##revisit
          return;
        }

        var name = menuItem.attr('name'); // No I18N

        this._removeData(menuItem); // remove the data present in _data for this menuitem.
        // Removing the group label if no element of that particular group is visible


        var groupTitle = name ? $('#' + name + '.zmenu__title') : undefined; // No I18N

        if (groupTitle && groupTitle.length) {
          var items = ele.find('.zmenu__item[name=' + name + ']:not(.zmenu__title):not([data-unique-key="' + menuItem.attr('data-unique-key') + '"])'); // No I18N

          if (!items.length) {
            this._removeData(groupTitle); // removing the group title data in _data.

          }
        }

        if (!isInternal) {
          this._invokeRender(); // invoke render will handle the height fixing

        }
      }
    }, {
      key: "addMenuItem",
      value: function addMenuItem(menuItemObj, itemCallback) {
        if (this._addedByComponent) {
          return;
        }

        var menuItem = menuItemObj instanceof $ || menuItemObj.nodeType === 1 ? $(menuItemObj) : undefined;

        if (_typeof(menuItemObj) === 'object') {
          // No I18N
          menuItemObj = Object.create(menuItem ? ZC._getOpts(menuItem) : menuItemObj);
        }

        var attrName,
            cAttrs = menuItemObj.customAttributes || {};

        for (var i in this._propNames) {
          attrName = this._propNames[i];

          if (menuItemObj[attrName]) {
            cAttrs[attrName] = menuItemObj[attrName];
          }
        }

        menuItemObj = this._getItemDetails(menuItemObj, this._opts, menuItem && menuItem[0]);
        var data = this._data,
            index = menuItemObj.index;

        if (this._isNotNull(index)) {
          data.items.splice(index, 0, menuItemObj);
        } else {
          data[menuItemObj.isHeader ? 'headerItems' : menuItemObj.isFooter ? 'footerItems' : 'items'].push(menuItemObj); // No I18N
        }
        /* Need to address
            ZC._getOpts(menuItem).action = menuItemObj.action;  // action might be a JS function
        */


        var submenuItems = menuItemObj.menuItems;

        if (submenuItems && submenuItems === 'object') {
          // No I18N revisit needed
          itemCallback = undefined;
        }

        if (menuItem) {
          // removing the custom element added. ##revisit
          menuItem[0].parentNode.removeChild(menuItem[0]);
        }

        return this._invokeRender(itemCallback, menuItemObj, true);
      }
    }, {
      key: "_refreshLabelArray",
      value: function _refreshLabelArray(menu) {
        this._labelList = [];
        this._prevSKey = this._prevKTime = this._prevSIndex = ''; // S denotes search key, K - keydown

        var itemSel = '.zmenu__item:not(.zmenu__title):not(.is-disabled):not(.zmenu__separator):visible',
            // No I18N
        menuItems = menu.find(itemSel),
            len = menuItems.length,
            item;

        for (var i = 0; i < len; i++) {
          item = menuItems[i];

          this._labelList.push({
            text: item.getAttribute('data-label') || $(item).find('.zmenu__text').text() || '',
            // No I18N
            itemId: item.id
          });
        } // Removed this code as this._getData takes lot of time to execute
        // let menuItems = menu.find(this._SELECTORS.visibleItems),
        //     iData;
        // for (let i = 0; i < menuItems.length; i++) {
        //     iData = this._getData($(menuItems[i]));
        //     this._labelList[i] = {
        //         text: iData.label || '', // No I18N
        //         itemId: iData.id
        //     };
        // }

      }
    }, {
      key: "_callMenuitemSearch",
      value: function _callMenuitemSearch(key, currentTime) {
        var sameKey = false;

        if (this._prevKTime && currentTime - this._prevKTime > 700) {
          // No I18N
          sameKey = this._prevSKey === key;
          this._prevSKey = key;
        } else {
          this._prevSKey = this._prevSKey + key;
        }

        this._prevKTime = currentTime;

        this._menuitemSearch(sameKey);
      }
    }, {
      key: "_menuitemSearch",
      value: function _menuitemSearch(sameKey) {
        var arr = this._labelList,
            len = arr.length,
            regExp = new RegExp('^' + this._prevSKey.replace(/[|()[{.+*?$\\]/g, '\\$0'), 'i'),
            // No I18N
        fromIndex = sameKey && this._prevSIndex < len ? this._prevSIndex + 1 : 0;
        fromIndex = fromIndex > 0 && fromIndex < len ? fromIndex : 0;

        for (var x = fromIndex; x < len; x++) {
          if (regExp.test(arr[x].text)) {
            var checkNextMatch = -1;

            for (var y = x + 1; y < len; y++) {
              if (regExp.test(arr[y].text)) {
                checkNextMatch = x;
                break;
              }
            }

            this._prevSIndex = checkNextMatch;

            this._handleMouseEnterOnMenuItems({
              // converting target to jquery obj is done in the method itself.
              target: '#' + arr[x].itemId // No I18N

            }, true);

            return;
          }
        }
      }
    }, {
      key: "_getCustItemInfo",
      value: function _getCustItemInfo(itemObj, item) {
        // itemObj passed by reference only
        var content,
            htmlContent = itemObj.innerHTML || itemObj.zinnerHTML;

        if (htmlContent) {
          var replaceArray = htmlContent.replaceArray;
          content = htmlContent.content || htmlContent;

          if (replaceArray) {
            for (var i = 0; i < replaceArray.length; i++) {
              content = content.replace('{' + i + '}', ZC.encodeHTML(replaceArray[i])); // No I18N
            }
          }
        }

        content = item ? item.innerHTML : content;
        itemObj.innerHTML = this._opts.isCustomHTMLEncoded ? content : ZC.encodeHTML(content);
        itemObj.customType = true; // delete itemObj.label; // commenting since label is used for access key navigation
      }
    }, {
      key: "_storeAllPortionItems",
      value: function _storeAllPortionItems() {
        var sel = this._SELECTORS,
            parts = ['header', 'menu', 'footer'],
            // No I18N
        pName,
            ele,
            data = this._data,
            opts = this._opts,
            isBody;
        data.headerItems = [];
        data.footerItems = [];

        for (var i = 0; i < 3; i++) {
          pName = parts[i];
          ele = this.element.find(sel[pName]);
          isBody = i === 1;

          if (isBody || ele.length || opts[pName]) {
            pName = isBody ? 'body' : pName; // No I18N

            this._storeMenuItemDetails(isBody ? '' : pName, ele.length ? ele : undefined); // No I18N

          }
        }

        this._updateSectionCls(opts.type === 'grid', data, true);
      }
    }, {
      key: "_setCustomAttrsForItems",
      value: function _setCustomAttrsForItems(itemsObj, isInitial) {
        var menuItems = [],
            parts = ['headerItems', 'items', 'footerItems']; // No I18N

        for (var i = 0; i < 3; i++) {
          menuItems = menuItems.concat(this._setCustomAttrsForItem(itemsObj, isInitial, parts[i]));
        }

        return menuItems; // return values are used in addMenuItems method.
      }
    }, {
      key: "_updateSectionCls",
      value: function _updateSectionCls(isGrid, data, isInit) {
        // used by setAttribute method.
        var parts = this.parts,
            pName,
            ele,
            partType,
            opts = this._opts || {},
            isPartIsGrid = null,
            sel = this._SELECTORS,
            pCls;

        for (var i = 0; i < 3; i++) {
          pName = parts[i];
          ele = this.element.find(isInit ? sel[pName] : '.zmenu__' + pName); // No I18N

          partType = ele.length && ZC._getOpts(ele).type || opts[pName + 'Type'] || opts.type; // No I18N

          pCls = 'zmenu__' + pName + ((!partType || partType !== 'list') && isGrid ? ' zmenu--thumbnail' : ''); // No I18N

          if (isInit && !opts.allowReplace && ele && ele[0] !== this.element[0]) {
            data[pName + 'Element'] = ele[0]; // No I18N

            ele.addClass(pCls);
          }

          data[pName + 'ClassName'] = pCls; // No I18N
        }
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        this._addedByComponent = this.isCE;
        var ele = this.element,
            data = this._data,
            isVisible = ele.is(':visible'),
            // No I18N
        opts = this._opts,
            renderNeeded = false; // No I18N

        if (optionName === 'height' || optionName === 'width') {
          var parsedValue = parseInt(value);
          opts[optionName] = parsedValue;
          ele.data(optionName, parsedValue); // No I18N
          // Revisit - Check whether it is necessary

          if (isVisible) {
            if (optionName === 'height') {
              // No I18N
              this._fixMenuHeight(ele, {});
            } else {
              ele.width(parsedValue);
            }
          }
        } else if (optionName === 'pointer' || optionName === 'displayType') {
          // No I18N
          // render handled in the below method itself
          this._changeCalloutData(value && value !== 'box'); // No I18N

        } else if (optionName === 'renderInPlace' && !value) {
          // No I18N
          ele.removeClass('zmenu--inline'); // No I18N
        } else if (optionName === 'handleAccessKeyNavigation') {
          // No I18N
          // Keypress events
          this['_' + (value ? '' : 'un') + 'bindRuntimeEvents'](); // No I18N
        } else if (optionName === 'contentType') {
          // No I18N
          var cTypes = ZMenu._CONTENT_TYPES;

          this._updateClass(cTypes[value], cTypes[opts.contentType]);

          var oldVal = opts.contentType;
          opts.contentType = value;

          this._changeOpt('contentType', value, oldVal); // No I18N

        } else if (optionName === 'type') {
          // No I18N
          opts.type = value;
          var isGrid = value === 'grid'; // No I18N

          if (this._isContainer) {
            this._updateSectionCls(isGrid, data);
          } else {
            this._updateClass(isGrid ? 'zmenu--thumbnail' : '', isGrid ? '' : 'zmenu--thumbnail'); // No I18N

          }

          if (opts.contentType !== 'text') {
            // No I18N
            this._changeOpt('type', isGrid); // No I18N

          }
        } else if (optionName === 'header' || optionName === 'footer' || optionName === 'body' || optionName === 'items') {
          // No I18N
          this.addMenuItems(optionName === 'items' ? value : _defineProperty({}, optionName, value));
        }

        opts[optionName] = value;

        if (optionName === 'columns' && isVisible) {
          // No I18N
          this._fixGridMenuWidth();
        } else if (['scrollDownArrowIconClass', 'scrollDownArrowIconClassName', 'scrollDownArrowSVGIconId', 'scrollUpArrowIconClass', 'scrollUpArrowIconClassName', 'scrollUpArrowSVGIconId'].indexOf(optionName) !== -1 && data.scroller) {
          // No I18N
          this._changeScrollerIcons(optionName.indexOf('Down') === -1 ? 'Up' : 'Down'); // No I18N

        } else if (optionName === 'arrowIconClassName' || optionName === 'arrowIconClass' || optionName === 'arrowSVGIconId') {
          // No I18N
          this._changeArrowIcon();
        } else if (optionName === 'checkedCheckboxItemSVGIconId' || optionName === 'checkedCheckboxItemIconClassName' || optionName === 'checkedCheckboxItemIconClass' || optionName === 'checkedRadioItemSVGIconId' || optionName === 'checkedRadioItemIconClassName' || optionName === 'checkedRadioItemIconClass') {
          // No I18N
          this._changeCheckedIcons(optionName, value);
        } // For the above set of conditional icon change related conditional statements, rendering is needed.


        if (optionName.indexOf('Icon') !== -1 || optionName === 'contentType' || optionName === 'type') {
          // No I18N
          renderNeeded = true;
        }

        if (!this._domChanged) {
          this._domChanged = renderNeeded;
        }

        this._addedByComponent = false;
      }
    }, {
      key: "_changeOpt",
      value: function _changeOpt(optionName, value, oldVal) {
        var parts = ['headerItems', 'items', 'footerItems'],
            // No I18N
        section; // No I18N

        for (var i = 0; i < 3; i++) {
          section = this._data[parts[i]];

          if (section && section.length) {
            this._changeItemData(section, value, optionName, oldVal);
          }
        }
      }
    }, {
      key: "_changeItemData",
      value: function _changeItemData(section, value, optName, oldVal) {
        var _this39 = this;

        var listIcon = 'zmenu__icon',
            // No I18N
        gridIcon = 'zmenu__image',
            // No I18N
        newValue = value ? gridIcon : listIcon;
        section.forEach(function (iData) {
          if (optName === 'contentType') {
            // No I18N
            iData.contentType = iData.itemType === 'itemgroup' ? 'text' : oldVal === iData.contentType ? value : iData.contentType; // No I18N
          } else if (_this39._opts.contentType !== 'text') {
            // No I18N
            iData.iconClassName = iData.iconClassName ? iData.iconClassName.replace(value ? listIcon : gridIcon, newValue) : newValue;
          }
        });
      }
    }, {
      key: "_changeArrowIcon",
      value: function _changeArrowIcon() {
        // used by setAttribute method
        var opts = this._opts,
            items = this.element.find('.zmenu--submenu,.zmenu--split');

        for (var j = 0; j < items.length; j++) {
          this._getData($(items[j])).arrowIcon = ZC._getIconInfo(opts.arrowIconClassName || opts.arrowIconClass, opts.arrowSVGIconId, 'zc__svg--arrow zmenu__arrow zh-arrowicon', 'zmenu__icon zh-alignright'); // No I18N
        }
      }
    }, {
      key: "_hideAllSubmenus",
      value: function _hideAllSubmenus(menu) {
        var items = menu.find(this._SELECTORS.item);

        for (var i = 0; i < items.length; i++) {
          var item = $(items[i]),
              itemData = this._getData(item),
              subMenu = itemData.submenu;

          if (subMenu && subMenu.is(':visible')) {
            // No I18N
            this._hideAllSubmenus(subMenu); // hiding all the submenus of submenu.


            item.trigger('mouseleave'); // No I18N
          }
        }

        this._isToBeDelayed = false;
      }
    }, {
      key: "_findParentMenu",
      value: function _findParentMenu(menu) {
        var par = menu.data('parent'),
            // No I18N
        _menu;

        while (par) {
          _menu = par.closest('.zmenu'); // No I18N

          if (_menu.is(':visible')) {
            // No I18N
            menu = _menu;
            par = menu.data('parent'); // No I18N
          } else {
            par = false;
          }
        }

        return menu;
      }
    }, {
      key: "_setLastOverlayedSubMenu",
      value: function _setLastOverlayedSubMenu(menu) {
        ZC.menu(this._findMain()).setLastOverlayedMenu(menu, true);
      }
    }, {
      key: "_getSubmenu",
      value: function _getSubmenu(menuItem) {
        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getData(menuItem);

        if (data.submenu) {
          return data.submenu;
        }

        var menuId = data.menuId,
            submenu = menuId ? $("#".concat(menuId)) : menuItem.children("".concat(this._SELECTORS.container, ":not(.zmenu__iconcontainer):first"));

        if (!submenu.length) {
          return;
        }

        var submenuData = ZC._getOpts(submenu);

        if (!menuId) {
          // have to append the nested submenu to the appendTo container/body.
          $(submenuData.appendTo ? submenuData.appendTo : 'body')[0].appendChild(submenu[0]); // No I18N
        }

        submenuData.rtl = this._opts.rtl;

        if (!submenu.data('zmenu')) {
          // No I18N
          ZC.menu(submenu); // initializing the submenu
        }

        data.submenu = submenu;
        submenu.data({
          isExternalSubmenu: true,
          parent: menuItem
        });
        return submenu;
      }
    }, {
      key: "_openCloseSubmenu",
      value: function _openCloseSubmenu(key, event) {
        if (key === 'right') {
          // No I18N
          // open the submenu if submenu is available for currently hovered menu item.
          var item = this._lastOverlayedMenu.find('.on-hover'),
              submenu = this._getSubmenu(item);

          if (!submenu || !submenu.length) {
            return;
          }

          this.show({
            forElement: this._lastOverlayedMenuItem,
            event: event
          }, submenu);
          this._lastOverlayedMenuItem = undefined;
          submenu.find("".concat(this._SELECTORS.visibleItems, ":first")).trigger('mouseenter'); // No I18N

          this._lastOverlayedMenu = submenu;
        } else if (!this._isMenuMainMenu(this._lastOverlayedMenu)) {
          // close the submenu associated with the hovered menu item.
          // Pressing left from submenu will hide the submenu.
          this._hideLastShownMenu();
        }
      }
    }, {
      key: "_handleMouseEnterOnSubmenuItem",
      value: function _handleMouseEnterOnSubmenuItem(menuItem, event, data) {
        clearTimeout(this._menuTimeout);

        if (data.itemType === 'splitmenu') {
          // No I18N
          this._mouseEnterOnSplit(menuItem, event, data);
        } else {
          this._showSubmenu(menuItem, event, data);
        }
      }
    }, {
      key: "_handleMouseLeaveOnSubmenuItem",
      value: function _handleMouseLeaveOnSubmenuItem(menuItem, event) {
        var isDirect = !!event.originalEvent;

        if (isDirect) {
          if (!menuItem.parent().has(event.relatedTarget).length) {
            if (menuItem.data('submenu') && this._isMenuOfMenuItemShown(menuItem)) {
              return false;
            }

            this._setLastOverlayedMenuItem(undefined);
          }

          return false;
        }

        var data = this._getData(menuItem),
            submenu = data.submenu;

        if (this._isMenuOfMenuItemShown(menuItem) && (!event || $(event.relatedTarget).closest('.zmenu')[0] === submenu[0])) {
          // No I18N
          return false;
        }

        if (data.itemType === 'splitmenu') {
          // No I18N
          this._mouseLeaveOnSplit(menuItem);
        }

        clearTimeout(this._menuTimeout);

        if ($(submenu).data('parent') && $(submenu).data('parent')[0] === menuItem[0]) {
          // No I18N
          // submenu's parent item is checked since submenu can be used as main menu for some other item.
          this.hide(submenu); // hiding the sub menu.

          this.element.off('mousemove' + this._namespace); // No I18N
        }

        return true;
      }
    }, {
      key: "_isMenuOfMenuItemShown",
      value: function _isMenuOfMenuItemShown(menuItem) {
        var data = this._getData(menuItem);

        return data.submenu && data.submenu.is(':visible'); // No I18N
      }
    }, {
      key: "_isElementInMenu",
      value: function _isElementInMenu(element) {
        var menu = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.element;
        return menu[0].contains($(element)[0]);
      }
    }, {
      key: "_removeAllSubmenus",
      value: function _removeAllSubmenus(menu) {
        var submenuItems = menu.find('.zmenu--submenu,.zmenu--split'),
            // No I18N
        submenu;

        for (var i = 0; i < submenuItems.length; i++) {
          submenu = this._getData($(submenuItems[i]), undefined, menu);

          if (submenu && submenu.data('usingJSON')) {
            // No I18N
            this._removeAllSubmenus(submenu);
          }
        }

        menu.zmenu('destroy'); // No I18N

        menu.remove();
      }
    }, {
      key: "_showSubmenu",
      value: function _showSubmenu(menuItem, event, data, showImmediately) {
        var _this40 = this;

        // data contains menuItem's data.
        var isDirectEvent = event ? !!event.originalEvent : false,
            submenu = data.submenu || this._getSubmenu(menuItem, data); // building the submenu here because menu created using createMenu method will not have its submenu created previously.


        if (submenu && isDirectEvent) {
          // No I18N
          this._hideAllSubmenus(menuItem.closest('.zmenu')); // No I18N


          var f = function f() {
            if (menuItem.is(':visible')) {
              // No I18N
              var options = {
                forElement: menuItem,
                direction: submenu.data('zmenu')._opts.submenuDirection ? submenu.data('zmenu')._opts.submenuDirection : _this40._DIRECTIONS.submenu // No I18N

              };
              options = _this40.show(options, submenu);

              _this40._clearMouseHoverTimeout();

              _this40._mousex = event.clientX;
              _this40._prevmousex = event.pageX;

              _this40._bindMousemoveEvent(submenu, options.position.direction); // options.position.direction is the actual opening direction.

            }
          };

          this._menuTimeout = setTimeout(f, showImmediately ? 0 : 100);
        }
      }
    }, {
      key: "_bindMousemoveEvent",
      value: function _bindMousemoveEvent(subMenu, direction) {
        var _this41 = this;

        var offset = subMenu.offset(),
            parentOffset = subMenu.data('parent').closest('.zmenu').offset(),
            // No I18N
        moveRight = direction.indexOf('left') !== 0;
        this.element.on('mousemove' + this._namespace, function (event) {
          // No I18N
          // equal values are considered since safari browser produces erroneous results by executing stmts differently.
          _this41._isToBeDelayed = _this41._prevmousex && (moveRight ? _this41._prevmousex <= event.pageX : _this41._prevmousex >= event.pageX) && (moveRight ? event.pageX <= offset.left : event.pageX >= parentOffset.left);
          _this41._prevmousex = event.pageX;
        });
      }
    }, {
      key: "_isMenuMainMenu",
      value: function _isMenuMainMenu(menu) {
        return $(menu)[0] === this.element[0];
      }
    }, {
      key: "_hideLastShownMenu",
      value: function _hideLastShownMenu() {
        var nextItem = this._lastOverlayedMenu.data('parent'); // No I18N


        this._lastOverlayedMenuItem = nextItem;
        this.hide(this._lastOverlayedMenu);
        this.setLastOverlayedMenu(nextItem.closest('.zmenu')); // No I18N

        ZC._getOpts(this.element)._lastOverlayedMenuItem = nextItem;
      }
    }, {
      key: "_clearMouseHoverTimeout",
      value: function _clearMouseHoverTimeout() {
        var eleOptions = ZC._getOpts(this.element);

        clearTimeout(eleOptions.mouseOverTimeout);
        clearTimeout(eleOptions.mouseOutTimeout);

        if (this.element.data('parent') !== undefined) {
          // No I18N
          var parData = ZC._getOpts(this.element.data('parent').closest('.zmenu')); // No I18N


          clearTimeout(parData.mouseOverTimeout);
          clearTimeout(parData.mouseOutTimeout);
        }
      }
    }, {
      key: "_checkSubmenuEnter",
      value: function _checkSubmenuEnter(event) {
        var isdirect = !!event.originalEvent,
            mouseOverFunc = function mouseOverFunc() {
          this._handleMouseEnterOnMenuItems(event, !event.originalEvent);
        };

        this._clearMouseHoverTimeout();

        if (isdirect) {
          // if(!(relatedItem.length && relatedItem.data("submenu") && $(event.target).closest(".zmenu")[0] !== $(relatedItem.data("submenu"))[0] && this._isToBeDelayed)){
          var forElement = $(this.element.data('forElement')); // No I18N

          if (forElement.is('.zmenu__item')) {
            // No I18N
            forElement.closest('.zmenu').data('zmenu')._isToBeDelayed = false; // No I18N
          }

          if (this._isToBeDelayed) {
            ZC._getOpts(this.element).mouseOverTimeout = setTimeout(mouseOverFunc.bind(this), 300);
          } else {
            mouseOverFunc.bind(this)();
            clearTimeout(this._mouseoutTimer);
          }
        } else {
          mouseOverFunc.bind(this)();
          clearTimeout(this._mouseoutTimer);
        }
      }
    }, {
      key: "_checkSubmenuLeave",
      value: function _checkSubmenuLeave(event) {
        var isdirect = !!event.originalEvent,
            menuItem = $(event.target).closest('.zmenu__item'),
            mouseOutFunc = function mouseOutFunc() {
          if (isdirect && this._isToBeDelayed) {
            this._mouseoutTimer = setTimeout(mouseOutFunc.bind(this), 20);
          } else {
            this._handleMouseLeaveOnMenuItems(event);
          }

          clearTimeout(this._mouseoutTimer);
        };

        if (!isdirect || !menuItem.data('submenu') && !ZC._getOpts(this.element).mouseOverTimeout) {
          mouseOutFunc.bind(this)();
        } else {
          ZC._getOpts(this.element).mouseOutTimeout = setTimeout(mouseOutFunc.bind(this), 10);
        }
      }
    }, {
      key: "_triggerEventToSubmenu",
      value: function _triggerEventToSubmenu(type, event, data, menu) {
        // if external submenu has menu events binded on it
        menu.zmenu('triggerEvent', type.replace('submenu', ''), event, data); // No I18N
        // temporary fix to find the parent element for custom tag notation.

        var parentMenu = menu.data('parent').closest('.zmenu'); // No I18N
        // parentMenu is passed as argument since it is currently needed in custom element case.

        return parentMenu.zmenu('triggerEvent', type, event, data, parentMenu); // No I18N
      }
    }, {
      key: "_getCalloutDetails",
      value: function _getCalloutDetails(options) {
        var _this42 = this;

        this._changeCalloutData(true);

        options.arrowCallback = function (element, direction) {
          _this42._arrowDirection = direction;
          element.removeClass('zh-top zh-bottom zh-right zh-left').addClass("zh-".concat(direction)); // No I18N
        };

        return options;
      }
    }, {
      key: "_changeCalloutData",
      value: function _changeCalloutData(createCallout) {
        // pointer element
        if (createCallout && this._pointerElement && this._pointerElement.length) {
          return this._pointerElement.removeClass('zh-top zh-bottom zh-left zh-right'); // No I18N
        }

        this._data.callout = !!createCallout;

        this._render();
      } // ZMenu.propertyName = { key: value }; This notation should be used to define a static getter function.

    }, {
      key: "_getIconDetails",
      value: function _getIconDetails(itemObj, opts, checked, isGrid) {
        // static member function belongs to ZMenu class.
        var iType = itemObj.itemType,
            defaultIconClass = isGrid ? 'zmenu__image' : 'zmenu__icon',
            // No I18N
        name = iType[0].toUpperCase() + iType.slice(1),
            iconClass = opts["checked".concat(name, "ItemIconClass")] || opts["checked".concat(name, "ItemIconClassName")] || '',
            // No I18N
        SVGIconId = opts["checked".concat(name, "ItemSVGIconId")],
            defaultSVGId = "#zc__svg--".concat(iType === 'radio' ? 'round' : 'tick'); // No I18N
        // Revisit - itemObj.iconClassName.trim() can be stored and reused

        if (isGrid || itemObj.iconClass || itemObj.iconClassName && itemObj.iconClassName.trim() !== defaultIconClass && itemObj.iconClassName.trim() !== (defaultIconClass + ' ' + iconClass).trim() || itemObj.SVGIconId && itemObj.SVGIconId !== defaultSVGId && itemObj.SVGIconId.slice(1) !== SVGIconId) {
          // icon is present
          var className = itemObj.className.replace(/is-selected/g, " "); // No I18N

          if (checked) {
            className += ' is-selected'; // No I18N
          }

          itemObj.className = className;
        } else if (checked) {
          itemObj.iconClassName = defaultIconClass + ' ' + iconClass; // No I18N

          itemObj.SVGIconId = !iconClass && (opts["checked".concat(name, "ItemSVGIconId")] || defaultSVGId); // No I18N

          if (itemObj.SVGIconId && itemObj.SVGIconId.indexOf('#') === -1) {
            // No I18N
            itemObj.SVGIconId = '#' + itemObj.SVGIconId; // No I18N
          }

          itemObj.SVGIconClassName = iType === 'radio' ? 'zmenu__radio' : 'zmenu__tick'; // No I18N
        } else {
          // Removed itemObj.iconClassName existence check since it is not necessary in this scenario
          if (itemObj.iconClassName === defaultIconClass + ' ' + iconClass) {
            // No I18N
            itemObj.iconClassName = defaultIconClass;
          }

          if (itemObj.SVGIconId && (itemObj.SVGIconId === defaultSVGId || itemObj.SVGIconId.slice(1) === SVGIconId)) {
            itemObj.SVGIconId = undefined;
          }
        }

        itemObj.iconAsPrefix = itemObj.customType; // custom layout but checkbox/radio type.

        return itemObj;
      }
    }, {
      key: "_checkMenuItem",
      value: function _checkMenuItem(menuItem, checked, data) {
        data = this._getData(menuItem);
        this[data.itemType === 'radio' ? '_handleRadioItem' : '_addCheckedStateIcon'](menuItem, checked, data); // No I18N
      }
    }, {
      key: "_addCheckedStateIcon",
      value: function _addCheckedStateIcon(menuItem, checked, data, doNotRender) {
        var isGrid = this._isGridMenu(menuItem, true),
            iconEle = menuItem.find('i:first'); // No I18N


        if (iconEle.length) {
          var itemData = this._getData(menuItem); // updating item details present in this._data


          itemData = this._getIconDetails(itemData, ZC.menu(this._lastOverlayedMenu)._opts, checked, isGrid);
          var attrs = itemData.attrs || {};
          attrs.checked = attrs['aria-checked'] = itemData.checked = checked; // No I18N

          itemData.attrs = attrs;

          this._itemsHavingAttrs.push(itemData.id); // !doNotRender && this._render();
          // ##revisit Try to use this._render();


          !doNotRender && ZC.menu(menuItem.closest('.zmenu')).callRender(); // No I18N
        }

        menuItem.prop('checked', checked); // No I18N
      }
    }, {
      key: "_handleRadioItem",
      value: function _handleRadioItem(menuItem, checked, data, doNotRender) {
        if (checked) {
          var name = $(menuItem).attr('name'),
              // No I18N
          sel = this._SELECTORS,
              _menu2 = menuItem.closest(sel.menu);

          _menu2 = _menu2.length ? _menu2 : menuItem.closest(sel.container);

          var radios = _menu2.find("".concat(sel.item, "[role=menuitemradio][name=").concat(name, "]"));

          for (var i = 0, radio; i < radios.length; i++) {
            radio = $(radios[i]); // Try using javascript properties

            if (radio.prop('checked') || radio.attr('checked')) {
              // No I18N
              this._addCheckedStateIcon(radio, false, this._getData(radio), doNotRender);
            }
          }
        }

        this._addCheckedStateIcon(menuItem, checked, data, doNotRender);
      }
    }, {
      key: "_changeCheckedIcons",
      value: function _changeCheckedIcons() {
        // used by setAttribute method.
        var opts = this._opts,
            items = this.element.find('[role="menuitemradio"],[role="menuitemcheckbox"]'),
            itemData;

        for (var j = 0; j < items.length; j++) {
          itemData = this._getData($(items[j]));
          itemData.iconClass = itemData.iconClassName = itemData.SVGIconId = ''; // No I18N

          itemData = this._getIconDetails(itemData, opts, itemData.checked);
        }
      }
    }, {
      key: "_clearRadioCheckboxData",
      value: function _clearRadioCheckboxData(iData) {
        // if default icon details are present, it should be removed
        var iType = iData.itemType,
            name = iType[0].toUpperCase() + iType.slice(1),
            opts = this._opts,
            iconClass = opts["checked".concat(name, "ItemIconClass")] || opts["checked".concat(name, "ItemIconClassName")] || '',
            // No I18N
        SVGIconId = opts["checked".concat(name, "ItemSVGIconId")],
            defaultSVGId = "#zc__svg--".concat(iType === 'radio' ? 'round' : 'tick'); // No I18N

        if (iData.iconClassName === iconClass || iData.SVGIconId === defaultSVGId || iData.SVGIconId && iData.SVGIconId.indexOf(SVGIconId) >= 0) {
          iData.SVGIconId = iData.iconClassName = null;
        }
      }
    }, {
      key: "_mouseEnterOnSplit",
      value: function _mouseEnterOnSplit(menuItem, event, data) {
        var _this43 = this;

        clearTimeout(this._splitDelay);
        this._splitDelay = window.setTimeout(function () {
          // Hover delay for split menu item
          _this43._hoverSplit(menuItem, true);

          _this43._showSubmenu(menuItem, event, data);
        }, 150);
      }
    }, {
      key: "_mouseLeaveOnSplit",
      value: function _mouseLeaveOnSplit(menuItem) {
        this._hoverSplit(menuItem);
      }
    }, {
      key: "_hoverSplit",
      value: function _hoverSplit(menuItem, enter) {
        menuItem.find('.zmenu__icon.zh-alignright')[enter ? 'addClass' : 'removeClass']('on-hover'); // No I18N

        clearTimeout(this._splitDelay);
      }
    }, {
      key: "hideMenuItems",
      value: function hideMenuItems(items) {
        this._toggleMenuItems(items, true);
      }
    }, {
      key: "showMenuItems",
      value: function showMenuItems(items) {
        this._toggleMenuItems(items, false);
      }
    }, {
      key: "_toggleMenuItems",
      value: function _toggleMenuItems(items, hide) {
        var sel = this._SELECTORS;

        if (!items) {
          if (hide) {
            items = this.element.find(sel.item + ', ' + sel.separator).filter(function () {
              // No I18N
              return $(this).css('display') !== 'none'; // No I18N
            });
          } else {
            items = this.element.find(sel.item + ':not(' + sel.item + '[data-hidden=true])'); // No I18N
          }
        }

        this.setMenuItemsAttribute(items, 'hidden', hide); // No I18N
      }
    }, {
      key: "_initSliders",
      value: function _initSliders(menu) {
        var mData = ZC.menu(menu).getData(),
            actualMenu = menu.find('.zmenu__body').length ? menu.find('.zmenu__body') : menu;

        if (!mData.scroller) {
          this._getScrollInfo(mData);

          this._getScrollInfo(mData, true); // create bottom slider.


          this._render();

          this._bindSliderEvents(actualMenu, mData);
        }

        this._positionSliders(actualMenu, mData);
      }
    }, {
      key: "_positionSliders",
      value: function _positionSliders(actualMenu, data) {
        var container = actualMenu.closest('.zmenu'),
            // No I18N
        scrollerInfo = data.scroller,
            topScroller = scrollerInfo.upEle,
            bottomScroller = scrollerInfo.downEle,
            topLeft,
            bottomLeft,
            topTop,
            bottomTop,
            offset = actualMenu.position();

        if (container.length) {
          var _container = actualMenu.parent();

          bottomTop = offset.top + actualMenu.height() - bottomScroller.outerHeight(true); // No I18N

          if (!data.footerItems.length) {
            bottomTop += parseInt(_container.css('padding-bottom')); // No I18N
          }

          topLeft = bottomLeft = '0px'; // No I18N

          topTop = offset.top - (data.headerItems.length ? 0 : parseInt(_container.css('padding-top'))); // No I18N
        } else {
          topTop = offset.top + 1;
          topLeft = bottomLeft = offset.left + 1;
          bottomTop = offset.top + (actualMenu.outerHeight() - bottomScroller.outerHeight(true) - 1);
        }

        bottomScroller.show();
        topScroller.css({
          left: topLeft,
          top: topTop
        });
        bottomScroller.css({
          left: bottomLeft,
          top: bottomTop
        });
      }
    }, {
      key: "_bindSliderEvents",
      value: function _bindSliderEvents(actualMenu, data) {
        var _this44 = this;

        var container = actualMenu.closest('.zmenu'),
            // No I18N
        topScroller = container.find('.zmenu--scrollerup'),
            // No I18N
        bottomScroller = container.find('.zmenu--scrollerdown'); // No I18N

        data.scroller.upEle = topScroller;
        data.scroller.downEle = bottomScroller;
        var eSuf = this._namespace; // binding events to scroller elements

        topScroller.add(bottomScroller).off('mouseenter mouseleave').on('mouseenter', function (e) {
          // No I18N
          _this44._startScroll(actualMenu, $(e.target).closest('.zmenu--scroller').hasClass('zmenu--scrollerup'));
        }).on('mouseleave', function () {
          _this44._stopScroll(actualMenu);
        }).hide();
        var cEve = 'click' + eSuf; // No I18N

        topScroller.add(bottomScroller).off(cEve).on(cEve, function () {
          var isTop = $(_this44).hasClass('.zmenu--scrollerup'),
              top = Math.round(actualMenu.scrollTop()); // rounding the value since windows machine contains floating point numbers

          _this44._stopScroll(actualMenu);

          actualMenu.scrollTop(top + (isTop ? -1 : 1));

          _this44._startScroll(actualMenu, isTop);

          return false;
        });
        var mEve = 'mousewheel' + eSuf; // No I18N
        // Binding mousewheel event for the menu to scroll the menu using mouse eventhough scrollers are present.

        actualMenu.off(mEve).on(mEve, function (event) {
          actualMenu.stop();
          actualMenu.scrollTop(Math.round(actualMenu.scrollTop()) + (event.originalEvent.wheelDelta > 0 ? -6 : 6));

          _this44._showScrollEle(actualMenu);

          event.stopPropagation();
          event.preventDefault();
        });
      }
    }, {
      key: "_getScrollInfo",
      value: function _getScrollInfo(data, isTop) {
        var direction = isTop ? 'up' : 'down'; // No I18N

        if (!data[direction]) {
          data.scroller = data.scroller || {};
          data.scroller[direction] = {
            className: 'zmenu--scroller zmenu--scroller' + direction // No I18N

          };

          this._changeScrollerIcons(direction[0].toUpperCase() + direction.slice(1));
        }
      }
    }, {
      key: "_showScrollEle",
      value: function _showScrollEle(menu) {
        var scrollElement = this._data.scroller,
            scrollTop = Math.round(menu.scrollTop());
        scrollElement.upEle[scrollTop === 0 ? 'hide' : 'show'](); // No I18N

        scrollElement.downEle[menu[0].scrollHeight - scrollTop <= menu.outerHeight() ? 'hide' : 'show'](); // No I18N
      }
    }, {
      key: "_startScroll",
      value: function _startScroll(menu, isTop) {
        var _this45 = this;

        var stop = isTop ? 0 : menu[0].scrollHeight - menu.innerHeight(),
            distance = Math.round(menu.scrollTop()) - stop,
            duration = Math.abs(distance * 1000 / 50); // 1000 ms for 50px

        menu.animate({
          scrollTop: stop
        }, {
          duration: duration,
          // No I18N
          easing: 'linear',
          // No I18N
          complete: function complete() {
            _this45._showScrollEle(menu);
          }
        });
      }
    }, {
      key: "_stopScroll",
      value: function _stopScroll(menu) {
        menu.stop();

        this._showScrollEle(menu);
      }
    }, {
      key: "_uninitSliders",
      value: function _uninitSliders(menu, isFromDestroy) {
        var data = ZC.menu(menu).getData().scroller || {};
        menu = menu.find('.zmenu__body').length ? menu.find('.zmenu__body') : menu;
        data.upEle && data.upEle[isFromDestroy ? 'remove' : 'hide'](); // No I18N

        data.downEle && data.downEle[isFromDestroy ? 'remove' : 'hide'](); // No I18N

        if (isFromDestroy) {
          data = null;
        } // mousewheel need not be unbinded here since everytime we don't generate sliders now.
        // menu.off('mousewheel'); // No I18N

      }
    }, {
      key: "_changeScrollerIcons",
      value: function _changeScrollerIcons(position) {
        var place = position.toLowerCase(),
            opts = this._opts,
            iconCls = opts['scroll' + position + 'ArrowIconClass'] || opts['scroll' + position + 'ArrowIconClassName'] || ''; // No I18N

        this._data.scroller[place].icon = {
          iconClassName: 'zmenu__icon ' + iconCls,
          // No I18N
          SVGIconId: '#' + (opts['scroll' + position + 'ArrowSVGIconId'] || !iconCls && 'zc__svg--' + place + 'scroller'),
          // No I18N
          SVGIconClassName: 'zmenu__' + place + 'scroller' // No I18N

        };
      }
    }, {
      key: "_fixGridMenuWidth",
      value: function _fixGridMenuWidth() {
        var menu = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.element;

        var options = menu.data('zmenu')._opts,
            // No I18N
        columns = parseInt(options.columns),
            gridDivisions = menu.find('.zmenu--thumbnail'),
            actualMenu = menu;

        if (gridDivisions.length) {
          var opt, data;
          columns = 0;

          for (var j = 0; j < gridDivisions.length; j++) {
            data = ZC._getOpts(gridDivisions[j]);
            opt = data.columns;

            if (opt && opt > columns) {
              columns = opt;
              actualMenu = $(gridDivisions[j]);
            }
          }
        }

        if (!columns || columns === -1) {
          var _menu = menu.closest('.zmenu'),
              // No I18N
          _data2 = ZC._getOpts(_menu);

          columns = _menu.data('isExternalSubmenu') ? _data2.columns : this._opts.columns; // No I18N

          if (!columns || columns === -1) {
            return;
          }
        }

        if (actualMenu[0] === menu[0] && !menu.hasClass('zmenu--thumbnail')) {
          // No I18N
          actualMenu = menu.find('.zmenu--thumbnail'); // No I18N
        } else if (actualMenu.find('.zmenu__body').length) {
          // No I18N
          // menu may contain thumbnail class as a whole but header and footer items will be of list type.
          actualMenu = menu.find('.zmenu__body'); // No I18N
        }

        var items = this._getAllMenuItems(actualMenu, false, false, true),
            floatingMenuWidth = 0,
            itemStyle;

        for (var i = 0; i < columns && i < items.length; i++) {
          // outerWidth is replaced by native javascript method since it truncates the floating point values.
          itemStyle = window.getComputedStyle(items[i]);
          floatingMenuWidth += Math.round(parseFloat(itemStyle.width)) + Math.round(parseFloat(itemStyle.marginLeft)) + Math.round(parseFloat(itemStyle.marginRight)); // rounding the values since width/margins might contain floating point numbers.

          if (ZC.Browser.isIE && ZC.Browser.getIEVersion() <= 11) {
            // IE check is added since item's width doesn't include padding and border there.
            floatingMenuWidth += Math.round(parseFloat(itemStyle.paddingLeft)) + Math.round(parseFloat(itemStyle.paddingRight)) + Math.round(parseFloat(itemStyle.borderRightWidth)) + Math.round(parseFloat(itemStyle.borderLeftWidth));
          }
        }

        menu.width(floatingMenuWidth); // setting width here in order to retrieve correct height before menu show. scroll bar width will be added after fixing height in show method.

        menu.data('width', floatingMenuWidth); // No I18N
      }
    }, {
      key: "_gridNavigation",
      value: function _gridNavigation(key, portion) {
        var menu = this._lastOverlayedMenu || this.element,
            item = this._lastOverlayedMenuItem || menu.find('.on-hover'),
            // No I18N
        isPrev = key === 'up' || key === 'left',
            // No I18N
        itemSel = '.zmenu__item:not(.is-disabled):visible',
            // No I18N
        list = item[isPrev ? 'prevAll' : 'nextAll'](itemSel),
            // No I18N
        index = 0,
            nextItem = this._getNextGridMenuItem(item.position(), list, key === 'up', key === 'left' || key === 'right'); // No I18N


        if (!nextItem) {
          var sec1, sec2;
          sec1 = portion === 'header' ? 'footer' : 'header'; // No I18N

          sec2 = portion === 'body' ? isPrev ? 'header' : 'footer' : ''; // No I18N
          // Revisit - To check whether header or footer exist, use the objects instead of selectors

          if (portion !== 'footer' && isPrev && menu.find(".zmenu__".concat(sec1)).length) {
            itemSel = ".zmenu__".concat(sec1, " ").concat(itemSel);
          } else if (portion !== 'header' && !isPrev && menu.find(".zmenu__".concat(sec1)).length) {
            // No I18N
            itemSel = ".zmenu__".concat(sec2 || sec1, " ").concat(itemSel);
          } else {
            itemSel = menu.find('.zmenu__body').length ? ".zmenu__body ".concat(itemSel) : itemSel;
          }

          list = menu.find(itemSel);

          if (portion === 'footer') {
            // No I18N
            index = !isPrev ? 0 : key === 'left' ? list.length - 1 : !isPrev ? 0 : this._getLRFItem($(list[list.length - 1]).position(), list); // No I18N
          } else {
            index = !isPrev ? 0 : list.length - 1;
          }

          nextItem = list[index];
        }

        return nextItem;
      }
    }, {
      key: "_getNextGridMenuItem",
      value: function _getNextGridMenuItem(currentItemPos, items, isPrev, compareTop, isReverse) {
        var next,
            key = compareTop ? 'top' : 'left',
            // No I18N
        total = items.length;

        for (var i = 0, item; i < total; i++) {
          item = $(items[isReverse ? total - i - 1 : i]);
          var ipos = item.position(); // ##revisit the logic by testing the navigation.

          if (ipos[key] === currentItemPos[key] || key === 'top') {
            // No I18N
            // Top key check is added to allow Navigation to next row items (example: open office application)
            next = item;
            break;
          }
        }

        return next;
      }
    }, {
      key: "_getLRFItem",
      value: function _getLRFItem(itemPos, items) {
        // get last row first item
        var prev,
            total = items.length - 1,
            ipos;

        for (var i = total; i >= 0; i--) {
          ipos = $(items[i]).position();

          if (ipos.top === itemPos.top) {
            prev = items[i];
          } else {
            break;
          }
        }

        return items.index(prev);
      }
    }, {
      key: "_getAllMenuItems",
      value: function _getAllMenuItems(menu, excludeFloatingItems, excludeSubMenuItems, isOnlyVisible, excludeseparator) {
        if (!menu || !menu.length) {
          menu = this.element;
        }

        return menu.find(".zmenu__item:not(.zmenu__title".concat(excludeseparator ? ',.zmenu__separator' : '').concat(excludeFloatingItems ? ',.zmenu--thumbnail' : '').concat(excludeSubMenuItems ? ',li ul[mtype=submenu] li' : '', ")").concat(isOnlyVisible ? ':visible' : '')); // No I18N
      }
    }, {
      key: "name",
      get: function get() {
        return "zmenu";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          // allowReplace is introduced to completely replace the child elements present inside the element given by the user with the new elements created by the templates.
          allowReplace: true,
          // No I18N
          constructMenu: true,
          // No I18N
          appendTo: null,
          // No I18N
          arrowIconClass: null,
          // No I18N
          arrowSVGIconId: null,
          // No I18N
          checkedCheckboxItemIconClass: null,
          // No I18N
          checkedCheckboxItemSVGIconId: null,
          // No I18N
          checkedRadioItemIconClass: null,
          // No I18N
          checkedRadioItemSVGIconId: null,
          // No I18N
          columns: 3,
          // No I18N
          contentType: 'text',
          // No I18N
          direction: 'auto',
          // No I18N
          displayType: 'box',
          // No I18N
          forElement: null,
          // No I18N
          menuClass: '',
          // No I18N
          zclassName: '',
          // No I18N
          height: null,
          // No I18N
          usingJSON: false,
          isCustomHTMLEncoded: true,
          // No I18N
          offset: null,
          // No I18N
          pointer: false,
          // No I18N
          renderInPlace: false,
          // No I18N
          scroll: 'slider',
          // No I18N
          scrollDownArrowIconClass: null,
          // No I18N
          scrollDownArrowSVGIconId: null,
          // No I18N
          scrollUpArrowIconClass: null,
          // No I18N
          scrollUpArrowSVGIconId: null,
          // No I18N
          type: 'list',
          // No I18N
          toggle: true,
          // No I18N
          width: null,
          // No I18N
          EFFECTS: {
            // No I18N
            slide: {
              // No I18N
              open: 'slideDown',
              // No I18N
              close: 'slideUp' // No I18N

            },
            fade: {
              // No I18N
              open: 'fadeIn',
              // No I18N
              close: 'fadeOut' // No I18N

            }
          },
          minWidth: 200,
          // No I18N
          handleAccessKeyNavigation: true,
          // No I18N
          itemTagName: 'li',
          // No I18N
          groupTagName: 'ul',
          // No I18N
          viewport: null,
          // No I18N
          menuItems: null // No I18N

        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          items: null,
          header: null,
          footer: null,
          body: null,
          arrowIconClassName: null,
          // No I18N
          checkedCheckboxItemIconClassName: null,
          // No I18N
          checkedRadioItemIconClassName: null,
          // No I18N
          scrollDownArrowIconClassName: null,
          // No I18N
          scrollUpArrowIconClassName: null,
          // No I18N
          animation: {} // No I18N

        };
      }
    }, {
      key: "parts",
      get: function get() {
        return ['header', 'body', 'footer']; // No I18N
      }
    }, {
      key: "_DIRECTIONS",
      get: function get() {
        return {
          menu: 'bottom-left',
          // No I18N
          submenu: 'right-bottom',
          // No I18N
          pointer: 'bottom' // No I18N

        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['beforeshow', 'beforehide', 'show', 'hide', 'beforesubmenushow', 'submenushow', 'beforesubmenuhide', 'submenuhide', 'itemhover', 'itemclick', 'beforefocus', 'keydown', 'submenuitemclick']; // No I18N
      }
    }, {
      key: "SELECTORS",
      get: function get() {
        var isCE = this.isCE;
        return {
          container: isCE ? 'z-menu' : 'div',
          // No I18N
          menu: isCE ? 'z-menubody' : 'ul:not([data-header]):not([data-footer])',
          // No I18N
          body: isCE ? 'z-menubody' : 'ul:not([data-header]):not([data-footer])',
          // No I18N
          header: isCE ? 'z-menuheader' : 'ul[data-header=true]',
          // No I18N
          footer: isCE ? 'z-menufooter' : 'ul[data-footer=true]',
          // No I18N
          // footer: isCE ? 'z-menufooter' : 'ul:last:not(.zmenu__body):not([data-body])', // No I18N
          group: isCE ? 'z-menuitemheading' : 'li[data-item-type=itemgroup]',
          // No I18N
          item: isCE ? 'z-menuitem' : 'li',
          // No I18N
          separator: isCE ? 'z-menuseparator' : 'li[data-item-type=separator]',
          // No I18N
          visibleItems: '.zmenu__item:not(.is-disabled):visible' // No I18N

        };
      }
    }], [{
      key: "getScrollWidth",
      value: function getScrollWidth() {
        var scrollEle = document.createElement('div'),
            bodyEle = document.querySelector('body'); // No I18N

        bodyEle.appendChild(scrollEle); // No I18N

        scrollEle.style.cssText = 'width:50px;height:50px;overflow:scroll;'; // No I18N

        ZMenu._scrollWidth = $(scrollEle).width() - scrollEle.scrollWidth;
        bodyEle.removeChild(scrollEle); // No I18N

        return ZMenu._scrollWidth;
      }
    }, {
      key: "_CONTENT_TYPES",
      get: function get() {
        return {
          text: '',
          // No I18N
          icon: 'zmenu--icononly',
          // No I18N
          'icon-text': 'zmenu--iconwithtext' // No I18N

        };
      }
    }, {
      key: "_ITEM_TYPES",
      get: function get() {
        return {
          'default': 'zmenu__item',
          // No I18N
          separator: 'zmenu__separator',
          // No I18N
          splitmenu: 'zmenu__item zmenu--split',
          // No I18N
          itemgroup: 'zmenu__title',
          // No I18N
          custom: 'zmenu__item zmenu__custom' // No I18N

        };
      }
    }, {
      key: "ARIA_ROLES",
      get: function get() {
        return {
          'default': 'menuitem',
          // No I18N
          splitmenu: 'menuitem',
          // No I18N
          custom: 'menuitem',
          // No I18N
          radio: 'menuitemradio',
          // No I18N
          checkbox: 'menuitemcheckbox',
          // No I18N
          itemgroup: 'group',
          // No I18N
          separator: 'separator' // No I18N

        };
      }
    }]);

    return ZMenu;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZMenu', ZMenu);

  (function (ZC) {
    var template = ZC.zmenu.Templates,
        utilities = ZC.Templates.Utilities;

    template.container = function (data) {
      return ZT.html(_templateObject79(), data.className, data.id, data.children && template.children(data));
    };

    template.children = function (data) {
      return ZT.html(_templateObject80(), data.simple ? ZT.html(_templateObject81(), data.items && data.items.map(function (item) {
        return template.item(item);
      })) : template.advancedChildren(data));
    };

    template.item = function (data) {
      return ZT.html(_templateObject82(), data.element || ZT.html(_templateObject83(), data.isDefault ? template.defaultItem(data) : data.isSeparator ? template.separator(data) : data.isHeading ? template.heading(data) : ''));
    };

    template.defaultItem = function (data) {
      return ZT.html(_templateObject84(), data.id, data.itemType, data.className, data.role, data.name, data.menuId, data.uniqueKey, data.label, data.checked, data, template[data.layoutName](data));
    };

    template.heading = function (data) {
      return ZT.html(_templateObject85(), data.id, data.itemType, data.className, data.role, data.name, data.uniqueKey, data, data.label && ZT.html(_templateObject86(), ZT.customHTML(data.label)));
    };

    template.separator = function (data) {
      return ZT.html(_templateObject87(), data.id, data.itemType, data.className, data.role, data.uniqueKey, data);
    };

    template.anchorLayout = function (data) {
      return ZT.html(_templateObject88(), data.url, data.target, data.rel, template.defaultLayout(data));
    };

    template.destroyLayout = function (data) {
      return ZT.html(_templateObject89(), data.label);
    };

    template.defaultLayout = function (data) {
      return ZT.html(_templateObject90(), ZT.customHTML(''), data.contentType !== 'text' && ZT.html(_templateObject91(), data.iconText || utilities.icon(data)), data.contentType !== 'icon' && !data.customType && ZT.html(_templateObject92(), data.label && ZT.html(_templateObject93(), ZT.customHTML(data.label || '')), data.shortcutKey && ZT.html(_templateObject94(), data.shortcutKey), data.description ? ZT.html(_templateObject95(), data.description) : ''), data.hasSubmenu && utilities.icon(data.arrowIcon));
    };

    template.callout = function () {
      return ZT.html(_templateObject96());
    };

    template.customLayout = function (data) {
      return ZT.html(_templateObject97(), data.iconAsPrefix && template.defaultLayout(data), ZT.customHTML(data.innerHTML || ''), data.iconAsSuffix && template.defaultLayout(data));
    };

    template.scroller = function (data) {
      return ZT.html(_templateObject98(), data.className, utilities.icon(data.icon));
    };

    template.container = function (data) {
      return ZT.html(_templateObject99(), data.className, data.id, data.children && template.children(data));
    };

    template.advancedChildren = function (data) {
      return ZT.html(_templateObject100(), data.callout && ZT.html(_templateObject101(), template.callout(data)), data.headerItems.length && ZT.html(_templateObject102(), data.headerElement || ZT.html(_templateObject103(), data.headerClassName, template.items(data.headerItems))), data.items && ZT.html(_templateObject104(), data.bodyElement || ZT.html(_templateObject105(), data.bodyClassName, template.items(data.items))), data.footerItems.length && ZT.html(_templateObject106(), data.footerElement || ZT.html(_templateObject107(), data.footerClassName, template.items(data.footerItems))), data.scroller && ZT.html(_templateObject108(), template.scroller(data.scroller.up), template.scroller(data.scroller.down)));
    };

    template.items = function (data) {
      return ZT.html(_templateObject109(), data.map(function (item) {
        return template.item(item);
      }));
    };
  })(ZComponents);

  var ZList =
  /*#__PURE__*/
  function (_ZC$CoreComponent11) {
    _inherits(ZList, _ZC$CoreComponent11);

    function ZList() {
      _classCallCheck(this, ZList);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZList).apply(this, arguments));
    }

    _createClass(ZList, [{
      key: "_create",
      value: function _create() {
        this._namespace = '.' + this.name;

        this._init();

        this._initDS();
      } // Method to initiate all the options

    }, {
      key: "_init",
      value: function _init() {
        var options = this._opts;
        this._groupsIncluded = [];
        this.params = {};
        this._dataMapping = options.dataMapping;
        this._isGrouped = !!this._dataMapping.groupLabel;
        this._showSearchField = options.showSearchField;
        this._isCheckBoxType = options.checkedIcon || options.itemType === 'checkbox'; // No I18N

        this.inputField = this._maxHt = this._opened = undefined;

        if (!this._showSearchField && options.inputField) {
          this.inputField = $(options.inputField);

          this._bindInputFieldEvents();
        }

        this._searchable = options.showSearchField || options.inputField;

        if (options.forElement) {
          options.forElement = $(options.forElement);
        }

        this._setContentProps(options.contentType);
      }
    }, {
      key: "_setContentProps",
      value: function _setContentProps(contentType) {
        if (!/^(image-text|image-text-desc|text-desc|text|custom|image)$/.test(contentType) || contentType === 'image' && this._dataMapping.image) {
          // No I18N
          contentType = 'text'; // No I18N
        } // Validating the list content type


        this._isCustom = contentType.indexOf('custom') > -1; // No I18N

        this._hasImage = this._hasIcon = this._hasContentTag = false;

        if (!this._isCustom) {
          this._hasText = contentType.indexOf('text') > -1; // No I18N

          this._hasDesc = this._hasContentTag = contentType.indexOf('desc') > -1; // No I18N

          if (contentType.indexOf('image') > -1) {
            // No I18N
            this._hasContentTag = this._hasText;
            this._hasIcon = !(this._hasImage = this._dataMapping.image);
          }
        }
      }
    }, {
      key: "_setNoResults",
      value: function _setNoResults(inSufficientQuery) {
        if (inSufficientQuery) {
          this._inSufficentQuery = true;
        } else {
          this._noResults = true;

          if (this._opts.search.showNoResultsMessage) {
            return this._addNoResults();
          }
        }

        if (this._opts.showSearchField) {
          this._hideAllItems();
        } else {
          this._hideSuggestions();

          return false;
        }
      } // Menu creation

    }, {
      key: "_createMenu",
      value: function _createMenu(menuJSON) {
        if (!this._menu) {
          $('#' + this._opts.id).remove(); // No I18N

          this._menu = $(ZC.createMenu(this._opts.id, menuJSON || [], this._getMenuSettings()));
          this._menuBody = $(this._menu[0].querySelector('.' + this.CLASSES.menubody)); // No I18N

          this._menuInstance = ZC.menu(this._menu);

          if (this._showSearchField) {
            this._storeSearchBox();
          }

          this._bindMenuEvents();

          this._trigger('menucreation', undefined, {
            // No I18N
            menu: this._menu,
            instance: this._menuInstance
          });
        }
      }
    }, {
      key: "_getMenuSettings",
      value: function _getMenuSettings() {
        var _this46 = this;

        // Revisit
        var customAttributes = this._opts.customAttributes || {};
        customAttributes.role = 'listbox'; // No I18N

        var menuSettings = {
          allowReplace: true,
          scroll: 'default',
          // No I18N
          className: this._getClass(),
          contentType: this._isCheckBoxType ? 'icon-text' : this._hasIcon ? this._hasText ? 'icon-text' : 'text' : 'text',
          // No I18N
          // beforeshow: this._onBeforeShow.bind(this),
          customAttributes: customAttributes,
          templateData: {
            searchBox: null,
            loader: null
          },
          handleAccessKeyNavigation: this._searchable ? false : this._opts.handleAccessKeyNavigation,
          templateFunc: 'listChildren' // No I18N

        }; // Direct options

        ['forElement', // No I18N
        'isCE', // No I18N
        'rtl', // No I18N
        'positionAlterable', // No I18N
        'direction', // No I18N
        'appendTo', // No I18N
        'viewport', // No I18N
        'animation', // No I18N
        'height', // No I18N
        'width'].forEach(function (key) {
          return menuSettings[key] = _this46._opts[key];
        }); // Events

        ['BeforeFocus', // No I18N
        'ItemClick', // No I18N
        'ItemHover', // No I18N
        'Show', // No I18N
        'BeforeHide', // No I18N
        'Hide', // No I18N
        'ItemChecked', // No I18N
        'BeforeItemChecked'] // No I18N
        .forEach(function (event) {
          var Levent = event.toLowerCase();
          menuSettings[Levent] = _this46['_on' + event].bind(_this46, Levent); // No I18N
        });

        if (this._loading) {
          this._includeLoaderData(menuSettings.templateData);
        }

        if (this._showSearchField) {
          this._addSearchBox(menuSettings);
        }

        return menuSettings;
      }
    }, {
      key: "_onItemChecked",
      value: function _onItemChecked() {
        this._trigger.apply(this, arguments);
      }
    }, {
      key: "_onBeforeItemChecked",
      value: function _onBeforeItemChecked() {
        this._trigger.apply(this, arguments);
      }
    }, {
      key: "_onBeforeFocus",
      value: function _onBeforeFocus(eventName, orgEvent) {
        if (this.inputField) {
          return orgEvent.preventDefault();
        }

        this._trigger.apply(this, arguments);
      }
    }, {
      key: "_hideEle",
      value: function _hideEle(element) {
        element.addClass('zh-dnone'); // No I18N
      }
    }, {
      key: "_showEle",
      value: function _showEle(element) {
        element.removeClass('zh-dnone'); // No I18N
      } // Method to create datasource instance

    }, {
      key: "_initDS",
      value: function _initDS() {
        var options = this._opts;
        this._menuLoaded = this._ajaxSource = this._highlighted = this._moreResultsData = false;
        this._headerJSON = [];
        this._footerJSON = [];
        this._groupHeads = [];
        var headerItems = options.headerItems;
        var footerItems = options.footerItems;

        if (headerItems && headerItems.length || footerItems && footerItems.length) {
          this._setHeaderFooterItems(headerItems, footerItems);
        }

        var dataSource = options.dataSource;
        var data = options.data;
        this._dsInit = false;

        if (dataSource && dataSource.URL || data && data.length) {
          this._dsInit = true;
          this.params = {};
          var dataSourceSettings = {
            callbacks: {}
          };

          if (dataSource && dataSource.URL) {
            this._ajaxSource = true;

            this._bindAjaxEvents(dataSourceSettings.callbacks);
          } else if (options.dataStructure === 'nested') {
            // No I18N
            this._isGrouped = true;
            data = this._flattenData(data);
            this._dataMapping.groupLabel = 'groupLabel'; // No I18N
          }

          dataSourceSettings.dataSource = dataSource;
          dataSourceSettings.data = data;
          this._virtualization = false;

          if (options.filterByCSSSelector && !this._ajaxSource) {
            this._lazyLoadData = false;
            this._styleBasedFilter = true;
            this._filterFn = this._filterListViaStyles;
          } else {
            this._lazyLoadData = options.lazyLoading;

            if (options.virtualization) {
              this._virtualization = this._lazyLoadData = true;
            }

            this._styleBasedFilter = false;
            this._filterFn = this._filterByAddRemoval;
          }

          dataSourceSettings.filter = options.search;
          ['sort', // No I18N
          'sortBy', // No I18N
          'sortOrder', // No I18N
          'customSorter', // No I18N
          'serverSearch', // No I18N
          'customSorter', // No I18N
          'dataMapping', // No I18N
          'isResponseFiltered', // No I18N
          'cacheData', // No I18N
          'customSearch'] // No I18N
          .forEach(function (key) {
            dataSourceSettings[key] = options[key];
          });
          var viewPerPage = options.viewPerPage;
          dataSourceSettings.maxResults = this._lazyLoadData ? this._isNotNull(viewPerPage) ? viewPerPage : 10 : 0;
          dataSourceSettings.searchIncrementsInCache = options.search.searchIncrementsInCache;
          this.DSInstance = new ZC.ZDatasourceHandler(null, dataSourceSettings);
        }
      } // Menu Object created from the datasource record using data mapping.

    }, {
      key: "getMenuData",
      value: function getMenuData(data, groupID, itemgroup) {
        var _this47 = this;

        /* style & title would be passed in custom atributes */
        var mData = {};
        mData.id = this._getItemId(data);
        mData.name = groupID;
        mData.itemType = itemgroup ? 'itemgroup' : 'custom'; // No I18N

        mData.selectable = !itemgroup;
        mData.originalData = data;
        mData.custom = true;

        if (_typeof(data) === 'object') {
          // No I18N
          ['className', 'hidden', 'disabled', 'customAttributes', 'isHeader', 'isFooter'].forEach(function (key) {
            // No I18N
            mData[key] = data[key];
          });

          if (data.separator) {
            mData.itemType = 'separator'; // No I18N

            mData.selectable = false;
          }

          var dataMapping = this._dataMapping;

          if (data.isHeader || data.isFooter) {
            if (!data.separator) {
              mData.innerHTML = data.innerHTML || this._mapJSONToData(data, dataMapping.label, true);
              mData.clickable = true;
            }

            mData.selectable = false;
          } else if (!data.separator) {
            var addToMenuData = function addToMenuData(key, dataKeyLabel) {
              mData[key] = dataKeyLabel && _this47._mapJSONToData(data, dataKeyLabel, true);
            };

            ['label', 'image', 'iconClassName', 'SVGIconId', 'textIcon'].forEach(function (key) {
              // No I18N
              addToMenuData(key, dataMapping[key]);
            });
            addToMenuData('description', dataMapping.informativeText); // No I18N
          }
        } else {
          mData.label = this._encodeContent(data);
          data = {
            label: data
          };
        }

        if (itemgroup) {
          mData.label = this._highlight(mData.label, this._dataMapping.groupLabel);
        }

        if (mData.selectable) {
          if (this._isCheckBoxType) {
            mData.itemType = 'checkbox'; // No I18N

            mData.custom = true;
          }

          mData.innerHTML = this._getMenuItemTemplate(mData, data);
          mData.iconClassName = mData.SVGIconId = mData.description = ''; // No I18N

          var attrs = mData.customAttributes = mData.customAttributes || {};
          attrs['data-label'] = mData.label; // No I18N

          if (data.value) {
            attrs['data-value'] = data.value; // No I18N
          }

          if (this._styleBasedFilter && this._searchable) {
            this._getAttrForCSSFilter(data, attrs);
          }
        }

        mData.normalisedData = data;
        return mData;
      } // Filter results using css style tag

    }, {
      key: "_openList",
      value: function _openList(orgEvent, applyFilterStyle) {
        var _this48 = this;

        // Menu is populated only once
        if (this._menuLoaded) {
          this._callMenuShow(orgEvent);
        } else {
          // this._groupsIncluded = [];
          this._noResults = false;
          var query = this.params.query;
          this.params.query = ''; // No I18N

          this._loadDataSource(function (dataSource) {
            var eventData = {
              results: dataSource,
              params: _this48.params
            };
            _this48.params.query = query;

            _this48._trigger('beforelistupdate', orgEvent, eventData); // No I18N


            eventData.addedMenuItems = _this48._replaceMenuItems(_this48._getMenuJSON(dataSource));
            applyFilterStyle && _this48._applyFilterStyles();

            _this48._afterFilter(orgEvent, eventData);

            _this48._menuLoaded = true;
          });
        }
      } // This is called only on new page creation

    }, {
      key: "_afterFilter",
      value: function _afterFilter(orgEvent, eventData, lazyLoaded) {
        var options = this._opts;
        var addedMenuItems = eventData && eventData.addedMenuItems;

        if (!lazyLoaded) {
          if (this._styleBasedFilter ? this.getFirstItem() : addedMenuItems && addedMenuItems.length) {
            if (this._styleBasedFilter) {
              options.search.showNoResultsMessage && this._removeNoResults();
              options.search.moreResultsAction && this._showMoreResults();
            }
          } else if (this._trigger('noresults', orgEvent, {
            // No I18N
            query: this.params.query
          })) {
            if (this._setNoResults() === false) {
              return;
            }
          }

          this._callMenuShow(orgEvent);
        }

        if (options.search.highlightKeyword) {
          this._highlightInList(eventData);
        }

        if (!this._noResults && this._lazyLoadData) {
          if (this._hasImage || this._hasIcon && this._isCheckBoxType) {
            var totalImgWidth = this._totalImgWidth;

            if (this._freshRequest) {
              var firstItem = this.getFirstItem();
              totalImgWidth = 0;
              firstItem = $(firstItem);
              var avatar = firstItem.find('.zsuggestfield__avatar'); // No I18N

              var icons = firstItem.find('.zmenu__iconcontainer'); // No I18N

              if (avatar.length) {
                totalImgWidth = avatar.outerWidth(true);
              }

              if (icons.length) {
                if (icons.length === 1) {
                  totalImgWidth += icons.outerWidth(true);
                } else {
                  icons.toArray().forEach(function (icon) {
                    return totalImgWidth += $(icon).outerWidth(true);
                  });
                }
              }

              this._totalImgWidth = totalImgWidth;
            }

            if (!this._freshRequest && totalImgWidth) {
              addedMenuItems.forEach(function (item) {
                return $(item).find('.zmenu__content').css('width', "calc(100% - ".concat(String(totalImgWidth), "px)"));
              }); // No I18N
            }
          } // Setting the width of items alters the scrollTop and hence scrollTop is set after all the operations.


          if (lazyLoaded) {
            this._afterLazyLoad();
          }
        }

        this._trigger('listupdate', orgEvent, eventData); // No I18N

      } // Method to get the display messages

    }, {
      key: "_getMsg",
      value: function _getMsg(key) {
        var options = this._opts;
        var instance = this.componentInstance;
        return instance ? instance._getI18NText(key) : options.messages[key];
      } // Menu class need to be provided since the items are generated and given as custom content to the menu.

    }, {
      key: "_getClass",
      value: function _getClass() {
        var classToBeAdded = this._opts.className || ''; // No I18

        var classes = this.CLASSES;

        var addClass = function addClass(newClass) {
          classToBeAdded += ' ' + newClass; // No I18N
        };

        if (!this._isCustom) {
          if (this._hasIcon) {
            if (this._hasText) {
              addClass(this._hasDesc ? classes.iconhint : classes.icon);
            } else {
              addClass(classes.icononly);
            }
          } else if (this._hasImage) {
            addClass(classes.suggestfield);

            if (this._hasDesc) {
              addClass(classes.withhint);
            }
          } else if (this._isCheckBoxType) {
            addClass(classes.icontext);
          }
        }

        if (this._loading) {
          addClass(classes.loadingmenu);
        }

        return classToBeAdded;
      } // To generate custom content for a menu item

    }, {
      key: "_getMenuItemTemplate",
      value: function _getMenuItemTemplate(mData, originalData) {
        var iconDOMStr = '',
            // No I18N
        textDOMStr = '',
            // No I18N
        descDOMStr = ''; // No I18N

        var classes = this.CLASSES;

        if (this._isCustom) {
          return this._getCustomContent(mData.originalData, originalData.zinnerHTML || originalData.innerHTML || this._opts.template, true);
        }

        if (this._hasIcon || this._hasImage) {
          iconDOMStr = this._getIconHTML(mData);
        }

        if (this._hasText) {
          textDOMStr = '<span class="' + classes.text + '">' + this._highlight(mData.label, this._dataMapping.label) + '</span>'; // No I18N
        }

        if (this._hasDesc) {
          descDOMStr = '<span class="' + classes.hint + '">' + (this._highlight(mData.description, this._dataMapping.informativeText) || '') + '</span>'; // No I18N
        }

        return iconDOMStr + (this._hasContentTag ? '<div class="zmenu__content">' + (textDOMStr + descDOMStr) + '</div>' : textDOMStr); // No I18N
      }
    }, {
      key: "_highlight",
      value: function _highlight(content, key) {
        if (content) {
          if (this.params.query && this._opts.search.highlightKeyword) {
            content = this._highlightValidKey(content, key);
          }
        }

        return content;
      } // Method to get the first visible menu item

    }, {
      key: "getFirstItem",
      value: function getFirstItem(selector) {
        var _this49 = this;

        selector = ".".concat(this.CLASSES.menuitem, ":not(#").concat(this._getID('noresults'), "):not([item-type=itemgroup]):not([hidden])").concat(selector || ''); // No I18N

        return _toConsumableArray(this._menuBody[0].children).find(function (item) {
          var $item = $(item);
          return $item.is(selector) && (!_this49._styleBasedFilter || $item.css('display') !== 'none'); // No I18N
        });
      }
    }, {
      key: "getFirstValidItem",
      value: function getFirstValidItem() {
        return this.getFirstItem(':not(.is-disabled)'); // No I18N
      } // Method to handle item hover

    }, {
      key: "_onItemHover",
      value: function _onItemHover(eventName, orgEvent, menuEventData) {
        menuEventData = this._getEventData(orgEvent, menuEventData);

        if (menuEventData.unhoverable) {
          orgEvent.preventDefault();
        } else {
          var eventData = this._getItemEventData(menuEventData);

          var originalEvent = orgEvent && orgEvent.detail.originalEvent;

          if (originalEvent && originalEvent.type === 'keydown') {
            // No I18N
            eventData.keyEvent = this._scrolledOnKeyDown = true;

            if (this._opts.inputFieldSettings.autoFill) {
              this._autoFilled = true;

              this._setInputValue(menuEventData);
            }
          }

          this._trigger(eventName, orgEvent, eventData); // No I18N

        }
      } // // Method to handle before show
      // _onBeforeShow(orgEvent, eventData) {
      //     this._trigger('beforeshow', orgEvent, eventData); // No I18N
      // }
      // Method to handle show

    }, {
      key: "_onShow",
      value: function _onShow() {
        var options = this._opts;
        this._opened = true;
        var itemToBeHovered;

        if (!this._noResults) {
          if (options.search.focusFirstResult) {
            itemToBeHovered = this.getFirstValidItem();
          }

          this._bindMenuBodyEvents();

          if (this._freshRequest && this._lazyLoadData && (this.params.totalPages > this.params.pageIndex || this.params.moreServerPages)) {
            this._bindScroll();

            if (this._virtualization) {
              this._calcItemHts();
            }
          }
        }

        if (options.showSearchField) {
          this._updateSearchBoxOnMenuShow();

          this.focusInputField();
        }

        this._menu.off('keydown.zmenu'); // No I18N


        this.hoverMenuItem(itemToBeHovered);

        this._setExpandAttr();

        this._trigger.apply(this, arguments); // No I18N

      }
    }, {
      key: "hoverMenuItem",
      value: function hoverMenuItem(itemToBeHovered) {
        if (!this._loading) {
          this._menuInstance.hoverMenuItem(itemToBeHovered); // It gives incorrect scrolltop as scrolltop needs some time to get updated.
          // this._lastScrollTop = this._menuBody[0].scrollTop;

        }
      }
    }, {
      key: "_bindMenuEvents",
      value: function _bindMenuEvents() {
        this._addEvents({
          menuKeyDown: 'keydown',
          // No I18N
          menuFocus: 'focusin' // No I18N

        }, this._menu);
      }
    }, {
      key: "_bindMenuBodyEvents",
      value: function _bindMenuBodyEvents() {
        this._addEvents({
          scroll: 'scroll' // No I18N

        }, this._menuBody);
      }
    }, {
      key: "_scrollHandler",
      value: function _scrollHandler(orgEvent) {
        if (this._considerScrollForLazyLoad) {
          this._scrollHandlerToLoadPage(orgEvent);
        } else {
          this._lastScrollTop = this._menuBody[0].scrollTop;
        }
      }
    }, {
      key: "_menuFocusHandler",
      value: function _menuFocusHandler() {
        this.focusInputField();
      }
    }, {
      key: "focusInputField",
      value: function focusInputField() {
        var inputField = this.inputField;

        if (inputField && this._opts.inputFieldSettings.handleEvents && document.activeElement !== inputField[0]) {
          inputField[0].focus();
        }
      }
    }, {
      key: "_handleKeyCode",
      value: function _handleKeyCode(orgEvent) {
        return this._menuInstance.handleKeyCode(orgEvent);
      }
    }, {
      key: "_onEnterKeyPress",
      value: function _onEnterKeyPress(orgEvent) {
        if (this._showSearchField && this._noResults) {
          return;
        }

        var hovered = this._getHovered();

        if (hovered.length) {
          return this._handleKeyCode(orgEvent);
        }

        this.closeDropdownList(orgEvent);
      }
    }, {
      key: "_getHovered",
      value: function _getHovered() {
        return this._menu.find('.on-hover'); // No I18N
      }
    }, {
      key: "_onEscKeyPress",
      value: function _onEscKeyPress(orgEvent) {
        // In Firefox, pressing ESC shows old value bug --> https://bugzilla.mozilla.org/show_bug.cgi?id=524360 and the event is prevented.
        orgEvent.preventDefault();

        this._trigger('esckeypress', orgEvent); // No I18N


        return this._handleKeyCode(orgEvent);
      }
    }, {
      key: "_upDownKeyPress",
      value: function _upDownKeyPress(orgEvent) {
        if (!this._lazyLoadData || !$(this._menuBody[0][orgEvent.code === ZC.keyCode.UP ? 'firstChild' : 'lastChild']).hasClass('on-hover')) {
          // No I18N
          return this._handleKeyCode(orgEvent);
        }
      }
    }, {
      key: "_menuKeyDownHandler",
      value: function _menuKeyDownHandler(orgEvent) {
        var ZkeyCode = ZC.keyCode;
        var code = orgEvent.keyCode;

        if (code === ZkeyCode.ESCAPE) {
          return this._onEscKeyPress(orgEvent);
        }

        if (!this._loader) {
          switch (code) {
            case ZkeyCode.DOWN:
            case ZkeyCode.UP:
              return this._upDownKeyPress(orgEvent);

            case ZkeyCode.PAGE_DOWN:
            case ZkeyCode.PAGE_UP:
              return this._handleKeyCode(orgEvent);

            case ZkeyCode.ENTER:
              return this._onEnterKeyPress(orgEvent);

            case ZkeyCode.SPACE:
              if (!this.inputField) {
                this._onEnterKeyPress(orgEvent);
              }

              break;

            case ZkeyCode.TAB:
              this.closeDropdownList(orgEvent);
              orgEvent.preventDefault();
              return;

            default:
              return this._handleKeyCode(orgEvent);
          }
        }
      } // Method to handle item click

    }, {
      key: "_onItemClick",
      value: function _onItemClick(eventName, orgEvent, menuEventData) {
        menuEventData = this._getEventData(orgEvent, menuEventData);

        if (menuEventData.noresults) {
          orgEvent.preventDefault();
          return;
        }

        if (menuEventData.selectable || menuEventData.clickable) {
          this._setInputValue && this._setInputValue(menuEventData);
        } else if (menuEventData.moreresults) {
          var moreResultsAction = this._opts.search.moreResultsAction;

          if (typeof moreResultsAction === 'function') {
            // No I18N
            moreResultsAction();
          }

          this._trigger('moreactionclick', orgEvent, this._getItemEventData(menuEventData)); // No I18N

        } else {
          return;
        }

        return this._trigger(eventName, orgEvent, this._getItemEventData(menuEventData));
      }
    }, {
      key: "_getItemEventData",
      value: function _getItemEventData(menuEventData) {
        return {
          data: menuEventData.originalData,
          listItem: menuEventData.menuitem,
          listItemData: menuEventData.data
        };
      } // Method to get the event detail

    }, {
      key: "_getEventData",
      value: function _getEventData(orgEvent, eventData) {
        return eventData || (orgEvent && _typeof(orgEvent.detail) === 'object' ? orgEvent.detail : undefined); // No I18N
      } // Method to handle menu hide

    }, {
      key: "_onHide",
      value: function _onHide() {
        this._opened = false;
        this._cachedData = undefined;

        if (this._showSearchField) {
          this.inputField.val(''); // No I18N
        }

        this._setExpandAttr();

        this._removeStyle();

        this._trigger.apply(this, arguments); // No I18N

      }
    }, {
      key: "_setExpandAttr",
      value: function _setExpandAttr() {
        if (this._opts.forElement) {
          this._opts.forElement.attr('aria-expanded', this._opened); // No I18N

        }
      } // Method to handle before hide

    }, {
      key: "_onBeforeHide",
      value: function _onBeforeHide() {
        return this._trigger.apply(this, arguments); // No I18N
      } // Method to hide suggestions

    }, {
      key: "_hideSuggestions",
      value: function _hideSuggestions(orgEvent) {
        if (this._menu && this._opened) {
          this._menuInstance.hide(undefined, orgEvent);
        }
      } // Method to call callback functions

    }, {
      key: "_trigger",
      value: function _trigger(customEvent, orgEvent, eventData) {
        var callback = this._opts.callbacks[customEvent];
        var response;

        if (typeof callback === 'function') {
          // No I18N
          response = callback(orgEvent, this._getEventData(orgEvent, eventData));
        }

        return response === undefined ? !(orgEvent && orgEvent.isDefaultPrevented()) : response;
      }
    }, {
      key: "_getMenuJSON",
      value: function _getMenuJSON(dataSource) {
        var _this50 = this;

        if (this._isGrouped) {
          return this._getMenuJSONForGroupedData(dataSource);
        }

        return dataSource.map(function (data) {
          return _this50.getMenuData(data);
        });
      }
    }, {
      key: "_addMenuItems",
      value: function _addMenuItems(menuJSON) {
        if (this._menu) {
          return this._menuInstance.addMenuItems(menuJSON, null, !this._freshRequest);
        }

        this._createMenu(menuJSON);

        return _toConsumableArray(this._menuBody[0].children);
      }
    }, {
      key: "_replaceMenuItems",
      value: function _replaceMenuItems(menuJSON) {
        menuJSON = {
          header: this._headerJSON,
          body: menuJSON,
          footer: this._footerJSON
        };
        this._opts.search.moreResultsAction && this._setMoreResults();

        if (this._menu) {
          return this._menuInstance.replaceMenuItems(menuJSON, null, !this._freshRequest);
        }

        this._createMenu(menuJSON);

        return _toConsumableArray(this._menuBody[0].children);
      }
    }, {
      key: "_getID",
      value: function _getID(key) {
        return 'z' + this._opts.id + '-' + key; // No I18N
      }
    }, {
      key: "_loadDataSource",
      value: function _loadDataSource(callback) {
        var _this51 = this;

        var results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        if (this._dsInit) {
          // Incase of static data, data is fetched only once
          this.DSInstance.fetch(this.params, function (data) {
            _this51.params = data;
            results = results.concat(data.results);

            if (data.moreServerPages && _this51._lazyLoadData && results.length < _this51._opts.viewPerPage) {
              _this51._getNextPage(callback, undefined, results);
            } else {
              callback(results);
            }
          });
        } else {
          callback([]);
        }
      }
    }, {
      key: "_mapJSONToData",
      value: function _mapJSONToData(data, mapper) {
        return _get(_getPrototypeOf(ZList.prototype), "_mapJSONToData", this).call(this, data, mapper, true);
      }
    }, {
      key: "_getItemId",
      value: function _getItemId(data) {
        return _get(_getPrototypeOf(ZList.prototype), "_getItemId", this).call(this, data, this._opts.id);
      }
    }, {
      key: "_callMenuShow",
      value: function _callMenuShow(orgEvent) {
        var options = this._opts;
        var openOptions = {
          event: orgEvent,
          mustBeShown: true,
          positionAlterable: options.positionAlterable,
          forElement: options.forElement
        };
        var direction = options.direction;
        var positionAlterable = options.positionAlterable;

        if (direction === 'auto') {
          // No I18N
          direction = 'bottom-left'; // No I18N
        }

        if (positionAlterable) {
          openOptions.direction = direction;
          openOptions.positionAlterable = positionAlterable;

          this._alterPositionOptions(openOptions);
        }

        if (this._trigger('beforeshow', orgEvent, {
          // No I18N
          openOptions: openOptions
        })) {
          this._createMenu();

          this._menuInstance.show(openOptions);
        }
      }
    }, {
      key: "_alterPositionOptions",
      value: function _alterPositionOptions(openOptions) {
        var _this52 = this;

        if (!this._opened) {
          this._maxHt = 0;
        }

        openOptions.callbacks = {
          beforeComputingDir: {
            dimensionModifier: function dimensionModifier(targetDim, elementDim, withinDim, options) {
              if (elementDim.height > _this52._maxHt || !_this52._maxHt) {
                _this52._maxHt = elementDim.height;
              } else {
                options.positionAlterable = false;
                options.direction = _this52._menu.data('direction'); // No I18N
              }
            }
          }
        };
      }
    }, {
      key: "openDropdownList",
      value: function openDropdownList(orgEvent) {
        var options = this._opts;

        if (this._searchable || this._lazyLoadData) {
          var searchTerm;

          if (!this._searchable || options.showSearchField || options.showAllItemsOnDOWNKeyPress && !options.serverSearch) {
            searchTerm = ''; // No I18N
          }

          this.search(searchTerm, orgEvent, !options.showSearchField); // No I18N
        } else {
          this._openList(orgEvent);
        }
      }
    }, {
      key: "closeDropdownList",
      value: function closeDropdownList(orgEvent) {
        this._hideSuggestions(orgEvent);
      }
    }, {
      key: "_destroyDSIns",
      value: function _destroyDSIns() {
        if (this.DSInstance) {
          this.DSInstance.destroy();
        }
      }
    }, {
      key: "_removeStyle",
      value: function _removeStyle() {
        if (this.styletag) {
          this.styletag.remove();
          this.styletag = undefined;
        }
      }
    }, {
      key: "refresh",
      value: function refresh() {
        var query = this.params && this.params.query;
        var reopen = this._opened;
        this._highlightData = undefined;

        this._detachEvents();

        this._removeStyle();

        this._destroyDSIns();

        this._create();

        if (this._menu) {
          this._menuInstance.setAttributes(this._getMenuSettings());

          if (this._showSearchField) {
            this._storeSearchBox();
          }

          if (reopen) {
            if (query) {
              this.search(query);
            } else {
              this.openDropdownList();
            }

            this._setScrollTop();
          }
        }
      }
    }, {
      key: "_setScrollTop",
      value: function _setScrollTop() {
        this._menuBody[0].scrollTop = this._lastScrollTop;
      }
    }, {
      key: "_getText",
      value: function _getText(feature) {
        var innerText = ZC.encodeHTML(this._getMsg(feature)).replace(/#query#/g, '<b class="h-bold">' + this.params.query + '</b>'); // No I18N

        return '<span class=' + this.CLASSES.text + '>' + innerText + '</span>'; // No I18N
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        this._opts[optionName] = value;
      }
    }, {
      key: "setAttributes",
      value: function setAttributes(optionName, value) {
        _get(_getPrototypeOf(ZList.prototype), "setAttributes", this).call(this, optionName, value);

        this.refresh();
      }
    }, {
      key: "_detachEvents",
      value: function _detachEvents() {
        if (this.inputField) {
          this._removeEvents('', this.inputField); // No I18N

        }

        if (this._menuBody) {
          this._removeEvents('', this._menuBody); // No I18N

        }
      }
    }, {
      key: "clearCache",
      value: function clearCache() {
        this.refresh();
      }
    }, {
      key: "destroy",
      value: function destroy() {
        clearTimeout(this._searchTimer);

        this._detachEvents();

        this._destroyDSIns();

        this._removeStyle();

        this.componentInstance = undefined;

        if (this._menu) {
          if (!this._opts.isCE) {
            ZC.menu(this._menu).destroy();
          }

          this._menu.remove();
        }
      }
    }, {
      key: "positionList",
      value: function positionList() {
        this._callMenuShow();

        this._setScrollTop();
      }
    }, {
      key: "_includeLoader",
      value: function _includeLoader() {
        if (this._menuInstance) {
          this._updateLoaderState(true);
        } else {
          this._loading = true;

          this._createMenu();

          this._callMenuShow();
        }
      }
    }, {
      key: "_removeLoader",
      value: function _removeLoader() {
        this._updateLoaderState(false);
      }
    }, {
      key: "_updateLoaderState",
      value: function _updateLoaderState(loader) {
        if (loader !== this._loading) {
          var menuInstance = this._menuInstance;
          this._loading = loader;
          var templateData = menuInstance.getAttribute('templateData'); // No I18N

          if (loader) {
            this._includeLoaderData(templateData);
          } else {
            templateData.loader = false;
          }

          menuInstance.setAttributes(_defineProperty({
            templateData: templateData
          }, (this._opts.isCE ? 'z' : '') + 'className', this._getClass()));
        }

        loader && !this._opened && this._callMenuShow();
      }
    }, {
      key: "_includeLoaderData",
      value: function _includeLoaderData(templateData) {
        var options = this._opts;
        var loaderIconClassName = options.loaderIconClassName;
        var loaderSVGIconId = options.loaderSVGIconId;

        if (loaderIconClassName || loaderSVGIconId) {
          templateData.loader = ZC._getIconInfo(loaderIconClassName, loaderSVGIconId, '#zc__svg--loader zmenu__svg zmenu__loader zeffects--rotate', 'zmenu__icon zh-loading', templateData.loader = {}); // No I18N
        } else {
          templateData.loader = templateData.defaultLoader = true;
        }
      }
    }, {
      key: "_bindAjaxEvents",
      value: function _bindAjaxEvents(callbacks) {
        callbacks.requeststart = this._onReqStart.bind(this);
        callbacks.requestend = this._onReqEnd.bind(this);
        callbacks.requesterror = this._onReqErr.bind(this);
      } // Method to handle before ajax request starts

    }, {
      key: "_onReqStart",
      value: function _onReqStart(eventData) {
        this._includeLoader();

        this._trigger('requeststart', null, eventData); // No I18N

      } // Method to handle when ajax reuwst ends

    }, {
      key: "_onReqEnd",
      value: function _onReqEnd(eventData) {
        this._removeLoader();

        this._trigger('requestend', null, eventData); // No I18N

      } // Method to handle when ajax request fails

    }, {
      key: "_onReqErr",
      value: function _onReqErr(eventData) {
        this._removeLoader();

        this._replaceMenuItems([{
          innerHTML: this._getText('serverError'),
          // No I18N
          itemType: 'custom',
          // No I18N
          className: this.CLASSES.unselectable + ' zmenu__servererror',
          // No I18N
          unhoverable: true
        }]);

        this._trigger('requesterror', null, eventData); // No I18N
        // console.log("ajaxreq error");

      }
    }, {
      key: "search",
      value: function search(query, orgEvent, showComplete) {
        this._search(query, orgEvent, null, showComplete);
      }
    }, {
      key: "searchWithDelay",
      value: function searchWithDelay(query, orgEvent, delay, searchOnCurPos) {
        var _this53 = this;

        clearTimeout(this._searchTimer);

        if (delay) {
          this._searchTimer = setTimeout(function () {
            _this53._search(query, orgEvent, searchOnCurPos);
          }, delay);
        } else {
          this._search(query, orgEvent, searchOnCurPos);
        }
      }
    }, {
      key: "_search",
      value: function _search(query, orgEvent, searchOnCurPos, showComplete) {
        var options = this._opts;
        var inputField = this.inputField && this.inputField[0];

        if (query === undefined) {
          query = inputField ? inputField.value : ''; // No I18N
        }

        if (query && searchOnCurPos && inputField) {
          var selectionStart = inputField.selectionStart;
          var selectionEnd = inputField.selectionEnd;

          if (selectionStart !== selectionEnd) {
            selectionStart = query.length - 1;
          }

          query = query.substring(0, selectionStart);
        }

        this.params.previousQuery = this._inSufficentQuery ? undefined : this.params.query;
        this.params.query = query;

        if (this._trigger('beforesearch', orgEvent, {
          // No I18N
          params: this.params
        })) {
          var minKeywordLength = options.search.minKeywordLength;
          var inSufficientQuery = minKeywordLength && !showComplete && query.length < minKeywordLength;

          if (this._dsInit && query !== undefined && !inSufficientQuery) {
            this._filterFn(orgEvent);
          } else if (this._setNoResults(inSufficientQuery) !== false) {
            if (this._styleBasedFilter && !this._menuLoaded) {
              this._replaceMenuItems([]);
            }

            this._callMenuShow(orgEvent);
          }
        } else {
          this.params.query = this.params.previousQuery;

          this._hideSuggestions();
        }
      }
    }, {
      key: "_filterByAddRemoval",
      value: function _filterByAddRemoval(orgEvent) {
        var _this54 = this;

        this._inSufficentQuery = false; // Check with previous and open the previous menu incase query is the same.

        if (this._menu && this.params.query === this.params.previousQuery && !this._virtualization) {
          if (!this._opened) {
            if (!this._noResults || this._opts.search.showNoResultsMessage) {
              this._trigger('beforelistupdate'); // No I18N


              this._callMenuShow();

              this._setScrollTop();

              this._trigger('listupdate'); // No I18N

            }
          }

          return;
        } // Initialisation related to virtualisation


        this._freshRequest = true;
        this.params.pageIndex = 1;
        this._noResults = null;
        this._lastScrollTop = 0;
        this._scroll = {};
        this._groupsIncluded = [];

        if (this.DSInstance._serverPaging) {
          this.params.serverPageIndex = 0;
          this.params.moreServerPages = true;
        }

        this._unbindScroll && this._unbindScroll();

        if (this._virtualization) {
          this._showVirtualData(orgEvent);
        } else {
          this._loadDataSource(function (filteredData) {
            return _this54._addDataToMenu(filteredData, orgEvent);
          });
        }
      }
    }, {
      key: "_addDataToMenu",
      value: function _addDataToMenu(filteredData, orgEvent) {
        var eventData = {
          results: filteredData,
          params: this.params
        };

        this._trigger('beforelistupdate', orgEvent, eventData); // No I18N


        filteredData = eventData.results;

        if (filteredData.length) {
          eventData.addedMenuItems = this[this._freshRequest ? '_replaceMenuItems' : '_addMenuItems'](this._getMenuJSON(filteredData)); // No I18N
        }

        this._afterFilter(orgEvent, eventData, !this._freshRequest);
      }
    }, {
      key: "_bindInputFieldEvents",
      value: function _bindInputFieldEvents() {
        if (this.inputField && this.inputField.length) {
          var inputSettings = this._opts.inputFieldSettings;

          if (inputSettings.handleEvents) {
            var events = {
              inputKeydown: 'keydown',
              // No I18N
              paste: 'paste' // No I18N

            };

            if (inputSettings.filterBasedOnCurPos || inputSettings.suggestOnFocus) {
              events.inputMousedown = 'mousedown'; // No I18N

              events.inputMouseup = 'mouseup'; // No I18N

              events.inputKeyup = 'keyup'; // No I18N
            }

            this._addEvents(events, this.inputField);

            this.inputField.on((this.isIE9 ? 'keyup' : 'input') + '.' + this.name, this._inputHandler.bind(this)); // No I18N
          }
        }
      }
    }, {
      key: "_inputKeydownHandler",
      value: function _inputKeydownHandler(orgEvent) {
        if (this.isIE9) {
          clearTimeout(this._searchTimer);
        }

        var options = this._opts;
        var code = orgEvent.keyCode;
        var ZkeyCode = ZC.keyCode;
        this._lastKeyCode = this._lastKeyCode ? undefined : code;

        if (this._showSearchField) {
          if (code === ZkeyCode.LEFT || code === ZkeyCode.RIGHT) {
            orgEvent.stopPropagation();
          }
        } else if (this._noResults && code === ZkeyCode.ENTER) {
          orgEvent.stopPropagation();

          this._trigger('newvalue', orgEvent); // No I18N

        } else if (code === ZkeyCode.TAB) {
          this._opened && options.preventDefaultOnTabPress && orgEvent.preventDefault();

          if (this._noResults) {
            this._trigger('newvalue', orgEvent); // No I18N

          } else if (this._opened) {
            if (options.selectHoveredOnTabPress) {
              var hovered = this._getHovered();

              if (hovered.length) {
                this._menuInstance.selectHoveredMenuItem();

                return;
              }
            }

            this.closeDropdownList(orgEvent);
          }
        } else if ((this._opened || code === ZkeyCode.ESCAPE) && code !== ZkeyCode.LEFT && code !== ZkeyCode.RIGHT) {
          return this._menuKeyDownHandler(orgEvent);
        } else if (code === ZkeyCode.DOWN || code === ZkeyCode.UP
        /* && !this._ajaxSource */
        ) {
            this.openDropdownList(orgEvent);
          }
      }
    }, {
      key: "_inputHandler",
      value: function _inputHandler(orgEvent) {
        if (orgEvent.type === 'input' || this._isAlphaNumericKey(orgEvent)) {
          // No I18N
          var value = orgEvent.target.value;

          this._trigger('input', orgEvent); // No I18N

          /* Value is passed here because the input content might vary when autoComplete is done in combobox */


          this.searchWithDelay(value, orgEvent, this._opts.search.delay);
        }
      }
    }, {
      key: "_inputKeyupHandler",
      value: function _inputKeyupHandler(orgEvent) {
        var ZkeyCode = ZC.keyCode;
        var keyCode = orgEvent.keyCode;
        var inputFieldSettings = this._opts.inputFieldSettings;

        if (inputFieldSettings.suggestOnFocus && keyCode === ZkeyCode.TAB && keyCode !== this._lastKeyCode) {
          this.searchWithDelay(undefined, orgEvent, 1);
        } else if (inputFieldSettings.filterBasedOnCurPos && [ZkeyCode.LEFT, ZkeyCode.RIGHT, ZkeyCode.HOME, ZkeyCode.END].indexOf(keyCode) > -1) {
          this.searchWithDelay(undefined, orgEvent, 1, true);
        }

        this._lastKeyCode = undefined;
      }
    }, {
      key: "_inputMousedownHandler",
      value: function _inputMousedownHandler(orgEvent) {
        var inputField = this.inputField[0];
        this._filteredOnMouseDown = false;

        if (inputField.selectionStart === inputField.selectionEnd) {
          this._filteredOnMouseDown = true;

          this._searchBasedOnCurPos(orgEvent);
        }
      }
    }, {
      key: "_searchBasedOnCurPos",
      value: function _searchBasedOnCurPos(orgEvent) {
        if (!orgEvent.button) {
          var inputFieldSettings = this._opts.inputFieldSettings;
          var filterBasedOnCurPos = inputFieldSettings.filterBasedOnCurPos;

          if (inputFieldSettings.suggestOnFocus || filterBasedOnCurPos) {
            this.searchWithDelay(undefined, orgEvent, 200, filterBasedOnCurPos);
          }
        }
      }
    }, {
      key: "_inputMouseupHandler",
      value: function _inputMouseupHandler(orgEvent) {
        if (!this._filteredOnMouseDown) {
          this._searchBasedOnCurPos(orgEvent);
        }
      }
    }, {
      key: "_pasteHandler",
      value: function _pasteHandler(orgEvent) {
        var _this55 = this;

        clearTimeout(this._searchTimer);
        this._searchTimer = setTimeout(function () {
          var value = orgEvent.target.value;

          _this55._trigger('input', orgEvent); // No I18N


          _this55.search(value, orgEvent);
        });
      } // Method to set the inputfield value if given

    }, {
      key: "_setInputValue",
      value: function _setInputValue(menuData) {
        if (this.inputField && !this._showSearchField && menuData.selectable && this._opts.inputFieldSettings.updateOnSelect) {
          this.inputField[0].value = this._mapJSONToData(menuData.normalisedData, this._dataMapping.label);
        }
      }
    }, {
      key: "_addNoResults",
      value: function _addNoResults() {
        if (this._opts.search.moreResultsAction && this._styleBasedFilter) {
          this._hideMoreResults();
        }

        var addMethodName = '_replaceMenuItems'; // No I18N

        if (this._styleBasedFilter) {
          this._removeNoResults();

          addMethodName = '_addMenuItems'; // No I18N
        }

        var classes = this.CLASSES;
        this[addMethodName]([{
          innerHTML: this._getText('noResults'),
          // No I18N
          itemType: 'custom',
          // No I18N
          id: this._getID('noresults'),
          // No I18N
          className: classes.unselectable + ' zmenu__noresults',
          // No I18N
          unhoverable: true,
          noresults: true
        }]);
      } // Method to remove no results item

    }, {
      key: "_removeNoResults",
      value: function _removeNoResults() {
        this._menu && this._menuInstance.removeMenuItem('#' + this._getID('noresults')); // No I18N
      }
    }, {
      key: "_getMenuJSONForGroupedData",
      value: function _getMenuJSONForGroupedData(dataSource) {
        var _this56 = this;

        var menuJSON = [];
        dataSource.forEach(function (data) {
          var groupLabel = _this56._mapJSONToData(data, _this56._dataMapping.groupLabel);

          var groupID;
          var groupData = groupLabel = _this56._isNotNull(groupLabel) ? groupLabel : ''; // No I18N

          if (_this56._isGrouped && _this56._groupHeads.length) {
            groupData = _this56._groupHeads.find(function (data) {
              return groupLabel === _this56._mapJSONToData(data, _this56._dataMapping.label);
            });
          }

          groupData = _this56.getMenuData(groupData, null, true);
          groupID = groupData.id;

          if (groupData && _this56._groupsIncluded.indexOf(groupID) === -1) {
            menuJSON.push(groupData);

            _this56._groupsIncluded.push(groupID);
          }

          menuJSON.push(_this56.getMenuData(data, groupID));
        });
        return menuJSON;
      } // Method to convert grouped datas to flat datas

    }, {
      key: "_flattenData",
      value: function _flattenData(dataSource, groupData) {
        var _this57 = this;

        var newDS = [];
        var subGroupLabel = this._dataMapping.options;
        dataSource.forEach(function (data) {
          var subOptions = data[subGroupLabel];

          if (subOptions) {
            _this57._groupHeads.push(data);

            newDS = newDS.concat(_this57._flattenData(subOptions, data));
          } else {
            if (groupData) {
              data.groupLabel = _this57._mapJSONToData(groupData, _this57._dataMapping.groupLabel);
              data.hidden = data.hidden || groupData.hidden;
              data.disabled = data.disabled || groupData.disabled;
            }

            newDS.push(data);
          }
        });
        return newDS;
      }
    }, {
      key: "_getIconHTML",
      value: function _getIconHTML(mData) {
        if (this._hasIcon) {
          var splits;
          var SVGIconId = mData.SVGIconId;
          var iconClassName = mData.iconClassName;

          if (SVGIconId) {
            splits = SVGIconId.split(' '); // No I18N

            splits[0] = splits[0].trim().replace(/^#/, ''); // No I18N

            iconClassName = undefined;
          }

          var iconHTML;

          if (!iconClassName && !SVGIconId && mData.textIcon) {
            iconHTML = "<i class=\"zmenu__icon zmenu__texticon\">".concat(mData.textIcon, "</i>");
          } else {
            iconHTML = "<i class=\"zmenu__icon ".concat(iconClassName || '', "\">").concat(SVGIconId ? "<svg class=\"zmenu__svg ".concat(splits[1] || '', "\"><use xlink:href=\"#").concat(splits[0], "\"></use></svg>") : '', "</i>");
          }

          return '<div class="zmenu__iconcontainer">' + iconHTML + '</div>'; // No I18N
        }

        return '<img src="' + mData.image + '" class="zsuggestfield__avatar">'; // No I18N
      }
    }, {
      key: "_filterListViaStyles",
      value: function _filterListViaStyles(orgEvent) {
        this._noResults = this._inSufficentQuery = false;

        if (this._menuLoaded) {
          this._trigger('beforelistupdate', orgEvent); // No I18N


          this._applyFilterStyles();

          this._afterFilter(orgEvent);
        } else {
          this._openList(orgEvent, true);
        }
      }
      /* Function to inject styles for filtering */

    }, {
      key: "_applyFilterStyles",
      value: function _applyFilterStyles() {
        var _this58 = this;

        var query = this.params.query;

        if (query.length) {
          var search = this._opts.search || {};

          if (!search.caseSensitive) {
            query = query.toLowerCase();
          }

          var operator = search.criteria === 'startswith' ? '^' : '*'; // No I18N

          var styles = "#".concat(this._opts.id, " .").concat(this.CLASSES.menubody, " > *:not(.").concat(this.CLASSES.title, ")").concat(this._getSearchBy(this._opts.search.by).map(function (by) {
            return ":not([data-".concat(by).concat(operator, "=\"").concat(_this58._escapeQuery(query), "\"])");
          }).join(''), ":not(#").concat(this._getID('noresults'), ") {display:none !important;}"); // No I18N

          this._injectStyle(styles);

          if (this._isGrouped) {
            if (!this._opened) {
              this._menu.show();
            }

            var groupIDsToHide = this._groupsIncluded.filter(function (groupId) {
              return !_this58.getFirstItem('[name=' + groupId + ']');
            }); // No I18N


            if (groupIDsToHide.length) {
              styles += '#' + groupIDsToHide.join(',#') + '{display:none; !important}'; // No I18N
            }

            if (!this._opened) {
              this._menu.hide();
            }

            this._injectStyle(styles);
          }
        } else {
          this._removeStyle();
        }
      }
    }, {
      key: "_getAttrForCSSFilter",
      value: function _getAttrForCSSFilter(data, attrs) {
        var _this59 = this;

        var searchBy = this._getSearchBy(this._opts.search.by);

        searchBy.forEach(function (by) {
          var value = data[by];

          if (_this59._isNotNull(value)) {
            attrs['data-' + by] = _this59._opts.search.caseSensitive ? value : value.toLowerCase(); // No I18N
          }
        });
      }
    }, {
      key: "_injectStyle",
      value: function _injectStyle(styles) {
        if (!this.styletag) {
          this.styletag = $('<style id=' + this._getID('style') + '>').appendTo($('head')); // No I18N
        }

        this.styletag.text(styles);
      }
    }, {
      key: "_hideItemsUsingCSS",
      value: function _hideItemsUsingCSS() {
        this._injectStyle("#".concat(this._opts.id, " .").concat(this.CLASSES.menubody, " .").concat(this.CLASSES.menuitem, " {display:none; !important}")); // No I18N

      }
    }, {
      key: "name",
      get: function get() {
        return "zlist";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          id: null,
          direction: 'auto',
          // No I18N
          positionAlterable: true,
          forElement: null,
          contentType: 'text',
          // No I18N
          appendTo: null,
          height: null,
          width: null,
          messages: {},
          checkedIcon: null,
          checkedIconClassName: null,
          checkedSVGIconId: null,
          showSearchField: false,
          isGrouped: false,
          lazyLoading: true,
          virtualization: false,
          maxPage: 3,
          viewPerPage: null,
          sort: false,
          sortBy: null,
          sortOrder: null,
          customSorter: null,
          filterByCSSSelector: false,
          serverSearch: false,
          cacheData: true,
          selectHoveredOnTabPress: false,
          preventDefaultOnTabPress: false,
          customSearch: null,
          showAllItemsOnDOWNKeyPress: false,
          search: {
            by: 'label',
            // No I18N
            searchIncrementsInCache: false,
            highlightKeyword: false,
            showNoResultsMessage: false,
            moreResultsAction: false
          },
          dataMapping: {
            label: 'label',
            // No I18N
            value: 'value',
            // No I18N
            informativeText: 'informativeText',
            // No I18N
            iconClassName: 'iconClassName',
            // No I18N
            textIcon: null,
            // No I18N
            SVGIconId: 'SVGIconId',
            // No I18N
            options: 'options' // No I18N

          },
          inputField: null,
          inputFieldSettings: {
            updateOnSelect: true,
            autoFill: true,
            handleEvents: true,
            filterBasedOnCurPos: false,
            suggestOnFocus: true
          },
          callbacks: {}
        };
      } // Revisit - Remove it

    }, {
      key: "CLASSES",
      get: function get() {
        return {
          suggestfield: 'zsuggestfield',
          // No I18N
          unselectable: 'zsuggestfield__nonselectable',
          // No I18N
          iconhint: 'zsuggestfield--withiconandhint',
          // No I18N
          icon: 'zsuggestfield--withicon',
          // No I18N
          loadingmenu: 'zsuggestfield--loading',
          // No I18N
          withhint: 'zmenu--withhint',
          // No I18N
          icononly: 'zmenu--icononly',
          // No I18N
          icontext: 'zmenu--iconwithtext',
          // No I18N
          title: 'zmenu__title',
          // No I18N
          loader: 'zmenu--loading',
          // No I18N
          text: 'zmenu__text',
          // No I18N
          hint: 'zmenu__description',
          // No I18N
          menuicon: 'zmenu__icon',
          // No I18N
          menuitem: 'zmenu__item',
          // No I18N
          menubody: 'zmenu__body' // No I18N

        };
      }
    }, {
      key: "isIE9",
      get: function get() {
        return ZC.Browser.getIEVersion() === 9;
      }
    }]);

    return ZList;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZList', ZList);

  (function (ZC) {
    var template = ZC.zmenu.Templates;
    var utilities = ZC.Templates.Utilities;

    template.listChildren = function (data) {
      return ZT.html(_templateObject110(), (data.searchBox || data.headerItems.length) && ZT.html(_templateObject111(), data.headerElement || ZT.html(_templateObject112(), data.searchBox && ZT.html(_templateObject113(), utilities.icon(data.searchBox), data.searchBoxId), data.headerItems.map(function (item) {
        return template.item(item);
      }))), data.items && ZT.html(_templateObject114(), data.bodyElement || ZT.html(_templateObject115(), data.items.map(function (item) {
        return template.item(item);
      }))), data.footerItems.length && ZT.html(_templateObject116(), data.footerElement || ZT.html(_templateObject117(), data.footerItems.map(function (item) {
        return template.item(item);
      }))), data.loader && ZT.html(_templateObject118(), template.loader(data)));
    };

    template.loader = function (data) {
      return ZT.html(_templateObject119(), data.id, data.defaultLoader ? ZT.customHTML(_templateObject120()) : ZT.html(_templateObject121(), icon(data.loader)));
    };
  })(ZComponents);

  var ZSuggestfield =
  /*#__PURE__*/
  function (_ZC$CoreComponent12) {
    _inherits(ZSuggestfield, _ZC$CoreComponent12);

    function ZSuggestfield() {
      _classCallCheck(this, ZSuggestfield);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZSuggestfield).apply(this, arguments));
    }

    _createClass(ZSuggestfield, [{
      key: "_init",
      value: function _init(element, options) {
        this._id = this._getID(element);
        this._menuId = this._id + '-menu'; // No I18N

        if (!this.isCE) {
          ['disabled', 'placeholder'].forEach(function (prop) {
            // No I18N
            options[prop] = options[prop] || element[0][prop];
          });
        }
      }
    }, {
      key: "_render",
      value: function _render() {
        var element = this.element;
        var options = this._opts;
        var data = this._data;
        data.disabled = options.disabled;

        if (this._beforeRender(options, data)) {
          _get(_getPrototypeOf(ZSuggestfield.prototype), "_render", this).apply(this, arguments);
        } else {
          !data._rendered && this._postRender(element);

          this._postEachRender(element);

          data._rendered = true;
        }
      }
    }, {
      key: "_beforeRender",
      value: function _beforeRender(options, data) {
        data.inputClass = 'zsuggestfield-element ' + (options.className || options.zclassName || ''); // No I18N

        return this.isCE;
      }
    }, {
      key: "_initSource",
      value: function _initSource() {
        var listSettings = this._getListSettings();

        this._listInstance = new ZC.ZList(null, listSettings);
        this._listInstance.componentInstance = this;
      }
    }, {
      key: "_postRender",
      value: function _postRender(element) {
        this._input = this.isCE ? element.find('input') : element; // No I18N

        this._initSource();
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender() {
        var data = this._data;
        var options = this._opts;

        if (this._domChanged || !data.rendered) {
          var attrs = {
            disabled: options.disabled || null,
            role: 'search',
            // No I18N
            'aria-owns': this._menuId,
            // No I18N
            'aria-haspopup': true,
            // No I18N
            placeholder: options.placeholder,
            autocomplete: 'off' // No I18N

          };
          var inputElement = this.isCE ? this.element.find('input') : this.element; // No I18N

          inputElement.attr(attrs);
          var parentClass = attrs.disabled ? ' is-disabled' : ''; // No I18N

          data.className = this.isCE ? parentClass : data.inputClass + parentClass;
        }
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        this._addEvents({
          blur: 'blur' // No I18N

        }, this._input);
      }
    }, {
      key: "_blurHandler",
      value: function _blurHandler(orgEvent) {
        var _this60 = this;

        clearTimeout(this._blurTimer);
        var value = this._opts.value;

        if (value !== this._oldVal) {
          this._blurTimer = setTimeout(function () {
            if (_this60._input[0] !== document.activeElement) {
              _this60._oldVal = value;

              _this60._trigger('change', orgEvent, _this60._getEventData()); // No I18N

            }
          });
        }
      }
    }, {
      key: "_getListSettings",
      value: function _getListSettings() {
        var options = this._opts;
        var dropdownList = options.dropdownList;
        var dataMapping = options.dataMapping;
        var search = options.search;
        var settings = {
          id: this._menuId,
          rtl: options.rtl,
          isCE: this.isCE,
          direction: this._getMenuPos(dropdownList.position),
          dataMapping: _objectSpread({}, dataMapping, {}, {
            label: dataMapping.text
          }),
          search: _objectSpread({}, search, {}, {
            focusFirstResult: options.autoComplete ? false : search.focusFirstResult
          }),
          callbacks: this._getListCallbacks(),
          inputFieldSettings: {
            autoFill: options.autoComplete,
            suggestOnFocus: options.suggestOnFieldFocus,
            filterBasedOnCurPos: options.filterBasedOnCurPos
          }
        };
        settings.inputField = settings.forElement = this._input; // Copied from options

        ['dataSource', // No I18N
        'data', // No I18N
        'cacheData', // No I18N
        'isResponseFiltered', // No I18N
        'lazyLoading', // No I18N
        'viewPerPage', // No I18N
        'filterByCSSSelector', // No I18N
        'sort', // No I18N
        'sortBy', // No I18N
        'sortOrder', // No I18N
        'customSorter', // No I18N
        'serverSearch', // No I18N
        'customSearch', // No I18N
        'headerItems', // No I18N
        'footerItems' // No I18N
        ].forEach(function (prop) {
          return settings[prop] = options[prop];
        }); // Copied from dropdownList options

        $.extend(settings, dropdownList);
        return settings;
      }
    }, {
      key: "_getListCallbacks",
      value: function _getListCallbacks() {
        var _this61 = this;

        var callbacks = {};
        ['ItemClick', // No I18N
        'ItemHover', // No I18N
        'BeforeShow', // No I18N
        'Show', // No I18N
        'BeforeHide', // No I18N
        'Hide', // No I18N
        'BeforeSearch', // No I18N
        'RequestEnd', // No I18N
        'RequestError', // No I18N
        'MoreActionClick', // No I18N
        'Input', // No I18N
        'MenuCreation', // No I18N
        'BeforeListUpdate', // No I18N
        'ListUpdate' // No I18N
        ].forEach(function (event) {
          callbacks[event.toLowerCase()] = _this61['_on' + event].bind(_this61); // No I18N
        });
        return callbacks;
      }
    }, {
      key: "_onItemHover",
      value: function _onItemHover(orgEvent, eventData) {
        var newEventData = this._getEventData(eventData.data);

        newEventData.listItem = eventData.listItem;

        this._trigger('listitemfocus', orgEvent, newEventData); // No I18N

      }
    }, {
      key: "_onItemClick",
      value: function _onItemClick(orgEvent, eventData) {
        this._oldVal = this._opts.value = this._input.val();

        this._input.focus();

        this._actualData = eventData.data;

        var newEventData = this._getEventData();

        newEventData.listItem = eventData.listItem;
        return this._trigger('listitemselect', orgEvent, newEventData); // No I18N
      }
    }, {
      key: "_onMenuCreation",
      value: function _onMenuCreation(orgEvent, eventData) {
        this._menu = eventData.menu;
      }
    }, {
      key: "_onInput",
      value: function _onInput() {
        this._actualData = undefined;
        this._opts.value = this._input.val();
      }
    }, {
      key: "_getMappedData",
      value: function _getMappedData(data) {
        var _this62 = this;

        if (_typeof(data) === 'object') {
          // No I18N
          var mappedData = {};

          this._getDataKeys().forEach(function (prop) {
            return mappedData[prop] = _this62._mapJSONToData(data, _this62._opts.dataMapping[prop]);
          });

          return mappedData;
        }

        return data;
      }
    }, {
      key: "_getDataKeys",
      value: function _getDataKeys() {
        return ['image', 'text', 'value', 'groupLabel', 'iconClassName', 'informativeText', 'customValues']; // No I18N
      }
    }, {
      key: "_onBeforeShow",
      value: function _onBeforeShow(orgEvent) {
        return this._trigger('dropdownlistbeforeopen', orgEvent); // No I18N
      }
    }, {
      key: "_onShow",
      value: function _onShow(orgEvent) {
        return this._trigger('dropdownlistopen', orgEvent); // No I18N
      }
    }, {
      key: "_onBeforeListUpdate",
      value: function _onBeforeListUpdate() {
        return this._trigger.apply(this, ['beforedropdownlistupdate'].concat(Array.prototype.slice.call(arguments))); // No I18N
      }
    }, {
      key: "_onListUpdate",
      value: function _onListUpdate() {
        return this._trigger.apply(this, ['dropdownlistupdate'].concat(Array.prototype.slice.call(arguments))); // No I18N
      }
    }, {
      key: "_onNoResults",
      value: function _onNoResults() {
        return this._trigger.apply(this, ['noresults'].concat(Array.prototype.slice.call(arguments))); // No I18N
      }
    }, {
      key: "_onHide",
      value: function _onHide(orgEvent) {
        return this._trigger('dropdownlistclose', orgEvent); // No I18N
      }
    }, {
      key: "_onBeforeHide",
      value: function _onBeforeHide(orgEvent) {
        return this._trigger('dropdownlistbeforeclose', orgEvent); // No I18N
      }
    }, {
      key: "_onBeforeSearch",
      value: function _onBeforeSearch(orgEvent, eventData) {
        return this._trigger('beforesearch', orgEvent, {
          // No I18N
          params: eventData.params
        });
      }
    }, {
      key: "_onRequestEnd",
      value: function _onRequestEnd() {
        return this._trigger.apply(this, ['searchsuccess'].concat(Array.prototype.slice.call(arguments))); // No I18N
      }
    }, {
      key: "_onRequestError",
      value: function _onRequestError() {
        return this._trigger.apply(this, ['searcherror'].concat(Array.prototype.slice.call(arguments))); // No I18N
      }
    }, {
      key: "_onMoreActionClick",
      value: function _onMoreActionClick(orgEvent, eventData) {
        return this._trigger('moreactionclick', orgEvent, {
          // No I18N
          listItem: eventData.listItem,
          params: eventData.params
        });
      }
    }, {
      key: "_getEventData",
      value: function _getEventData(actualData) {
        actualData = actualData || this._actualData;
        return {
          data: actualData,
          mappedData: this._getMappedData(actualData)
        };
      }
    }, {
      key: "_trigger",
      value: function _trigger(customEvent, orgEvent, eventData) {
        eventData = eventData || {};
        eventData.value = this._opts.value;
        eventData.dropdownList = this._menu && this._menu[0];
        return _get(_getPrototypeOf(ZSuggestfield.prototype), "_dispatchEvent", this).call(this, customEvent, orgEvent, eventData);
      }
    }, {
      key: "_getMenuPos",
      value: function _getMenuPos(position) {
        var positionObj = {
          top: 'top-left',
          // No I18N
          bottom: 'bottom-left' // No I18N

        };
        return positionObj[position] || position;
      }
    }, {
      key: "openDropdownList",
      value: function openDropdownList() {
        this._listInstance.openDropdownList();
      }
    }, {
      key: "closeDropdownList",
      value: function closeDropdownList() {
        this._listInstance.closeDropdownList();
      }
    }, {
      key: "getValue",
      value: function getValue() {
        return this._actualData;
      }
    }, {
      key: "search",
      value: function search(query) {
        this.element.val(query);

        this._listInstance.search(query);
      }
    }, {
      key: "searchList",
      value: function searchList(query) {
        if (!this._opts.disabled) {
          var _this$_listInstance;

          this._input.val(query);

          (_this$_listInstance = this._listInstance).search.apply(_this$_listInstance, arguments);
        }
      }
    }, {
      key: "clearCache",
      value: function clearCache() {
        this._listInstance.clearCache();
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        this._input.val('') // No I18N
        .off('.' + this.name) // No I18N
        .removeClass('zsuggestfield-element'); // No I18N


        clearTimeout(this._blurTimer);

        this._listInstance.destroy();
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        var options = this._opts;

        if (['placeholder', 'className', 'zclassName'].indexOf(optionName) > -1) {
          // No I18N
          options[optionName] = value;
          this._stopAttrUpdate = this._domChanged = true;
        } else if (['autoComplete', // No I18N
        'cacheData', // No I18N
        'dataMapping', // No I18N
        'data', // No I18N
        'dataSource', // No I18N
        'dropdownList', // No I18N
        'isImageSourceSprited', // No I18N
        'isResponseFiltered', // No I18N
        'lazyLoading', // No I18N
        'viewPerPage', // No I18N
        'messages', // No I18N
        'rtl', // No I18N
        'search', // No I18N
        'customSearch', // No I18N
        'suggestOnFieldFocus', // No I18N
        'filterBasedOnCurPos', // No I18N
        'filterByCSSSelector', // No I18N
        'headerItems', // No I18N
        'footerItems', // No I18N
        'sort', // No I18N
        'sortBy', // No I18N
        'sortOrder', // No I18N
        'customSorter', // No I18N
        'serverSearch' // No I18N
        ].indexOf(optionName) > -1) {
          // No I18N
          options[optionName] = value;
          this._reInit = true;
        } else if (optionName === 'value') {
          // No I18N
          this._input.val(value);
        }
      }
    }, {
      key: "_buildData",
      value: function _buildData() {
        this._listInstance.setAttributes($.extend(true, {}, this._listInstance._DEFAULTS, this._getListSettings()));
      }
    }, {
      key: "_disable",
      value: function _disable() {
        var disable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this._stopAttrUpdate = this._domChanged = true;
        disable && this.closeDropdownList();
      }
    }, {
      key: "name",
      get: function get() {
        return "zsuggestfield";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          cacheData: true,
          autoComplete: false,
          filterBasedOnCurPos: true,
          suggestOnFieldFocus: false,
          lazyLoading: true,
          viewPerPage: null,
          sort: true,
          sortBy: null,
          sortOrder: null,
          serverSearch: null,
          filterByCSSSelector: false,
          disabled: false,
          placeholder: null,
          zclassName: null,
          dataStructure: 'flat',
          // No I18N
          value: ''
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          customSorter: null,
          customSearch: null,
          data: [],
          dataSource: null,
          dataMapping: {},
          search: {
            minKeywordLength: 0,
            maxKeywordLength: 50,
            caseSensitive: false,
            criteria: 'contains',
            // No I18N
            delay: 100,
            by: null,
            highlightKeyword: false,
            searchIncrementsInCache: false,
            showNoResultsMessage: false,
            moreResultsAction: false,
            focusFirstResult: true
          },
          dropdownList: {
            contentType: 'text',
            // No I18N
            loaderIconClassName: null,
            loaderSVGIconId: null,
            virtualization: false,
            className: null,
            position: 'auto',
            // No I18N
            positionAlterable: true,
            height: 350,
            width: null,
            appendTo: null
          },
          messages: {
            noResults: 'No results found.',
            // No I18N
            moreAction: 'See more results',
            // No I18N
            serverError: 'Server request failed. Please try again later.' // No I18N

          },
          headerItems: [],
          footerItems: []
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['listitemselect', // No I18N
        'listitemfocus', // No I18N
        'dropdownlistbeforeopen', // No I18N
        'dropdownlistopen', // No I18N
        'dropdownlistbeforeclose', // No I18N
        'dropdownlistclose', // No I18N
        'change', // No I18N
        'beforesearch', // No I18N
        'searchsuccess', // No I18N
        'searcherror', // No I18N
        'moreactionclick', // No I18N
        'beforedropdownlistupdate', // No I18N
        'dropdownlistupdate', // No I18N
        'noresults' // No I18N
        ];
      }
    }]);

    return ZSuggestfield;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZSuggestfield', ZSuggestfield);

  (function (ZC) {
    var template = ZC.zsuggestfield.Templates;

    template.children = function (data) {
      return ZT.html(_templateObject122(), data.inputClass, data.disabled ? 'is-disabled' : '');
    };
  })(ZComponents);

  var ZColorPickerBase =
  /*#__PURE__*/
  function (_ZC$CoreComponent13) {
    _inherits(ZColorPickerBase, _ZC$CoreComponent13);

    function ZColorPickerBase() {
      _classCallCheck(this, ZColorPickerBase);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZColorPickerBase).apply(this, arguments));
    }

    _createClass(ZColorPickerBase, [{
      key: "_init",
      value: function _init(element, options) {
        this._fromInit = true;

        this._appendEle(this._opts.appendTo);

        this._id = this._getID();
        this._namespace = '.' + this.name; // No I18N

        this._validate(options);

        this._setInitial();

        this._fromInit = false;
        this._changedAttrs = [];
      }
    }, {
      key: "_isAttrChanged",
      value: function _isAttrChanged(optionName) {
        var changedAttrs = this._changedAttrs;
        return !this._data.rendered || changedAttrs.indexOf('all') > -1 || changedAttrs.indexOf(optionName) > -1; // No I18N
      }
    }, {
      key: "_setMainEle",
      value: function _setMainEle(objects) {
        var _this63 = this;

        objects = this._toArr(objects);
        objects.forEach(function (obj) {
          if (obj && !obj.mainElement) {
            var mainElement = _this63._getById(obj.id);

            obj.mainElement = mainElement[0];
            obj.instance = ZC[obj.ctype](mainElement);
            obj.container = obj.instance.getElement();
          }
        });
      }
    }, {
      key: "_destroyComp",
      value: function _destroyComp(object) {
        if (object) {
          var element = $('#' + object.id, this.element); // No I18N

          if (element.length) {
            if (!this.isCE) {
              ZC[object.ctype](element).destroy();
            }

            element.remove();
          }
        }
      }
    }, {
      key: "_getById",
      value: function _getById(id) {
        return $('#' + id, this.element); // No I18N
      }
    }, {
      key: "_getID",
      value: function _getID(name) {
        var id = name ? name + '-' + this._id : _get(_getPrototypeOf(ZColorPickerBase.prototype), "_getID", this).call(this); // No I18N

        return id.replace(/\s/g, ''); // No I18N
      }
    }, {
      key: "_validateCount",
      value: function _validateCount(number) {
        return Math.max(+number || 0, 0);
      }
    }, {
      key: "_getCanvasContext",
      value: function _getCanvasContext(element) {
        var canvas = element.querySelector('canvas'); // No I18N

        return canvas.getContext('2d'); // No I18N
      }
    }, {
      key: "_preRender",
      value: function _preRender() {
        var data = this._data;
        var options = this._opts;
        data.rgb = this._currentColor;
        data._inPreRender = true;

        this._setRenderData(data, options, this.element);

        data._inPreRender = false;
        return data;
      }
    }, {
      key: "_setRenderData",
      value: function _setRenderData(data, options, element) {
        data.rtl = options.rtl;
        data.closeOnSelect = options.closeOnSelect;

        if (!data.rendered || this._domChanged) {
          data.id = this._id;
          var tabindex = element.attr('tabindex'); // No I18N

          if (tabindex === undefined) {
            tabindex = 0;
          }

          data.attrs = {
            tabindex: tabindex,
            title: element[0].title
          };
        }

        var isAttrChanged = this._isAttrChanged.bind(this);

        if (isAttrChanged('displayType')) {
          // No I18N
          data.hasCallout = options.displayType === 'callout'; // No I18N
        }

        if (isAttrChanged('title')) {
          // No I18N
          if (options.title || data.title) {
            this._setTitleBarData(data, options);
          }
        }
      }
    }, {
      key: "_getRTLBasedPercent",
      value: function _getRTLBasedPercent(percent) {
        return this._opts.rtl ? 100 - percent : percent;
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender(element, data) {
        this._storeRef(data, this._opts, element);

        if (!data.rendered || this._domChanged) {
          this._setClassName(data);

          this._setDimension();

          if (this._reopen) {
            ZC.unBindDocumentEvents(this.element);
            this.open();
            this._reopen = false;
          }

          if (data.dragged) {
            this._hideCallout();
          }
        }
      }
    }, {
      key: "_setDimension",
      value: function _setDimension() {
        if (!this._opened) {
          this._display();
        }

        this._updateDim();

        if (!this._opened && this._floating) {
          this._display(false);
        }
      }
    }, {
      key: "_setClassName",
      value: function _setClassName(data) {
        data.className += ' ' + this._CLASSES.CONTAINER; // No I18N
      }
    }, {
      key: "_storeRef",
      value: function _storeRef(data, options, element) {
        var isAttrChanged = this._isAttrChanged.bind(this);

        if (isAttrChanged('displayType')) {
          // No I18N
          this._callout = false;

          if (data.hasCallout) {
            this._callout = $(this.element[0].querySelector('.zcolorpicker__pointer')); // No I18N
          }
        }

        if (isAttrChanged('title')) {
          // No I18N
          this._titleBar = false;

          if (options.title) {
            this._storeTitleBarRef(data, options, element);
          }
        }

        if (isAttrChanged('draggable') || isAttrChanged('title')) {
          // No I18N
          if (options.draggable || data.draggableIns) {
            this._initDraggable(data, options, element);
          }
        }

        this._selectedPan = element.find('.' + this._CLASSES.COLORBOX + '.is-selected'); // No I18N
      }
    }, {
      key: "_validate",
      value: function _validate(options) {
        this._floating = options.type !== 'inline'; // No I18N

        var colorInstance = this._getClrInstance(options.value);

        if (options.value !== 'none' && options.value !== 'transparent' && !colorInstance.isValid()) {
          // No I18N
          options.value = this._DEFAULTS.value;
        }

        this._setClrMode(options.value);
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        this._addEvents({
          keydown: 'keydown' // No I18N

        });

        if (this._colorPanEventHandler) {
          this._addEvents({
            colorPanEvent: 'click mouseover mouseout' // No I18N

          }, this._container || this.container);
        }

        this._addEvents({
          focus: 'focusin',
          // No I18N
          blur: 'focusout' // No I18N

        });
      }
    }, {
      key: "_focusHandler",
      value: function _focusHandler(orgEvent) {
        clearTimeout(this._blurTimer);

        if (!this._focussed) {
          this._trigger('focus', orgEvent); // No I18N

        }

        this._focussed = true;
      }
    }, {
      key: "_blurHandler",
      value: function _blurHandler(orgEvent) {
        var _this64 = this;

        clearTimeout(this._blurTimer);
        this._blurTimer = setTimeout(function () {
          _this64._focussed = false;

          _this64._trigger('blur', orgEvent); // No I18N

        });
      }
    }, {
      key: "_closeClickHandler",
      value: function _closeClickHandler(orgEvent) {
        this.close(orgEvent);
      }
    }, {
      key: "_setInitial",
      value: function _setInitial() {
        this._setValue(this._opts.value);
      }
    }, {
      key: "_arrowCallback",
      value: function _arrowCallback(element, direction) {
        this.element.removeClass('zcolorpicker--top zcolorpicker--bottom zcolorpicker--left zcolorpicker--right') // No I18N
        .addClass('zcolorpicker--' + direction); // No I18N
      }
    }, {
      key: "_getTitle",
      value: function _getTitle(orgObject, instance, baseObj) {
        return orgObject.title || instance.getColor('hex').toUpperCase(); // No I18N
      }
    }, {
      key: "_hideCallout",
      value: function _hideCallout() {
        if (this._data.hasCallout) {
          this._display(false, this._callout);
        }
      }
    }, {
      key: "_onDragStart",
      value: function _onDragStart() {
        this._data.dragged = true;

        this._hideCallout();
      }
    }, {
      key: "_keydownHandler",
      value: function _keydownHandler(orgEvent) {
        var code = orgEvent.keyCode;
        var activeElement = document.activeElement;
        var activeTag = activeElement.tagName;

        if (activeTag === 'LI') {
          // No I18N
          if (code === ZC.keyCode.ENTER || code === ZC.keyCode.SPACE) {
            activeElement.click();
          }
        } else if (code === ZC.keyCode.ENTER && activeTag === 'INPUT') {
          // No I18N
          this._onSubmit(orgEvent);
        }
      }
    }, {
      key: "_toArr",
      value: function _toArr(value) {
        return Array.isArray(value) ? value : [value];
      }
    }, {
      key: "_getClrInstance",
      value: function _getClrInstance(color) {
        return ZC.ColorUtil.getColorInstance(color);
      }
    }, {
      key: "_getPosition",
      value: function _getPosition(positionSettings) {
        return ZC.Position.get($(this._opts.forElement), this.element, positionSettings);
      }
    }, {
      key: "_setPosition",
      value: function _setPosition() {
        var options = this._opts;
        var element = this.element;

        if (options.offset) {
          element.css(options.offset);
          return;
        }

        if (ZC.Position) {
          var positionAlterable = options.positionAlterable;
          var target = $(options.forElement);
          var position = this._lastPosition || options.position;

          if (target.length) {
            if (position === 'auto') {
              // No I18N
              position = options.displayType === 'callout' ? 'bottom' : 'bottom-left'; // No I18N

              positionAlterable = true;
            }

            positionAlterable = positionAlterable || 'fit'; // No I18N

            var positionOptions = {
              rtl: options.rtl,
              direction: position,
              within: options.viewport || options.appendTo,
              positionAlterable: positionAlterable,
              arrow: {
                element: this._callout,
                callback: this._arrowCallback.bind(this)
              }
            };

            var positionObject = this._getPosition(positionOptions);

            if (positionObject && positionObject.elementPosition) {
              var elementPos = positionObject.elementPosition;

              if (options.margin) {
                var top = +options.margin.top || 0;
                var left = +options.margin.left || 0;
                var dir = positionObject.direction.split('-'); // No I18N

                if (dir[0] === 'top') {
                  // No I18N
                  elementPos.top -= top;
                } else if (dir[0] === 'bottom') {
                  // No I18N
                  elementPos.top += top;
                } else if (dir[0] === 'right') {
                  // No I18N
                  elementPos.left += left;
                } else if (dir[0] === 'left') {
                  // No I18N
                  elementPos.left -= left;
                }
              }

              element.css(elementPos);

              if (this._callout) {
                this._callout.css(positionObject.arrowPosition);
              }

              this._lastPosition = positionObject.direction;
            }
          }
        }
      }
    }, {
      key: "_setGradientColors",
      value: function _setGradientColors(gradient, rgbs) {
        rgbs = rgbs.slice(0);
        var frac = Math.round(1 / (rgbs.length - 1) * 100) / 100;
        var offset = 0;

        while (rgbs.length > 1) {
          gradient.addColorStop(offset, rgbs.shift());
          offset = offset + frac;
        }

        gradient.addColorStop(1, rgbs.shift());
      }
    }, {
      key: "_limit",
      value: function _limit(value, min, max) {
        return Math.max(Math.min(value, max), min);
      }
    }, {
      key: "_setClrMode",
      value: function _setClrMode(color) {
        var options = this._opts;
        this._colorMode = options.valueColorModel;

        if (!this._REGEX.colorMode.test(this._colorMode)) {
          var colorInstance = this._getClrInstance(color || options.value);

          this._colorMode = colorInstance.format;
          options.valueColorModel = 'auto'; // No I18N
        }
      }
    }, {
      key: "_updateUI",
      value: function _updateUI(setDim) {
        if (!this._data._inPreRender && (this._mustRender || this._data.rendered && !this._domChanged)) {
          this._render();

          setDim && this._setDimension();
        }
      }
    }, {
      key: "_updateSelectedColor",
      value: function _updateSelectedColor() {
        this._selectedInstance = this._getClrInstance(this._colorInstance.getObject());
        this._selectedInstance.initialColor = this._colorInstance.initialColor;
        this._opts.value = this._noFill ? 'transparent' : this._colorInstance.getColor(this._colorMode, undefined, this._opts.valueColorModel === 'auto'); // No I18N
      }
    }, {
      key: "_dragStartHandler",
      value: function _dragStartHandler(orgEvent) {
        if (!orgEvent.button) {
          this._onPickerDragged(orgEvent);

          this._trigger('dragstart', orgEvent); // No I18N


          this._addEvents({
            drag: 'mousemove',
            // No I18N
            dragStop: 'mouseup' // No I18N

          }, ZC.$document);
        }
      }
    }, {
      key: "_dragHandler",
      value: function _dragHandler(orgEvent) {
        this._onPickerDragged(orgEvent);

        this._trigger('drag', orgEvent); // No I18N


        orgEvent.preventDefault();
      }
    }, {
      key: "_dragStopHandler",
      value: function _dragStopHandler(orgEvent) {
        this._onPickerDragged(orgEvent);

        this._removeEvents('mousemove mouseup', ZC.$document); // No I18N


        this._trigger('dragstop', orgEvent); // No I18N

      }
    }, {
      key: "_display",
      value: function _display() {
        var display = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var container = arguments.length > 1 ? arguments[1] : undefined;
        (container || this.element)[0].style.display = display ? '' : 'none'; // No I18N
      }
    }, {
      key: "_animate",
      value: function _animate(element, animation, action, callback) {
        var _this65 = this;

        var animationCallback = function animationCallback() {
          _this65._display(action !== 'close'); // No I18N


          callback && callback();
        };

        if (animation && ZC.animationHandler && !$.isEmptyObject(animation)) {
          var animationObject = {
            element: element,
            action: action,
            animation: animation,
            callback: animationCallback
          };
          ZC.animationHandler(animationObject);
        } else {
          animationCallback();
        }
      }
    }, {
      key: "setFocus",
      value: function setFocus(orgEvent) {
        var _this66 = this;

        if (this._trigger('beforefocus', orgEvent) && this.element.attr('tabindex') !== -1) {
          // No I18N
          clearTimeout(this._focusTimer);
          this._focusTimer = setTimeout(function () {
            _this66.element[0].focus();
          }, 100);
        }
      }
    }, {
      key: "_closeHandlerClose",
      value: function _closeHandlerClose(arg1, orgEvent) {
        this.close(orgEvent);
      }
    }, {
      key: "_onOpen",
      value: function _onOpen(orgEvent) {
        this._opened = true;
        this._opts.closeOnBodyClick && this._bindBodyClick();
        this.setFocus(orgEvent);
        this._addedByComponent = true;
        this.element.attr('aria-hidden', false); // No I18N

        this._addedByComponent = false;

        this._bindDocEvents();

        this._trigger('open', orgEvent); // No I18N

      }
      /* Function to open the palette */

    }, {
      key: "open",
      value: function open(userOptions, orgEvent) {
        if (this._floating && this._trigger('beforeopen', orgEvent)) {
          // No I18N
          this._opened = false;
          var options = this._opts;

          if (userOptions) {
            this.setAttributes(userOptions);
          }

          this._setPosition();

          this._animate(this.element, this._reopen ? false : options.animation, 'open', this._onOpen.bind(this, orgEvent)); // No I18N

        }
      }
    }, {
      key: "_bindDocEvents",
      value: function _bindDocEvents() {
        this._addEvents({
          docKeydown: 'keydown' // No I18N

        }, ZC.$document);
      }
    }, {
      key: "_unBindDocEvents",
      value: function _unBindDocEvents() {
        this._removeEvents('', ZC.$document); // No I18N

      }
    }, {
      key: "_docKeydownHandler",
      value: function _docKeydownHandler(orgEvent) {
        if (orgEvent.keyCode === ZC.keyCode.ESCAPE) {
          this.close(orgEvent);
        }
      }
    }, {
      key: "_onClose",
      value: function _onClose(orgEvent) {
        var data = this._data;
        this._opened = this._lastPosition = false;

        this._unBindDocEvents();

        clearTimeout(this._focusTimer);
        data.dragged = false;

        if (data.hasCallout) {
          this._display(true, this._callout);
        }

        if (data.closeButton) {
          $(data.closeButton.mainElement).removeClass('has-focus'); // No I18N
        }

        this.element.attr('aria-hidden', true); // No I18N

        this._trigger('close', orgEvent); // No I18N

      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        this._removeEvents('', ZC.$document); // No I18N


        this.element.removeClass(this._CLASSES.CONTAINER).removeAttr('style'); // No I18N

        clearTimeout(this._fieldChangeTimer);
        clearTimeout(this._focusTimer);
        clearTimeout(this._blurTimer);
      }
      /* Function to trigger custom events */

    }, {
      key: "_trigger",
      value: function _trigger(customEvent, orgEvent, data) {
        if (!this._fromInit) {
          var colorMode = this._colorMode;
          var selectedInstance = this._selectedInstance;
          var colorInstance = this._colorInstance;
          orgEvent = orgEvent && orgEvent.preventDefault ? orgEvent : undefined;
          data = data || {};
          data.value = data.color = this.getValue();
          data.rgb = selectedInstance.getColor();
          data.opacity = selectedInstance.getAlpha();
          data.colorData = selectedInstance.getObject(colorMode);
          data.currentValue = colorInstance.getColor(colorMode);
          data.currentOpacity = colorInstance.getAlpha();
          data.currentRGB = colorInstance.getColor();
          data.otherData = {};
          var selectedPan = this._selectedPan;

          if (selectedPan.length) {
            data.otherData.colorPan = selectedPan;
            selectedPan = $(selectedPan[0]);

            if (selectedPan.attr('data-shade')) {
              // No I18N
              data.otherData.isShade = true;
              data.otherData.baseColor = selectedPan.attr('data-base-color'); // No I18N

              data.otherData.toneType = selectedPan.attr('data-tone-type'); // No I18N

              data.otherData.tonePercent = selectedPan.attr('data-tone-percent'); // No I18N

              data.otherData.theme = selectedPan.attr('data-theme'); // No I18N
            }
          }

          return this._dispatchEvent(customEvent, orgEvent, data, undefined, !!orgEvent);
        }

        return true;
      }
    }, {
      key: "getValue",
      value: function getValue() {
        return this._opts.value;
      }
      /* Function to select a color */

    }, {
      key: "setValue",
      value: function setValue(color, orgEvent) {
        this._setValue(color, orgEvent, null, true);
      }
    }, {
      key: "close",
      value: function close(orgEvent) {
        if (this._floating && this._opened) {
          if (this._trigger('beforeclose', orgEvent)) {
            // No I18N
            this._animate(this.element, this._opts.animation, 'close', this._onClose.bind(this, orgEvent)); // No I18N

          }
        }
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        if (optionName === 'value') {
          // No I18N
          this._domChanged = true;
          this.setValue(value);
        } else {
          return this._setAdvAttr(optionName, value);
        }
      }
    }, {
      key: "_addPalettes",
      value: function _addPalettes(paletteDatas, index, paletteKey) {
        var _this67 = this;

        var data = this._data;
        paletteKey = paletteKey || 'palettes'; // No I18N

        var nPalettes = [];
        var isCustom = paletteKey === 'customColorLibraries'; // No I18N

        if (paletteDatas) {
          paletteDatas = this._toArr(paletteDatas);
          paletteDatas.forEach(function (paletteData) {
            paletteData.isCustom = isCustom;

            var paletteTemplateData = _this67._getPaletteTemplateData(paletteData);

            if (paletteTemplateData) {
              nPalettes.push(paletteTemplateData);
            }
          });

          this._addToObject(data[paletteKey], nPalettes, index);

          data.rendered && this._updatePalettes(paletteKey);
        }
      }
    }, {
      key: "_colorPanEventHandler",
      value: function _colorPanEventHandler(orgEvent) {
        var colorpan = orgEvent.target;
        var $colorpan = $(colorpan);

        if ($colorpan.is(".".concat(this._CLASSES.COLORBOX))) {
          var eventType = orgEvent.type;

          var eventData = this._getColorPanData(colorpan);

          if (eventType === 'click') {
            // No I18N
            this._setValue(colorpan.style.backgroundColor, orgEvent); // if (!$colorpan.is('.is-selected')) { // No I18N
            // }


            this._data.closeOnSelect && this.close(orgEvent);

            this._trigger('colorpanclick', orgEvent, eventData); // No I18N

          } else if (eventType === 'mouseover') {
            // No I18N
            this._trigger('colorpanmouseover', orgEvent, eventData); // No I18N

          } else {
            this._trigger('colorpanmouseout', orgEvent, eventData); // No I18N

          }
        }
      }
    }, {
      key: "_getPaletteTemplateData",
      value: function _getPaletteTemplateData(paletteData) {
        if (_typeof(paletteData) === 'object') {
          // No I18N
          var name = paletteData.heading || paletteData.name;

          if (name && !this._getPalette(name)) {
            var paletteTemplateData = {
              heading: paletteData.heading,
              name: name,
              className: paletteData.className,
              id: paletteData.id || this._getID(name),
              hasTones: paletteData.hasTones,
              tones: paletteData.tones,
              maxColorsCount: this._validateCount(paletteData.maxColorsCount),
              isCustom: paletteData.isCustom,
              paletteData: paletteData
            };
            paletteTemplateData.colors = this._getPaletteColors(paletteTemplateData, paletteData.colors);

            this._spliceColors(paletteTemplateData);

            return paletteTemplateData;
          }
        }
      }
    }, {
      key: "_getPaletteColors",
      value: function _getPaletteColors(paletteData, colors) {
        var _this68 = this;

        var nColors = [];

        if (colors) {
          this._toArr(colors).forEach(function (orgObject) {
            var initalValue = orgObject;

            if (typeof orgObject === 'string' || Array.isArray(orgObject)) {
              // No I18N
              orgObject = {
                color: orgObject
              };
            }

            var colorInstance = _this68._getClrInstance(orgObject.color);

            if (colorInstance.isValid()) {
              nColors.push({
                orgObject: initalValue,
                theme: orgObject.theme,
                rgb: colorInstance.getColor(),
                title: _this68._getTitle(orgObject, colorInstance),
                paletteId: paletteData.id,
                paletteName: paletteData.name,
                tabindex: _this68._data.attrs.tabindex,
                tones: paletteData.hasTones ? _this68._getTones(colorInstance, orgObject.tones || paletteData.tones, orgObject) : undefined
              });
            }
          });
        }

        return nColors;
      }
    }, {
      key: "_spliceColors",
      value: function _spliceColors(paletteTemplateData) {
        var paletteColumns = this._opts.paletteColumns;
        var colors = paletteTemplateData.colors;
        var colorChunks = paletteTemplateData.colorChunks = [];

        if (colors.length || paletteTemplateData.isCustom) {
          var maxColorsCount = paletteTemplateData.maxColorsCount;

          if (maxColorsCount && colors.length > maxColorsCount) {
            var spliceCount = maxColorsCount - colors.length;
            colors.splice(spliceCount);
            paletteTemplateData.paletteData.colors.splice(spliceCount);
          }

          colors = _toConsumableArray(colors);

          if (paletteTemplateData.isCustom) {
            var addBtn = paletteTemplateData.addBtn = this._getAddBtnData(paletteTemplateData);

            colors.push(addBtn);
          }

          if (paletteColumns) {
            for (var i = 0; i < colors.length; i = i + paletteColumns) {
              colorChunks.push(colors.slice(i, i + paletteColumns));
            }
          } else {
            colorChunks.push(colors);
          }
        }
      }
    }, {
      key: "_addToObject",
      value: function _addToObject(object, newObject, index) {
        if (index === undefined) {
          object.push.apply(object, _toConsumableArray(newObject));
        } else {
          object.splice.apply(object, [index, 0].concat(_toConsumableArray(newObject)));
        }
      }
    }, {
      key: "_getPalette",
      value: function _getPalette(paletteName) {
        var data = this._data;

        var callback = function callback(palette) {
          return palette.name === paletteName;
        };

        var paletteData = paletteName;

        if (typeof paletteName === 'string') {
          // No I18N
          paletteData = data.palettes.find(callback);

          if (!paletteData && data.customColorLibraries) {
            paletteData = data.customColorLibraries.find(callback);
          }
        }

        return paletteData;
      }
    }, {
      key: "_getColorPanData",
      value: function _getColorPanData(colorpan) {
        return {
          colorpan: colorpan,
          colorpanData: {
            color: this._getClrInstance(colorpan.getAttribute('data-zcolor')).getColor(this._colorMode) // No I18N

          }
        };
      }
    }, {
      key: "_updateClrSelection",
      value: function _updateClrSelection(colors) {
        var _this69 = this;

        colors.forEach(function (color) {
          color.selected = color.rgb === _this69._currentColor;

          if (color.tones) {
            _this69._updateClrSelection(color.tones);
          }
        });
      }
      /* Function to get tones for a base color */

    }, {
      key: "_getTones",
      value: function _getTones(baseColorInstance, toneFactors, orgObject) {
        var _this70 = this;

        toneFactors = toneFactors || this._getDefaultToneFactors(baseColorInstance);
        /* Tones are given by the user */

        return toneFactors.map(function (toneFactor) {
          var color = toneFactor.color || toneFactor;

          if (typeof color === 'string') {
            // No I18N
            var toneInstance = _this70._getClrInstance(color);

            return {
              rgb: toneInstance.getColor(),
              baseColor: baseColorInstance.initialColor,
              title: _this70._getTitle(toneFactor, toneInstance, orgObject),
              theme: orgObject.theme,
              isShade: 'true' // No I18N

            };
          }

          return _this70._getTone(baseColorInstance, toneFactor, orgObject);
        });
      }
      /* Function to generate default tones for a base color based on its brightness and darkness  */

    }, {
      key: "_getDefaultToneFactors",
      value: function _getDefaultToneFactors(colorInstance) {
        var colorProps = colorInstance.getObject();
        var rgbArr = [colorProps.r, colorProps.g, colorProps.b];
        var brightness = ZC.ColorUtil.brightness(rgbArr);
        var fixedPer = !(brightness >= 210 && brightness <= 255 || brightness >= 0 && brightness <= 38);
        var percents = brightness >= 240 && brightness <= 255 ? [0.05, 0.15, 0.25, 0.35, 0.50] : brightness >= 0 && brightness <= 15 ? [0.50, 0.35, 0.25, 0.15, 0.05] : brightness >= 224 && brightness < 240 ? [0.10, 0.25, 0.50, 0.75, 0.90] : brightness > 15 && brightness <= 31 ? [0.90, 0.75, 0.50, 0.25, 0.10] : [0.80, 0.60, 0.40, 0.25, 0.50];
        var isDark = ZC.ColorUtil.isDark(rgbArr);
        return percents.map(function (percent, index) {
          if (fixedPer) {
            isDark = index <= 2;
          }

          return {
            'function': isDark ? 'lighten' : 'darken',
            // No I18N
            percent: percent * 100
          };
        });
      }
      /* Function to get tone from the given tone Factor */

    }, {
      key: "_getTone",
      value: function _getTone(baseColorInstance, toneFactor, orgObject) {
        var toneType = toneFactor['function'];
        var tonePercent = toneFactor.percent;

        if (/^(lighten|darken|tint|shade)$/.test(toneType)) {
          var colorProps = baseColorInstance.getObject();
          var nRGB = ZC.ColorUtil[toneType]([colorProps.r, colorProps.g, colorProps.b], tonePercent / 100);
          nRGB.push(colorProps.a);

          var toneInstance = this._getClrInstance(nRGB);

          return {
            rgb: toneInstance.getColor(),
            title: this._getTitle(toneFactor, toneInstance, orgObject),
            toneType: toneType,
            tonePercent: tonePercent,
            tabindex: this._data.attrs.tabindex,
            baseColor: baseColorInstance.initialColor,
            theme: orgObject.theme,
            isShade: 'true' // No I18N

          };
        }
      }
    }, {
      key: "_setTitleBarData",
      value: function _setTitleBarData(data, options) {
        this._destroyComp(data.closeButton);

        data.closeButton = false;
        data.title = options.isTitleHTMLEncoded ? options.title : ZC.encodeHTML(options.title);

        if (options.closeButton) {
          this._setCloseBtnData.apply(this, arguments);
        }
      }
    }, {
      key: "_storeTitleBarRef",
      value: function _storeTitleBarRef(data, options, element) {
        this._titleBar = $(element[0].querySelector('.' + this._CLASSES.TITLEBAR)); // No I18N

        if (options.closeButton) {
          this._setMainEle(data.closeButton);

          this._addEvents({
            closeClick: 'mousedown' // No I18N

          }, $(data.closeButton.mainElement));
        }
      }
    }, {
      key: "_setCloseBtnData",
      value: function _setCloseBtnData(data, options) {
        var SVGIconId = options.closeSVGIconId;
        var iconClassName;

        if (!SVGIconId) {
          iconClassName = options.closeIconClassName || options.closeIconClass;

          if (!iconClassName) {
            SVGIconId = 'zc__svg--close'; // No I18N
          }
        }

        data.closeButton = _objectSpread({}, this._getBaseObj('button'), {}, {
          className: this._CLASSES.CLOSE,
          // No I18N
          id: this._getID('closebutton'),
          // No I18N
          iconClassName: iconClassName,
          SVGIconId: SVGIconId,
          defaultIconClassName: 'zcolorpicker__icon',
          // No I18N
          title: this._getI18NText('close') // No I18N

        });
      }
    }, {
      key: "_getBaseObj",
      value: function _getBaseObj(cname) {
        return {
          ctype: cname,
          isCE: this.isCE,
          rtl: this._opts.rtl,
          templateRender: true,
          locale: this._opts.locale
        };
      }
    }, {
      key: "_updateColors",
      value: function _updateColors(paletteTemplateData) {
        var colors = paletteTemplateData.colors;
        paletteTemplateData.paletteData.colors = colors.map(function (color) {
          return color.orgObject;
        });

        this._spliceColors(paletteTemplateData);

        this._updateUI(true);
      }
    }, {
      key: "_addColors",
      value: function _addColors(paletteName, colors, index) {
        var paletteTemplateData = this._getPalette(paletteName);

        if (paletteTemplateData) {
          var nColors = this._getPaletteColors(paletteTemplateData, colors);

          var orgColors = paletteTemplateData.colors;

          this._addToObject(orgColors, nColors, index);

          this._updateColors(paletteTemplateData);

          return paletteTemplateData.paletteData.colors;
        }
      }
    }, {
      key: "_removeColors",
      value: function _removeColors(palette, colors) {
        var _this71 = this;

        var paletteTemplateData = this._getPalette(palette);

        if (paletteTemplateData) {
          colors = this._toArr(colors);
          var paletteColors = paletteTemplateData.colors;
          colors.forEach(function (color) {
            var colorInstance = _this71._getClrInstance(color);

            if (colorInstance.isValid()) {
              var _color = colorInstance.getColor();

              paletteColors = paletteColors.filter(function (pColor) {
                return pColor.rgb !== _color;
              });
            }
          });
          paletteTemplateData.colors = paletteColors;

          this._updateColors(paletteTemplateData);
        }
      }
    }, {
      key: "_removeColorsAt",
      value: function _removeColorsAt(palette, indexes) {
        var paletteTemplateData = this._getPalette(palette);

        if (paletteTemplateData) {
          indexes = this._toArr(indexes);
          paletteTemplateData.colors = this._removeFromObjAt(paletteTemplateData.colors, indexes);

          this._updateColors(paletteTemplateData);
        }
      }
    }, {
      key: "addColor",
      value: function addColor(paletteName, color) {
        this._addColors(paletteName, color);
      }
    }, {
      key: "insertColorAt",
      value: function insertColorAt(paletteName, color, index) {
        this._addColors(paletteName, color, index);
      }
    }, {
      key: "removeColor",
      value: function removeColor(paletteName, color) {
        this._removeColors(paletteName, color);
      }
    }, {
      key: "removeColorAt",
      value: function removeColorAt(paletteName, index) {
        this._removeColorsAt(paletteName, index);
      }
    }, {
      key: "_bindBodyClick",
      value: function _bindBodyClick() {
        ZC.bindDocumentEvents({
          element: this.element,
          forElement: this._opts.forElement,
          ctype: this.name,
          closeMethodName: '_closeHandlerClose',
          // No I18N
          closeEvent: 'close' // No I18N

        });
      }
    }, {
      key: "_getThumbData",
      value: function _getThumbData(data) {
        if (data) {
          var thumbIcon;
          var thumbIconClassName = data.thumbIconClassName;
          var thumbSVGIconId = data.thumbSVGIconId;

          if (thumbSVGIconId || thumbIconClassName) {
            ZC._getIconInfo(thumbIconClassName, thumbSVGIconId, '', '', thumbIcon = {}); // No I18N

          }

          return thumbIcon;
        }
      }
    }, {
      key: "_getThumb",
      value: function _getThumb(element) {
        return $(element.querySelector('.' + this._CLASSES.SLIDERTHUMB)); // No I18N
      }
    }, {
      key: "_getBasicNumberFieldOptions",
      value: function _getBasicNumberFieldOptions() {
        return _objectSpread({}, this._getBaseObj('numberfield'), {}, {
          min: 0,
          required: true,
          width: 'none',
          // No I18N
          spinButtons: 'none',
          // No I18N
          clearButton: 'none',
          // No I18N
          bindedSpinAndChange: true
        });
      }
    }, {
      key: "_bindTextField",
      value: function _bindTextField(field) {
        this._addEvents({
          fieldChange: 'input change paste',
          // No I18N
          textFieldFocus: 'focus blur' // No I18N

        }, field);
      }
    }, {
      key: "_textFieldFocusHandler",
      value: function _textFieldFocusHandler(orgEvent) {
        var target = orgEvent.target;

        if (!target.readonly) {
          $(target).parent()[orgEvent.type === 'blur' ? 'removeClass' : 'addClass']('has-focus'); // No I18N
        }
      }
    }, {
      key: "_setAdvAttr",
      value: function _setAdvAttr(optionName, value) {
        var options = this._opts;
        var changedAttrs = this._changedAttrs;

        if (optionName === 'valueColorModel') {
          // No I18N
          options[optionName] = value;

          this._setClrMode();

          this._updateSelectedColor();

          changedAttrs.push('colorField'); // No I18N

          this._domChanged = true;
        } else if (['title', 'isTitleHTMLEncoded', 'closeButton', 'closeIconClass', 'closeIconClassName', 'closeSVGIconId'].indexOf(optionName) > -1) {
          // No I18N
          options[optionName] = value;
          changedAttrs.push('title'); // No I18N

          this._domChanged = true;
        } else if (optionName === 'draggable' || optionName === 'displayType') {
          // No I18N
          options[optionName] = value;
          this._reopen = this._opened;
          changedAttrs.push(optionName); // No I18N

          this._domChanged = true;
        } else if (optionName === 'type') {
          // No I18N
          options[optionName] = value;
          this._floating = value !== 'inline'; // No I18N

          if (this._floating) {
            this.close();
          } else {
            this._display();
          }
        } else if (optionName === 'closeOnSelect') {
          // No I18N
          options[optionName] = value;
          this._domChanged = true;
        } else if (['closeOnBodyClick', 'position', 'forElement', 'offset', 'margin', 'animation'].indexOf(optionName) > -1) {
          // No I18N
          options[optionName] = value;
          this._reopen = this._opened;
          this._domChanged = true;
        } else if (['locale', 'labels', 'rtl'].indexOf(optionName) > -1) {
          // No I18N
          options[optionName] = value;
          changedAttrs.push('all'); // No I18N

          this._domChanged = true;
        } else {
          return false;
        }
      }
    }, {
      key: "_initDraggable",
      value: function _initDraggable(data, options, element) {
        data.draggableIns && data.draggableIns.destroy();
        data.draggableIns = undefined;

        if (options.draggable && options.title && this._floating) {
          data.draggableIns = ZC.draggable(element, {
            handle: this._titleBar,
            cursor: 'default',
            // No I18N
            start: this._onDragStart.bind(this)
          });
        }
      }
    }, {
      key: "_removePalettes",
      value: function _removePalettes(palettes, paletteKey) {
        var _this72 = this;

        var data = this._data;
        paletteKey = paletteKey || 'palettes'; // No I18N

        if (palettes) {
          palettes = this._toArr(palettes);
          palettes.forEach(function (palette) {
            var paletteTemplateData = _this72._getPalette(palette);

            if (paletteTemplateData) {
              data[paletteKey] = data[paletteKey].filter(function (ePalette) {
                return ePalette !== paletteTemplateData;
              });
            }
          });

          this._updatePalettes(paletteKey);
        }
      }
    }, {
      key: "_removePalettesAt",
      value: function _removePalettesAt(indexes, paletteKey) {
        var data = this._data;
        paletteKey = paletteKey || 'palettes'; // No I18N

        this._removeFromObjAt(data[paletteKey], indexes);

        this._updatePalettes(paletteKey);
      }
    }, {
      key: "_removeFromObjAt",
      value: function _removeFromObjAt(object, indexes) {
        indexes = this._toArr(indexes);
        return object.filter(function (data, index) {
          return indexes.indexOf(index) === -1;
        });
      }
    }, {
      key: "addPalette",
      value: function addPalette(paletteData) {
        this._addPalettes(paletteData);
      }
    }, {
      key: "insertPaletteBefore",
      value: function insertPaletteBefore(paletteData, paletteName) {
        var index;

        var paletteTemplateData = this._getPaletteTemplateData(paletteName);

        if (paletteTemplateData) {
          index = this._data.palettes.indexOf(paletteTemplateData);
        }

        this._addPalettes(paletteData, index);
      }
    }, {
      key: "insertPaletteAt",
      value: function insertPaletteAt(paletteData, index) {
        this._addPalettes(paletteData, index);
      }
    }, {
      key: "removePalette",
      value: function removePalette(palettes) {
        this._removePalettes(palettes);
      }
    }, {
      key: "removePaletteAt",
      value: function removePaletteAt(indexes) {
        this._removePalettesAt(indexes);
      }
    }, {
      key: "getPaletteColors",
      value: function getPaletteColors(paletteName) {
        var paletteTemplateData = this._getPalette(paletteName);

        if (paletteTemplateData) {
          return paletteTemplateData.paletteData.colors;
        }
      }
    }, {
      key: "setPaletteColors",
      value: function setPaletteColors(paletteName, colors) {
        var paletteTemplateData = this._getPalette(paletteName);

        if (paletteTemplateData) {
          paletteTemplateData.colors = this._getPaletteColors(paletteTemplateData, colors);

          this._updateColors(paletteTemplateData);
        }
      }
    }, {
      key: "name",
      get: function get() {
        return "zcolorpickerbase";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          value: 'rgba(0,0,0,1)',
          // No I18N
          valueColorModel: 'auto',
          // No I18N
          paletteColumns: 10,
          isTitleHTMLEncoded: false,
          title: '',
          // No I18N
          closeButton: false,
          closeIconClass: null,
          closeSVGIconId: null,
          closeOnSelect: true,
          closeOnBodyClick: true,
          position: 'auto',
          // No I18N
          forElement: null,
          displayType: 'box',
          // No I18N
          type: 'popup',
          // No I18N
          draggable: false,
          appendTo: null,
          viewport: null,
          rtl: null,
          locale: null
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          offset: null,
          margin: null,
          closeIconClassName: null,
          labels: {
            close: 'Close' // No I18N

          },
          animation: null
        };
      }
    }, {
      key: "CLASSES",
      get: function get() {
        return {
          CONTAINER: 'zcolorpicker',
          // No I18N
          RTL: 'h-rtl',
          // No I18N
          FLIPY: 'h-flipY',
          // No I18N
          ICON: 'zcolorpicker__icon',
          // No I18N
          TEXT: 'zcolorpicker__text',
          // No I18N
          TITLEBAR: 'zcolorpicker__titlebar',
          // No I18N
          CLOSE: 'zcolorpicker__close',
          // No I18N
          PALETTE: 'zcolorpicker__palette',
          // No I18N
          WITHSHADES: 'zcolorpicker__shades',
          // No I18N
          COLORBOX: 'zcolorpicker__colorpan',
          // No I18N
          ACTIVE: 'is-selected',
          // No I18N
          DISABLED: 'is-disabled',
          // No I18N
          NUMBERFIELD: 'zcolorpicker__numberfield',
          // No I18N
          COLORFIELD: 'zcolorpicker__colorfield',
          // No I18N
          SLIDER: 'zslider',
          // No I18N
          SLIDERTHUMB: 'zslider__thumb' // No I18N

        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['change', // No I18N
        'select', // No I18N
        'pick', // No I18N
        'beforeopen', // No I18N
        'open', // No I18N
        'beforeclose', // No I18N
        'close', // No I18N
        'colorpanmouseover', // No I18N
        'colorpanmouseout', // No I18N
        'colorpanclick', // No I18N
        'beforefocus', // No I18N
        'focus', // No I18N
        'blur', // No I18N
        'dragstart', // No I18N
        'drag', // No I18N
        'dragstop' // No I18N
        ];
      }
    }, {
      key: "_REGEX",
      get: function get() {
        return {
          position: /^(bottom-right|bottom-left|top-right|top-left|top|bottom|left|right|center|auto|right-bottom|right-top|left-bottom|left-top)$/,
          colorMode: ZC.ColorUtil.REGEX.colorMode
        };
      }
    }]);

    return ZColorPickerBase;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZColorPickerBase', ZColorPickerBase);

  (function (ZC) {
    var template = ZC.zcolorpickerbase.Templates;

    template.canvas = function (data) {
      return ZT.html(_templateObject123(), data.rtl ? 'zh-flipY' : '');
    };

    template.palette = function (data) {
      var responseTemplate = data.colorChunks.length && ZT.html(_templateObject124(), data.id, data.isCustom, data.className || '', data.name, data.heading && ZT.html(_templateObject125(), data.heading), data.colorChunks.map(function (colorChunk) {
        return data.hasTones ? ZT.html(_templateObject126(), colorChunk.map(function (baseColor) {
          return ZT.html(_templateObject127(), template.colorpan(baseColor), baseColor.tones.map(function (shade) {
            return template.colorpan(shade);
          }));
        })) : ZT.html(_templateObject128(), colorChunk.map(function (baseColor) {
          return baseColor.addBtn ? ZT.html(_templateObject129(), ZC.createButton(baseColor)) : template.colorpan(baseColor);
        }));
      }));
      return responseTemplate;
    };

    template.colorpan = function (data) {
      return ZT.html(_templateObject130(), data.isShade, data.paletteName, data.selected ? 'is-selected' : '', data.tabindex, data.toneType, data.theme, data.tonePercent, data.rgb, data.baseColor, data.rgb, data.hidden, data.selected, data.title);
    };

    var utilities = ZC.Templates.Utilities;

    template.slider = function (data) {
      return ZT.html(_templateObject131(), data.id, data.className || '', data.opacity ? 'zcolorpicker__transparentbg' : '', template.canvas(data), data.thumbIcon ? '' : 'zslider__circlethumb', data.left, data.thumbIcon && utilities.icon(data.thumbIcon));
    };

    template.title = function (data) {
      var template = ZT.html(_templateObject132(), ZT.customHTML(data.title), data.closeButton && ZT.html(_templateObject133(), ZC.createButton(data.closeButton)));
      return template;
    };
  })(ZComponents);
  /* API DOUBTS
      serverSearch - option - is it necessary
      moreResultsAction
      showNoResultsMessage
  */

  /******
      TAGS
      1. z-optionsheader
      2. z-optionsfooter
      3. z-optionsbody
      4. z-option
      5. z-optgroup
      6. z-optionsseparator
  *****/


  var ZSelect =
  /*#__PURE__*/
  function (_ZC$CoreComponent14) {
    _inherits(ZSelect, _ZC$CoreComponent14);

    function ZSelect() {
      _classCallCheck(this, ZSelect);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZSelect).apply(this, arguments));
    }

    _createClass(ZSelect, [{
      key: "_init",
      value: function _init(element, options) {
        this._fromInit = true;
        this._useParent = false;
        this._elementId = element[0].id || this._getID();
        this._menuID = options.menuId || this._elementId + '-menu'; // No I18N

        this._selected = [];
        ['disabled', 'multiple', 'placeholder'].forEach(function (key) {
          // No I18N
          options[key] = options[key] || element[0][key];
        });

        if (options.multiple) {
          this._initMultiple();
        }

        this._initDS();

        this._setInitial();

        this._fromInit = false;

        this._trigger('init'); // No I18N

      }
    }, {
      key: "_preRender",
      value: function _preRender() {
        var options = this._opts;
        var data = this._data;

        if (!this._data.rendered || this._domChanged) {
          this._onAttrChange(data, options);
        }

        var attrs = data.attrs;
        attrs['aria-expanded'] = this._opened; // No I18N

        this._setValueData(options, data);

        return this._data;
      }
    }, {
      key: "_onAttrChange",
      value: function _onAttrChange(data, options) {
        var element = this.element; // let style = element.attr('style') || ''; // No I18N

        data.alwaysSetAttrs = true;
        data.clearButton = options.clearButton;
        data.disabled = options.disabled;
        data.multiple = options.multiple;
        data.placeholder = options.placeholder; // ContentType

        data.isCustom = options.contentType === 'custom'; // No I18N

        data.hasText = data.hasIcon = false;

        if (!data.isCustom) {
          data.hasText = options.contentType.indexOf('text') > -1; // No I18N

          data.hasIcon = options.contentType.indexOf('image') > -1; // No I18N
        }

        data.width = this._getWidth(options.width);
        data.tabindex = data.disabled ? null : options.tabindex || element.attr('tabindex') || 0; // No I18N

        data.attrs = {
          // style: style && style.replace(/(display\s*:\s*none\s*;?)/g, '') || '', // No I18N
          style: data.width ? 'width:' + data.width : undefined,
          // No I18N
          title: element.attr('title'),
          // No I18N
          'aria-disabled': options.disabled,
          // No I18N
          'aria-haspopup': 'listbox',
          // No I18N
          'aria-owns': this._menuID,
          // No I18N
          id: this._elementId + '-container',
          // No I18N
          role: this.ARIA_ROLES.CONTAINER,
          tabindex: data.tabindex
        };

        ZC._getIconInfo(options.arrowIconClassName || options.arrowIconClass, options.arrowSVGIconId, '#zc__svg--downarrow zselectbox__arrow', 'zselectbox__icon zselectbox__arrowicon', data.arrow = {}); // No I18N

      }
    }, {
      key: "_setValueData",
      value: function _setValueData(options, data) {
        var selected = this._selected;
        data.label = data.icon = data.noSelection = data.innerHTML = null;

        if (data.clearButton) {
          this._setClrBtnData(options, data);
        }

        if (selected.length) {
          this._setContentData(selected, options, data);
        } else {
          data.noSelection = true;
        }
      }
    }, {
      key: "_setContentData",
      value: function _setContentData(selected, options, data) {
        if (options.multiple) {
          data.label = this._getLabelForMultiple(selected);
        } else {
          var optData = this._getOptData(selected[0]);

          if (data.isCustom) {
            data.innerHTML = this._getCustomContent(optData, options.template || optData.zinnerHTML || optData.innerHTML);
          } else {
            this._setIconTextData(optData, data);
          }

          data.attrs['aria-activedescendant'] = optData.zitemid; // No I18N
        }
      }
    }, {
      key: "_setIconTextData",
      value: function _setIconTextData(optData, data) {
        if (data.hasText) {
          data.label = this._getRenderText(optData);
        }

        if (data.hasIcon) {
          ZC._getIconInfo(optData.iconClassName, optData.SVGIconId, null, this._CLASSES.ICON, data.icon = {});
        }
      }
    }, {
      key: "_getRenderText",
      value: function _getRenderText(optData) {
        return this._getLabel(optData);
      }
    }, {
      key: "_getLabel",
      value: function _getLabel(optData) {
        var encode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return this._mapJSONToData(optData, this._opts.dataMapping.label, encode);
      }
    }, {
      key: "_postRender",
      value: function _postRender() {
        this._storeRef();

        this.element.hide();

        var listInstance = this._getListSettings();

        this.listInstance = new ZC.ZList(null, listInstance);
        this.listInstance.componentInstance = this;

        this._postEachRender.apply(this, arguments);
      }
    }, {
      key: "_storeRef",
      value: function _storeRef() {
        if (this._data.clearButton) {
          this._storeClrBtn();
        }
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender() {
        this._domChanged && this._storeRef();

        this._setTitle();

        this._setClassName();
      }
    }, {
      key: "_setClassName",
      value: function _setClassName() {
        var options = this._opts;
        var classes = this._CLASSES;
        var className = classes.CONTAINER + ' ' + (this.element.attr('class') || '') + ' ' + (options.className || options.zclassName || ''); // No I18N

        if (options.contentType === 'image') {
          // No I18N
          className += ' ' + classes.ICONONLY; // No I18N
        } else if (options.contentType === 'image-text') {
          // No I18N
          className += ' ' + classes.ICONTEXT; // No I18N
        }

        if (options.rtl) {
          className += ' zh-rtl'; // No I18N
        }

        if (options.disabled) {
          className += ' ' + classes.DISABLED; // No I18N
        } else if (this._isFocussed()) {
          className += ' ' + classes.FOCUS; // No I18N

          if (this._opened) {
            className += ' ' + classes.ACTIVE + ' ' + (this._menu.data('direction').indexOf('top') === 0 ? classes.DROPUP : classes.DROPDOWN); // No I18N
          }
        }

        if (this._data.clearButton) {
          className += ' zselectbox--withclear'; // No I18N

          this._hideClrBtn();
        }

        this._data.className = className;
      }
    }, {
      key: "_isFocussed",
      value: function _isFocussed() {
        var activeElement = document.activeElement;

        if (activeElement) {
          var activeElementId = activeElement.id;
          activeElement = $(activeElement);
          return activeElement[0] === this.container[0] || activeElementId === this._menuID || activeElementId === this.listInstance._getID('searchbox') || this._menu && this._menu.find(activeElement).length || this.container.find(activeElement).length;
        }
      }
    }, {
      key: "_setTitle",
      value: function _setTitle() {
        var data = this._data;
        var options = this._opts;
        var title = ''; // No I18N

        if (!data.noSelection && !data.isCustom) {
          var textspan = this.container[0].querySelector('.' + this._CLASSES.TEXT); // No I18N

          if (options.contentType === 'image' || textspan && textspan.clientWidth < textspan.scrollWidth) {
            // No I18N
            title = this._opts.multiple ? data.label : this._getLabel(this._getOptData(this._selected[0]), false);
          }
        }

        this.container[0].title = title;
      }
    }, {
      key: "_isNotNull",
      value: function _isNotNull(value) {
        return _get(_getPrototypeOf(ZSelect.prototype), "_isNotNull", this).call(this, value) && !/^\s*$/.test(value); // No I18N
      }
    }, {
      key: "_getWidth",
      value: function _getWidth(width) {
        width = width || this.element[0].style.width;

        if (width !== 'none') {
          // No I18N
          // For webcomponent, by default given as auto - since its width will be 0.
          width = width || (this.isCE ? 'auto' : this.element[0].offsetWidth); // No I18N

          if (width) {
            return isNaN(width) ? width : width + 'px'; // No I18N
          }
        }
      }
    }, {
      key: "_getListSettings",
      value: function _getListSettings() {
        var _this73 = this;

        var options = this._opts;
        var menuSettings = options.dropdownList;
        var checkedIcon = menuSettings.checkedIcon;
        this._isCheckBoxType = checkedIcon = checkedIcon || options.multiple && checkedIcon === null;
        var settings = $.extend(true, {
          id: this._menuID,
          forElement: this.container,
          className: (menuSettings.className || '') + ' ' + this._CLASSES.MENU.CLASSNAME,
          // No I18N
          positionAlterable: menuSettings.positionAlterable === undefined ? menuSettings.direction === 'auto' ? 'flipsidefit' : false : menuSettings.positionAlterable,
          // No I18N
          contentType: menuSettings.contentType || options.contentType,
          checkedIcon: checkedIcon,
          selectHoveredOnTabPress: true,
          preventDefaultOnTabPress: true,
          template: menuSettings.template || options.template,
          rtl: options.rtl,
          isCE: this.isCE,
          inputFieldSettings: {
            autoFill: false,
            suggestOnFocus: false
          },
          dataMapping: _objectSpread({}, options.dataMapping)
        }, this._listDS);

        var search = settings.search = _objectSpread({}, options.search);

        search.focusFirstResult = false;
        ['direction', // No I18N
        'height', // No I18N
        'appendTo', // No I18N
        'viewport', // No I18N
        'animation', // No I18N
        'virtualization', // No I18N
        'checkedIconClassName', // No I18N
        'checkedSVGIconId', // No I18N
        'loaderIconClassName', // No I18N
        'loaderSVGIconId' // No I18N
        ].forEach(function (key) {
          return settings[key] = menuSettings[key];
        });
        ['showSearchField', // No I18N
        'filterByCSSSelector', // No I18N
        'lazyLoading', // No I18N
        'viewPerPage', // No I18N
        'sort', // No I18N
        'sortBy', // No I18N
        'sortOrder', // No I18N
        'customSorter', // No I18N
        'dataSourceSettings', // No I18N
        'cacheData', // No I18N
        'isResponseFiltered', // No I18N
        'serverSearch', // No I18N
        'customSearch', // No I18N
        'messages', // No I18N
        'isLabelHTMLEncoded' // No I18N
        ].forEach(function (key) {
          return settings[key] = options[key];
        }); // EVENTS

        settings.callbacks = {};
        ['menuCreation', // No I18N
        'itemClick', // No I18N
        'itemHover', // No I18N
        'beforeListUpdate', // No I18N
        'listUpdate', // No I18N
        'noResults', // No I18N
        'beforeSearch', // No I18N
        'requestend', // No I18N
        'requesterror' // No I18N
        ].forEach(function (event) {
          return settings.callbacks[event.toLowerCase()] = _this73['_' + event + 'Handler'].bind(_this73);
        }); // No I18N

        ['BeforeShow', // No I18N
        'BeforeHide', // No I18N
        'Show', // No I18N
        'Hide' // No I18N
        ].forEach(function (event) {
          return settings.callbacks[event.toLowerCase()] = _this73['_menu' + event + 'Handler'].bind(_this73);
        }); // No I18N

        return settings;
      }
    }, {
      key: "_requesterrorHandler",
      value: function _requesterrorHandler(orgEvent, eventData) {
        this._trigger('searcherror', orgEvent, eventData); // No I18N

      }
    }, {
      key: "_requestendHandler",
      value: function _requestendHandler(orgEvent, eventData) {
        if (this._staticData) {
          this._dataFetched = true;

          this._updateData(eventData.response, true);
        }

        this._trigger('searchsuccess', orgEvent, eventData); // No I18N

      }
    }, {
      key: "_beforeSearchHandler",
      value: function _beforeSearchHandler(orgEvent, eventData) {
        return this._trigger('beforesearch', orgEvent, eventData); // No I18N
      }
    }, {
      key: "_noResultsHandler",
      value: function _noResultsHandler(orgEvent, eventData) {
        return this._trigger('noresults', orgEvent, eventData); // No I18N
      }
    }, {
      key: "_menuCreationHandler",
      value: function _menuCreationHandler(orgEvent, eventData) {
        this._menu = eventData.menu;
        this._menuInstance = eventData.instance;

        this._bindMenuEvents();
      }
    }, {
      key: "_beforeListUpdateHandler",
      value: function _beforeListUpdateHandler(orgEvent, eventData) {
        this._trigger('beforedropdownlistupdate', orgEvent, eventData); // No I18N

      }
    }, {
      key: "_listUpdateHandler",
      value: function _listUpdateHandler(orgEvent, eventData) {
        if (this._opened) {
          var menuItems = eventData && eventData.addedMenuItems;

          if (menuItems) {
            this._checkItem(this._selected, true);
          }
        }

        this._trigger('dropdownlistupdate', orgEvent, eventData); // No I18N

      }
    }, {
      key: "_renderMenu",
      value: function _renderMenu() {
        this._skipMenuRender = false;
        this._menu && this._menuInstance.callRender();
      }
    }, {
      key: "_checkItem",
      value: function _checkItem(options, checked, skipRender) {
        var _this74 = this;

        if (this._menu) {
          this._skipMenuRender = true;
          var additionalClass = checked ? ' is-selected' : ''; // No I18N

          options.forEach(function (option) {
            var optData = _this74._getOptData(option);

            var className = (optData.className || '') + additionalClass; // No I18N

            var menuItem = _this74._getMenuItemForOption([option]); // Revisit


            if ($(menuItem).hasClass('on-hover')) {
              // No I18N
              className += ' on-hover'; // No I18N
            }

            _this74._updateMenuItem(menuItem, 'className', className); // No I18N


            _this74._isCheckBoxType && _this74._updateMenuItem(menuItem, 'checked', checked); // No I18N
          });
          !skipRender && this._renderMenu();
        }
      }
    }, {
      key: "_bindMenuEvents",
      value: function _bindMenuEvents() {
        this._addEvents({
          menuBlur: 'focusout' // No I18N

        }, this._menu);
      }
    }, {
      key: "_menuBlurHandler",
      value: function _menuBlurHandler() {
        this._blurHandler();
      }
    }, {
      key: "_menuBeforeHideHandler",
      value: function _menuBeforeHideHandler(orgEvent) {
        if (this._isFocussed()) {
          this._setFocus(true);
        }

        return this._trigger('beforedropdownlistclose', orgEvent); // No I18N
      }
    }, {
      key: "_menuBeforeShowHandler",
      value: function _menuBeforeShowHandler(orgEvent, eventData) {
        eventData.openOptions.minWidth = Math.max(this.container[0].offsetWidth, parseFloat(this._opts.dropdownList.width || 0));

        if (!this._opened) {
          return this._trigger('beforedropdownlistopen', orgEvent, {
            // No I18N
            optionOption: eventData.openOptions
          });
        }
      }
    }, {
      key: "search",
      value: function search(query, orgEvent) {
        this.listInstance.search(query, orgEvent);
      }
    }, {
      key: "_menuHideHandler",
      value: function _menuHideHandler(orgEvent) {
        this._opened = false;

        this._setClassName();

        this._trigger('dropdownlistclose', orgEvent); // No I18N

      }
    }, {
      key: "_menuShowHandler",
      value: function _menuShowHandler(orgEvent) {
        var alreadyOpened = this._opened;
        this._opened = this._completeMenuLoaded = true;

        this._setClassName();

        this._hoverSelectedItem(orgEvent);

        if (!alreadyOpened) {
          this._trigger('dropdownlistopen', orgEvent); // No I18N

        }
      }
    }, {
      key: "_hoverSelectedItem",
      value: function _hoverSelectedItem(orgEvent) {
        var itemToBeHovered;
        var originalEvent = orgEvent.detail.originalEvent;

        if (!this._opts.multiple && this._selected.length && (!originalEvent || originalEvent.type !== 'input')) {
          // No I18N
          itemToBeHovered = this._getMenuItemForOption(this._selected)[0];
        }

        if (!itemToBeHovered && this._opts.search.focusFirstResult) {
          itemToBeHovered = this.listInstance.getFirstValidItem();
        }

        this.listInstance.hoverMenuItem(itemToBeHovered);
      }
    }, {
      key: "_getSelectionFromDS",
      value: function _getSelectionFromDS() {
        var dsOptions = this._dataSource.options;
        var options = this._opts;

        var callback = function callback(dsOption) {
          return dsOption.selected && !dsOption.hidden;
        };

        if (dsOptions.length) {
          if (options.multiple) {
            return dsOptions.filter(callback); // No I18N
          }

          return dsOptions.find(callback); // No I18N
        }
      }
    }, {
      key: "_setInitial",
      value: function _setInitial() {
        var options = this._opts;
        var defaultOption = this._isNotNull(options.value) ? options.value : options.selectedValue;

        if (this._isNull(defaultOption)) {
          var dsOptions = this._dataSource.options;

          if (dsOptions.length) {
            var selectedIndex = options.selectedIndex;

            if (selectedIndex === null) {
              defaultOption = this._getSelectionFromDS();

              if (!options.multiple && !defaultOption) {
                defaultOption = dsOptions.find(function (dsOption) {
                  return !dsOption.disabled && !dsOption.hidden && !dsOption.separator;
                });
              }
            } else if (parseInt(selectedIndex) > -1) {
              defaultOption = this._getOptDataAt(selectedIndex);
            }
          }
        }

        if (!this.isCE) {
          this.element[0].selectedIndex = -1;
        }

        this._setValue(defaultOption);
      }
    }, {
      key: "_getOptDataAt",
      value: function _getOptDataAt(indexes) {
        var _this75 = this;

        return this._toArr(indexes).map(function (index) {
          return _this75._dataSource.options[index];
        });
      }
    }, {
      key: "_initDS",
      value: function _initDS() {
        var options = this._opts;

        var initialDS = this._initialDS = this._getDataSource();

        var dataSource = options.dataSource;
        var optionsData = options.options;
        this._ajaxSource = false;
        this._dataFetched = this._staticData = true;

        if (Array.isArray(optionsData)) {
          optionsData = JSON.parse(JSON.stringify(optionsData));
          initialDS = initialDS.concat(optionsData);
        }

        if (dataSource && dataSource.URL) {
          this._ajaxSource = true;
          this._dataFetched = false;

          if (dataSource.paginated || options.serverSearch) {
            this._staticData = false;
          }
        }

        this._updateData(initialDS);
      }
    }, {
      key: "_updateData",
      value: function _updateData(finalDS, fromAjaxSuccess) {
        var listInstance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.listInstance;

        if (fromAjaxSuccess) {
          finalDS = finalDS.concat(this._initialDS);
        }

        var ds = this._dataSource = this._splitDataSource(finalDS);

        var header = ds.header;
        var footer = ds.footer;
        var body = ds.body;
        var dsoptions = this._listDS = {
          headerItems: header,
          footerItems: footer
        };
        dsoptions.dataSource = this._opts.dataSource;
        dsoptions.data = body;

        if (!fromAjaxSuccess) {
          this._setGroupRelData(dsoptions);

          if (listInstance) {
            listInstance.setAttributes(dsoptions);
          }
        }

        this._updateLocalDS();

        if (!this._fromInit && !fromAjaxSuccess) {
          this._setValue(this._selected.map(function (option) {
            return option.optData;
          }));
        } // !dataSource && this._updateTags();

      }
    }, {
      key: "_getMenuType",
      value: function _getMenuType() {
        return this._opts.dropdownList.contentType || this._opts.contentType;
      }
    }, {
      key: "_getOptDatas",
      value: function _getOptDatas(options) {
        var _this76 = this;

        return options.map(function (option) {
          return _this76._getOptData(option);
        });
      }
    }, {
      key: "_getOptData",
      value: function _getOptData(option) {
        if (!option.optData) {
          var itemId = option.getAttribute('data-zitemid'); // No I18N

          option.optData = this._dataSource.options.find(function (data) {
            return data.zitemid === itemId;
          }); // option.optData.element = option;
        }

        return option.optData;
      }
      /* Function to construct the menu object with which menu can be created */

    }, {
      key: "_genDataForTag",
      value: function _genDataForTag(options, groupData) {
        var _this77 = this;

        var contentType = this._getMenuType();

        return options.map(function (option) {
          var optData = ZC._getOpts(option);

          optData.id = option.id;
          var attrs = optData.customAttributes = optData.customAttributes || {};

          if (!optData.separator) {
            var dataMapping = _this77._opts.dataMapping;

            var label = _this77._mapJSONToData(optData, dataMapping.label);

            label = String(_this77._isNotNull(label) ? label : option.label || ''); // No I18N

            var value = _this77._mapJSONToData(optData, dataMapping.value);

            if (option.tagName.toLowerCase() === _this77._SELECTORS.OPTGROUP) {
              optData.value = String(_this77._isNotNull(value) ? value : label);

              var subOptions = _this77._getValidSubOptions($(option));

              if (!_this77.isCE || subOptions[0]._initialized) {
                optData.options = _this77._genDataForTag(subOptions, optData);
              }

              optData.isOptGroup = _this77._isGrouped = true;
              optData[dataMapping.optgroupLabel || 'label'] = label; // No I18N
            } else {
              label = label || option.textContent.trim();
              optData.value = String(_this77._isNotNull(value) ? value : option.value || label);
              optData.unselectable = optData.isFooter || optData.isHeader;
              optData.selected = option.selected;
              optData[dataMapping.label] = label;
            }

            optData.label = label;
            optData[dataMapping.value] = optData.value;
            attrs.title = optData.title || attrs.title || (contentType === 'image' ? optData.label : undefined); // No I18N

            optData.disabled = optData.disabled || option.disabled || undefined;
          }

          if (groupData) {
            optData.groupName = groupData.value; // attrs['data-group'] = optData.name = groupData.zitemid; // No I18N
          } // Since hidden property is not available in IE10 and below, attribute check is included.


          optData.hidden = optData.hidden || (typeof option.hidden === 'boolean' ? option.hidden : option.hasAttribute('hidden')) || undefined; // No I18N

          optData.className = option.className || optData.className;
          attrs.style = attrs.style || option.getAttribute('style'); // No I18N

          if (!optData.zitemid) {
            var itemid;

            if (optData.id) {
              itemid = _this77.name + '-' + _this77._menuID + '-option-' + optData.id; // No I18N
            } else {
              itemid = _this77._getID(null, _this77._menuID + '-option'); // No I18N
            }

            optData.zitemid = itemid;
          }

          optData.zpopulated = true;
          var parentEle = option.parentElement;

          if (groupData) {
            parentEle = parentEle.parentElement;
          }

          if (parentEle) {
            _this77._addedByComponent = true;
            option.setAttribute('data-zitemid', optData.zitemid); // No I18N

            _this77._addedByComponent = false; // optData.element = option;

            /* For isCE - instance is stored */

            _this77.isCE && option.saveParentIns(_this77.element);
          }

          option.optData = optData;
          return optData;
        });
      }
    }, {
      key: "_getItemId",
      value: function _getItemId(optData) {
        return _get(_getPrototypeOf(ZSelect.prototype), "_getItemId", this).call(this, optData, this._menuID);
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        this._addEvents({
          focus: 'focusin',
          // No I18N
          containerBlur: 'focusout',
          // No I18N
          keyDown: 'keydown',
          // No I18N
          keyPress: 'keypress',
          // No I18N
          mouseUp: 'mouseup' // No I18N

        });

        this._addEvents({
          mouseDown: 'mousedown' // No I18N

        }, this._arrowTarget);

        this._handleFocus(this.container);
      } // Fix for Chrome which loses inputField focus on mouseup of the container

    }, {
      key: "_mouseUpHandler",
      value: function _mouseUpHandler() {
        this._opened && this.listInstance.focusInputField();
      }
    }, {
      key: "_focusHandler",
      value: function _focusHandler(orgEvent) {
        this._setClassName();

        this._trigger('focus', orgEvent); // No I18N

      }
    }, {
      key: "_keyDownHandler",
      value: function _keyDownHandler(orgEvent) {
        var options = this._opts;

        if (!options.disabled) {
          var ZkeyCode = ZC.keyCode;

          switch (orgEvent.keyCode) {
            case ZkeyCode.SPACE:
              this._open(orgEvent);

              orgEvent.preventDefault();
              return;

            case ZkeyCode.ENTER:
              this._open(orgEvent);

              return;

            case ZkeyCode.DOWN:
            case ZkeyCode.UP:
              this._open();

              return false;

            default:
              if (!options.showSearchField && options.selectOnCharPress && this._isAlphaNumericKey(orgEvent)) {
                this._selectItemOnKeydown(orgEvent);
              }

          }
        }
      }
    }, {
      key: "_keyPressHandler",
      value: function _keyPressHandler(orgEvent) {
        if (this._opts.showSearchField && this._isAlphaNumericKey(orgEvent)) {
          this.search(String.fromCharCode(orgEvent.keyCode), orgEvent);
        }
      }
    }, {
      key: "_mouseDownHandler",
      value: function _mouseDownHandler(orgEvent) {
        if (!this._opts.disabled && !orgEvent.button) {
          this[this._opened ? '_close' : '_open'](orgEvent, true); // No I18N
        }
      }
    }, {
      key: "_containerBlurHandler",
      value: function _containerBlurHandler(orgEvent) {
        this._blurHandler(orgEvent);
      }
    }, {
      key: "_blurHandler",
      value: function _blurHandler(orgEvent) {
        clearTimeout(this._focusoutTimer);
        this._focusoutTimer = setTimeout(this._afterBlur.bind(this, orgEvent));
      }
    }, {
      key: "_afterBlur",
      value: function _afterBlur(orgEvent) {
        if (this.container && !this._isFocussed()) {
          // method invoked after destroy. So, container check is added.
          this._close(orgEvent);

          this._setClassName();

          this._trigger('blur', orgEvent); // No I18N

        }
      }
    }, {
      key: "_itemClickHandler",
      value: function _itemClickHandler(orgEvent, eventData) {
        var menuitem = eventData.listItem;
        var menuItemData = eventData.listItemData;
        var optionData = eventData.data;

        if (!/(itemgroup|separator)/.test(menuItemData.itemType)) {
          var eventName = 'optionclick'; // No I18N

          eventData = {
            optionData: optionData,
            menuitem: menuitem
          };

          if (menuItemData.selectable) {
            if (this._opts.multiple) {
              if (menuitem[0].checked) {
                this._setValueForMultiple(optionData, orgEvent, menuitem);
              } else {
                this._deselectOption(optionData, orgEvent);
              }
            } else {
              this._setValue(optionData, orgEvent);
            }
          } else if (this.isCE) {
            eventName = 'addoptionclick'; // No I18N
          }

          this._trigger(eventName, orgEvent, eventData); // No I18N


          this._trigger('itemclick', orgEvent, eventData); // No I18N


          if (!this._opts.multiple) {
            this._close(orgEvent); // The menu close is controlled here.

          }
        }

        orgEvent.preventDefault(); // return false;
      }
    }, {
      key: "_itemHoverHandler",
      value: function _itemHoverHandler(orgEvent, eventData) {
        return this._trigger('itemhover', orgEvent, eventData); // No I18N
      }
    }, {
      key: "_getOptionForData",
      value: function _getOptionForData(optData, orgEvent) {
        // optData can be value/completeData
        var existingData = true;

        if (this._dataFetched) {
          var matchedOptData = this._getMatchData(optData);

          if (matchedOptData) {
            optData = matchedOptData;
          } else {
            existingData = false;
          }
        }

        var option = this._getOptionByZItemId(this._getItemId(optData)); // querySelector doesn't support values that starts with digit. It needs to be escaped.
        // let option = this.element[0].querySelector('[data-zitemid=' + this._getItemId(optData) + ']'); // No I18N


        if (!option && !this._skipTagCreation) {
          if (existingData) {
            option = this._addOptionTag(optData);
          } else if (this._opts.acceptNewValues) {
            option = this._acceptNewValues(optData, orgEvent);
          }
        }

        return option;
      }
    }, {
      key: "_getOptionByZItemId",
      value: function _getOptionByZItemId(zitemid) {
        return this.element.find('[data-zitemid="' + zitemid + '"]')[0]; // No I18N
      }
      /* Function to match the option that are selectable */

    }, {
      key: "_getMatchData",
      value: function _getMatchData(value) {
        var items = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._dataSource.options;
        var dataMapping = this._opts.dataMapping;
        var matchingKey = 'value'; // No I18N

        if (_typeof(value) === 'object') {
          // No I18N
          if (value.zitemid) {
            value = value.zitemid;
            matchingKey = 'zitemid'; // No I18N
          } else {
            var uniqueIds = ['id', 'value', 'label']; // No I18N

            for (var i = 0; i < uniqueIds.length; i++) {
              var key = uniqueIds[i];

              var tempValue = this._mapJSONToData(value, dataMapping[key]);

              if (this._isNotNull(tempValue)) {
                matchingKey = key;
                value = tempValue;
                break;
              }
            }
          }
        } else if (typeof value === 'string') {
          // No I18N
          if (value.indexOf('#') === 0) {
            // No I18N
            value = value.slice(1);
            matchingKey = 'id'; // No I18N
          }
        } else {
          value = String(value);
        }

        return items.find(function (item) {
          return String(item[matchingKey]) === value;
        });
      }
    }, {
      key: "_getValidSubOptions",
      value: function _getValidSubOptions(parent, includeOptGroup) {
        var selectors = this._SELECTORS;
        var allowedTags = [selectors.OPTION];

        if (includeOptGroup) {
          allowedTags.push(selectors.OPTGROUP);
        }

        if (this.isCE) {
          allowedTags.push.apply(allowedTags, [selectors.OPTIONSEPARATOR, selectors.ADDOPTION]);

          if (parent.is(this.element)) {
            allowedTags.push.apply(allowedTags, [selectors.OPTIONSHEADER, selectors.OPTIONSFOOTER, selectors.OPTIONSBODY]);
          }
        }

        return parent.children(allowedTags.join(',')).toArray(); // No I18N
      }
    }, {
      key: "_getDataSource",
      value: function _getDataSource() {
        var _this78 = this;

        var options = this._getValidSubOptions(this.element, true);

        if (this.isCE) {
          var selectors = this._SELECTORS;
          var newOptions = [];
          var regex = new RegExp("(".concat(selectors.OPTIONSHEADER, "|").concat(selectors.OPTIONSFOOTER, "|").concat(selectors.OPTIONSBODY, ")"), 'i'); // No I18N

          options.forEach(function (option) {
            if (regex.test(option.tagName)) {
              newOptions.push.apply(newOptions, _toConsumableArray(_this78._getValidSubOptions($(option), true)));
            } else {
              newOptions.push(option);
            }
          });

          if (!newOptions.length || !newOptions[0]._initialized) {
            return [];
          }

          options = newOptions;
        }

        return this._genDataForTag(options.filter(function (option) {
          return !option.getAttribute('data-ztemp');
        })); // No I18N
      }
    }, {
      key: "_splitDataSource",
      value: function _splitDataSource(dataSource) {
        var _this79 = this;

        var newSource = {
          body: [],
          header: [],
          footer: []
        };
        dataSource.forEach(function (data) {
          data = _this79._getCompleteData(data);

          if (data.isFooter) {
            newSource.footer.push(data);
          } else if (data.isHeader) {
            newSource.header.push(data);
          } else {
            newSource.body.push(data);

            if (data.options) {
              _this79._isGrouped = true;
            }
          }
        });
        return newSource;
      }
    }, {
      key: "_setGroupRelData",
      value: function _setGroupRelData(settings) {
        var groupLabel = this._opts.dataMapping.optgroupLabel;
        var dataStructure = 'flat'; // No I18N

        if (this._isGrouped) {
          groupLabel = groupLabel || 'label'; // No I18N

          dataStructure = 'nested'; // No I18N
        }

        settings.dataMapping = {
          groupLabel: groupLabel
        };
        settings.dataStructure = dataStructure;
      }
    }, {
      key: "_updateList",
      value: function _updateList() {
        this._setGroupRelData(this._listDS);

        this.listInstance.setAttributes(this._listDS);

        this._updateLocalDS();

        this._reselect(); // !this._opts.dataSource && this._updateTags();

      }
    }, {
      key: "_reselect",
      value: function _reselect() {
        var _this80 = this;

        this._selected = this._selected.filter(function (option) {
          return _this80._dataSource.options.indexOf(option.optData) > -1;
        });

        this._updateValues();
      }
    }, {
      key: "_updateLocalDS",
      value: function _updateLocalDS() {
        var DSSplits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._dataSource;
        var options = DSSplits.options = [];
        DSSplits.body.forEach(function (data) {
          if (data.options) {
            options.push.apply(options, _toConsumableArray(data.options));
          } else {
            options.push(data);
          }
        });
        this._dataSource = DSSplits;
      }
    }, {
      key: "_updateMenuItem",
      value: function _updateMenuItem(menuItem, optionName, value) {
        this._completeMenuLoaded && this._menuInstance.setMenuItemsAttribute(menuItem, optionName, value, this._skipMenuRender);
      }
    }, {
      key: "_selectOption",
      value: function _selectOption(optionsToBeSelected, orgEvent) {
        var _this81 = this;

        var options = this._opts;

        var optionData = this._getOptDatas(optionsToBeSelected);

        var eventData = {
          action: 'selection',
          // No I18N
          optionData: optionData
        };

        if (this._trigger('beforechange', orgEvent, eventData)) {
          // No I18N
          this._addedByComponent = true;

          if (!options.multiple) {
            this._checkItem(this._selected, false, true);

            this._selected = [];
          }

          optionsToBeSelected.forEach(function (option) {
            option.selected = true;

            _this81._selected.push(option);
          });
          this._addedByComponent = false;

          this._checkItem(this._selected, true);

          eventData.previousValue = options.selectedValue;

          this._updateValues();

          if (eventData.previousValue !== options.selectedValue) {
            this._trigger('change', orgEvent, eventData); // No I18N

          }
        }
      }
    }, {
      key: "_deselectOption",
      value: function _deselectOption(values, orgEvent) {
        if (this._selected.length) {
          this._skipTagCreation = true;

          var matchedOptions = this._getMatchedOptions(values);

          var selected = [];

          var optionsToBeDeSelected = this._selected.filter(function (option) {
            if (matchedOptions.indexOf(option) > -1) {
              return true;
            }

            selected.push(option);
          });

          this._skipTagCreation = false;

          if (optionsToBeDeSelected.length) {
            var optionData = this._getOptDatas(optionsToBeDeSelected);

            var eventData = {
              action: 'deselection',
              // No I18N
              optionData: optionData
            };

            if (this._trigger('beforechange', orgEvent, eventData)) {
              // No I18N
              this._addedByComponent = true;
              optionsToBeDeSelected.forEach(function (option) {
                return option.selected = false;
              });
              this._addedByComponent = false;

              this._checkItem(optionsToBeDeSelected, false);

              this._selected = selected;
              eventData.previousValue = this._opts.selectedValue;

              this._updateValues();

              if (eventData.previousValue !== this._opts.selectedValue) {
                this._trigger('change', orgEvent, eventData); // No I18N

              }

              return;
            }
          }
        }

        this._fromInit && this._updateValues();
      }
    }, {
      key: "_updateValues",
      value: function _updateValues() {
        var _this82 = this;

        var options = this._opts;

        if (this._selected.length) {
          options.selectedValue = options.value = [];
          options.selectedIndex = [];

          var optDatas = this._getOptDatas(this._selected);

          this._selected.forEach(function (item, index) {
            var value = _this82._mapJSONToData(optDatas[index], options.dataMapping.value);

            options.value.push(value);
            options.selectedIndex.push(_this82._dataSource.options.indexOf(optDatas[index]));
          });

          if (!options.multiple) {
            options.value = options.selectedValue = options.value[0];
            options.selectedIndex = options.selectedIndex[0];
          }
        } else {
          options.value = options.selectedValue = options.multiple ? [] : ''; // No I18N

          this._addedByComponent = true;
          options.selectedIndex = this.element[0].selectedIndex = -1;
          this._addedByComponent = false;
        }

        this._updateView();
      }
      /* Function to update the value in combobox */

    }, {
      key: "_updateView",
      value: function _updateView() {
        if (this._data.rendered && !this._skipRender && !this._domChanged) {
          this._render();
        }
      }
    }, {
      key: "_trigger",
      value: function _trigger(customEvent, originalEvent, data) {
        var _this83 = this;

        if (!this._fromInit) {
          data = data || {};
          data.dropdownList = this._menu && this._menu[0];
          data.selectedValue = data.value = this._opts.value || ''; // No I18N

          data.selectedIndex = this._opts.selectedIndex;
          var optionDatas = data.optionData;

          if (optionDatas) {
            optionDatas = Array.isArray(optionDatas) ? optionDatas : [optionDatas];
            optionDatas = optionDatas.map(function (optData) {
              return _objectSpread({}, optData, {
                element: _this83.element.find('[data-zitemid=' + optData.zitemid + ']')[0] // No I18N

              });
            });

            if (optionDatas.length === 1) {
              optionDatas = optionDatas[0];
            }

            data.optionData = optionDatas;
          } // data[this.name.replace(/^z/, '')] = this.container; // No I18N


          return this._dispatchEvent(customEvent, originalEvent, data, undefined, !!originalEvent);
        }

        return true;
      }
    }, {
      key: "_fetch",
      value: function _fetch(params, callback) {
        this.listInstance.DSInstance.fetch(params, function (response) {
          return callback(response.results);
        });
      }
    }, {
      key: "_fetchAData",
      value: function _fetchAData(params, callback) {
        this._fetch(params, function (results) {
          return callback(results[0]);
        });
      }
    }, {
      key: "_getMenuItemForOption",
      value: function _getMenuItemForOption(options) {
        var menuitems = [];

        if (this._menu) {
          options.forEach(function (option) {
            var menuitem = $('#' + option.getAttribute('data-zitemid'))[0]; // No I18N

            menuitem && menuitems.push(menuitem);
          });
        }

        return menuitems;
      }
    }, {
      key: "_handleKeyCode",
      value: function _handleKeyCode(orgEvent) {
        if (this._menu) {
          this._menuInstance.handleKeyCode(orgEvent);
        }
      }
    }, {
      key: "_getMatchedOptions",
      value: function _getMatchedOptions(values) {
        var _this84 = this;

        var matchedOptions = [];
        values = this._toArr(values);
        values.forEach(function (value, i) {
          if (values.indexOf(value) === i) {
            var matchedOption = _this84._getMatchedOption(value);

            matchedOption && matchedOptions.push(matchedOption);
          }
        });
        return matchedOptions;
      }
    }, {
      key: "_getValidVal",
      value: function _getValidVal(value) {
        if (value instanceof $) {
          value = value[0];
        }

        return value;
      }
    }, {
      key: "_getMatchedOption",
      value: function _getMatchedOption(value, orgEvent) {
        value = this._getValidVal(value);

        if (this._isNotNull(value)) {
          return value.nodeType ? this._contains(value) && value : this._getOptionForData(value, orgEvent);
        }
      }
    }, {
      key: "_getMatchDataForUpdate",
      value: function _getMatchDataForUpdate(option, isGroup, items) {
        // items are passed incase of header and footer
        option = this._getValidVal(option);

        if (this._isNotNull(option)) {
          if (option.nodeType) {
            return option.optData;
          }

          return this._getMatchData(option, items || this._dataSource[isGroup ? 'body' : 'options']); // No I18N
        }
      }
    }, {
      key: "_contains",
      value: function _contains(node) {
        return this.element[0].contains(node);
      }
    }, {
      key: "_isSelected",
      value: function _isSelected(option) {
        return this._selected.indexOf(option) === -1;
      }
    }, {
      key: "_setValue",
      value: function _setValue(values, orgEvent) {
        var options = this._opts;

        if (options.multiple) {
          this._setValueForMultiple(values, orgEvent);
        } else if (this._isNotNull(values)) {
          values = this._toArr(values);

          var matchedOption = this._getSelectableOption(values[0], orgEvent);

          if (matchedOption) {
            if (this._isSelected(matchedOption)) {
              return this._selectOption([matchedOption], orgEvent);
            }

            return this._updateValues();
          }
        }

        if (this._fromInit) {
          this._updateValues();
        } else {
          !this._opts.multiple && this.deselectAllOptions(orgEvent);
        }
      }
    }, {
      key: "_getSelectableOption",
      value: function _getSelectableOption(value, orgEvent) {
        var matchedOption = this._getMatchedOption(value, orgEvent);

        var OPTGROUP_SELECTOR = this._SELECTORS.OPTGROUP;

        if (matchedOption) {
          var optData = matchedOption.optData;

          if (!optData.hidden && !optData.disabled && !optData.separator && !optData.isHeader && !optData.isFooter && !optData.isOptGroup) {
            var parent = matchedOption.parentElement;

            if (parent.tagName.toLowerCase() !== OPTGROUP_SELECTOR || !parent.disabled && !parent.hidden) {
              return matchedOption;
            }
          }
        }
      }
    }, {
      key: "_addOptionTag",
      value: function _addOptionTag(optData) {
        optData = this._getCompleteData(optData); // DOMUTIL check

        var option =
        /* optData.element = */
        $('<' + this._SELECTORS.OPTION + '/>').attr({
          // No I18N
          selected: optData.selected,
          id: optData.id,
          'data-ztemp': true,
          // No I18N
          value: optData.value,
          'data-zitemid': optData.zitemid // No I18N

        })[0];
        option.optData = optData;

        if (this.isCE) {
          // Option needs to be appended to z-selectbody
          this._appendTag(option);
        } else {
          this.element.append(option);
        }

        return option;
      }
    }, {
      key: "_getCompleteData",
      value: function _getCompleteData(optData, isGroup, groupData) {
        var _this85 = this;

        var dataMapping = this._opts.dataMapping;

        if (optData.nodeType) {
          return this._genDataForTag([optData], groupData)[0];
        }

        if (/(number|string)/.test(_typeof(optData))) {
          optData = _defineProperty({}, dataMapping.label, optData);
        }

        if (_typeof(optData) === 'object') {
          // No I18N
          optData.zitemid = this._getItemId(optData);
          optData.label = this._mapJSONToData(optData, dataMapping.label);
          optData.value = this._mapJSONToData(optData, dataMapping.value);
          optData.iconClassName = this._mapJSONToData(optData, dataMapping.iconClassName);
          optData.label = this._isNotNull(optData.label) ? String(optData.label) : ''; // No I18N

          optData.value = this._isNotNull(optData.value) ? String(optData.value) : optData.label;
          optData.unselectable = optData.isFooter || optData.isHeader;

          if (groupData) {
            optData.hidden = groupData.hidden || optData.hidden;
            optData.disabled = groupData.disabled || optData.disabled;
          }

          if (optData.options || isGroup) {
            optData.options = optData.options ? optData.options.map(function (option) {
              return _this85._getCompleteData(option, null, optData);
            }) : [];
          }
        }

        return optData;
      }
    }, {
      key: "_close",
      value: function _close(orgEvent) {
        this.listInstance.closeDropdownList(orgEvent);
      }
    }, {
      key: "_open",
      value: function _open(orgEvent) {
        this.listInstance.openDropdownList(orgEvent);
      }
    }, {
      key: "_toArr",
      value: function _toArr(values) {
        if (values instanceof $) {
          return values.toArray();
        }

        return Array.isArray(values) ? values : [values];
      }
    }, {
      key: "_setFocus",
      value: function _setFocus(focusContainer, fromUser) {
        if (this._trigger('beforefocus')) {
          // No I18N
          if (!focusContainer && this._opened) {
            this._menu.focusin();
          } else {
            this.container.focus();
          }

          if (fromUser) {
            this.container.addClass(this._CLASSES.FOCUS);
          }
        }
      }
    }, {
      key: "_selectItemOnKeydown",
      value: function _selectItemOnKeydown(orgEvent) {
        var _this86 = this;

        var options = this._opts;
        /* To handle keypress selection when menu is not opened */

        if (!this._ajaxSource && !options.multiple && !/^(custom|icon)$/.test(options.contentType)) {
          var selectedIndex = options.selectedIndex;

          if (options.sortOptions) {
            this._fetch(undefined, function (dataSource) {
              if (selectedIndex > -1) {
                var zitemid = _this86._dataSource.options[selectedIndex].zitemid;
                dataSource.find(function (data, index) {
                  if (data.zitemid === zitemid) {
                    selectedIndex = index;
                    return true;
                  }
                });
              }

              _this86._selectNextMatchingItem(orgEvent, dataSource, selectedIndex);
            });
          } else {
            this._selectNextMatchingItem(orgEvent, this._dataSource.options, selectedIndex);
          }
        }
      }
    }, {
      key: "_selectNextMatchingItem",
      value: function _selectNextMatchingItem(orgEvent, quickSearchData, selectedIndex) {
        if (quickSearchData.length) {
          var startIndex = selectedIndex + 1;
          var searchKey = orgEvent.key;
          var currentTime = new Date().getTime();

          if (this._prevKey) {
            var timeDiff = currentTime - this._prevTimeStamp;

            if (timeDiff < 300 && this._prevKey !== searchKey) {
              searchKey = this._prevKey + searchKey;
              startIndex--;
            }
          }

          this._prevTimeStamp = currentTime;
          this._prevKey = searchKey;

          if (startIndex >= 0) {
            var search = function search(start, end) {
              for (var x = start; x < end; x++) {
                var _data3 = quickSearchData[x];

                if (!_data3.hidden && !_data3.disabled && _data3.label.match(pattern)) {
                  return _data3;
                }
              }
              /* If the data is not found in the last half... first half is searched */


              return start && search(0, start);
            };

            var pattern = this._getMatchingRegex(searchKey, {
              criteria: 'startswith',
              // No I18N
              caseSensitive: false
            });

            var data = search(startIndex, quickSearchData.length);
            data && this._setValue(data);
          }
        }
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        var options = this._opts;
        this._addedByComponent = true;

        switch (optionName) {
          case 'selectedIndex':
            // No I18N
            this._setAttribute('selectedValue', this._getOptDataAt(value)); // No I18N


            break;

          case 'value': // No I18N

          case 'selectedValue':
            // No I18N
            this._domChanged = true;
            options.multiple && this.deselectAllOptions();
            this.setValue(value);
            break;

          default:
            this._setAdvAttribute.apply(this, arguments);

        }

        this._addedByComponent = false;
      }
      /** **PUBLIC FUNCTIONS*** */

      /** ******************** */

    }, {
      key: "setFocus",
      value: function setFocus() {
        if (!this._opts.disabled) {
          this._setFocus(false, true);
        }
      }
    }, {
      key: "close",
      value: function close() {
        this._close();
      }
    }, {
      key: "open",
      value: function open() {
        if (!this._opts.disabled && (!this._menu || this._menu && !this._menu.is(':visible'))) {
          this.setFocus();

          this._open();
        }
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this._setValue(value);
      }
    }, {
      key: "deselectAllOptions",
      value: function deselectAllOptions(orgEvent) {
        this._deselectOption(this._selected, orgEvent);
      }
    }, {
      key: "deselectOption",
      value: function deselectOption() {
        this._deselectOption.apply(this, arguments);
      }
    }, {
      key: "getValue",
      value: function getValue() {
        return this._opts.value;
      }
    }, {
      key: "refresh",
      value: function refresh() {
        this._buildData();
      }
    }, {
      key: "_buildData",
      value: function _buildData(render) {
        this._opened = false; // If the options are changed, the items are reselected.

        if (this._dataChanged) {
          this._initDS();
        }

        this._skipRender = true;

        this._reselect();

        var settings = this._getListSettings();

        this.listInstance.setAttributes($.extend(true, {}, this.listInstance._DEFAULTS, settings));
        this._dataChanged = this._skipRender = false;
        render && this._render();
      }
    }, {
      key: "clearCache",
      value: function clearCache() {
        this.listInstance.clearCache();
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        clearTimeout(this._focusoutTimer);
        this.listInstance.destroy();

        this._removeEvents('', this._arrowTarget); // No I18N

      }
    }, {
      key: "_setAdvAttribute",
      value: function _setAdvAttribute(optionName, value) {
        var options = this._opts;

        switch (optionName) {
          case 'acceptNewValues': // No I18N

          case 'newValuePattern': // No I18N

          case 'selectOnCharPress':
            // No I18N
            options[optionName] = value;
            break;

          case 'arrowIconClassName': // No I18N

          case 'arrowSVGIconId': // No I18N

          case 'clearButton': // No I18N

          case 'placeholder': // No I18N

          case 'template':
            // No I18N
            options[optionName] = value;
            this._domChanged = true;
            break;

          case 'width':
            // No I18N
            options[optionName] = value;
            this._data.width = undefined;
            this._domChanged = true;
            break;

          case 'multiple':
            // No I18N
            if (value) {
              this.element.attr('multiple', true); // No I18N
            } else {
              this._deselectOption(this._selected.slice(1));

              this.element.removeAttr('multiple'); // No I18N
            }

            options[optionName] = value;
            this._reInit = true;
            break;

          case 'selectionLimit':
            // No I18N
            {
              options[optionName] = value;

              if (value) {
                var extra = this._selected.length - value;

                if (extra) {
                  this._deselectOption(this._selected.slice(-1 * extra));
                }
              }

              break;
            }

          case 'options': // No I18N

          case 'dataSource':
            // No I18N

            /* Previous option tags are removed except header and footer items  */
            {
              var selectors = this._SELECTORS;
              var childSelector = this.isCE ? selectors.OPTION + ',' + selectors.OPTIONSBODY + ',' + selectors.OPTIONSEPARATOR : 'option:not([data-is-header]):not([data-is-footer]),optgroup'; // No I18N

              this.element.children(childSelector).remove();
              options[optionName] = value;
              this._reInit = this._dataChanged = true;
            }
            break;

          case 'dataMapping':
            // No I18N
            options[optionName] = value;
            this._reInit = this._dataChanged = true;
            break;

          case 'isResponseFiltered': // No I18N

          case 'serverSearch': // No I18N

          case 'cacheData': // No I18N

          case 'viewPerPage': // No I18N

          case 'lazyLoading': // No I18N

          case 'filterByCSSSelector': // No I18N

          case 'sort': // No I18N

          case 'sortBy': // No I18N

          case 'sortOrder': // No I18N

          case 'customSorter': // No I18N

          case 'contentType': // No I18N

          case 'dropdownList': // No I18N

          case 'showSearchField': // No I18N

          case 'search': // No I18N

          case 'rtl':
            // No I18N
            options[optionName] = value;
            this._reInit = true;
            break;

          default:
            options[optionName] = value;
        }
      }
    }, {
      key: "_updateMenuAttribute",
      value: function _updateMenuAttribute(optionName, value) {
        this._menu && this._menuInstance.setAttribute(optionName, value);
      }
    }, {
      key: "disableOptions",
      value: function disableOptions(options) {
        this.setOptionAttributes(options, 'disabled', true); // No I18N
      }
    }, {
      key: "enableOptions",
      value: function enableOptions(options) {
        this.setOptionAttributes(options, 'disabled', false); // No I18N
      }
    }, {
      key: "_disable",
      value: function _disable(disable) {
        disable && this.close();
        this.element[0].disabled = !!disable;
        this._domChanged = true;
      }
    }, {
      key: "_setOptionAttribute",
      value: function _setOptionAttribute(optData, optionName, value) {
        var _this87 = this;

        if (optData) {
          var updateTag = false;

          if (optionName === 'options') {
            // No I18N
            optData.options = value;

            this._getCompleteData(optData);
          } else if (optionName === 'value' || optionName === 'label') {
            // No I18N
            optData[optionName] = value;
            updateTag = true;
          } else if (optionName === 'disabled' || optionName === 'hidden') {
            // No I18N
            optData[optionName] = value;
            updateTag = true;

            if (optData.options) {
              if (optData.options.length) {
                optData.options.forEach(function (subOptData) {
                  return _this87._setOptionAttribute(subOptData, optionName, value);
                });
              }
            } else {
              value && this.deselectOption(optData);
            }
          } else if (optionName === 'selected') {
            // No I18N
            if (value) {
              this._setValue(optData);
            } else {
              this.deselectOption(optData);
            }
          } else {
            optData[optionName] = value;
          }

          var optionTag = this._getOptionForData(optData);

          if (optionTag && updateTag) {
            optionTag[optionName] = value;
          }
        }
      }
    }, {
      key: "setOptionAttributes",
      value: function setOptionAttributes(options, optionName, value) {
        var _this88 = this;

        this._addedByComponent = true;

        if (!this._ajaxSource) {
          this._toArr(options).forEach(function (option) {
            var optData = _this88._getMatchDataForUpdate(option, null, _this88._isGrouped ? _this88._dataSource.body.concat(_this88._dataSource.options) : null);

            if (_typeof(optionName) === 'object' && !$.isEmptyObject(optionName)) {
              // No I18N
              for (var key in optionName) {
                _this88._setOptionAttribute(optData, key, optionName[key]);
              }
            } else {
              _this88._setOptionAttribute(optData, optionName, value);
            }
          }); // replace menu items


          this._updateList();
        }

        this._addedByComponent = false;
      }
    }, {
      key: "_addOption",
      value: function _addOption(optDatas, action, refEle, isGroup) {
        var _this89 = this;

        optDatas = this._toArr(optDatas);
        var optgroupTagName = this.isCE ? 'Z-OPTGROUP' : 'OPTGROUP'; // No I18N

        optDatas = optDatas.map(function (optData) {
          var groupData;

          if (!isGroup && optData.nodeType) {
            var parentElement = optData.parentElement;

            if (parentElement && parentElement.tagName === optgroupTagName) {
              groupData = ZC._getOpts(parentElement);
            }
          }

          return _this89._getCompleteData(optData, isGroup, groupData);
        });
        var type = optDatas[0].isHeader ? 'header' : optDatas[0].isFooter ? 'footer' : 'body'; // No I18N

        if (!this._ajaxSource || type !== 'body') {
          // No I18N
          this[!isGroup && this._isGrouped && type === 'body' ? '_addOptionToGroup' : '_addOptionDirectly'](optDatas, action, refEle, type); // No I18N
        }
      }
    }, {
      key: "_addOptionDirectly",
      value: function _addOptionDirectly(optDatas, action, refEle, type) {
        var index;
        var items = this._dataSource[type];

        if (typeof action === 'number') {
          // No I18N
          index = action;
        } else if (refEle) {
          index = items.indexOf(this._getMatchDataForUpdate(refEle, null, items));

          if (action === 'after') {
            // No I18N
            index++;
          }
        }

        this._addDatasAt(optDatas, items, index);
      }
    }, {
      key: "_addDatasAt",
      value: function _addDatasAt(newDatas, existingDatas, index) {
        if (index === undefined || index === -1) {
          existingDatas.push.apply(existingDatas, _toConsumableArray(newDatas));
        } else {
          existingDatas.splice.apply(existingDatas, [index, 0].concat(_toConsumableArray(newDatas)));
        }
      }
    }, {
      key: "_getOptionType",
      value: function _getOptionType(type) {
        return /(header|footer)/.test(type) ? type : 'body'; // No I18N
      }
    }, {
      key: "_removeOptionsAt",
      value: function _removeOptionsAt(indexes, isGroup, type) {
        var _this90 = this;

        if (!this._ajaxSource || type === 'header' || type === 'footer') {
          // No I18N
          indexes = indexes.filter(function (index, i) {
            return index > -1 && indexes.indexOf(index) === i;
          });
          indexes.sort(function (a, b) {
            return b - a;
          });
          type = this._getOptionType(type);
          var items = this._dataSource[type];
          indexes.forEach(function (index) {
            if (_this90._isGrouped && !isGroup && type === 'body') {
              // No I18N
              var optData = _this90._dataSource.options[index];
              index = undefined;

              if (optData) {
                var data = _this90._getGroupAndIndex(optData);

                index = data.index;
                items = data.items;
              }
            }

            _this90._removeDataAt(index, items);
          });
        }
      }
    }, {
      key: "_removeDataAt",
      value: function _removeDataAt(index, items) {
        if (index !== undefined && index > -1) {
          var option = this._getOptionByZItemId(items[index].zitemid);

          if (option) {
            $(option).remove();
          }

          items.splice(index, 1);
        }
      }
    }, {
      key: "_removeOption",
      value: function _removeOption(values, isGroup, type) {
        var _this91 = this;

        type = this._getOptionType(type);
        var items = isGroup ? this._dataSource.body : type === 'body' ? this._dataSource.options : this._dataSource[type]; // No I18N

        values = this._toArr(values);
        var indexesToBeRemoved = values.map(function (value) {
          return items.indexOf(_this91._getMatchDataForUpdate(value, isGroup, items));
        });

        this._removeOptionsAt(indexesToBeRemoved, isGroup, type);
      }
    }, {
      key: "removeAllOptions",
      value: function removeAllOptions(type) {
        var dataSource = this._dataSource;

        if (type === 'header' || type === 'footer') {
          // No I18N
          this.removeOption(dataSource[type]);
        } else if (!this._ajaxSource) {
          this.element.empty();
          this._opts.options = [];
          this._dataChanged = true;

          this._buildData(true);
        }
      }
    }, {
      key: "addOption",
      value: function addOption(optDatas, action, refElement) {
        this._addOption(optDatas, action, refElement);

        this._updateList();
      }
    }, {
      key: "addOptionAt",
      value: function addOptionAt(optDatas, index, group) {
        this._addOption(optDatas, index, group);

        this._updateList();
      }
    }, {
      key: "refresh",
      value: function refresh() {
        this._dataChanged = true;

        this._buildData(true);
      }
    }, {
      key: "removeOption",
      value: function removeOption(values, type) {
        if (this._isNotNull(values)) {
          this._removeOption(values, undefined, type);

          this._updateList();
        } else {
          this.removeAllOptions(type);
        }
      }
    }, {
      key: "removeOptionAt",
      value: function removeOptionAt(indexes, type) {
        this._removeOptionsAt(this._toArr(indexes), null, type);

        this._updateList();
      }
    }, {
      key: "_addOptionToGroup",
      value: function _addOptionToGroup(optDatas, action, refEle) {
        var index, items;

        if (typeof action === 'number') {
          // No I18N
          // action is index here
          if (refEle) {
            index = action;
            items = this._getMatchDataForUpdate(refEle, true).options;
          } else {
            var elementAtIndex = this._dataSource.options[action];

            if (elementAtIndex) {
              var data = this._getGroupAndIndex(elementAtIndex);

              index = data.index;
              items = data.items;
            }
          }
        } else if (refEle) {
          if (action === 'append') {
            // No I18N
            items = this._getMatchDataForUpdate(refEle, true).options;
          } else {
            var refEleData = this._getMatchDataForUpdate(refEle);

            if (refEleData) {
              var _data4 = this._getGroupAndIndex(refEleData);

              index = _data4.index;
              items = _data4.items;

              if (action === 'after') {
                // No I18N
                index++;
              }
            }
          }
        } // if (!items) {
        //     items = items[items.length - 1].options;
        // }


        this._addDatasAt(optDatas, items, index);
      }
    }, {
      key: "removeOptGroup",
      value: function removeOptGroup(groupLabels) {
        this._removeOption(groupLabels, true);

        this._updateList();
      }
    }, {
      key: "addOptGroup",
      value: function addOptGroup(optDatas, refElement) {
        this._addOption(optDatas, 'before', refElement, true); // No I18N


        this._updateList();
      }
    }, {
      key: "_getGroupAndIndex",
      value: function _getGroupAndIndex(optData) {
        var groupOptData = this._getMatchDataForUpdate(optData.groupName, true);

        return {
          items: groupOptData.options,
          index: groupOptData.options.indexOf(optData)
        };
      }
    }, {
      key: "name",
      get: function get() {
        return "zselect";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          multiple: false,
          selectionLimit: 0,
          selectedIndex: null,
          selectedValue: null,
          value: null,
          placeholder: 'Select',
          // No I18N
          disabled: false,
          contentType: 'text',
          // No I18N
          template: null,
          arrowIconClass: null,
          arrowSVGIconId: null,
          selectOnCharPress: true,
          // className: null
          // zclassName: null,

          /* API TO ARRIVE */
          sort: false,
          sortBy: null,
          sortOrder: 'asc',
          // No I18N
          width: null,
          isLabelHTMLEncoded: false,
          cacheData: true,
          dataStructure: 'flat',
          // No I18N
          isResponseFiltered: false,
          serverSearch: false,
          acceptNewValues: false,
          newValuePattern: false,
          showSearchField: false,
          clearButton: false,
          lazyLoading: true,
          filterByCSSSelector: true,
          viewPerPage: 10
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          customSorter: null,
          customSearch: null,
          arrowIconClassName: null,
          options: null,
          dataSource: null,
          dropdownList: {
            contentType: null,
            template: null,
            height: null,
            width: null,
            appendTo: null,
            direction: 'auto',
            // No I18N
            viewport: null,

            /* API TO ARRIVE */
            checkedIcon: null,
            checkedIconClassName: null,
            checkedSVGIconId: null,
            // Loader Icon
            loaderIconClassName: null,
            loaderSVGIconId: null,
            // className: null,
            positionAlterable: undefined,
            virtualization: false
          },
          search: {
            // Changed
            delay: 150,
            criteria: 'contains',
            // No I18N
            caseSensitive: false,
            minKeywordLength: 0,
            by: 'label',
            // No I18N

            /* API TO ARRIVE */
            focusFirstResult: true,
            highlightKeyword: false,
            maxKeywordLength: 0,
            searchIncrementsInCache: false,
            showNoResultsMessage: true
          },
          messages: {
            allOptionsSelected: 'All Selected',
            // No I18N
            noResults: 'No Results',
            // No I18N
            serverError: 'Server request failed. Please try again later.',
            // No I18N

            /* API TO ARRIVE */
            clear: 'Clear',
            // No I18N
            moreAction: 'More Results' // No I18N

          },

          /* API TO ARRIVE */
          dataMapping: {
            id: 'id',
            // No I18N
            label: 'label',
            // No I18N
            value: 'value',
            // No I18N
            informativeText: 'informativeText',
            // No I18N
            iconClassName: 'iconClassName',
            // No I18N
            SVGIconId: 'SVGIconId',
            // No I18N
            options: 'options',
            // No I18N
            optgroupLabel: null
          }
        };
      }
    }, {
      key: "ARIA_ROLES",
      get: function get() {
        return {
          CONTAINER: 'combobox',
          // No I18N
          OPTION: 'option',
          // No I18N
          DROPDOWN: 'listbox' // No I18N

        };
      }
    }, {
      key: "SELECTORS",
      get: function get() {
        var isCE = this.isCE;
        return {
          OPTION: isCE ? 'z-option' : 'option',
          // No I18N
          OPTGROUP: isCE ? 'z-optgroup' : 'optgroup',
          // No I18N
          OPTIONSBODY: 'z-selectbody',
          // No I18N
          OPTIONSHEADER: 'z-selectheader',
          // No I18N
          OPTIONSFOOTER: 'z-selectfooter',
          // No I18N
          OPTIONSEPARATOR: 'z-optionseparator',
          // No I18N
          ADDOPTION: 'z-addoption' // No I18N

        };
      }
    }, {
      key: "CLASSES",
      get: function get() {
        return {
          CONTAINER: 'zselectbox',
          // No I18N
          ICON: 'zselectbox__icon',
          // No I18N
          ICONTEXT: 'zselectbox--icontext',
          // No I18N
          ICONONLY: 'zselectbox--icononly',
          // No I18N
          TEXT: 'zselectbox__text',
          // No I18N
          DROPUP: 'zselectbox--top',
          // No I18N
          DROPDOWN: 'zselectbox--bottom',
          // No I18N
          ACTIVE: 'is-active',
          // No I18N
          FOCUS: 'has-focus',
          // No I18N
          DISABLED: 'is-disabled',
          // No I18N
          CLEARBUTTON: 'zselectbox__clearbutton',
          // No I18N
          MENU: {
            CLASSNAME: 'zmenu--selectmenu',
            // No I18N
            ITEM: 'zmenu__item',
            // No I18N
            BODY: 'zmenu__body' // NO I18N

          }
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['init', // No I18N
        'beforedropdownlistopen', // No I18N
        'dropdownlistopen', // No I18N
        'beforedropdownlistclose', // No I18N
        'dropdownlistclose', // No I18N
        'beforechange', // No I18N
        'change', // No I18N
        'itemclick', // No I18N
        'optionclick', // No I18N
        'addoptionclick', // No I18N
        'blur', // No I18N
        'beforefocus', // No I18N
        'focus', // No I18N
        'noresults', // No I18N
        'beforedropdownlistupdate', // No I18N
        'dropdownlistupdate', // No I18N
        'newvalueadd', // No I18N
        'beforesearch', // No I18N
        'searcherror', // No I18N
        'searchsuccess' // No I18N
        ];
      }
    }]);

    return ZSelect;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZSelect', ZSelect);

  (function (ZC) {
    var template = ZC.zselect.Templates;
    var utilities = ZC.Templates.Utilities;

    template.container = function (data) {
      return ZT.html(_templateObject134(), data.children && template.children(data));
    };

    template.children = function (data) {
      return ZT.html(_templateObject135(), data.noSelection ? ZT.html(_templateObject136(), data.placeholder) : ZT.html(_templateObject137(), ZT.customHTML(data.innerHTML || ''), data.icon && utilities.icon(data.icon), data.label && ZT.html(_templateObject138(), ZT.customHTML(data.label))), data.clearButton && ZC.createButton(data.clearButton), utilities.icon(data.arrow));
    };
  })(ZComponents);

  var ZInputField =
  /*#__PURE__*/
  function (_ZC$CoreComponent15) {
    _inherits(ZInputField, _ZC$CoreComponent15);

    function ZInputField() {
      _classCallCheck(this, ZInputField);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZInputField).apply(this, arguments));
    }

    _createClass(ZInputField, [{
      key: "_init",
      value: function _init(element, opts) {
        var isCE = this.isCE,
            data = this._data,
            optWidth = opts.width,
            // No I18N
        title = element.attr('title'); // No I18N

        title && !isCE && (opts.title = title);

        if (optWidth === 'none') {
          // No I18N
          opts.width = null; // needed because opts and data are merged in _render method
        } else {
          var width = parseInt(optWidth) || element.outerWidth(); // setting the element's width to the outer container.

          data.width = width; // if width was given by the user, need to set it to element

          parseInt(width) && (data.style = 'width:' + data.width + 'px'); // No I18N
        } // assigning input element attributes


        data.tabindex = element[0].getAttribute('tabindex') || 0; // No I18N

        data.attrs = {
          tabindex: -1 // No I18N

        };
        var fVal = 'none'; // No I18N

        data.spinButtons = opts.spinButtons !== fVal;

        if (data.spinButtons) {
          this._getSpinBtnProps();
        }

        data.clearButton = opts.clearButton !== fVal;

        if (data.clearButton) {
          this._getClearBtnProps();
        }

        if (!isCE) {
          data.id = this._getID(element) + '-container';
        }
      }
    }, {
      key: "_postRender",
      value: function _postRender() {
        var data = this._data,
            opts = this._opts,
            readonly = opts.readonly,
            cls = (readonly || opts.disabled ? ' is-disabled' : '') + (readonly ? ' is-readonly' : ''); // No I18N

        data.className += ' zinputfield ' + cls; // No I18N

        this._input = this.container.find('.zinputfield__textbox'); // No I18N

        opts.placeholder && this._input.attr('placeholder', opts.placeholder); // No I18N
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender(ele) {
        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._data;
        var modified = data.modifiedAttr,
            opts = this._opts,
            hasSpinBtn = data.spinButtons;

        if (data.clearButton && (!modified || modified === 'clearButton')) {
          // No I18N
          this._updateClearBtn();
        }

        if (!modified || modified === 'spinButtons') {
          // No I18N
          if (hasSpinBtn) {
            this._updateSpinButtons();
          } else {
            this._data.className += ' zinputfield--spinbtnnone'; // No I18N
          }
        }

        if (modified && modified === 'spinButtonsType') {
          // No I18N
          this._input = this.container.find('.zinputfield__textbox'); // No I18N

          this._bindEvents(); // input element's position and events will be lost on this render.


          this._setValue(this._opts.value);
        }

        if (hasSpinBtn && !data.isVertical && (!modified || modified.indexOf('spinButtons') === 0)) {
          this._data.className += ' zinputfield--split'; // No I18N
        }

        if (data.clearButton && opts.clearButton === 'always' && (!modified || modified === 'clearButton')) {
          // No I18N
          this._data.className += ' zinputfield--withclrbtn'; // No I18N

          if (!opts.value) {
            // field remains empty
            this._toggleBtnDisplay(true, true);
          }
        }

        if (data.spinButtons || data.clearButton) {
          this._bindContainerEvents();
        }

        if (data.modifiedAttr === 'spinButtonsOrientation' && this.isCE && this._buttons) {
          this._buttons[0].$c._addedByComponent = false;
          this._buttons[1].$c._addedByComponent = false;
        }

        data.modifiedAttr = undefined;
      } // kept as common here because both clearButton and spinButton uses it

    }, {
      key: "_toggleBtnDisplay",
      value: function _toggleBtnDisplay(hide, isClear, both) {
        // toggle the visibility of the button
        var elements = both ? this._clearButton.add(this._buttonPane) : isClear ? this._clearButton : this._buttonPane;
        elements[hide ? 'addClass' : 'removeClass']('zh-dnone'); // No I18N
      }
    }, {
      key: "_bindContainerEvents",
      value: function _bindContainerEvents() {
        // ##revisit - Try to reuse in datefield
        this._addEvents({
          containerHover: 'mouseenter mouseleave',
          // No I18N
          containerFocusIn: 'focusin' // No I18N

        });
      }
    }, {
      key: "_containerHoverHandler",
      value: function _containerHoverHandler(event) {
        var opts = this._opts,
            data = this._data;

        if (!opts.readonly && !opts.disabled) {
          var isEnter = event.type === 'mouseenter',
              // No I18N
          hasFocus = !isEnter && this.container.hasClass('has-focus'),
              // No I18N
          _opts2 = this._opts,
              hasClearBtn = data.clearButton && _opts2.clearButton === 'focus',
              // No I18N
          hasSpinBtn = data.spinButtons && _opts2.spinButtons === 'focus',
              // No I18N
          clrMod = 'zinputfield--withclrbtn',
              // No I18N
          spinMod = 'zinputfield--spinbtnonfocus'; // No I18N

          if ((hasClearBtn || hasSpinBtn) && this._input.val().length && !hasFocus) {
            if (isEnter) {
              this._data.className += (hasClearBtn ? ' ' + clrMod : '') + (hasSpinBtn ? ' ' + spinMod : ''); // No I18N
            } else {
              this._updateClass('', (hasClearBtn ? clrMod : '') + (hasSpinBtn ? (hasClearBtn ? '|' : '') + spinMod : '')); // No I18N

            }

            this._toggleBtnDisplay(!isEnter, hasClearBtn, hasClearBtn && hasSpinBtn, event.type);
          }
        }
      }
    }, {
      key: "_containerFocusInHandler",
      value: function _containerFocusInHandler(event) {
        event.stopPropagation();
      }
      /* Method is provided because input element's outerWidth will be 0 if it's parent was hidden while initializing the component.
         This method is applicable to normal JS component alone. */

    }, {
      key: "resetWidth",
      value: function resetWidth() {
        if (!this.isCE) {
          this.container.outerWidth(this.element.outerWidth());
        }
      } // kept as common here because both clearButton and spinButton uses it

    }, {
      key: "_getBtnProps",
      value: function _getBtnProps(buttonType, defaultSVGId, clsName, mainEle) {
        var opts = this._opts;
        return {
          className: clsName,
          templateRender: true,
          defaultIconClassName: 'zinputfield__icon',
          // No I18N
          iconClassName: opts[buttonType + 'ButtonIconClass'] || opts[buttonType + 'ButtonIconClassName'],
          // No I18N
          SVGIconId: opts[buttonType + 'ButtonSVGIconId'],
          // No I18N
          defaultSVGIconId: defaultSVGId + ' zbutton__svg zinputfield__svg',
          // No I18N
          isCE: this.isCE,
          mainElement: mainEle,
          customAttributes: {
            tabindex: -1 // tabindex is set to avoid keyboard navigation to those buttons

          }
        };
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        var cName = this.name;

        this._input.off(".".concat(cName));

        this._input = this._clearButton = this._buttons = this._buttonPane = undefined;

        if (this.isCE) {
          this.element.removeClass(this._data.className).empty();
        }

        ZC.$document.off(".".concat(cName));
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        var container = this.container,
            opts = this._opts,
            inputEle = this._input;

        if (optionName === 'title') {
          // No I18N
          container[0].setAttribute('title', value); // No I18N
        } else if (optionName === 'placeholder') {
          // No I18N
          inputEle.attr("placeholder", value); // No I18N
        } else if (optionName === 'width') {
          // No I18N
          container.outerWidth(value);
        } else if (optionName === 'maxLength') {
          // No I18N
          inputEle[value ? 'attr' : 'removeAttr']('maxlength', value); // No I18N
        } else if (optionName.indexOf('clearButton') > -1) {
          // No I18N
          this._domChanged = true;

          this._handleClearBtn(optionName, value, opts);
        } else if (/incrementButton|decrement|spinButtons/g.test(optionName)) {
          // if increment alone is used, incrementOnWrapAround also falls into the condition
          this._domChanged = true;

          this._handleSpinBtns(optionName, value, opts);
        } else if (optionName === 'readonly') {
          // No I18N
          var rCls = 'is-readonly is-disabled'; // No I18N

          this._updateClass(value ? rCls : '', value ? '' : '(is-readonly' + (opts.disabled ? '' : '|is-disabled') + ')'); // No I18N


          if (value) {
            inputEle.attr({
              readonly: true,
              'aria-readonly': true // No I18N

            });
          } else {
            inputEle.removeAttr('readonly aria-readonly'); // No I18N
          }
        } else if (optionName === 'required') {
          // No I18N
          var val = this._opts.value;

          if (!val) {
            this._setInitialValue();
          }
        }
      }
    }, {
      key: "_disable",
      value: function _disable(disable) {
        _get(_getPrototypeOf(ZInputField.prototype), "_disable", this).call(this, disable, undefined, !disable && this._opts.readonly);

        var inputEle = this._input;

        if (disable) {
          inputEle.attr({
            disabled: true,
            'aria-disabled': true // No I18N

          });
        } else {
          inputEle.removeAttr('disabled aria-disabled'); // No I18N
        }
      }
    }, {
      key: "_getClearBtnProps",
      value: function _getClearBtnProps() {
        this._data.clearButtonProps = this._getBtnProps('clear', 'zc__svg--clear', 'zinputfield__clearbutton', this._clearButton && this._clearButton[0]); // No I18N
      }
    }, {
      key: "_updateClearBtn",
      value: function _updateClearBtn() {
        this._clearButton = this.container.find('.zinputfield__clearbutton'); // No I18N

        if (this._opts.clearButton === 'focus') {
          // No I18N
          this._toggleBtnDisplay(true, true);
        }

        this._data.clearButtonProps.mainElement = this._clearButton[0];

        this._bindClearBtnEvents();
      }
    }, {
      key: "_bindClearBtnEvents",
      value: function _bindClearBtnEvents() {
        var clearButton = this._clearButton;

        this._addEvents({
          cBtnMouse: 'mousedown mouseup',
          // No I18N
          cBtnClick: 'click' // No I18N

        }, clearButton);
      }
    }, {
      key: "_cBtnMouseHandler",
      value: function _cBtnMouseHandler(event) {
        this._mouseDown = event.type === 'mousedown'; // No I18N
      }
    }, {
      key: "_cBtnClickHandler",
      value: function _cBtnClickHandler() {
        var opts = this._opts;

        if (opts.disabled || opts.readonly) {
          return;
        } // focus is set because in firefox browser, focus is not retained after clearing the value.


        opts._lastValue = opts.value;

        this._input.val('').focus(); // No I18N


        this._toggleBtnDisplay(true, true);
      }
    }, {
      key: "_handleClearBtn",
      value: function _handleClearBtn(optionName, value, opts) {
        // optionName can be clearButton, clearButtonIconClassName, clearButtonIconClass, clearButtonSVGIconId
        var data = this._data;
        opts[optionName] = value;
        data.clearButton = opts.clearButton !== 'none'; // No I18N

        if (data.clearButton) {
          this._getClearBtnProps();

          if (optionName === 'clearButton') {
            // No I18N
            data.modifiedAttr = optionName;
          } else {
            this._domChanged = false;

            this._setBtnValue(data.clearButtonProps, data.clearButtonProps);
          }
        } else {
          // remove the clear button
          this._updateClass('', 'zinputfield--withclrbtn'); // No I18N


          this._clearButton = undefined;
        }
      }
    }, {
      key: "_getSpinBtnProps",
      value: function _getSpinBtnProps() {
        var data = this._data,
            opts = this._opts,
            orientation = opts.spinButtonsOrientation || opts.spinButtonsType,
            UpProps,
            downProps,
            getBtnProps = this._getBtnProps.bind(this),
            getSpinIconInfo = this._getSpinIconInfo.bind(this);

        data.isVertical = orientation === 'vertical' || orientation === 'together'; // No I18N

        data.attrs.role = 'spinbutton'; // No I18N

        UpProps = getSpinIconInfo('increment', data.isVertical); // No I18N

        downProps = getSpinIconInfo('decrement', data.isVertical); // No I18N

        data.incrementProps = getBtnProps('increment', UpProps[0], UpProps[1], this._buttons && this._buttons[0]); // No I18N

        data.decrementProps = getBtnProps('decrement', downProps[0], downProps[1], this._buttons && this._buttons[1]); // No I18N
      }
    }, {
      key: "_getSpinIconInfo",
      value: function _getSpinIconInfo(button, isVertical) {
        var svgId = 'zc__svg--' + (isVertical ? '' : 'horizontal') + button + (isVertical ? '' : ' zh-arrowicon'),
            // No I18N
        clsName = 'zinputfield__spinbutton' + (button === 'increment' ? ' zh-up' : ' zh-down'); // No I18N

        return [svgId, clsName];
      }
    }, {
      key: "_updateSpinButtons",
      value: function _updateSpinButtons() {
        var opts = this._opts,
            value = opts.spinButtons,
            container = this.container,
            // No I18N
        isFocus = value === 'focus',
            // No I18N
        data = this._data; // No I18N

        this._buttonPane = container.find('.zinputfield__spinbuttonpane'); // No I18N

        this._buttons = container.find('.zinputfield__spinbutton'); // No I18N

        var index = +data.isVertical;
        data.incrementProps.mainElement = this._buttons[+!index];
        data.decrementProps.mainElement = this._buttons[index];

        this._toggleBtnDisplay(isFocus && true);

        this._bindSpinButtonEvents();
      }
    }, {
      key: "_handleSpinBtns",
      value: function _handleSpinBtns(optionName, value, opts) {
        var data = this._data;
        opts[optionName] = value;

        if (optionName === 'spinButtonsType' && opts.spinButtons === 'focus') {
          // No I18N
          opts.spinButtons = 'always'; // No I18N
        }

        data.spinButtons = value = opts.spinButtons !== 'none'; // No I18N

        this._updateClass('', 'zinputfield--split|zdatetimefield|zdatetimefield--buttonsonhover|zinputfield--spinbtnonfocus|zinputfield--spinbtnnone'); // No I18N


        if (['spinButtons', 'spinButtonsType', 'spinButtonsOrientation'].indexOf(optionName) > -1) {
          // No I18N
          data.modifiedAttr = optionName;
        } else {
          this._domChanged = false;
        }

        if (value) {
          this._getSpinBtnProps();

          var up, down;

          if (this._buttons) {
            up = this._buttons[0];
            down = this._buttons[1];
          }

          if (this.isCE && up && down) {
            up.$c._addedByComponent = true;
            down.$c._addedByComponent = true;
          }

          this._setBtnValue(data.incrementProps, data.incrementProps);

          this._setBtnValue(data.decrementProps, data.decrementProps);
        } else {
          // remove the spin buttons
          this._buttons = this._buttonPane = undefined;
        }
      }
    }, {
      key: "name",
      get: function get() {
        return "zinputfield";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          min: null,
          max: null,
          spinButtons: 'always',
          // No I18N
          locale: null,
          clearButton: 'focus',
          // No I18N
          clearButtonSVGIconId: null,
          clearButtonIconClass: null,
          width: null,
          value: null,
          spinButtonsType: 'together',
          // No I18N
          incrementButtonSVGIconId: null,
          incrementButtonIconClass: null,
          decrementButtonIconClass: null,
          decrementButtonSVGIconId: null,
          spinEventTriggerDelay: 0,
          disabled: false,
          readonly: false
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          incrementButtonIconClassName: null,
          decrementButtonIconClassName: null,
          clearButtonIconClassName: null
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['focus', 'blur', 'change', 'spin', 'spinstart', 'spinend']; // No I18N
      }
    }]);

    return ZInputField;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZInputField', ZInputField);

  (function (ZC) {
    var template = ZC.zinputfield.Templates,
        button = ZC.createButton;

    template.container = function (data) {
      return ZT.html(_templateObject139(), data.className, data.title, data.style, data.id, data.children && template.children(data));
    };

    template.children = function (data) {
      return ZT.html(_templateObject140(), data.tabindex, data.min, data.max, data.readonly, data.readonly, data.disabled, data.disabled, data.maxLength, data.clearButton && button(data.clearButtonProps), data.spinButtons && ZT.html(_templateObject141(), data.isVertical ? button(data.incrementProps) : button(data.decrementProps), data.isVertical ? button(data.decrementProps) : button(data.incrementProps)));
    };
  })(ZComponents);
  /*
  _prevKUTime - Previous Key Up Time.
  _currKUTime - Current Key Up Time.
  _currKDTime - Current Key Down Time.
  _prevKDTime - Previous Key Down Time.
  _kuTimer - Key Up Timer
  _muTimer - Mouse Up Timer
  _sTimer - Spin Timer
  _changeDisVal - Change Event dispatched value.
  _mwTimer - Mouse Wheel Timer
  */


  var ZNumberField =
  /*#__PURE__*/
  function (_ZC$ZInputField) {
    _inherits(ZNumberField, _ZC$ZInputField);

    function ZNumberField() {
      _classCallCheck(this, ZNumberField);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZNumberField).apply(this, arguments));
    }

    _createClass(ZNumberField, [{
      key: "_init",
      value: function _init(ele, opts) {
        _get(_getPrototypeOf(ZNumberField.prototype), "_init", this).call(this, ele, opts);

        var numericAttrs = ['min', 'max', 'step', 'value', 'disabled', 'readonly'],
            // No I18N
        aName,
            aValue;

        for (var i = 0; i < 6; i++) {
          aName = numericAttrs[i]; // attributes present in the elements will be given preference.

          aValue = ele.attr(aName) || opts[aName];
          opts[aName] = i < 3 ? parseFloat(aValue) : aValue; // parsefloat to boolean attributes avoided.
        }

        this._validateOpts(this._opts);

        if (opts.decimalPlaces || opts.showThousandSeparator) {
          this._setSeparatorValues();

          if (opts.value) {
            opts.value = this._removeSeparators(opts.value + ''); // No I18N
          }
        }

        opts.value = parseFloat(opts.value);
        this._factor = opts.stepBehavior === 'w3' ? this._getFactorValue() : 1; // No I18N

        this._hasAffix = (opts.prefix || opts.suffix || '').trim().length; // No I18N

        opts.templateName = 'zinputfield'; // No I18N

        if (this._data.spinButtons) {
          // No I18N
          this._validateSBtnOpts(opts);
        }
      }
    }, {
      key: "_validateOpts",
      value: function _validateOpts() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._opts;

        // Revisit - Remove destructuring. It does not have proper browser support.
        var min = opts.min,
            max = opts.max,
            step = opts.step,
            decimalPlaces = opts.decimalPlaces,
            longStep = opts.longStep,
            isNotNull = this._isNotNull.bind(this);

        if (!isNotNull(min)) {
          // minValue might be zero. So having all the checks.
          min = opts.allowNegativeValue ? undefined : 0;
        }

        if (!isNotNull(max) || max < min) {
          max = undefined;
        }

        if (!step || step <= 0) {
          // zero or negative value might be provided
          step = 1;
        } else if (step > max - min) {
          step = max - min;
        } // check whether the number is a floating point number or integer.


        var isMinFloat = Number(min) === min && min % 1 !== 0,
            isMaxFloat = Number(max) === max && max % 1 !== 0,
            isStepFloat = Number(step) === step && step % 1 !== 0;

        if (isMinFloat || isMaxFloat || isStepFloat) {
          this._hasFloatingNumber = true;
        }

        if (decimalPlaces < 0 || decimalPlaces > 20) {
          decimalPlaces = 0;
        }

        if (!longStep && isNotNull(max) && isNotNull(min)) {
          var dStep = 2 * step;
          longStep = dStep > max ? dStep / (max - min) : dStep;
        }

        opts.min = min;
        opts.max = max;
        opts.step = step;
        opts.decimalPlaces = decimalPlaces;
        opts.longStep = longStep;
        var arr = ['min', 'max', 'readonly', 'disabled', 'spinButtonsType', 'maxLength'],
            // No I18N
        prop;

        for (var j = 0; j < 6; j++) {
          prop = arr[j];
          this._data[prop] = opts[prop];
        }

        this._dispatchEvent('optionschanged', {}); // No I18N

      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender() {
        _get(_getPrototypeOf(ZNumberField.prototype), "_postEachRender", this).apply(this, arguments);

        if (!this._data.rendered) {
          this._setInitialValue();
        }
      }
    }, {
      key: "_toggleBtnDisplay",
      value: function _toggleBtnDisplay(hide, isClear, both) {
        // overrided
        var clrBtn = this._clearButton,
            spinBtn = this._opts.spinButtonsType === 'split' ? this._buttons : this._buttonPane,
            // No I18N
        elements = both ? clrBtn.add(spinBtn) : isClear ? clrBtn : spinBtn;
        elements[hide ? 'addClass' : 'removeClass']('zh-dnone'); // No I18N
      }
    }, {
      key: "_setInitialValue",
      value: function _setInitialValue() {
        var opts = this._opts,
            inputValue = opts.value,
            spinBtns = this._data.spinButtons;

        if (isNaN(inputValue) && !opts.required) {
          this._input.val(''); // No I18N


          spinBtns && this._toggleSpinBtnStates();
          opts.clearButton === 'always' && this._toggleBtnDisplay(true, true); // No I18N

          return;
        }

        if (inputValue && !inputValue + ''.match('[0-9]')) {
          // No I18N
          inputValue = isNaN(inputValue) ? opts.min : this._checkMinAndMax(inputValue);
        }

        this._setValue(inputValue);

        spinBtns && this._toggleSpinBtnStates(); // No I18N

        opts.previousValue = this._changeDisVal = opts.value;
      }
    }, {
      key: "_checkMinAndMax",
      value: function _checkMinAndMax(value) {
        var opts = this._opts;

        if (!this._isNotNull(value) || isNaN(value)) {
          return opts.min || 0;
        }

        value = parseFloat(value);
        value = value < opts.min ? opts.min : value > opts.max ? opts.max : value;
        return value;
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        this._bindSpinEvents();

        this._addEvents({
          inputEleFocus: 'focus',
          // No I18N
          inputEleBlur: 'blur',
          // No I18N
          inputEleClick: 'click',
          // No I18N
          inputEleChange: 'change',
          // No I18N
          inputEleKey: ZC.Browser.isIE && ZC.Browser.getIEVersion() === 9 ? 'keyup' : 'input' // No I18N

        }, this._input);

        if (this.isCE) {
          /* Native INPUT event is triggered for custom element. So preventing its propagation here since we will throw custom INPUT event on keyup. */
          this._bindCEInputEvents();
        }

        if (ZC.Browser.isSafari) {
          // safari will not retain focus on buttons. Active element will be container always.
          this._addEvents({
            containerBlur: 'blur' // No I18N

          });
        }
      }
    }, {
      key: "_containerBlurHandler",
      value: function _containerBlurHandler(event) {
        var orgEve = event.originalEvent,
            container = this.container;

        if (orgEve && $(orgEve.relatedTarget).closest('.zinputfield')[0] !== container[0]) {
          container.find('.zh-up').trigger('blur'); // No I18N
        }
      }
    }, {
      key: "_inputEleFocusHandler",
      value: function _inputEleFocusHandler(event) {
        var opts = this._opts;

        if (opts.disabled || opts.readonly) {
          // Firefox allows placing cursor in read-only text-boxes. Fixing this will disallow selecting the text on double click. So code is commented.
          // if(ZC.Browser.isFirefox){
          //     this._input.blur();
          // }
          return false;
        }

        if (this._hasAffix) {
          // removing the prefix/suffix will be handled here
          this._handleInputFocus();
        }

        this.container.addClass('has-focus');
        var fval = 'focus'; // No I18N

        opts.clearButton === fval && this._toggleBtnDisplay(!this._input.val().length, true); // No I18N

        if (!this._mouseDown) {
          // element will be focused on each spin button click also.
          this._triggerEvent(fval, event); // No I18N

        }

        if (opts.spinButtons === fval) {
          // No I18N
          this._toggleBtnDisplay();
        }
      }
    }, {
      key: "_inputEleBlurHandler",
      value: function _inputEleBlurHandler(event) {
        var relTarget = event.relatedTarget && $(event.relatedTarget),
            closestNumField = relTarget && relTarget.closest('.zinputfield'); // No I18N
        // checking whether blur event is triggered by clicking within the same numberfield or not.

        if (this._mouseDown || relTarget && closestNumField.length && closestNumField[0] === this.container[0]) {
          return;
        }

        this.container.removeClass('has-focus');

        var retVal = this._validateFieldValue();

        if (retVal === false) {
          return;
        }

        var opts = this._opts; // change eve might have triggered on ENTER.

        if (this._changeDisVal === undefined || parseFloat(this._changeDisVal) !== parseFloat(opts.value)) {
          // Change event will be triggered from this method.
          this._triggerEvent('change', event); // No I18N


          this._changeDisVal = opts.value;
        }

        if ((!opts.isWriter || !this._handleInputBlur()) && !this._mouseDown) {
          // _handleInputBlur - writer spec
          this._triggerEvent('blur', event); // No I18N

        }

        var data = this._data; // hiding spin/clear buttons

        if (data.spinButtons) {
          this._toggleSpinBtnStates();
        }

        var clrBtn = opts.clearButton,
            hasClr = clrBtn === 'focus',
            // No I18N
        hasSpin = opts.spinButtons === 'focus'; // No I18N

        if (hasClr || hasSpin) {
          this._toggleBtnDisplay(true, hasClr, hasClr && hasSpin);
        } else if (clrBtn === 'always') {
          // No I18N
          this._toggleBtnDisplay(false, true);
        }

        this._clearTimers();
      }
    }, {
      key: "_validateFieldValue",
      value: function _validateFieldValue() {
        var opts = this._opts,
            value = this._input.val();

        if (value === '' && !opts.required) {
          // No I18N
          return false;
        }

        var reg = /^[- . 0-9 e]+$/,
            valChanged = false;
        value = this._extractNumericValue(value);
        var parsedVal = parseFloat(value);

        if (isNaN(parsedVal) || !reg.test(value)) {
          valChanged = true;
          parsedVal = parseFloat(opts._lastValue);
        } else {
          var checkedValue = this._checkMinAndMax(value);

          if (checkedValue !== parsedVal) {
            valChanged = true;
            opts._lastValue = parsedVal = checkedValue;
          }
        }

        if (opts.value !== parsedVal) {
          valChanged = true;
        }

        this._setValue(valChanged ? parsedVal : opts.value); // updating the value here since prefix and suffix values might be omitted while editing.

      }
    }, {
      key: "_inputEleClickHandler",
      value: function _inputEleClickHandler() {
        var opts = this._opts;

        if (!opts.readonly && !opts.disabled && this._hasAffix) {
          this._input.select();
        }
      }
    }, {
      key: "_inputEleChangeHandler",
      value: function _inputEleChangeHandler(event) {
        event.stopPropagation(); // preventing the change event since we provide custom change event on blur after performing validations.
      }
    }, {
      key: "_inputEleKeyHandler",
      value: function _inputEleKeyHandler() {
        // translate the characters while typing itself because if handled in keyup, translation is visible in the UI.
        this._input.val(this._translateEToA(this._input.val()));
      }
    }, {
      key: "_bindSpinEvents",
      value: function _bindSpinEvents() {
        // executed only if spinValues is true
        if (this._opts.spinButtons !== 'none' || this._opts.spinValues) {
          // No I18N
          this._addEvents({
            inputEleMouseWheel: 'mousewheel DOMMouseScroll MozMousePixelScroll' // No I18N

          }, this._input);
        }

        this._addEvents({
          inputEleKeyDown: 'keydown',
          // No I18N
          inputEleKeyUp: 'keyup' // No I18N

        }, this._input);
      }
    }, {
      key: "_unbindSpinEvents",
      value: function _unbindSpinEvents() {
        this._removeEvents('mousewheel DOMMouseScroll MozMousePixelScroll', this._input); // No I18N

      }
    }, {
      key: "_inputEleKeyDownHandler",
      value: function _inputEleKeyDownHandler(event) {
        var opts = this._opts;

        if (opts.disabled || opts.readonly) {
          return false;
        }

        var key = ZC.keyCode,
            code = event.keyCode;

        if (code !== key.ESCAPE) {
          window.clearTimeout(this._mwTimer);
          this._prevKDTime = this._currKDTime;
          this._currKDTime = new Date().getTime();
          var longPress = false;

          if (this._prevKDTime && this._currKDTime && this._currKDTime - this._prevKDTime < 600) {
            longPress = true;
          }

          var allowSpinning = this._data.spinButtons || opts.spinValues,
              // No I18N
          dontStop = true;

          switch (code) {
            case key.UP:
            case key.DOWN:
              dontStop = false;

              if (allowSpinning) {
                !longPress && (!this._currKUTime || !this._prevKUTime || this._currKUTime - this._prevKUTime > 600) && this._triggerEvent('spinstart', event); // No I18N

                this._spinValue(code === key.UP, event.shiftKey, undefined); // event.ctrlKey || event.metaKey

              }

              break;

            case key.PAGE_UP: // alternate keys ( Function + Alt + Up)

            case key.PAGE_DOWN:
              // alternate keys ( Function + Alt + DOWN)
              allowSpinning && this._setValue(opts[code === key.PAGE_UP ? 'max' : 'min']); // No I18N

              break;

            case key.ENTER:
              clearTimeout(this._sTimer);
              this._changeDisVal = opts.value;

              this._setValue(this._input.val()); // invoked this method here inorder to perform min-max validations.


              this._triggerEvent('change', {}); // No I18N


              opts.isWriter && this._handleEnterKey();
              break;
          }

          this._shortcutKey = event.ctrlKey || event.metaKey;

          var eveRes = this._handleKeyDown(event);

          if (dontStop) {
            dontStop = eveRes;
          }

          return dontStop;
        }
      }
    }, {
      key: "_inputEleKeyUpHandler",
      value: function _inputEleKeyUpHandler(event) {
        var _this92 = this;

        var opts = this._opts;

        if (opts.disabled || opts.readonly) {
          return false;
        }

        var key = ZC.keyCode,
            code = event.keyCode,
            isUpDown = code === key.UP || code === key.DOWN;

        if (isUpDown) {
          // Continuous key up and down is tracking inorder to trigger spin-end event at the last keyup.
          this._prevKUTime = this._currKUTime;
          this._currKUTime = +new Date();

          if (this._prevKUTime !== undefined && this._currKUTime - this._prevKUTime < 600) {
            window.clearInterval(this._kuTimer);
            this._kuTimer = window.setInterval(function () {
              _this92._currKUTime = +new Date();

              if (_this92._currKUTime - _this92._prevKUTime > 600) {
                (!opts.isWriter || _this92._canTriggerSEnd(opts)) && _this92._triggerSpinEndEvent(event);
                window.clearInterval(_this92._kuTimer); // Revisit - These undefined are done too often. Store in a function and set undefined

                _this92._prevKDTime = _this92._prevKUTime = _this92._currKUTime = _this92._currKDTime = _this92._kuTimer = undefined;
              }
            }, 200);
            return;
          }
        } else {
          this._prevKUTime = this._currKUTime = undefined;
        }

        if (isUpDown && (!opts.isWriter || this._canTriggerSEnd(opts))) {
          this._triggerSpinEndEvent(event);
        }

        this._prevKDTime = this._currKDTime = undefined;
        return this._handleKeyUp(event); // selection start and selection end setting removed.
      }
    }, {
      key: "_inputEleMouseWheelHandler",
      value: function _inputEleMouseWheelHandler(event) {
        var _this93 = this;

        var opts = this._opts;

        if (opts.disabled || opts.readonly || !this.container.hasClass('has-focus')) {
          return false;
        }

        if (!this._mwTimer) {
          this._triggerEvent('spinstart', event); // No I18N

        }

        var orgEve = event.originalEvent,
            detail = orgEve.detail;

        this._spinValue(detail === 0 ? orgEve.wheelDelta < 0 : detail > 0, event.shiftKey); // event.ctrlKey || event.metaKey


        clearTimeout(this._mwTimer);
        this._mwTimer = setTimeout(function () {
          _this93._triggerSpinEndEvent(event);

          clearTimeout(_this93._mwTimer);
          _this93._mwTimer = undefined;
        }, 600);
        return false;
      }
    }, {
      key: "_extractNumericValue",
      value: function _extractNumericValue(value, doNotReplaceSeparators) {
        value = this._translateAToE(value + ''); // No I18N

        var opts = this._opts;

        if (this._hasAffix) {
          value = this._removeAffixes(value);
        }

        if (opts.showThousandSeparator || opts.decimalPlaces) {
          value = this._removeSeparators(value, doNotReplaceSeparators);
        }

        return value.trim();
      }
    }, {
      key: "_handleKeyDown",
      value: function _handleKeyDown(event) {
        var opts = this._opts;

        if (this._checkPatternKeys(event)) {
          var inputEle = this._input,
              fieldVal = inputEle.val(),
              val = this._extractNumericValue(fieldVal),
              selEnd = inputEle[0].selectionEnd;

          val = val.substr(0, selEnd) + String.fromCharCode(event.keyCode) + val.substr(selEnd, fieldVal.length);
          val = parseFloat(val);

          if (!isNaN(val) && val > opts.max && inputEle[0].selectionStart === selEnd) {
            event.preventDefault(); // prevent entering a value in the field if entered value will be greater than maximum value.
          } else if (val >= opts.min) {
            // minimum value check is added since value is updated with wrong value if fieldValue is lesser than min value.
            opts.value = val;
          }

          this._data.spinButtons && this._toggleSpinBtnStates(); // No I18N
        } else {
          return this._handleShortcutKeys(event);
        }
      }
    }, {
      key: "_handleKeyUp",
      value: function _handleKeyUp(event) {
        var retValue = true,
            key = ZC.keyCode;

        if (this._checkPatternKeys(event)) {
          // input event should be triggered on keyup only.
          this._triggerEvent('input', event); // No I18N

        } else {
          retValue = this._handleShortcutKeys(event); // shortcut key handling is moved to keyup event since pasted value cannot be retrieved in keydown event.

          if (!event.ctrlKey && !event.metaKey) {
            this._shortcutKey = false;
          }
        }

        var inputEle = this._input,
            val = inputEle.val();

        if (this._data.clearButton) {
          this._toggleBtnDisplay(!val.length, true);
        }

        if (event.keyCode === key.SPACE && val.trim() === '') {
          // No I18N
          inputEle.val(''); // No I18N
        }

        return retValue; // value is returned to avoid stopEvent from being called from handleshortcutkeys method.
      }
    }, {
      key: "_triggerSpinEndEvent",
      value: function _triggerSpinEndEvent(event) {
        this._opts.isWriter && this._handleSpinEnd();

        this._triggerEvent('spinend', event); // No I18N

      }
    }, {
      key: "_triggerEvent",
      value: function _triggerEvent(eventName) {
        var originalEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var value = this._input.val(),
            ui = {
          value: value === '' ? this._opts.min || null : parseFloat(this._extractNumericValue(value)),
          // No I18N
          translatedValue: this._translateEToA(value),
          // No I18N
          event: originalEvent // No I18N

        };

        ui[this.name.replace('z', '')] = this.container; // No I18N

        return this._dispatchEvent(eventName, originalEvent, ui);
      }
    }, {
      key: "_clearTimers",
      value: function _clearTimers() {
        clearTimeout(this._sTimer);
        this._data.spinButtons && this._clearMTimer(undefined, true);
        clearInterval(this._kuTimer);
        this._prevMUTime = this._currMUTime = this._prevKUTime = this._prevKDTime = this._currKUTime = this._currKDTime = this._kuTimer = undefined;
      }
    }, {
      key: "_checkPatternKeys",
      value: function _checkPatternKeys(event) {
        var pattern,
            opts = this._opts,
            key = ZC.keyCode,
            code = event.keyCode;
        pattern = !event.shiftKey && (code >= 48 && code <= 57 || code === 8 || code >= 96 && code <= 105 || code === 69); // Numbers and Backspace key
        // key code: 69 -> letter e [To provide numbers in exponential notation]

        if (code === key.SPACE && opts.thousandSeparator !== ' ') {
          // No I18N
          var inputEle = this._input;

          if (inputEle[0].selectionStart === 0 && inputEle[0].selectionEnd === inputEle.val().length) {
            pattern = true;
          } else {
            // Return value is needed for other purpose
            event.preventDefault();
            event.stopPropagation();
          }
        }

        var min = opts.min;

        if (opts.allowNegativeValue && !min || this._isNotNull(min) && min.toString().indexOf('-') !== -1) {
          // No I18N
          pattern = pattern || code === 189 || code === 173; // Hyphen Key
        }

        if (!pattern && (opts.decimalPlaces || opts.showThousandSeparator && !opts.suppressThousandSeparatorKey)) {
          pattern = this._isSeparator(code);
        }

        return pattern;
      }
    }, {
      key: "_handleShortcutKeys",
      value: function _handleShortcutKeys(event) {
        var key = ZC.keyCode,
            code = event.keyCode,
            dontStop = true;

        if (this._shortcutKey) {
          if (code === 89) {
            // Key "Y"
            if (this._mac) {
              dontStop = false;
            }
          } else if ([65, 67, 86, 88, 90, 89, 82, key.LEFT, key.RIGHT].indexOf(code) < 0) {
            // Cmd+Shift+Right and Cmd+Shift+Left
            // Key "A" (65), Key "C" (67), Key "X" (88), Key "Z" (90), Key "R" (82)
            dontStop = false;
          }

          if (code === 86 || code === 91) {
            // Key "V"
            this._handlePasteOption();
          }
        } else if ([key.DOWN, key.UP, key.DELETE, key.BACKSPACE, key.LEFT, key.RIGHT, key.TAB, key.ENTER].indexOf(code) < 0) {
          dontStop = false;
        }

        return dontStop;
      }
    }, {
      key: "_handlePasteOption",
      value: function _handlePasteOption() {
        var value = this._extractNumericValue(this._input.val());

        this._opts.value = this._checkMinAndMax(value);
      }
    }, {
      key: "_spinValue",
      value: function _spinValue(isUp, longStep) {
        var increment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._opts[longStep ? 'longStep' : 'step'];

        // No I18N
        var opts = this._opts,
            value = this._input.val(),
            fieldValue = value,
            min = opts.min,
            max = opts.max,
            isNotNull = this._isNotNull.bind(this);

        opts.previousValue = opts.value;
        value = this._extractNumericValue(value); // replace the thousand separator and decimal separator

        if (isNaN(value) || value.trim() === '') {
          // No I18N
          value = isUp ? isNotNull(min) ? min - opts.step : 0 : isNotNull(max) ? max + opts.step : 0;
        }

        value = parseFloat(value);
        var step = parseFloat(increment); // No I18N

        if (opts.stepBehavior === 'w3' && this._checkModuloValue(value, step, min)) {
          // No I18N
          // Implementation similar to HTML5 Behavior
          value = this._getCorrectedVal(value, step, min, isUp ? 1 : 0);
        } else {
          var cVal = value + (isUp ? step : -step); // since 0.1+0.2 produces 0.30000000004 as result & 0.4-0.1 produces 0.30000000004 as result, truncating here.

          value = this._hasFloatingNumber ? parseFloat(cVal).toFixed(12) : cVal;
        }

        var end = isUp ? max : min;

        if (isNotNull(end) && !isNaN(end) && (value > max || value < min)) {
          // out of boundary
          if (opts.wrapAround) {
            value = (isUp ? min : max) || opts.nullValue;
          } else {
            value = parseFloat(parseFloat(end).toFixed(opts.decimalPlaces));
          }
        }

        this._setValue(value);

        this._data.spinButtons && this._toggleSpinBtnStates(); // No I18N

        this._triggerSpinEvent();

        if (!fieldValue && this._data.clearButton && this._clearButton.is(':hidden')) {
          // No I18N
          this._toggleBtnDisplay(false, true);
        }
      }
    }, {
      key: "_triggerSpinEvent",
      value: function _triggerSpinEvent() {
        var opts = this._opts,
            lastVal = opts._lastValue;

        if ((lastVal === undefined || lastVal !== opts.value) && (!opts.isWriter || this._canTriggerSpin())) {
          this._triggerEvent('spin'); // No I18N


          opts._lastValue = opts.value; // last value should be updated after triggering spin events.
        }
      }
    }, {
      key: "_setValue",
      value: function _setValue(val) {
        var opts = this._opts;
        opts._lastValue = opts.value || val; // opts.value will be null if field was made empty previously.

        var formattedVal = opts.value = this._checkMinAndMax(val);

        if (!isNaN(formattedVal)) {
          if (opts.decimalPlaces) {
            // Providing option "decimalsForWholeNumber" since decimal places for whole numbers can be omitted instead of showing .00
            var valueStr = formattedVal.toString();

            if (opts.decimalsForWholeNumber || valueStr.indexOf('.') !== -1) {
              // No I18N
              valueStr = formattedVal.toFixed(opts.decimalPlaces);
            }

            formattedVal = valueStr.replace('.', opts.decimalSeparator);
          } else if (!this._hasFloatingNumber) {
            // Giving values with decimal precision via setValue() method should be corrected here.
            formattedVal = Math.round(formattedVal);
          }

          if (opts.showThousandSeparator) {
            formattedVal = this._insertSeparators(formattedVal);
          }

          if ((opts.prefix || opts.suffix) && !this.container.hasClass('has-focus')) {
            formattedVal = this._attachAffixes(formattedVal);
          }

          formattedVal = this._translateEToA(formattedVal);

          this._input.val(formattedVal).attr('aria-valuenow', parseFloat(this._extractNumericValue(formattedVal))); // No I18N


          !this.isCE && this.element.val(formattedVal);
          return formattedVal;
        }
      }
    }, {
      key: "getValue",
      value: function getValue() {
        var opts = this._opts,
            val = opts.value;
        return isNaN(parseFloat(val)) ? opts.min || 0 : val;
      }
    }, {
      key: "setValue",
      value: function setValue() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._opts.value;

        if (!this._muTimer && !this._kuTimer) {
          // if value change occurs and event is not triggered yet, do not set the value... [ Fix for Getter and Setter Issue ]
          var opts = this._opts;

          this._setValue(this._extractNumericValue(value));

          opts.previousValue = this._changeDisVal = opts.value;
          this._data.spinButtons && this._toggleSpinBtnStates();
        }
      }
    }, {
      key: "increment",
      value: function increment(incrementValue) {
        // Revisit - Change arguments order.
        this._spinValue(true, undefined, incrementValue);
      }
    }, {
      key: "decrement",
      value: function decrement(decrementValue) {
        this._spinValue(false, undefined, decrementValue);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        _get(_getPrototypeOf(ZNumberField.prototype), "_destroy", this).call(this);

        ZC.$window.off('.' + this.name); // No I18N
      }
    }, {
      key: "_attachAffixes",
      value: function _attachAffixes(val) {
        var opts = this._opts;
        return ((opts.prefix || '') + ' ' + val + ' ' + (opts.suffix || '')).trim(); // No I18N
      }
    }, {
      key: "_removeAffixes",
      value: function _removeAffixes(val) {
        var opts = this._opts;
        val = this._remove(val, opts.prefix);
        val = this._remove(val, opts.suffix);
        return val;
      }
    }, {
      key: "_remove",
      value: function _remove(val, portion) {
        var regex = this.escapeSequence;

        if (portion && portion.trim() !== '') {
          // No I18N
          var esc = portion.replace(regex, '');
          val = val.replace(regex, '').replace(new RegExp(esc, 'g'), ''); // No I18N
        }

        return val;
      }
    }, {
      key: "_handleInputFocus",
      value: function _handleInputFocus() {
        var cName = this.name,
            key = ZC.keyCode; // determining whether focus is initiated by TAB key.
        // Use bindEleEvents

        $(window).on("keyup.".concat(cName), function (nestedEvent) {
          if (nestedEvent.keyCode === key.TAB) {
            $(nestedEvent.target).closest('.zinputfield__textbox').select(); // No I18N

            $(window).off("keyup.".concat(cName));
          }
        });

        this._input.val(this._translateEToA(this._extractNumericValue(this._input.val(), true))); // No I18N

      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optName, value) {
        var valueUpdationProp = ["min", "max", "value", "showThousandSeparator", "allowNegativeValue", "thousandSeparator", "decimalSeparator", "decimalPlaces", "prefix", "suffix", "locale"],
            // No I18N
        requiresValidationProp = ["min", "max", "step", "decimalPlaces"],
            opts = this._opts,
            // No I18N
        data = this._data,
            toggleBtnFunc = this._toggleSpinBtnStates && this._toggleSpinBtnStates.bind(this);

        opts[optName] = value;

        if (optName === "spinValues" && !data.spinButtons) {
          // No I18N
          this['_' + (value ? '' : 'un') + 'bindSpinEvents'](); // No I18N

          value ? this._input.attr("role", "spinbutton") : this._input.removeAttr("role"); // No I18N
        } else if (optName === "spinButtonsType") {
          // No I18N
          opts.templateName = value === 'together' ? 'zinputfield' : 'znumberfield'; // No I18N

          this._domChanged = true;

          this._handleSpinBtns(optName, value, opts);
        } else if (optName === "locale" || optName === "thousandSeparator" || optName === "showThousandSeparator" || optName === "decimalPlaces") {
          // No I18N
          this._getSeparatorFromLocale("decimalSeparator", opts.locale); // No I18N


          this._getSeparatorFromLocale("thousandSeparator", opts.locale); // No I18N

        } else if (optName === "allowNegativeValue") {
          // No I18N
          var min = opts.min;

          if (value) {
            min = min >= 0 ? undefined : min;
          } else {
            min = !this._isNotNull(min) || min < 0 ? 0 : min;
          }

          opts.min = min;
        } else if (optName === "wrapAround") {
          // No I18N
          if (value && data.spinButtons) {
            this._buttons.removeClass("is-disabled");
          } else if (data.spinButtons) {
            // No I18N
            toggleBtnFunc();
          }
        } else {
          _get(_getPrototypeOf(ZNumberField.prototype), "_setAttribute", this).call(this, optName, value);
        }

        if (requiresValidationProp.indexOf(optName) !== -1) {
          opts[optName] = parseFloat(value);

          this._validateOpts(opts);
        }

        if (valueUpdationProp.indexOf(optName) !== -1) {
          this._setValue(opts.value);

          data.spinButtons && toggleBtnFunc(); // No I18N
        }

        if (optName === "prefix" || optName === "suffix") {
          // No I18N
          this._hasAffix = opts.prefix && opts.prefix.trim() !== '' || opts.suffix && opts.suffix.trim() !== ''; // No I18N
        }

        if (optName === "min" || optName === "max") {
          // No I18N
          this._input.attr({
            "aria-valuemax": opts.max,
            "aria-valuemin": opts.min
          }); // No I18N

        }
      }
    }, {
      key: "_bindWriterEvents",
      value: function _bindWriterEvents() {
        this._addEvents({
          wInputEleFocus: 'focus' // No I18N

        }, this._input);
      }
    }, {
      key: "_wInputEleFocusHandler",
      value: function _wInputEleFocusHandler() {
        this._focusedValue = this._opts.value;
      }
    }, {
      key: "_handleInputBlur",
      value: function _handleInputBlur() {
        var opts = this._opts;

        if (parseFloat(this._changeDisVal) !== parseFloat(opts.value) && opts.triggerBlurOnSpinButtonClick) {
          this._triggerBlurEvent(event);

          return true;
        }
      }
    }, {
      key: "_handleEnterKey",
      value: function _handleEnterKey(opts) {
        opts.triggerBlurOnSpinButtonClick && this._triggerBlurEvent(event);
      }
    }, {
      key: "_canTriggerSEnd",
      value: function _canTriggerSEnd(opts) {
        return !opts.bindedSpinAndChange || parseFloat(this._changeDisVal) !== parseFloat(opts.value);
      }
    }, {
      key: "_handleSpinEnd",
      value: function _handleSpinEnd() {
        if (this._opts.bindedSpinAndChange) {
          this._changeDisVal = this._opts.value;
        }
      }
    }, {
      key: "_triggerBlurEvent",
      value: function _triggerBlurEvent(event) {
        var _this94 = this;

        var opts = this._opts,
            valueOnFocus = this._focusedValue;

        if (!event) {
          // triggered from spin button up handler.
          this._blurEventTimer = setTimeout(function () {
            _this94._triggerEvent('blur', event); // No I18N

          }, opts.blurEventDelay);
        } else if (!valueOnFocus || parseFloat(valueOnFocus) !== parseFloat(opts.value)) {
          this._triggerEvent('blur', event); // No I18N


          this._focusedValue = opts.value;
        }
      }
    }, {
      key: "_handleSBtnUp",
      value: function _handleSBtnUp() {
        this._opts.triggerBlurOnSpinButtonClick && this._triggerBlurEvent();
      }
    }, {
      key: "_canTriggerSpin",
      value: function _canTriggerSpin() {
        var _this95 = this;

        clearTimeout(this._sTimer);
        var delay = this._opts.spinEventTriggerDelay;

        if (delay) {
          if (!this._sEndTimer) {
            // sEnd -> spin end & sStart -> spin start
            this._sStartTimer = new Date().getTime();
          }

          this._sEndTimer = new Date().getTime() - this._sStartTimer;
          delay = parseInt(delay) - this._sEndTimer;

          if (delay) {
            this._sTimer = setTimeout(function () {
              _this95._triggerEvent('spin'); // No I18N


              _this95._sEndTimer = undefined;
            }, delay);
            return false;
          }
        }

        return true;
      }
      /*
          _prevMUTime - Previous Mouse Up Time
          _currMUTime - Current Mouse Up Time
      */

    }, {
      key: "_getSpinIconInfo",
      value: function _getSpinIconInfo(button, isVertical) {
        // input field overrided method since plus/minus icons differ.
        var isUp = button === 'increment',
            // No I18N
        svgId = 'zc__svg--' + (isVertical ? button : isUp ? 'plus' : 'minus'),
            // No I18N
        clsName = 'zinputfield__spinbutton zh-' + (isUp ? 'up' : 'down'); // No I18N

        return [svgId, clsName];
      }
    }, {
      key: "_validateSBtnOpts",
      value: function _validateSBtnOpts(opts) {
        if (opts.spinButtonsType === 'split') {
          // No I18N
          var svalue = opts.spinButtons;
          opts.spinButtons = svalue === 'focus' ? 'always' : svalue; // No I18N

          opts.templateName = 'znumberfield'; // No I18N
        }
      }
    }, {
      key: "_toggleSpinBtnStates",
      value: function _toggleSpinBtnStates() {
        var opts = this._opts;

        if (!opts.wrapAround) {
          var val = opts.value,
              maxReached = val >= opts.max,
              minReached = isNaN(val) || val <= opts.min; // let data = this._data; // to be removed
          // data.incrementProps.disabled = !!maxReached;
          // data.decrementProps.disabled = !!minReached;
          // calling render here removes the events binded to the spin buttons. Also, this method will be executed for every value change in the field. To be revisited if needed.
          // this._render();

          var dCls = 'is-disabled',
              // No I18N
          cont = this.container,
              btns = this._buttons;
          btns.removeClass(dCls);
          maxReached && cont.find('.zh-up').addClass(dCls); // No I18N

          minReached && cont.find('.zh-down').addClass(dCls); // No I18N
        }
      }
    }, {
      key: "_bindSpinButtonEvents",
      value: function _bindSpinButtonEvents() {
        this._addEvents({
          spinBtnMouseDown: 'mousedown',
          // No I18N
          spinBtnMouseUp: 'mouseup',
          // No I18N
          spinBtnKeyDown: 'keydown',
          // No I18N
          spinBtnBlur: 'blur' // No I18N

        }, this._buttons);
      }
    }, {
      key: "_spinBtnKeyDownHandler",
      value: function _spinBtnKeyDownHandler(event) {
        // Firefox will not support this behavior

        /* Clicking the up and down arrows whenever spin buttons has focus on it should set focus to the field. */
        var key = ZC.keyCode,
            code = event.keyCode,
            isUp = code === key.UP;

        if (isUp || code === key.DOWN) {
          // key denotes ZC.keyCode
          this._input.focus();

          this._spinValue(isUp, event.shiftKey, undefined, true);
        }
      }
    }, {
      key: "_spinBtnMouseDownHandler",
      value: function _spinBtnMouseDownHandler(event) {
        var _this96 = this;

        var spinBtn = $(event.target).closest('.zinputfield__spinbutton'); // No I18N

        if (this._handleMousedownOnControls(event, spinBtn)) {
          ZC.currentNumberField = this.container;
          var isUp = spinBtn.hasClass('zh-up'),
              // No I18N
          shft = event.shiftKey;
          (!this._prevMUTime || !this._currMUTime || this._currMUTime - this._prevMUTime > 600) && this._triggerEvent('spinstart', event); // No I18N

          this._spinValue(isUp, shft, undefined, false); // event.ctrlKey || event.metaKey


          if (this._blurEventTimer) {
            clearTimeout(this._blurEventTimer);
          }

          this._mousedownTimer = setInterval(function () {
            if (spinBtn.hasClass('is-disabled')) {
              // No I18N
              // If minimum or maximum value is reached while pressing the mouse, trigger spin end and exit...
              _this96._triggerSpinEndEvent(event);

              _this96._clearMTimer();
            }

            if (_this96._mouseDown) {
              _this96._spinValue(isUp, shft, undefined, true); // event.ctrlKey || event.metaKey

            } else {
              _this96._clearMTimer();
            }
          }, 200);
        }
      }
    }, {
      key: "_handleMousedownOnControls",
      value: function _handleMousedownOnControls(event, btn) {
        var opts = this._opts;

        if (opts.disabled || event.which > 1 || opts.readonly || btn.hasClass('is-disabled')) {
          return false;
        }

        this._mouseDown = true;
        this._hasFocus = !!this._input.is(':focus'); // No I18N
        // To decide whether to focus the field or not while pressing the spin buttons.

        var fCls = 'has-focus',
            // No I18N
        currField = ZC.currentNumberField,
            cont = this.container;

        if (currField && currField[0] !== cont[0]) {
          currField.removeClass(fCls);
        }

        cont.addClass(fCls);
        return true;
      }
    }, {
      key: "_spinBtnMouseUpHandler",
      value: function _spinBtnMouseUpHandler(event) {
        this._spinbuttonsMouseUpHandler(event);

        ZC.Browser.isFirefox && $(event.target).closest('.zinputfield__spinbutton').focus(); // To retain the focus on the spin button in firefox browser inorder to support focusing the field by pressing up/down arrow keys.
      }
    }, {
      key: "_spinBtnBlurHandler",
      value: function _spinBtnBlurHandler(event) {
        var rTarget = event.relatedTarget,
            closestField = rTarget && $(rTarget).closest('.zinputfield'),
            // No I18N
        sameFieldFocus = false;

        if (closestField && closestField.length) {
          // Input field check is added since input field will be focused on spin button click if it already has focus set on them before clicking spin button. While focusing the input field, blur event for spin button will be triggered.
          sameFieldFocus = closestField[0] === this.container[0];
        }

        if (!rTarget || !sameFieldFocus) {
          this._spinbuttonsMouseUpHandler(event, true);

          var opts = this._opts;

          if (opts.triggerBlurOnSpinButtonClick) {
            // value is updated here since prefix and suffix values are not updated whenever triggerBlurOnSpinButtonClick option is set.
            this._setValue(opts.value);
          } else {
            this._input.trigger('blur'); // No I18N

          }
        }
      }
    }, {
      key: "_spinbuttonsMouseUpHandler",
      value: function _spinbuttonsMouseUpHandler(event, viaBlur) {
        var _this97 = this;

        this._clearMTimer();

        var opts = this._opts;
        clearTimeout(this._mwTimer);
        var isButtonDisabled = $(event.target).closest('.zinputfield__spinbutton').hasClass('is-disabled');

        if (opts.disabled || opts.readonly || viaBlur && !this._mouseDown && isButtonDisabled) {
          return false;
        }

        this._prevMUTime = this._currMUTime || undefined;
        this._currMUTime = new Date().getTime();

        if (this._prevMUTime && this._currMUTime - this._prevMUTime < 600) {
          this._clearMTimer(true);

          this._muTimer = setInterval(function () {
            _this97._currMUTime = new Date().getTime();

            if (_this97._currMUTime - _this97._prevMUTime > 600) {
              _this97._canTriggerSpinEnd(opts) && _this97._triggerSpinEndEvent(event);

              _this97._clearMTimer(true);

              _this97._prevMUTime = _this97._currMUTime = _this97._mouseDown = undefined;
            }
          }, 200);
        }

        if (this._canTriggerSpinEnd(opts)) {
          this._mouseDown && this._triggerSpinEndEvent(event);
        }

        var _input = this._input;
        opts.isWriter && this._handleSBtnUp();

        if (viaBlur && !_input.is(':focus')) {
          // No I18N
          this.container.removeClass('has-focus');
          this._data.clearButton && opts.clearButton === 'focus' && this._toggleBtnDisplay(true, true); // No I18N
        } else if (this._hasFocus) {
          // setting focus places the cursor inside the element.
          _input.attr('tabindex', 0).focus(); // No I18N

        }

        this._mouseDown = false;
      }
    }, {
      key: "_canTriggerSpinEnd",
      value: function _canTriggerSpinEnd(opts) {
        var lastValue = this._changeDisVal;
        return !opts.bindedSpinAndChange || lastValue === undefined || parseFloat(lastValue) !== parseFloat(opts.value);
      }
    }, {
      key: "_clearMTimer",
      value: function _clearMTimer(up, both) {
        if (both) {
          clearInterval(this._mousedownTimer);
          this._mousedownTimer = undefined;
          up = true;
        }

        var name = '_mouse' + (up ? 'up' : 'down') + 'Timer'; // No I18N

        clearInterval(this[name]);
        this[name] = undefined;
      }
    }, {
      key: "_getFactorValue",
      value: function _getFactorValue() {
        // setting the maximum value based on the minimum,maximum and step values - compatible for HTML5 input type=number
        var opts = this._opts,
            min = opts.min,
            max = opts.max,
            factor = Math.pow(10, opts.decimalPlaces) || 1;

        if (this._isNotNull(min)) {
          var reminder = (max - min) * factor % (opts.step * factor) / factor;
          opts.max = Math.round((max - reminder) * factor) / factor;
        }

        return factor;
      }
    }, {
      key: "_checkModuloValue",
      value: function _checkModuloValue(value, step, min) {
        var factor = this._factor,
            factoredStep = step * factor,
            minModStep = min * factor % factoredStep,
            valueModStep = value * factor % factoredStep,
            staticMod = min < 0 ? (minModStep + factoredStep) % factoredStep : Math.round(minModStep),
            modValue = value < 0 ? Math.round((valueModStep + factoredStep) % factoredStep) : Math.round(valueModStep);
        /*  If value is less than zero, modulo calculation should be
                since modulo operation produces incorrect result for floating numbers, factorization is needed based on the precision given.
                ((this % n) + n) % n
                modValue = ((value%step) + step) % step;
        */

        return Math.abs(modValue) !== staticMod;
      }
    }, {
      key: "_getCorrectedVal",
      value: function _getCorrectedVal(value, step, min, inc) {
        // (quotient * step) + min
        return (parseInt((value - min) / step) + inc) * step + min;
      }
    }, {
      key: "_setSeparatorValues",
      value: function _setSeparatorValues() {
        var opts = this._opts;

        if (!opts.locale) {
          opts.locale = ZC.locale || window.navigator.language;
        }

        var getSep = this._getSeparatorFromLocale.bind(this);

        opts.showThousandSeparator && getSep('thousandSeparator', opts.locale); // No I18N

        opts.decimalPlaces && getSep('decimalSeparator', opts.locale); // No I18N
      }
    }, {
      key: "_getSeparatorFromLocale",
      value: function _getSeparatorFromLocale(separatorName, locale) {
        var localeInfo = ZC.localeInfo;

        if (localeInfo) {
          var opts = this._opts,
              numberFormat = localeInfo[locale] && localeInfo[locale].numberFormat || {},
              value = numberFormat[separatorName] || opts[separatorName]; // If given locale is not present in the data, use default thousand separator and decimal separators.

          opts[separatorName] = value;
        }
      }
    }, {
      key: "_insertSeparators",
      value: function _insertSeparators(value) {
        value += ''; // No I18N

        var opts = this._opts,
            decimalSep = opts.decimalSeparator,
            splitted = value.split(decimalSep),
            leftPart = splitted[0],
            rightPart = splitted[1] ? decimalSep + splitted[1] : '',
            // No I18N
        regex = /(\d+)(\d{3})/,
            portions = [];

        while (regex.test(leftPart)) {
          portions = leftPart.split(regex);
          leftPart = leftPart.replace(regex, portions[1] + opts.thousandSeparator + portions[2]);
        }

        return leftPart + rightPart;
      }
    }, {
      key: "_removeSeparators",
      value: function _removeSeparators(value, dontReplace) {
        var opts = this._opts,
            decimalSep = opts.decimalSeparator,
            thouSep = opts.thousandSeparator;

        if (!dontReplace && thouSep && opts.showThousandSeparator) {
          value = value.replace(new RegExp("\\".concat(thouSep), 'g'), '');
        } else if (!opts.showThousandSeparator && decimalSep !== ',') {
          // No I18N
          value = value.replace(/,/g, '');
        }

        if (!dontReplace && opts.decimalPlaces && decimalSep !== '.') {
          // No I18N
          value = value.replace(new RegExp("\\".concat(decimalSep), 'g'), '.');
        }

        return value;
      }
    }, {
      key: "_isSeparator",
      value: function _isSeparator(code) {
        // allow thousand separator. Permitted thousandSeparators are ".", ",", " " and "'".
        // allow decimal digits. Permitted decimalSeparators are "," and "."
        // key codes: 188 - Comma, 110 - Numpad dot and 190 - Dot, 59 - Firefox colon
        var opts = this._opts,
            allowedSep = this._SEPARATORS;
        return opts.decimalPlaces && allowedSep[opts.decimalSeparator].indexOf(code) >= 0 || !opts.suppressThousandSeparatorKey && allowedSep[opts.thousandSeparator].indexOf(code) >= 0;
      }
    }, {
      key: "name",
      get: function get() {
        return "znumberfield";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          step: 1,
          placeholder: '',
          // No I18N
          required: false,
          spinValues: true,
          wrapAround: false,
          thousandSeparator: ',',
          allowNegativeValue: false,
          showThousandSeparator: false,
          decimalPlaces: null,
          prefix: null,
          // No I18N
          suffix: null,
          // No I18N
          longStep: null,
          nullValue: 0,
          decimalSeparator: '.',
          // No I18N
          stepBehavior: 'default',
          // No I18N
          suppressThousandSeparatorKey: false,
          decimalsForWholeNumber: true,
          innerHTML: null,
          // below are added for writer spec needs
          isWriter: false,
          triggerBlurOnSpinButtonClick: false,
          spinEventTriggerDelay: 0,
          bindedSpinAndChange: false,
          blurEventDelay: 500
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['focus', 'blur', 'change', 'input', 'spin', 'spinstart', 'spinend', 'optionschanged']; // No I18N
      }
    }, {
      key: "escapeSequence",
      get: function get() {
        return /[[\]{}()*+?\\^$|#]/g;
      }
    }, {
      key: "_mac",
      get: function get() {
        return ZC.OS.isMac();
      }
    }, {
      key: "_SEPARATORS",
      get: function get() {
        return {
          '.': [110, 190],
          // No I18N
          ',': [188],
          // No I18N
          ' ': [32],
          // No I18N
          "'": [222] // No I18N

        };
      }
    }]);

    return ZNumberField;
  }(ZC.ZInputField);

  ZC.registerComponent('ZNumberField', ZC.ZInputField, ZNumberField);

  (function (ZC) {
    var template = ZC.znumberfield.Templates,
        button = ZC.createButton;

    template.container = function (data) {
      return ZT.html(_templateObject142(), data.className, data.title, data.width, data.id, data.children && template.children(data));
    };

    template.children = function (data) {
      return ZT.html(_templateObject143(), data.spinButtons && button(data.decrementProps), data.tabindex, data.min, data.max, data.readonly, data.readonly, data.disabled, data.disabled, data.maxLength, data.clearButton && button(data.clearButtonProps), data.spinButtons && button(data.incrementProps));
    };
  })(ZComponents);

  var ZAdvancedColorPicker =
  /*#__PURE__*/
  function (_ZC$ZColorPickerBase) {
    _inherits(ZAdvancedColorPicker, _ZC$ZColorPickerBase);

    function ZAdvancedColorPicker() {
      _classCallCheck(this, ZAdvancedColorPicker);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZAdvancedColorPicker).apply(this, arguments));
    }

    _createClass(ZAdvancedColorPicker, [{
      key: "_setDimension",
      value: function _setDimension() {
        if (!this._widthSet) {
          _get(_getPrototypeOf(ZAdvancedColorPicker.prototype), "_setDimension", this).apply(this, arguments);
        }
      }
    }, {
      key: "_updateDim",
      value: function _updateDim() {
        if (!this.element[0].style.width) {
          var width = this._opts.width || this._swatch[0].offsetWidth;

          if (width) {
            this.element[0].style.width = isNaN(width) ? width : width + 'px'; // No I18N

            this._widthSet = true;
          }
        }
      }
    }, {
      key: "_storeRef",
      value: function _storeRef(data, options) {
        var isAttrChanged = this._isAttrChanged.bind(this);

        _get(_getPrototypeOf(ZAdvancedColorPicker.prototype), "_storeRef", this).apply(this, arguments);

        if (!data.rendered) {
          this._swatch = this._getById(data.swatchId); // No I18N

          this._swatchContext = this._getCanvasContext(this._swatch[0]);
          this._swatchThumb = $(this._swatch[0].querySelector('.zcolorpicker__mapmarker')); // No I18N

          this._bar = this._getById(data.swatchBar.id);
          this._barContext = this._getCanvasContext(this._bar[0]);
          this._barThumb = this._getThumb(this._bar[0]);
        }

        if (isAttrChanged('opacity')) {
          // No I18N
          this._opacityBar = this._opacityContext = this._opacityThumb = false;

          if (options.opacity) {
            this._storeOpacityRef(data);
          }
        }

        if (isAttrChanged('colorPreview')) {
          // No I18N
          if (data.colorPreview && options.previousColorInPreview) {
            this._bindPreview(data.colorPreview);
          }
        }

        if (isAttrChanged('commandBar')) {
          // No I18N
          if (data.commandBar) {
            this._storeCmdBarRef(data.commandBar);
          }
        }

        if (isAttrChanged('palette') || this._paletteChanged) {
          // No I18N
          this._paletteChanged = false;

          if (options.palettes && options.customColorLibraries) {
            this._storeCustomLibRef(data, options);
          }
        }

        if (options.colorFields) {
          this._storeClrFieldRef(data.colorFields);
        }
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender(element, data) {
        _get(_getPrototypeOf(ZAdvancedColorPicker.prototype), "_postEachRender", this).apply(this, arguments);

        if (data.markerIcon) {
          this._swatch.find('.zcolorpicker__mapmarker') // No I18N
          .css({
            left: data.x + '%',
            // No I18N
            top: data.y + '%' // No I18N

          });
        }

        this._paintPicker(this._axisProps.x, this._axisProps.y, this._axisProps.z);

        data.opacity && this._paintOpacity();
        data.colorFields && this._setClrFieldValues(data.colorFields);
        this._changedAttrs = [];
      }
    }, {
      key: "_setRenderData",
      value: function _setRenderData(data, options, element) {
        _get(_getPrototypeOf(ZAdvancedColorPicker.prototype), "_setRenderData", this).apply(this, arguments);

        var isAttrChanged = this._isAttrChanged.bind(this);

        if (!data.rendered) {
          data.swatchId = this._getID('swatch'); // No I18N

          data.swatchBar = {
            id: this._getID('swatchbar'),
            // No I18N
            className: 'zcolorpicker__slider',
            // No I18N
            rtl: data.rtl
          };
          this._vertical = options.barOrientation === 'vertical'; // No I18N
        }

        if (isAttrChanged('marker')) {
          // No I18N
          data.markerIcon = false;
          var mapMarkerIconClass = options.mapMarkerIconClass || options.mapMarkerIconClassName;
          var mapMarkerSVGIconId = options.mapMarkerSVGIconId;

          if (mapMarkerIconClass || mapMarkerSVGIconId) {
            ZC._getIconInfo(mapMarkerIconClass, mapMarkerSVGIconId, '', 'zcolorpicker__mapmarker', data.markerIcon = {}); // No I18N

          }
        }

        if (isAttrChanged('opacity')) {
          // No I18N
          if (options.opacity || data.opacity) {
            this._setOpacityData(data, options);
          }
        }

        if (isAttrChanged('commandBar')) {
          // No I18N
          if (!options.immediateCommit || data.commandBar) {
            this._setCmdBarData(data, options);
          }
        }

        if (isAttrChanged('swatch')) {
          // No I18N
          data.swatchBar.thumbIcon = this._getThumbData(options.slider);

          this._configurePickerMethods(options);
        }

        if (isAttrChanged('palette')) {
          // No I18N
          if (options.palettes || data.palettes || data.customColorLibraries) {
            this._setPaletteData(data, options);
          }
        }

        if (isAttrChanged('colorField')) {
          // No I18N
          if (options.colorFields || data.colorFields) {
            this._setClrFieldData(data, options);
          }
        }

        if (options.colorPreview || data.colorPreview) {
          this._setPreviewData(data, options);
        }

        if (options.palettes) {
          this._updateSelection(data, options);
        }

        if (data.colorFields) {
          this._saveFieldValues(data.colorFields, options);
        }

        this._updatePickerPositionInData(data, options);
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        _get(_getPrototypeOf(ZAdvancedColorPicker.prototype), "_bindEvents", this).apply(this, arguments);

        var mousedownEvent = 'mousedown'; // No I18N

        this._addEvents({
          swatchDrag: mousedownEvent
        }, this._swatch);

        this._addEvents({
          swatchPickerDrag: mousedownEvent
        }, this._bar);
      }
    }, {
      key: "_swatchDragHandler",
      value: function _swatchDragHandler(orgEvent) {
        this._dragStartHandler(orgEvent, 'swatch'); // No I18N

      }
    }, {
      key: "_swatchPickerDragHandler",
      value: function _swatchPickerDragHandler(orgEvent) {
        this._dragStartHandler(orgEvent, 'swatchbar'); // No I18N

      }
    }, {
      key: "_dragStartHandler",
      value: function _dragStartHandler(orgEvent, type) {
        if (!orgEvent.button) {
          var picker, container;

          if (type === 'swatch') {
            // No I18N
            container = this._swatch;
            picker = this._swatchThumb;
          } else if (type === 'swatchbar') {
            // No I18N
            container = this._bar;
            picker = this._barThumb;
          } else {
            container = this._opacityBar;
            picker = this._opacityThumb;
          }

          this._activeContainer = {
            picker: picker,
            type: type,
            offset: container.offset(),
            height: container.height(),
            width: container.width()
          };

          _get(_getPrototypeOf(ZAdvancedColorPicker.prototype), "_dragStartHandler", this).call(this, orgEvent);

          this.setFocus();
        }
      }
    }, {
      key: "_onPickerDragged",
      value: function _onPickerDragged(orgEvent) {
        orgEvent.preventDefault();
        var container = this._activeContainer;
        var cursorPos, totalPixel;
        cursorPos = orgEvent.pageX - container.offset.left;
        totalPixel = container.width;
        var leftpercent = this._limit(cursorPos / totalPixel, 0, 1) * 100;
        cursorPos = orgEvent.pageY - container.offset.top;
        totalPixel = container.height;
        var toppercent = this._limit(cursorPos / totalPixel, 0, 1) * 100;
        var data = this._data;

        if (container.type === 'swatch') {
          // No I18N
          data.x = leftpercent;
          data.y = toppercent;
        } else {
          data[container.type === 'opacity' ? 'o' : 'z'] = this._vertical ? toppercent : leftpercent; // No I18N
        }

        var colorObj = this._getColorFromCoords();

        this._skipPickerData = true;

        this._setValue(colorObj, orgEvent);

        this._skipPickerData = false;
      }
    }, {
      key: "_getCoordsFromColor",
      value: function _getCoordsFromColor(options) {
        var color = this._colorInstance.getPercentageObject(options.boxSelectionTypeDefaultColorModel.toLowerCase());

        return {
          x: this._getRTLBasedPercent(parseFloat(color[this._axisProps.x[0]])),
          y: parseFloat(color[this._axisProps.y[0]]),
          z: this._getRTLBasedPercent(parseFloat(color[this._axisProps.z[0]])),
          o: this._getRTLBasedPercent(parseFloat(color.a))
        };
      }
    }, {
      key: "_updatePickerPositionInData",
      value: function _updatePickerPositionInData(data, options) {
        data.vertical = this._vertical;

        if (!this._skipPickerData) {
          var coords = this._getCoordsFromColor(options);

          data.x = coords.x;
          data.y = 100 - coords.y;
          data.z = coords.z;
          data.o = coords.o;
        }

        data.swatchBar.left = data.z;

        if (options.opacity) {
          var opacitySlider = data.opacitySlider;
          opacitySlider.left = data.o;
          opacitySlider.vertical = this._vertical;
        }
      }
    }, {
      key: "_configurePickerMethods",
      value: function _configurePickerMethods(options) {
        if (options.boxSelectionTypeDefaultColorModel === 'HSL') {
          // No I18N
          this._paintPicker = this._HSLUtils.paintPicker.bind(this);
          this._axisProps = this._HSLUtils.getXYProps(options.boxSpectrumHSLColorModel);
        } else {
          this._paintPicker = this._HSVUtils.paintPicker.bind(this);
          this._axisProps = this._HSVUtils.getXYProps(options.boxSpectrumHSVColorModel);
        }
      }
    }, {
      key: "_onSubmit",
      value: function _onSubmit(orgEvent) {
        this._onOkButtonClick(orgEvent);
      }
    }, {
      key: "_onOkButtonClick",
      value: function _onOkButtonClick(orgEvent) {
        this.setValue(this._currentColor, orgEvent);

        this._trigger('ok', orgEvent); // No I18N


        this.close(orgEvent);
      }
    }, {
      key: "_onCancelButtonClick",
      value: function _onCancelButtonClick(orgEvent) {
        this._revertColor(orgEvent);

        this._trigger('cancel', orgEvent); // No I18N


        this.close(orgEvent);
      }
    }, {
      key: "_onBackButtonClick",
      value: function _onBackButtonClick(orgEvent) {
        this._trigger('back', orgEvent); // No I18N

      }
    }, {
      key: "_revertColor",
      value: function _revertColor(orgEvent) {
        this.setValue(this._selectedInstance.getObject(), orgEvent);
      }
    }, {
      key: "_setHueStops",
      value: function _setHueStops(gradient) {
        this._setGradientColors(gradient, this._hueColors);
      }
    }, {
      key: "_fillCanvas",
      value: function _fillCanvas(context, gradient) {
        context.fillStyle = gradient;
        context.fill();
      }
    }, {
      key: "_clearCanvas",
      value: function _clearCanvas() {
        var rectContext = this._swatchContext;
        var barContext = this._barContext;
        rectContext.clearRect(0, 0, rectContext.canvas.width, rectContext.canvas.height);
        barContext.clearRect(0, 0, barContext.canvas.width, barContext.canvas.height);
        rectContext.rect(0, 0, rectContext.canvas.width, rectContext.canvas.height);
        barContext.rect(0, 0, barContext.canvas.width, barContext.canvas.height);
      }
    }, {
      key: "_createGradient",
      value: function _createGradient(context, vertical) {
        if (vertical) {
          return context.createLinearGradient(0, context.canvas.height, 0, 0);
        }

        return context.createLinearGradient(0, 0, context.canvas.width, 0);
      }
      /* Function to select a color */

    }, {
      key: "_setValue",
      value: function _setValue(color, orgEvent, data, fromUser) {
        var isNoFill = color === 'none' || color === 'transparent'; // No I18N

        var colorInstance = this._getClrInstance(isNoFill ? 'transparent' : color); // No I18N


        if (!this._opts.opacity) {
          colorInstance.setAlpha(1);
        }

        if (colorInstance.isValid()) {
          colorInstance.initialColor = color;
          var prevColor = this._currentColor;
          this._colorInstance = colorInstance;

          var currentColor = this._currentColor = this._colorInstance.getColor();

          var triggerChange;

          if (this._fromInit || fromUser || this._opts.immediateCommit && (!orgEvent || !/^(mousedown|mousemove|znumberfieldspin|znumberfieldinput)$/.test(orgEvent.type))) {
            if (this._fromInit || currentColor !== this._selectedInstance.getColor()) {
              this._updateSelectedColor();

              triggerChange = true;
            }
          }

          this._updateUI();

          if (prevColor !== currentColor) {
            this._trigger('select', orgEvent); // No I18N

          }

          if (!this._opts.immediateCommit || fromUser || this._fromInit) {
            this._previousInstance = this._selectedInstance;
          }

          if (triggerChange) {
            this._trigger('pick', orgEvent); // No I18N


            this._trigger('change', orgEvent); // No I18N

          }
        }
      }
    }, {
      key: "_getColorFromCoords",
      value: function _getColorFromCoords() {
        var axisProps = this._axisProps;
        var data = this._data;
        var color = {};

        var getRTLBasedPercent = this._getRTLBasedPercent.bind(this);

        color[axisProps.x[0]] = getRTLBasedPercent(data.x) + '%'; // No I18N

        color[axisProps.y[0]] = getRTLBasedPercent(100 - data.y) + '%'; // No I18N

        color[axisProps.z[0]] = getRTLBasedPercent(data.z) + '%'; // No I18N

        color.a = getRTLBasedPercent(data.o) + '%'; // No I18N

        return color;
      }
    }, {
      key: "_onClose",
      value: function _onClose(orgEvent) {
        // ColorFields are updated before closing
        this._revertColor(orgEvent);

        _get(_getPrototypeOf(ZAdvancedColorPicker.prototype), "_onClose", this).call(this, orgEvent);
      }
    }, {
      key: "setDimension",
      value: function setDimension() {
        this._setDimension();
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        var data = this._data;

        if (data.colorFields) {
          this._destroyClrFields();
        }

        if (data.commandBar) {
          this._destroyCmdBar(data.commandBar);
        }

        this._paintPicker = undefined;

        _get(_getPrototypeOf(ZAdvancedColorPicker.prototype), "_destroy", this).apply(this, arguments);
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        var response = _get(_getPrototypeOf(ZAdvancedColorPicker.prototype), "_setAttribute", this).call(this, optionName, value);

        if (response === false) {
          var regex = {
            opacity: /^(opacity|opacityFieldType)$/,
            colorField: /^(colorFields|colorFieldsList|currentColorField)$/,
            palette: /^(paletteColumns|palettes|palettesList|customColorLibraries|addIconClassName|addIconClass|addSVGIconId)$/,
            commandBar: /^(immediateCommit|commandBar|OKButtonLabel|OKButtonClassName|OKButtonClass|cancelButtonLabel|cancelButtonClassName|cancelButtonClass|hideCancelButton|backButtonLabel|backButtonClassName|backButtonClass)$/,
            colorPreview: /^(colorPreview|previousColorInPreview)$/,
            swatch: /^(boxSelectionTypeDefaultColorModel|boxSpectrumHSLColorModel|boxSpectrumHSVColorModel)$/,
            marker: /^(mapMarkerIconClass|mapMarkerIconClassName|mapMarkerSVGIconId)$/
          };
          this._opts[optionName] = value;

          if (optionName === 'slider') {
            // No I18N
            this._changedAttrs.push('opacity', 'swatch'); // No I18N


            this._domChanged = true;
          } else if (regex.opacity.test(optionName)) {
            this._changedAttrs.push('opacity', 'colorField'); // No I18N


            this._domChanged = true;

            if (!value) {
              this._setValue(this._currentColor);
            }
          } else {
            for (var mod in regex) {
              if (regex[mod].test(optionName)) {
                this._changedAttrs.push(mod);

                this._domChanged = true;
              }
            }
          }
        }
      }
    }, {
      key: "_storeCmdBarRef",
      value: function _storeCmdBarRef(commandBar) {
        for (var column in commandBar) {
          this._setMainEle(commandBar[column]);
        }
      }
    }, {
      key: "_setCmdBarData",
      value: function _setCmdBarData(data, options) {
        var _this98 = this;

        this._destroyCmdBar(data.commandBar);

        data.commandBar = false;

        if (!options.immediateCommit && options.commandBar) {
          var commandBar = options.commandBar;
          data.commandBar = {
            left: [],
            right: [],
            center: []
          };
          var handlers = {
            OK: this._onOkButtonClick,
            cancel: this._onCancelButtonClick,
            back: this._onBackButtonClick
          };
          var buttonObjects = {};
          ['OK', 'cancel', 'back'].forEach(function (command) {
            // No I18N
            buttonObjects[command] = _objectSpread({}, _this98._getBaseObj('button'), {}, {
              id: _this98._getID('zactionbutton-' + command),
              // No I18N
              click: handlers[command].bind(_this98),
              size: 'small',
              // No I18N
              zclassName: options[command + 'ButtonClassName'] || options[command + 'ButtonClass'],
              // No I18N
              text: options[command + 'ButtonLabel'] || _this98._getI18NText(command.toLowerCase()) // No I18N

            });
          });
          buttonObjects.OK.appearance = 'primary'; // No I18N

          ['left', 'right', 'center'].forEach(function (section) {
            // No I18N
            var column = commandBar[section + 'Column']; // No I18N

            var commands = column && column.commands;

            if (commands) {
              commands.forEach(function (action) {
                if (action !== 'cancel' || !options.hideCancelButton) {
                  // No I18N
                  var buttonObj = buttonObjects[action];

                  if (buttonObj) {
                    data.commandBar[section].push(buttonObj);
                    buttonObjects[action] = undefined;
                  }
                }
              });
            }
          });
        }
      }
    }, {
      key: "_destroyCmdBar",
      value: function _destroyCmdBar(commandBar) {
        var _this99 = this;

        if (commandBar) {
          for (var section in commandBar) {
            commandBar[section].forEach(function (buttonObj) {
              return _this99._destroyComp(buttonObj);
            });
          }
        }
      }
    }, {
      key: "_setClrFieldData",
      value: function _setClrFieldData(data, options) {
        this._destroyClrFields();

        if (options.colorFields) {
          var colorFieldsList = options.colorFieldsList || ['hex', 'rgb', 'hsv', 'hsl', 'cmyk']; // No I18N

          colorFieldsList = colorFieldsList.filter(function (mode) {
            return /^(hex|rgb|cmyk|hex|hsv|hsl)$/.test(mode);
          });

          if (colorFieldsList && colorFieldsList.length) {
            var colorFields = data.colorFields = {
              hexFieldId: this._getID('hexfield') // No I18N

            };
            var defaultColorField = options.currentColorField || options.defaultColorField;
            defaultColorField = colorFieldsList.indexOf(defaultColorField) === -1 ? colorFieldsList[0] : defaultColorField;

            if (colorFieldsList.length > 1) {
              this._createClrFieldSelect(colorFields, colorFieldsList, defaultColorField);
            }

            colorFields.includeHexClass = options.opacity || !options.opacity && !colorFields.select;

            this._onModeChange(defaultColorField);

            return;
          }
        }

        data.colorFields = false;
      }
    }, {
      key: "_destroyClrFields",
      value: function _destroyClrFields() {
        var _this100 = this;

        var data = this._data;
        var colorFields = data.colorFields;

        if (colorFields) {
          this._destroyComp(colorFields.select);

          colorFields.numberFields.forEach(function (numberFieldObj) {
            return _this100._destroyComp(numberFieldObj);
          });
          data.colorFields = false;
        }
      }
    }, {
      key: "_storeClrFieldRef",
      value: function _storeClrFieldRef(colorFields) {
        if (this._isAttrChanged('colorField') || this._fromModeChange) {
          // No I18N
          if (colorFields.currentMode === 'hex') {
            // No I18N
            this._bindTextField(this._getById(colorFields.hexFieldId));
          }

          this._setMainEle(colorFields.select);

          this._setMainEle(colorFields.numberFields);
        }
      }
    }, {
      key: "_setClrFieldValues",
      value: function _setClrFieldValues(colorFields) {
        if (!this._skipFieldUpdate) {
          var values = colorFields.propValues;

          if (colorFields.currentMode === 'hex') {
            // No I18N
            this._getById(colorFields.hexFieldId).val(values.hex);
          }

          colorFields.numberFieldProps.forEach(function (prop, index) {
            colorFields.numberFields[index].instance.setAttribute('value', values[prop]); // No I18N
          });
        }
      }
    }, {
      key: "_saveFieldValues",
      value: function _saveFieldValues(colorFields, options) {
        if (!this._skipFieldUpdate) {
          var currentMode = colorFields.currentMode;
          var colorInstance = this._colorInstance;
          var values = colorFields.propValues = {};

          if (currentMode === 'hex') {
            // No I18N
            var hexValue = colorInstance.getColor('hex', false, false); // No I18N

            values[currentMode] = hexValue;
          }

          var color = colorInstance.getObject(currentMode);
          colorFields.numberFieldProps.forEach(function (prop) {
            var value;

            if (prop === 'a') {
              // No I18N
              value = colorInstance.getAlpha();
              value = options.opacityFieldType === 'decimal' ? value : Math.round(value * 100); // No I18N

              values.a = parseInt(value);
            } else {
              value = parseInt(color[prop]);
            }

            values[prop] = value;
          });
        }
      }
    }, {
      key: "_onModeChange",
      value: function _onModeChange(currentMode, orgEvent) {
        var _this101 = this;

        var colorFields = this._data.colorFields;
        var options = this._opts;
        var opacity, emptyLabel;

        var props = colorFields.numberFieldProps = _toConsumableArray(this._MODEPROPS[currentMode]);

        colorFields.currentMode = options.currentColorField = currentMode; // Prev HexField needs to be unbinded - since new hexfield is created each and every time its cache resides in memory.

        var hexFieldId = colorFields.hexFieldId;

        if (hexFieldId) {
          this._getById(hexFieldId).off();
        }

        if (currentMode !== 'cmyk') {
          // No I18N
          if (options.opacity) {
            props.push('a'); // No I18N

            opacity = true;
          } else if (colorFields.select) {
            emptyLabel = true;
          }
        }

        colorFields.opacity = opacity;
        colorFields.labels = props.map(function (prop) {
          return _this101._getI18NText(_this101.PROP_EXP[prop] + 'Field');
        }); // No I18N

        if (emptyLabel) {
          colorFields.labels.push(''); // No I18N
        }

        var numberFields = colorFields.numberFields = colorFields.numberFields || [];

        if (currentMode === 'hex') {
          // No I18N
          props.shift();
        }

        (props.length || numberFields.length) && this._updateNumberFieldSettings(props, numberFields);
        orgEvent && this._trigger('colorfieldlistchange', orgEvent); // No I18N
      }
    }, {
      key: "_fieldChangeHandler",
      value: function _fieldChangeHandler(orgEvent) {
        var target = $(orgEvent.target);
        var targetId = target[0].id;
        var colorFields = this._data.colorFields;
        var value, colorProperty;

        if (targetId === colorFields.hexFieldId) {
          colorProperty = 'hex'; // No I18N

          value = target.val();
        } else {
          colorProperty = colorFields.numberFields.find(function (numberFieldObj) {
            return numberFieldObj.id === targetId;
          }).colorProperty;
          value = orgEvent.detail.value;
        }

        var propValues = colorFields.propValues; // NumberField Based Value

        propValues[colorProperty] = value;
        propValues = _objectSpread({}, propValues);

        if (this._opts.opacityFieldType !== 'decimal') {
          // No I18N
          // Decimal Based Value
          propValues.a /= 100;
        }

        this._skipFieldUpdate = true;

        this._setValue(propValues, orgEvent);

        this._skipFieldUpdate = false;
      }
    }, {
      key: "_createClrFieldSelect",
      value: function _createClrFieldSelect(colorFields, colorFieldsList, defaultColorField) {
        var _this102 = this;

        colorFields.select = _objectSpread({}, this._getBaseObj('select'), {}, {
          id: this._getID('colorFields'),
          // No I18N
          options: colorFieldsList.map(function (mode) {
            return {
              label: _this102._getI18NText(mode.toUpperCase()),
              value: mode,
              selected: defaultColorField === mode
            };
          }),
          zclassName: 'zcolorpicker__selectbox',
          // No I18N
          change: function change(orgEvent) {
            _this102._fromModeChange = true;

            _this102._onModeChange(orgEvent.detail.value, orgEvent);

            _this102._updateUI();

            _this102._fromModeChange = false;
          },
          width: 'none',
          // No I18N
          dropdownList: {
            viewport: window,
            appendTo: this.element
          }
        });
      }
    }, {
      key: "_paintOpacity",
      value: function _paintOpacity() {
        var context = this._opacityContext;
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.rect(0, 0, context.canvas.width, context.canvas.height);

        var gradient = this._createGradient(context, this._vertical);

        var rgbObj = this._colorInstance.getObject();

        this._setGradientColors(gradient, ["rgba(".concat(rgbObj.r, ", ").concat(rgbObj.g, ", ").concat(rgbObj.b, ", 0)"), "rgb(".concat(rgbObj.r, " ,").concat(rgbObj.g, " ,").concat(rgbObj.b, ")")]);

        this._fillCanvas(context, gradient);
      }
    }, {
      key: "_storeOpacityRef",
      value: function _storeOpacityRef(data) {
        var opacityBar = this._opacityBar = this._getById(data.opacitySlider.id);

        this._opacityContext = this._getCanvasContext(opacityBar[0]);
        this._opacityThumb = this._getThumb(opacityBar[0]);

        this._addEvents({
          opacityBarDrag: 'mousedown' // No I18N

        }, opacityBar);
      }
    }, {
      key: "_setOpacityData",
      value: function _setOpacityData(data, options) {
        data.opacitySlider = data.opacity = false;

        if (options.opacity) {
          data.opacity = true;
          data.opacitySlider = {
            id: this._getID('opacityslider'),
            // No I18N
            className: 'zcolorpicker__opacityslider',
            // No I18N
            rtl: data.rtl,
            opacity: true,
            thumbIcon: this._getThumbData(options.slider)
          };
        }
      }
    }, {
      key: "_opacityBarDragHandler",
      value: function _opacityBarDragHandler(orgEvent) {
        this._dragStartHandler(orgEvent, 'opacity'); // No I18N

      }
    }, {
      key: "_updateNumberFieldSettings",
      value: function _updateNumberFieldSettings(props, numberFields) {
        var _this103 = this;

        props.forEach(function (prop, index) {
          var fieldSettings = _this103._getFieldSettings(prop);

          var numberFieldObj = numberFields[index];

          if (numberFieldObj) {
            var instance = numberFieldObj.instance;
            instance.setAttributes(fieldSettings);

            _this103._display(true, numberFieldObj.container);
          } else {
            var basicSettings = _this103._getBasicNumberFieldOptions();

            basicSettings.id = _this103._getID('znumberfield-' + index); // No I18N

            ['change', 'spin', 'input', 'spinend'].forEach(function (eventName) {
              // No I18N
              basicSettings[eventName] = _this103._fieldChangeHandler.bind(_this103);
            });
            numberFieldObj = _objectSpread({}, basicSettings, {}, fieldSettings);
            numberFields.push(numberFieldObj);
          }

          numberFieldObj.colorProperty = prop;
        });
        numberFields.slice(props.length).forEach(function (numberFieldObj) {
          return _this103._display(false, numberFieldObj.container);
        });
      }
    }, {
      key: "_getFieldSettings",
      value: function _getFieldSettings(prop) {
        var settings = {
          max: 100,
          step: 1,
          suffix: '',
          // No I18N
          decimalPlaces: 0
        };

        if (prop === 'a' && this._opts.opacityFieldType === 'decimal') {
          // No I18N
          settings.step = 0.01;
          settings.decimalPlaces = 2;
          settings.max = 1;
        } else if (/^(s|l|v|c|m|y|k|a)$/.test(prop)) {
          // No I18N
          settings.suffix = '%'; // No I18N
        } else if (/^(r|g|b)$/.test(prop)) {
          settings.max = 255;
        } else if (prop === 'h') {
          // No I18N
          settings.max = 359;
        }

        return settings;
      }
    }, {
      key: "_getBasicNumberFieldOptions",
      value: function _getBasicNumberFieldOptions() {
        var settings = _get(_getPrototypeOf(ZAdvancedColorPicker.prototype), "_getBasicNumberFieldOptions", this).call(this);

        settings.className = 'zcolorpicker__othercolormodefield zcolorpicker__colorfield'; // No I18N

        return settings;
      }
    }, {
      key: "_setPreviewData",
      value: function _setPreviewData(data, options) {
        data.colorPreview = false;

        if (options.colorPreview) {
          var previousColor, previousColorId;

          if (options.previousColorInPreview) {
            previousColor = this._previousInstance.getColor();
            previousColorId = this._getID('previouscolor'); // No I18N
          }

          data.colorPreview = {
            color: data.rgb,
            previousColor: previousColor,
            previousColorId: previousColorId
          };
        }
      }
    }, {
      key: "_bindPreview",
      value: function _bindPreview(colorPreview) {
        this._addEvents({
          prevPreviewClick: 'mousedown' // No I18N

        }, this._getById(colorPreview.previousColorId));
      }
    }, {
      key: "_prevPreviewClickHandler",
      value: function _prevPreviewClickHandler(orgEvent) {
        this._revertColor(orgEvent);
      }
    }, {
      key: "_setPaletteData",
      value: function _setPaletteData(data, options) {
        data.palettes = data.customColorLibraries = false;

        if (options.palettes) {
          data.palettes = [];
          data.customColorLibraries = [];

          this._addPalettes(options.palettesList);

          this._addPalettes(options.customColorLibraries, null, 'customColorLibraries'); // No I18N

        }
      }
    }, {
      key: "_updateSelection",
      value: function _updateSelection(data) {
        var _this104 = this;

        var callback = function callback(palette) {
          return _this104._updateClrSelection(palette.colors);
        };

        data.palettes.forEach(callback);
        data.customColorLibraries.forEach(callback);
      }
    }, {
      key: "_updatePalettes",
      value: function _updatePalettes(paletteKey) {
        var data = this._data;
        var options = this._opts;

        var callback = function callback(paletteTemplateData) {
          return paletteTemplateData.paletteData;
        };

        if (paletteKey === 'palettes') {
          // No I18N
          options.palettesList = data.palettes.map(callback);
        } else {
          options.customColorLibraries = data.customColorLibraries.map(callback);
        }

        this._paletteChanged = true;

        this._updateUI(true);
      }
    }, {
      key: "_storeCustomLibRef",
      value: function _storeCustomLibRef(data, options) {
        var _this105 = this;

        data.customColorLibraries.forEach(function (paletteData) {
          var addBtnObject = paletteData.addBtn;

          _this105._setMainEle(addBtnObject);

          var addBtn = addBtnObject.mainElement;
          addBtn.paletteName = paletteData.name; // Binding add button

          _this105._addEvents({
            addBtnClick: 'mousedown' // No I18N

          }, $(addBtn)); // Binding DELETE Key press


          _this105._addEvents({
            delKey: 'keydown' // No I18N

          }, _this105._getById(paletteData.id));
        });
      }
    }, {
      key: "_addBtnClickHandler",
      value: function _addBtnClickHandler(orgEvent) {
        var button = $(orgEvent.target).closest('.zbutton')[0]; // No I18N

        this._skipPickerData = true;

        if (this.isCE) {
          button.$c._addedByComponent = true;
        }

        this.addColor(button.paletteName, this._colorInstance.getColor());

        if (this.isCE) {
          button.$c._addedByComponent = false;
        }

        this._skipPickerData = false;
      }
    }, {
      key: "_delKeyHandler",
      value: function _delKeyHandler(orgEvent) {
        if (orgEvent.keyCode === ZC.keyCode.DELETE) {
          var colorpan = orgEvent.target;

          if ($(colorpan).is(".".concat(this._CLASSES.COLORBOX))) {
            var eventData = this._getColorPanData(colorpan);

            if (this._trigger('beforecolorpanremove', orgEvent, eventData)) {
              // No I18N
              var paletteName = orgEvent.currentTarget.getAttribute('data-palettename'); // No I18N

              this._removeColors(paletteName, colorpan.getAttribute('data-zcolor')); // No I18N


              this._trigger('colorpanremove', orgEvent, eventData); // No I18N

            }
          }
        }
      }
    }, {
      key: "_getAddBtnData",
      value: function _getAddBtnData(paletteData) {
        var id = this._getID(paletteData.name) + '-addicon'; // No I18N

        var options = this._opts;
        var SVGIconId = options.addSVGIconId;
        var iconClassName = options.addIconClassName || options.addIconClass;

        if (!SVGIconId && !iconClassName) {
          SVGIconId = 'zc__svg--add addColorIcon'; // No I18N
        }

        var addBtnOptions = _objectSpread({}, this._getBaseObj('button'), {}, {
          id: id,
          iconClassName: iconClassName,
          SVGIconId: SVGIconId,
          defaultIconClassName: 'zcolorpicker__addcoloricon',
          // No I18N
          title: this._getI18NText('addcolor'),
          // No I18N
          addBtn: true
        });

        if (this._domChanged) {
          this._destroyComp(addBtnOptions);
        }

        return addBtnOptions;
      }
    }, {
      key: "addCustomColorsLibrary",
      value: function addCustomColorsLibrary(paletteData) {
        this._addPalettes(paletteData, undefined, 'customColorLibraries'); // No I18N

      }
    }, {
      key: "insertCustomColorsLibraryBefore",
      value: function insertCustomColorsLibraryBefore(paletteData, paletteName) {
        var index;

        var paletteTemplateData = this._getPaletteTemplateData(paletteName);

        if (paletteTemplateData) {
          index = this._data.customColorLibraries.indexOf(paletteTemplateData);
        }

        this._addPalettes(paletteData, index, 'customColorLibraries'); // No I18N

      }
    }, {
      key: "insertCustomColorsLibraryAt",
      value: function insertCustomColorsLibraryAt(paletteData, index) {
        this._addPalettes(paletteData, index, 'customColorLibraries'); // No I18N

      }
    }, {
      key: "removeCustomColorsLibrary",
      value: function removeCustomColorsLibrary(palettes) {
        this._removePalettes(palettes, 'customColorLibraries'); // No I18N

      }
    }, {
      key: "removeCustomColorsLibraryAt",
      value: function removeCustomColorsLibraryAt(index) {
        this._removePalettesAt(index, 'customColorLibraries'); // No I18N

      }
    }, {
      key: "name",
      get: function get() {
        return "zadvancedcolorpicker";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          opacity: true,
          mapMarkerIconClass: null,
          mapMarkerSVGIconId: null,
          colorPreview: true,
          previousColorInPreview: true,
          colorFields: true,
          defaultColorField: 'hex',
          // No I18N
          currentColorField: 'hex',
          // No I18N
          opacityFieldType: 'percent',
          // No I18N
          palettes: false,
          paletteColumns: 0,
          addIconClass: null,
          addSVGIconId: null,
          immediateCommit: false,
          closeOnSelect: false,
          OKButtonLabel: null,
          OKButtonClass: null,
          cancelButtonLabel: null,
          cancelButtonClass: null,
          hideCancelButton: false,
          backButton: true,
          backButtonLabel: null,
          backButtonClass: null,
          boxSelectionTypeDefaultColorModel: 'HSV' // No I18N

        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          slider: null,
          mapMarkerIconClassName: null,
          addIconClassName: null,
          OKButtonClassName: null,
          cancelButtonClassName: null,
          backButtonClassName: null,
          colorFieldsList: null,
          // No I18N
          palettesList: null,
          customColorLibraries: null,
          commandBar: {
            leftColumn: null,
            centerColumn: null,
            rightColumn: {
              commands: ['cancel', 'OK'] // No I18N

            }
          },
          boxSpectrumHSVColorModel: {
            xAxis: 'saturation',
            // No I18N
            yAxis: 'value' // No I18N

          },
          boxSpectrumHSLColorModel: {
            xAxis: 'hue',
            // No I18N
            yAxis: 'saturation' // No I18N

          },
          labels: {
            close: 'Close',
            // No I18N
            addcolor: 'Add Color',
            // No I18N
            HSV: 'HSV',
            // No I18N
            RGB: 'RGB',
            // No I18N
            HSL: 'HSL',
            // No I18N
            CMYK: 'CMYK',
            // No I18N
            HEX: 'HEX',
            // No I18N
            opacityField: 'A',
            // No I18N
            hexField: 'HEX',
            // No I18N
            hueField: 'H',
            // No I18N
            saturationField: 'S',
            // No I18N
            valueField: 'V',
            // No I18N
            lightnessField: 'L',
            // No I18N
            redField: 'R',
            // No I18N
            greenField: 'G',
            // No I18N
            blueField: 'B',
            // No I18N
            cyanField: 'C',
            // No I18N
            magentaField: 'M',
            // No I18N
            yellowField: 'Y',
            // No I18N
            keyField: 'K',
            // No I18N
            ok: 'OK',
            // No I18N
            cancel: 'Cancel',
            // No I18N
            back: 'Back' // No I18N

          }
        };
      }
    }, {
      key: "CLASSES",
      get: function get() {
        return {
          CONTAINER: 'zcolorpicker zcolorpicker--advanced' // No I18N

        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['cancel', // No I18N
        'back', // No I18N
        'ok', // No I18N
        'beforecolorpanadd', // No I18N
        'colorpanadd', // No I18N
        'beforecolorpanremove', // No I18N
        'colorpanremove', // No I18N
        'colorfieldlistchange' // No I18N
        ];
      }
    }, {
      key: "_MODEPROPS",
      get: function get() {
        return {
          hsv: ['h', 's', 'v'],
          // No I18N
          rgb: ['r', 'g', 'b'],
          // No I18N
          hex: ['hex'],
          // No I18N
          hsl: ['h', 's', 'l'],
          // No I18N
          cmyk: ['c', 'm', 'y', 'k'] // No I18N

        };
      }
    }, {
      key: "PROP_EXP",
      get: function get() {
        return {
          h: 'hue',
          // No I18N
          s: 'saturation',
          // No I18N
          v: 'value',
          // No I18N
          l: 'lightness',
          // No I18N
          r: 'red',
          // No I18N
          g: 'green',
          // No I18N
          b: 'blue',
          // No I18N
          a: 'opacity',
          // No I18N
          hex: 'hex',
          // No I18N
          c: 'cyan',
          // No I18N
          m: 'magenta',
          // No I18N
          y: 'yellow',
          // No I18N
          k: 'key' // No I18N

        };
      }
    }, {
      key: "_hueColors",
      get: function get() {
        return ['rgba(255, 0, 0, 1)', 'rgba(255, 255, 0, 1)', 'rgba(0, 255, 0, 1)', 'rgba(0, 255, 255, 1)', 'rgba(0, 0, 255, 1)', 'rgba(255, 0, 255, 1)', 'rgba(255, 0, 0, 1)']; // No I18N
      }
    }, {
      key: "_HSVUtils",
      get: function get() {
        return {
          fill: function fill(y, z, m, rgb) {
            var context = z === m ? this._barContext : this._swatchContext;
            var vertical = z === m && this._vertical || y === m;

            var gradient = this._createGradient(context, vertical);

            switch (m) {
              case 'hue':
                // No I18N
                this._setHueStops(gradient);

                break;

              case 'saturation':
                // No I18N
                this._setGradientColors(gradient, ['rgba(255,255,255,1)', rgb || 'rgba(255,255,255,0)']); // No I18N


                break;

              case 'value':
                // No I18N
                this._setGradientColors(gradient, ['rgba(0,0,0,1)', rgb || 'rgba(0,0,0,0)']);

              // No I18N
            }

            this._fillCanvas(context, gradient);
          },
          getValueLayer: function getValueLayer(value) {
            return 'rgba(0, 0, 0, ' + (1 - value / 100) + ')'; // No I18N
          },
          paintPicker: function paintPicker(x, y, z) {
            this._clearCanvas();

            var hsv = this._colorInstance.getObject('hsv'); // No I18N
            // let hsv = this._getColorFromCoords();


            var rectContext = this._swatchContext;
            var barContext = this._barContext;

            var fill = this._HSVUtils.fill.bind(this, y, z);

            var getValueLayer = this._HSVUtils.getValueLayer.bind(this, parseFloat(hsv.v));

            switch (z) {
              case 'value':
                // No I18N
                // Hue
                fill('hue'); // No I18N
                // Saturation

                fill('saturation'); // No I18N
                // Value

                this._fillCanvas(rectContext, getValueLayer()); // z


                fill('value', this._getClrInstance({
                  // No I18N
                  h: hsv.h,
                  s: hsv.s,
                  v: '100%'
                }).getColor());
                break;

              case 'hue':
                // No I18N
                // Actual Color
                this._fillCanvas(rectContext, this._getClrInstance({
                  h: hsv.h,
                  s: '100%',
                  v: '100%'
                }).getColor()); // Saturation


                fill('saturation'); // No I18N
                // Value

                fill('value'); // No I18N
                // z

                fill('hue'); // No I18N

                break;

              case 'saturation':
                // No I18N
                // Hue
                fill('hue'); // No I18N
                // Saturation

                this._fillCanvas(rectContext, 'rgba(255,255,255,' + (1 - parseFloat(hsv.s) / 100) + ')'); // No I18N
                // Value


                fill('value'); // No I18N
                // z

                fill('saturation', this._getClrInstance({
                  // No I18N
                  h: hsv.h,
                  s: '100%',
                  v: '100%'
                }).getColor());

                this._fillCanvas(barContext, getValueLayer());

                break;
            }
          },
          getXYProps: function getXYProps(XYAxis) {
            var x, y, z;

            switch (XYAxis.xAxis + '-' + XYAxis.yAxis) {
              // No I18N
              case 'hue-saturation':
                // No I18N
                x = 'hue'; // No I18N

                y = 'saturation'; // No I18N

                z = 'value'; // No I18N

                break;

              case 'saturation-hue':
                // No I18N
                x = 'saturation'; // No I18N

                y = 'hue'; // No I18N

                z = 'value'; // No I18N

                break;

              case 'hue-value':
                // No I18N
                x = 'hue'; // No I18N

                y = 'value'; // No I18N

                z = 'saturation'; // No I18N

                break;

              case 'value-hue':
                // No I18N
                x = 'value'; // No I18N

                y = 'hue'; // No I18N

                z = 'saturation'; // No I18N

                break;

              case 'value-saturation':
                // No I18N
                x = 'value'; // No I18N

                y = 'saturation'; // No I18N

                z = 'hue'; // No I18N

                break;

              default:
                x = 'saturation'; // No I18N

                y = 'value'; // No I18N

                z = 'hue'; // No I18N

                break;
            }

            return {
              x: x,
              y: y,
              z: z
            };
          }
        };
      }
    }, {
      key: "_HSLUtils",
      get: function get() {
        return {
          fill: function fill(y, z, m, rgb) {
            var context = z === m ? this._barContext : this._swatchContext;
            var vertical = z === m && this._vertical || y === m;

            var gradient = this._createGradient(context, vertical);

            switch (m) {
              case 'hue':
                // No I18N
                this._setHueStops(gradient);

                break;

              case 'saturation':
                // No I18N
                this._setGradientColors(gradient, ['rgba(128,128,128,1)', rgb || 'rgba(128,128,128,0)']); // No I18N


                break;

              case 'lightness':
                // No I18N
                gradient.addColorStop(0, 'rgb(0,0,0)'); // No I18N

                if (rgb) {
                  gradient.addColorStop(0.5, rgb);
                } else {
                  gradient.addColorStop(0.5, 'rgba(0,0,0,0)'); // No I18N

                  gradient.addColorStop(0.5, 'rgba(255,255,255,0)'); // No I18N
                }

                gradient.addColorStop(1, 'rgb(255,255,255)');
              // No I18N
            }

            this._fillCanvas(context, gradient);
          },
          getLightnessLayer: function getLightnessLayer(lightness) {
            if (lightness < 50) {
              return "rgba(0, 0, 0, ".concat(1 - lightness / 50, ")");
            } else if (lightness > 50) {
              return "rgba(255, 255, 255, ".concat((lightness - 50) / 50);
            }
          },
          paintPicker: function paintPicker(x, y, z) {
            this._clearCanvas();

            var hsl = this._colorInstance.getObject('hsl'); // No I18N
            // let hsl = this._getColorFromCoords();


            var rectContext = this._swatchContext;
            var barContext = this._barContext;

            var fill = this._HSLUtils.fill.bind(this, y, z);

            var getLightnessLayer = this._HSLUtils.getLightnessLayer.bind(this, parseFloat(hsl.l));

            switch (z) {
              case 'lightness':
                // No I18N
                // Hue
                fill('hue'); // No I18N
                // Saturation

                fill('saturation'); // No I18N
                // lightness
                // var lightnessLayer = getLightnessLayer();
                // lightnessLayer && this._fillCanvas( rectContext, lightnessLayer );
                // z

                fill('lightness', this._getClrInstance({
                  // No I18N
                  h: hsl.h,
                  s: hsl.s,
                  l: '50%' // No I18N

                }).getColor());
                break;

              case 'hue':
                // No I18N
                // Actual Color
                this._fillCanvas(rectContext, this._getClrInstance({
                  h: hsl.h,
                  s: '100%',
                  l: '50%'
                }).getColor()); // Saturation


                fill('saturation'); // No I18N
                // lightness

                fill('lightness'); // No I18N
                // z

                fill('hue'); // No I18N

                /* this._fillCanvas( barContext, 'rgba(128,128,128,'+ (1 - parseFloat( hsl.s )/100) +')'); //No I18N
                    var lightnessLayer = getLightnessLayer();
                    lightnessLayer && this._fillCanvas( barContext, lightnessLayer ); */

                break;

              case 'saturation':
                // No I18N
                {
                  // Hue
                  fill('hue'); // No I18N
                  // Saturation
                  // this._fillCanvas( rectContext, 'rgba(128,128,128,'+(1 - parseFloat( hsl.s )/100)+')' ); //No I18N
                  // lightness

                  fill('lightness'); // No I18N
                  // z

                  fill('saturation', this._getClrInstance({
                    // No I18N
                    h: hsl.h,
                    s: '100%',
                    l: '50%'
                  }).getColor());
                  var lightnessLayer = getLightnessLayer();
                  lightnessLayer && this._fillCanvas(barContext, lightnessLayer);
                }
                break;
            }
          },
          getXYProps: function getXYProps(XYAxis) {
            var x, y, z;

            switch (XYAxis.xAxis + '-' + XYAxis.yAxis) {
              // No I18N
              case 'saturation-hue':
                // No I18N
                x = 'saturation'; // No I18N

                y = 'hue'; // No I18N

                z = 'lightness'; // No I18N

                break;

              case 'hue-lightness':
                // No I18N
                x = 'hue'; // No I18N

                y = 'lightness'; // No I18N

                z = 'saturation'; // No I18N

                break;

              case 'lightness-hue':
                // No I18N
                x = 'lightness'; // No I18N

                y = 'hue'; // No I18N

                z = 'saturation'; // No I18N

                break;

              case 'lightness-saturation':
                // No I18N
                x = 'lightness'; // No I18N

                y = 'saturation'; // No I18N

                z = 'hue'; // No I18N

                break;

              case 'saturation-lightness':
                // No I18N
                x = 'saturation'; // No I18N

                y = 'lightness'; // No I18N

                z = 'hue'; // No I18N

                break;

              default:
                x = 'hue'; // No I18N

                y = 'saturation'; // No I18N

                z = 'lightness'; // No I18N

                break;
            }

            return {
              x: x,
              y: y,
              z: z
            };
          }
        };
      }
    }]);

    return ZAdvancedColorPicker;
  }(ZC.ZColorPickerBase);

  ZC.registerComponent('ZAdvancedColorPicker', ZC.ZColorPickerBase, ZAdvancedColorPicker);

  (function (ZC) {
    var template = ZC.zadvancedcolorpicker.Templates;
    var colorpickerBaseTemplate = ZC.zcolorpickerbase.Templates;
    var utilities = ZC.Templates.Utilities;

    template.children = function (data) {
      var returnTemplate = ZT.html(_templateObject144(), data.hasCallout && ZT.html(_templateObject145()), data.title && colorpickerBaseTemplate.title(data), data.swatchId, colorpickerBaseTemplate.canvas(data), data.markerIcon ? utilities.icon(data.markerIcon) : ZT.html(_templateObject146(), data.x, data.y), data.colorPreview && template.colorPreview(data.colorPreview), colorpickerBaseTemplate.slider(data.swatchBar), data.opacitySlider && colorpickerBaseTemplate.slider(data.opacitySlider), data.colorFields && template.colorFields(data.colorFields), data.palettes && data.palettes.map(function (paletteData) {
        return colorpickerBaseTemplate.palette(paletteData);
      }), data.customColorLibraries && data.customColorLibraries.map(function (paletteData) {
        return colorpickerBaseTemplate.palette(paletteData);
      }), data.commandBar && template.commandBar(data.commandBar));
      return returnTemplate;
    };

    template.colorFields = function (data) {
      var returnTemplate = ZT.html(_templateObject147(), data.select ? '' : 'zh-aligncenter', data.select && ZC.createSelect(data.select), data.currentMode === 'hex' && template.hexField(data), data.numberFields && data.numberFields.map(function (numberfield) {
        return ZC.createNumberField(numberfield);
      }), data.currentMode === 'hex' ? template.hexLabel(data) : ZT.html(_templateObject148(), data.labels.map(function (label) {
        return ZT.html(_templateObject149(), label);
      })));
      return returnTemplate;
    };

    template.colorPreview = function (data) {
      var returnTemplate = ZT.html(_templateObject150(), data.color, data.previousColor && ZT.html(_templateObject151(), data.previousColorId, data.previousColor));
      return returnTemplate;
    };

    template.commandBar = function (data) {
      var returnTemplate = ZT.html(_templateObject152(), data.left.length && ZT.html(_templateObject153(), template.colContent(data.left)), data.center.length && ZT.html(_templateObject154(), template.colContent(data.center)), data.right.length && ZT.html(_templateObject155(), template.colContent(data.right)));
      return returnTemplate;
    };

    template.colContent = function (data) {
      return data.map(function (button) {
        return ZC.createButton(button);
      });
    };

    template.hexField = function (data) {
      var returnTemplate = ZT.html(_templateObject156(), data.includeHexClass ? 'zcolorpicker__hexcolorfield' : '', data.hexFieldId, data.labels[0]);
      return returnTemplate;
    };

    template.hexLabel = function (data) {
      var returnTemplate = ZT.html(_templateObject157(), data.opacity && ZT.html(_templateObject158()));
      return returnTemplate;
    };
  })(ZComponents);

  var ZColorPicker =
  /*#__PURE__*/
  function (_ZC$ZColorPickerBase2) {
    _inherits(ZColorPicker, _ZC$ZColorPickerBase2);

    function ZColorPicker() {
      _classCallCheck(this, ZColorPicker);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZColorPicker).apply(this, arguments));
    }

    _createClass(ZColorPicker, [{
      key: "_onSubmit",
      value: function _onSubmit(orgEvent) {
        this.close(orgEvent);
      }
    }, {
      key: "_setAlpha",
      value: function _setAlpha(alpha, orgEvent) {
        var color = this._colorInstance.getObject();

        color.a = alpha;

        if (this._trigger('beforefocus', orgEvent)) {
          // No I18N
          this._data.opacityField.container.find('input').focus(); // No I18N

        }

        this._setValue(color, orgEvent);
      }
    }, {
      key: "_setRenderData",
      value: function _setRenderData(data, options) {
        _get(_getPrototypeOf(ZColorPicker.prototype), "_setRenderData", this).apply(this, arguments);

        data.closeOnSelect = !options.opacity && options.closeOnSelect;

        var isAttrChanged = this._isAttrChanged.bind(this);

        if (isAttrChanged('noColorButton')) {
          // No I18N
          if (data.noColorBtn) {
            // To avoid memory leak
            this._getById(data.noColorBtn.id).off();
          }

          data.noColorBtn = false;

          if (options.noColorButton) {
            data.noColorBtn = {
              id: this._getID('nocolorbtn'),
              // No I18N
              label: options.noColorButtonLabel || this._getI18NText('noColor') // No I18N

            };

            ZC._getIconInfo(options.noColorIconClassName || options.noColorIconClass, options.noColorSVGIconId, 'zc__svg--zcolorpicker-nocolor', 'zcolorpicker__icon', data.noColorBtn.icon = {}); // No I18N

          }
        }

        if (isAttrChanged('defaultColorButton')) {
          // No I18N
          if (data.defaultColor) {
            // To avoid memory leak
            this._getById(data.defaultColor.id).off();
          }

          data.defaultColor = false;

          if (options.defaultColorButton) {
            var colorInstance = this._getClrInstance(options.defaultValue);

            data.defaultColor = {
              id: this._getID('defaultcolorbtn'),
              // No I18N
              label: options.defaultColorButtonLabel || this._getI18NText('defaultColor'),
              // No I18N
              rgb: colorInstance.isValid() ? colorInstance.getColor() : this._DEFAULTS.defaultValue
            };
          }
        }

        if (isAttrChanged('advancedPicker')) {
          // No I18N
          if (options.advancedPicker || data.advancedPicker) {
            this._setMoreClrsData(options, data);
          }
        }

        if (isAttrChanged('colorField')) {
          // No I18N
          if (options.colorField || data.colorField) {
            this._setClrFieldData(data, options);
          }
        }

        if (isAttrChanged('opacity')) {
          // No I18N
          if (options.opacity || data.opacity) {
            this._setOpacityData(data, options);
          }
        }

        if (isAttrChanged('palette')) {
          // No I18N
          this._setPaletteData(data, options);
        }

        if (options.colorField) {
          data.colorField.rgb = data.rgb;
        }

        if (data.opacity) {
          this._setOpacityLeft(data);
        }

        this._updateSelection(data, options);
      }
    }, {
      key: "_setAdvPickerData",
      value: function _setAdvPickerData(options, data) {
        var _this106 = this;

        var userOptions = options.advancedPickerOptions;
        var advancedPickerOptions = $.extend(true, {}, this._getBaseObj('advancedcolorpicker'), // No I18N
        this._DEFAULTS.advancedPickerOptions, userOptions, {
          isFromPicker: true,
          type: 'inline',
          // No I18N
          hideCancelButton: true,
          immediateCommit: false,
          closeButton: false,
          palettes: false,
          value: options.value,
          valueColorModel: options.valueColorModel
        });

        if (!advancedPickerOptions.id) {
          advancedPickerOptions.id = this._getID('advancedpicker'); // No I18N
        }

        ['Ok', // No I18N
        'Cancel', // No I18N
        'Back', // No I18N
        'Select', // No I18N
        'ColorfieldListChangeHandler' // No I18N
        ].forEach(function (eventName) {
          advancedPickerOptions[eventName.toLowerCase()] = _this106._advPickerCallback.bind(_this106, _this106['_advPicker' + eventName + 'Handler']); // No I18N
        });

        if (data.advancedPicker) {
          data.advancedPicker.instance.setAttributes(advancedPickerOptions);
        } else {
          data.advancedPicker = advancedPickerOptions;
        }
      }
    }, {
      key: "_advPickerCallback",
      value: function _advPickerCallback(callback, orgEvent) {
        var data = orgEvent.detail;

        if (data.fromUI) {
          orgEvent = orgEvent.originalEvent;
          callback.call(this, orgEvent, data);
        }
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender(element, data) {
        _get(_getPrototypeOf(ZColorPicker.prototype), "_postEachRender", this).apply(this, arguments);

        if (data.colorField) {
          this._updateColorField();
        }

        if (data.opacity) {
          this._updateOpacityValues();
        }

        this._changedAttrs = [];
      }
    }, {
      key: "_storeRef",
      value: function _storeRef(data, options) {
        _get(_getPrototypeOf(ZColorPicker.prototype), "_storeRef", this).apply(this, arguments);

        var element = this.element;

        var isAttrChanged = this._isAttrChanged.bind(this);

        if (!data.rendered) {
          this._showHideContainer = $(this.element[0].querySelector('.zcolorpicker__showhidecontainer')); // No I18N

          this._container = this._basicPicker = $(this.element[0].querySelector('.zcolorpicker__default')); // No I18N

          this._borderThickness = element.outerHeight() - element.height() || 0;
        }

        if (isAttrChanged('colorField')) {
          // No I18N
          this._colorBox = false;

          if (options.colorField) {
            this._storeClrFieldRef(data.colorField, options);
          }
        }

        if (isAttrChanged('opacity')) {
          // No I18N
          this._opacityCanvasContext = this._opacitySlider = false;

          if (options.opacity) {
            this._storeOpacityRef(data, options);
          }
        }

        if (isAttrChanged('advancedPicker')) {
          // No I18N
          this._advPicker = false;

          if (options.advancedPicker) {
            this._storeAdvPickerRef(data, options);
          }
        }

        if (isAttrChanged('noColorButton')) {
          // No I18N
          if (options.noColorButton) {
            this._addEvents({
              noClrClick: 'click' // No I18N

            }, this._getById(data.noColorBtn.id));
          }
        }

        if (isAttrChanged('defaultColorButton')) {
          // No I18N
          if (options.defaultColorButton) {
            this._addEvents({
              defaultClrClick: 'click' // No I18N

            }, this._getById(data.defaultColor.id));
          }
        }
      }
    }, {
      key: "_makeSeen",
      value: function _makeSeen(element) {
        var display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        element.css('visibility', display ? 'visible' : 'hidden'); // No I18N
      }
    }, {
      key: "_makeUnSeen",
      value: function _makeUnSeen(element) {
        this._makeSeen(element, false);
      }
    }, {
      key: "_storeOpacityRef",
      value: function _storeOpacityRef(data) {
        var slider = this._opacitySlider = this._getById(data.opacitySlider.id);

        this._opacityCanvasContext = this._getCanvasContext(slider[0]);

        this._setMainEle(data.opacityField);

        this._addEvents({
          dragStart: 'mousedown' // No I18N

        }, slider);
      }
    }, {
      key: "_validate",
      value: function _validate(options) {
        _get(_getPrototypeOf(ZColorPicker.prototype), "_validate", this).apply(this, arguments);

        options.paletteColumns = this._validateCount(options.paletteColumns);

        if (options.otherUsedColorsHasLimit) {
          options.otherUsedColorsLimit = this._validateCount(options.otherUsedColorsLimit);
        }

        if (!options.defaultValue) {
          options.defaultValue = options.value;
        }
      }
    }, {
      key: "_noClrClickHandler",
      value: function _noClrClickHandler(orgEvent) {
        this._setValue('none', orgEvent, {
          // No I18N
          noColorButtonClick: true
        });

        this._data.closeOnSelect && this.close(orgEvent);
      }
    }, {
      key: "_defaultClrClickHandler",
      value: function _defaultClrClickHandler(orgEvent) {
        this._setValue(this._opts.defaultValue, orgEvent, {
          defaultColorButtonClick: true
        });

        this._data.closeOnSelect && this.close(orgEvent);
      }
    }, {
      key: "_onPickerDragged",
      value: function _onPickerDragged(orgEvent) {
        orgEvent.preventDefault();

        var containerOffset = this._opacitySlider.offset();

        var cursorPos = orgEvent.pageX - containerOffset.left;

        var totalPixel = this._opacitySlider.width();

        var percent = this._limit(cursorPos / totalPixel, 0, 1) * 100; // this._opacityThumb.css('left', percent + '%'); // No I18N

        percent = this._getRTLBasedPercent(percent);

        this._setAlpha(Math.round(percent) / 100, orgEvent);
      }
    }, {
      key: "_updateColorField",
      value: function _updateColorField() {
        if (this._colorBox && !this._skipClrFieldUpdate) {
          this._colorBox.val(this._noFill ? '' : this._colorInstance.getColor(this._data.colorField.colorMode, undefined, false)); // No I18N

        }
      }
    }, {
      key: "_fieldChangeHandler",
      value: function _fieldChangeHandler(orgEvent) {
        var _this107 = this;

        // timer
        clearTimeout(this._fieldChangeTimer);
        this._fieldChangeTimer = setTimeout(function () {
          var colorCode = _this107._colorBox.val();

          var colorInstance = _this107._getClrInstance(colorCode);

          _this107._skipClrFieldUpdate = orgEvent.type === 'input'; // No I18N

          if (colorInstance.isValid()) {
            _this107._setValue(colorInstance.getObject(), orgEvent);
          } else {
            _this107._updateColorField();
          }

          _this107._skipClrFieldUpdate = false;
        });
      }
    }, {
      key: "_calcDimension",
      value: function _calcDimension() {
        // Title height
        var titleHeight = 0;

        if (this._titleBar) {
          titleHeight = this._titleBar.outerHeight();
        }

        this._showHideContainer[0].style['max-height'] = 'calc(100% - ' + titleHeight + 'px)'; // No I18N

        var pickerWd = this._basicPicker[0].offsetWidth;
        this._pickerWd = pickerWd ? pickerWd + 'px' : ''; // No I18N

        var pickerHt = this._basicPicker[0].offsetHeight;
        this._pickerHt = pickerHt ? pickerHt + titleHeight + 'px' : ''; // No I18N

        this._advPickerWd = this._advPickerHt = 0;
        var advPicker = this._advPicker;

        if (advPicker) {
          // Setting advancedpicker width to retrieve the values correctly.
          this._data.advancedPicker.instance.setDimension();

          var pickerWidth = advPicker[0].offsetWidth;
          var pickerHeight = advPicker[0].offsetHeight;
          this._advPickerWd = pickerWidth ? pickerWidth + 'px' : ''; // No I18N

          this._advPickerHt = pickerHeight ? pickerHeight + titleHeight + 'px' : ''; // No I18N
        }
      }
    }, {
      key: "_updateDim",
      value: function _updateDim() {
        // this._setPickerDim('', ''); // No I18N
        this._calcDimension();

        if (this._advPickerVisible) {
          this._setPickerDim(this._advPickerWd, this._advPickerHt);
        } else {
          this._setPickerDim(this._pickerWd, this._pickerHt);
        }
      }
    }, {
      key: "_setPaletteData",
      value: function _setPaletteData(data, options) {
        data.palettes = [];
        data.defaultPalette = [];
        data.otherUsedColors = data.standardPalette = false;

        this._setDefaultPaletteData();

        if (options.standardColors) {
          this._setStandardPaletteData();
        }

        this._addPalettes(options.otherPalettes);

        options.otherUsedColors && this._setRecentColorsPalette();
      }
    }, {
      key: "_setStandardPaletteData",
      value: function _setStandardPaletteData() {
        var options = this._opts;

        var presetData = this._getPresetColors(options.standardColorsPalette);

        if (presetData) {
          this._data.standardPalette = this._getPaletteTemplateData({
            heading: options.standardColorsHeading || this._getI18NText('standardColorsHeading'),
            // No I18N
            name: 'standardcolors',
            // No I18N
            colors: presetData.colors
          });
        }
      }
    }, {
      key: "_setDefaultPaletteData",
      value: function _setDefaultPaletteData() {
        var options = this._opts;
        var defaultPaletteData = options.defaultPaletteType === 'custom' && options.customPalette; // No I18N

        if (!defaultPaletteData) {
          var presetData = this._getPresetColors('preset'); // No I18N


          defaultPaletteData = {
            colors: presetData.colors,
            hasTones: true,
            tones: presetData.tones
          };
        }

        defaultPaletteData.heading = defaultPaletteData.heading || options.defaultPaletteHeading || this._getI18NText('defaultColorsHeading'); // No I18N

        defaultPaletteData.name = 'themecolors'; // No I18N

        this._data.defaultPalette = this._getPaletteTemplateData(defaultPaletteData);
      }
    }, {
      key: "_setPickerDim",
      value: function _setPickerDim(width, height) {
        this.element.css({
          width: width,
          height: height
        });
      }
    }, {
      key: "_getPresetColors",
      value: function _getPresetColors(name) {
        return this.presetPalettes[name];
      }
    }, {
      key: "_updatePalettes",
      value: function _updatePalettes() {
        this._opts.otherPalettes = this._data.palettes.map(function (paletteTemplateData) {
          return paletteTemplateData.paletteData;
        });

        this._updateUI(true);
      }
    }, {
      key: "_advPickerCancelHandler",
      value: function _advPickerCancelHandler(orgEvent) {
        this.close(orgEvent);
      }
    }, {
      key: "_advPickerBackHandler",
      value: function _advPickerBackHandler(orgEvent) {
        this._switchToBasic(orgEvent);

        this.setFocus();
      }
    }, {
      key: "_advPickerOkHandler",
      value: function _advPickerOkHandler(orgEvent, data) {
        this._setValue(data.rgb, orgEvent, data, true);

        if (this._floating) {
          this.close(orgEvent);
        } else {
          this._addToRecentColors(orgEvent);
        }
      }
    }, {
      key: "_advPickerColorfieldListChangeHandler",
      value: function _advPickerColorfieldListChangeHandler(orgEvent, data) {
        this._trigger('colorfieldlistchange', orgEvent, data); // No I18N

      }
    }, {
      key: "_advPickerSelectHandler",
      value: function _advPickerSelectHandler(orgEvent, data) {
        this._setValue(data.currentRGB, orgEvent, data, false, true);
      }
    }, {
      key: "_addToRecentColors",
      value: function _addToRecentColors(orgEvent) {
        var options = this._opts;

        if (options.otherUsedColors && !this._noFill && !this._defaultColor && !this._selectedPan.length) {
          if (this._trigger('beforeotherusedcoloradd', orgEvent)) {
            // No I18N
            options.otherUsedColorsList = this._addColors(this._data.otherUsedColors, this._selectedInstance.getColor(), options.otherUsedColorsHasLimit ? 0 : undefined);

            this._trigger('otherusedcoloradd', orgEvent); // No I18N

          }
        }
      }
    }, {
      key: "_triggerChange",
      value: function _triggerChange(orgEvent, data) {
        // if( !this._opts.opacity || fromuser ){
        if (!this._avoidPickTrigger) {
          if (this._fromInit || this._currentColor !== this._selectedInstance.getColor()) {
            this._updateSelectedColor();

            this._trigger('change', orgEvent, data); // No I18N

          }

          this._trigger('pick', orgEvent, data); // No I18N

        } // }

      }
    }, {
      key: "_triggerSelect",
      value: function _triggerSelect(orgEvent, prevColor, data) {
        if (prevColor !== this._currentColor) {
          this._trigger('select', orgEvent, data); // No I18N

        }
      }
    }, {
      key: "_updateSelection",
      value: function _updateSelection(data) {
        var _this108 = this;

        var palettes = _toConsumableArray(data.palettes);

        palettes.push(data.defaultPalette);
        data.standardPalette && palettes.push(data.standardPalette);
        data.otherUsedColors && palettes.push(data.otherUsedColors);
        palettes.forEach(function (palette) {
          return _this108._updateClrSelection(palette.colors);
        });
      }
    }, {
      key: "_setAdvancedPickerValue",
      value: function _setAdvancedPickerValue(value) {
        this._data.advancedPicker.instance.setAttributes({
          value: value
        });

        this._advPicker.removeClass('zcolorpicker'); // No I18N

      }
      /* Function to select a color */

    }, {
      key: "_setValue",
      value: function _setValue(color, orgEvent, data, fromUser, selectFromAdvPicker) {
        var isNoFill = color === 'none' || color === 'transparent'; // No I18N

        var colorInstance = this._getClrInstance(isNoFill ? 'rgba(0,0,0,0)' : color); // No I18N


        if (colorInstance.isValid()) {
          colorInstance.initialColor = color;
          var prevColor = this._currentColor;
          this._colorInstance = colorInstance;
          this._currentColor = colorInstance.getColor();
          this._noFill = data && data.noColorButtonClick || isNoFill;
          this._defaultColor = data && data.defaultColorButtonClick;

          if (!selectFromAdvPicker) {
            this._mustRender = true;

            this._updateUI();

            this._mustRender = false;
          }

          this._triggerSelect(orgEvent, prevColor, data);

          if (!selectFromAdvPicker) {
            this._triggerChange(orgEvent, data);

            if (this._advPickerVisible) {
              this._setAdvancedPickerValue(colorInstance.getObject());
            }

            (fromUser || this._fromInit) && this._addToRecentColors(orgEvent);
          }
        }
      }
    }, {
      key: "_moreClrClickHandler",
      value: function _moreClrClickHandler() {
        this._advPickerVisible = true;

        this._setAdvancedPickerValue(this._currentColor);

        this._setPickerDim(this._advPickerWd, this._advPickerHt);

        this._makeSeen(this._advPicker);

        this._setTransitionMargin('-' + this._pickerWd); // No I18N


        this._reposition();
      }
    }, {
      key: "_switchToBasic",
      value: function _switchToBasic() {
        if (this._advPickerVisible) {
          this._advPickerVisible = false;

          this._setPickerDim(this._pickerWd, this._pickerHt);

          this._makeSeen(this._basicPicker);

          this._setTransitionMargin(0);

          if (this._opened) {
            this._reposition();
          } else {
            this._makeUnSeen(this._advPicker);
          }
        }
      }
    }, {
      key: "_addTransitionEvents",
      value: function _addTransitionEvents() {
        var include = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var container = this._showHideContainer;

        if (include) {
          this._addEvents({
            pickerSwitch: ZC._transitionEnd
          }, container);
        } else {
          this._removeEvents('', container); // No I18N

        }
      }
    }, {
      key: "_setTransitionMargin",
      value: function _setTransitionMargin(margin) {
        this._basicPicker.css(this._opts.rtl ? 'margin-right' : 'margin-left', margin); // No I18N

      }
    }, {
      key: "_pickerSwitchHandler",
      value: function _pickerSwitchHandler(orgEvent) {
        if (this._showHideContainer.is($(orgEvent.currentTarget))) {
          if (this._advPickerVisible) {
            this._makeUnSeen(this._basicPicker);

            this._data.advancedPicker.instance.setFocus();
          } else {
            this._makeUnSeen(this._advPicker);

            this._avoidPickTrigger = true;

            this._setValue(this._selectedInstance.initialColor, orgEvent);

            this._avoidPickTrigger = false;
          }

          this._addTransitionEvents(false);

          this._addTransitionClass(false);
        }
      }
    }, {
      key: "_updateCurrentColor",
      value: function _updateCurrentColor() {
        this._colorInstance = this._selectedInstance;
        this._currentColor = this._colorInstance.getColor();
      }
    }, {
      key: "_addTransitionClass",
      value: function _addTransitionClass() {
        var add = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this.element[add ? 'addClass' : 'removeClass']('zcolorpicker--transition'); // No I18N
      }
    }, {
      key: "_reposition",
      value: function _reposition() {
        if (!this._data.dragged && this._floating) {
          this._addTransitionEvents();

          this._addTransitionClass();

          this._setPosition();
        }
      }
    }, {
      key: "_onClose",
      value: function _onClose(orgEvent) {
        // this._opts.opacity && this._triggerChange( orgEvent, true );
        this._opened = false;
        this._avoidPickTrigger = true;

        this._switchToBasic(orgEvent);

        this._setValue(this._selectedInstance.initialColor, orgEvent, null, true);

        _get(_getPrototypeOf(ZColorPicker.prototype), "_onClose", this).apply(this, arguments);

        this._avoidPickTrigger = false;
      }
    }, {
      key: "_getPosition",
      value: function _getPosition(positionSettings) {
        var _this109 = this;

        positionSettings.computeElementDim = false;
        var borderThickness = this._borderThickness;
        var advPickerHt = parseInt(this._advPickerHt);
        var advPickerWd = parseInt(this._advPickerWd);
        var pickerHt = parseInt(this._pickerHt);
        var pickerWd = parseInt(this._pickerWd);
        positionSettings.callbacks = {
          beforeComputingDir: {
            dimensionModifier: function dimensionModifier(targetDim, elemDim) {
              var elementWidth, elementHeight;

              if (_this109._advPickerVisible) {
                elementWidth = advPickerWd;
                elementHeight = advPickerHt;
              } else {
                elementWidth = Math.max(advPickerWd, pickerWd);
                elementHeight = Math.max(advPickerHt, pickerHt);
              }

              elemDim.width = elementWidth + borderThickness;
              elemDim.height = elementHeight + borderThickness;
            }
          },
          beforeComputingPos: {
            dimensionModifier: function dimensionModifier(targetDim, elemDim) {
              if (!_this109._advPickerVisible) {
                elemDim.width = pickerWd + borderThickness;
                elemDim.height = pickerHt + borderThickness;
              }
            }
          }
        };
        return _get(_getPrototypeOf(ZColorPicker.prototype), "_getPosition", this).call(this, positionSettings);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        // Incase of webcomponent the destroy method is called automatically when the element is removed.
        if (!this.isCE) {
          // Picker is destroyed
          this._destroyPicker();

          this._destroyComp(this._data.opacityField);
        }

        _get(_getPrototypeOf(ZColorPicker.prototype), "_destroy", this).apply(this, arguments);
      }
    }, {
      key: "_destroyPicker",
      value: function _destroyPicker() {
        if (this._advPicker) {
          this._data.advancedPicker.instance.destroy();

          this._advPicker = undefined;
        }
      }
    }, {
      key: "_setRecentColorsPalette",
      value: function _setRecentColorsPalette() {
        var options = this._opts;
        this._data.otherUsedColors = this._getPaletteTemplateData({
          heading: options.otherUsedColorsHeading || this._getI18NText('otherUsedColorsHeading'),
          // No I18N
          name: 'otherusedcolors',
          // No I18N
          colors: options.otherUsedColorsList,
          maxColorsCount: options.otherUsedColorsHasLimit && options.otherUsedColorsLimit
        });
      }
    }, {
      key: "_setOpacityLeft",
      value: function _setOpacityLeft(data) {
        data.opacitySlider.left = this._getRTLBasedPercent(Math.round(this._colorInstance.getAlpha() * 100));
      }
    }, {
      key: "_setOpacityData",
      value: function _setOpacityData(data, options) {
        if (options.opacity) {
          data.opacity = true;
          var isDecimal = options.opacityFieldType === 'decimal',
              // No I18N
          max = 100,
              suffix = '%',
              // No I18N
          step,
              decimalPlaces;

          if (isDecimal) {
            max = 1;
            step = 0.01;
            suffix = ''; // No I18N

            decimalPlaces = 2;
          }

          var opacityChangeHandler = this._opacityChangeHandler.bind(this);

          var opacityField = _objectSpread({}, this._getBasicNumberFieldOptions(), {}, {
            id: this._getID('opacityfield'),
            // No I18N
            max: max,
            suffix: suffix,
            step: step,
            decimalPlaces: decimalPlaces,
            className: 'zcolorpicker__opacityfield',
            // No I18N
            spin: opacityChangeHandler,
            change: opacityChangeHandler,
            input: opacityChangeHandler,
            customAttributes: {
              'aria-label': this._getI18NText('opacityField') // No I18N

            }
          });

          if (data.opacityField) {
            data.opacityField.instance.setAttributes(opacityField);
          } else {
            data.opacityField = opacityField;
          }

          data.opacitySlider = {
            id: this._getID('opacityslider'),
            // No I18N
            rtl: data.rtl,
            opacity: true,
            thumbIcon: this._getThumbData(options.opacitySlider)
          };
        } else {
          this._destroyComp(data.opacityField);

          if (data.opacitySlider) {
            this._getById(data.opacitySlider.id).off();
          }

          data.opacity = data.opacityField = data.opacitySlider = false;
        }
      }
    }, {
      key: "_updateOpacityValues",
      value: function _updateOpacityValues() {
        this._setOpacitySliderClr();

        this._setOpacityField();
      }
    }, {
      key: "_setOpacitySliderClr",
      value: function _setOpacitySliderClr() {
        var rgbObj = this._colorInstance.getObject();

        var context = this._opacityCanvasContext;

        var rgb = this._colorInstance.getColor('rgb', undefined, false); // No I18N


        var canvas = context.canvas;
        context.rect(0, 0, canvas.width, canvas.height);
        context.clearRect(0, 0, canvas.width, canvas.height);
        var gradient = context.createLinearGradient(0, 0, canvas.width, 0);

        this._setGradientColors(gradient, ["rgba(".concat(rgbObj.r, ", ").concat(rgbObj.g, ", ").concat(rgbObj.b, ", 0)"), rgb]);

        context.fillStyle = gradient;
        context.fill();
      }
    }, {
      key: "_setOpacityField",
      value: function _setOpacityField() {
        if (!this._skipAlphaFieldUpdate) {
          var alpha = this._colorInstance.getAlpha();

          this._data.opacityField.instance.setAttribute('value', this._opts.opacityFieldType === 'decimal' ? alpha : Math.round(alpha * 100)); // No I18N

        }
      }
    }, {
      key: "_opacityChangeHandler",
      value: function _opacityChangeHandler(orgEvent) {
        var value = orgEvent.detail.value;
        this._skipAlphaFieldUpdate = true;

        this._setAlpha(this._opts.opacityFieldType === 'decimal' ? value : value / 100, orgEvent); // No I18N


        this._skipAlphaFieldUpdate = false;
      }
    }, {
      key: "_setClrFieldData",
      value: function _setClrFieldData(data, options) {
        if (data.colorField) {
          // To avoid memory leak
          this._getById(data.colorField.id).off();
        }

        data.colorField = false;

        if (options.colorField) {
          var colorFieldOptions = options.colorFieldOptions;
          var colorMode = colorFieldOptions.colorMode;
          data.colorField = {
            colorMode: this._REGEX.colorMode.test(colorMode) ? colorMode : this._colorMode,
            id: this._getID('colorfield'),
            // No I18N
            label: this._getI18NText('colorField'),
            // No I18N
            preview: colorFieldOptions.preview,
            readonly: colorFieldOptions.readonly
          };
        }
      }
    }, {
      key: "_storeClrFieldRef",
      value: function _storeClrFieldRef(colorField) {
        this._colorBox = this._getById(colorField.id);

        this._bindTextField(this._colorBox);
      }
    }, {
      key: "_storeAdvPickerRef",
      value: function _storeAdvPickerRef(data) {
        var advancedPicker = data.advancedPicker;

        this._addEvents({
          moreClrClick: 'click' // No I18N

        }, this._getById(data.moreColorBtn.id));

        this._setMainEle(advancedPicker);

        var advPicker = this._advPicker = $(advancedPicker.mainElement);

        if (!this._advPickerVisible) {
          this._makeUnSeen(advPicker);
        }
      }
    }, {
      key: "_setMoreClrsData",
      value: function _setMoreClrsData(options, data) {
        if (data.advancedPicker) {
          this._getById(data.advancedPicker.id).off();
        }

        if (options.advancedPicker) {
          var moreClrBtn = data.moreColorBtn = {
            id: this._getID('morecolors'),
            // No I18N
            label: options.advancedPickerButtonLabel || this._getI18NText('advancedPicker') // No I18N

          };

          ZC._getIconInfo(options.advancedPickerIconClassName || options.advancedPickerIconClass, options.advancedPickerSVGIconId, 'zc__svg--zcolorpicker-advancedpicker', 'zcolorpicker__icon zbutton__icon', moreClrBtn.icon = {}); // No I18N


          ZC._getIconInfo(options.advancedPickerArrowIconClassName || options.advancedPickerArrowIconClass, options.advancedPickerArrowSVGIconId, 'zc__svg--rightarrow', 'zcolorpicker__icon zh-arrowicon zh-alignright', data.rightArrow = {}); // No I18N


          this._setAdvPickerData(options, data);
        } else {
          this._destroyPicker();

          data.advancedPicker = data.moreColorBtn = false;
        }
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        if (value === 'valueColorModel') {
          // No I18N
          this._changedAttrs.push('advancedPicker'); // No I18N


          this._domChanged = true;
        }

        var response = _get(_getPrototypeOf(ZColorPicker.prototype), "_setAttribute", this).call(this, optionName, value);

        if (response === false) {
          var regex = {
            defaultColorButton: /^(defaultValue|defaultColorButton|defaultColorButtonLabel)$/,
            noColorButton: /^(noColorButton|noColorButtonLabel|noColorIconClassName|noColorSVGIconId)$/,
            palette: /^(defaultPaletteHeading|defaultPaletteType|customPalette|standardColors|standardColorsHeading|standardColorsPalette|paletteColumns|otherPalettes|otherUsedColors|otherUsedColorsHeading|otherUsedColorsList|otherUsedColorsHasLimit|otherUsedColorsLimit)$/,
            colorField: /^(colorField|colorFieldOptions)$/,
            opacity: /^(opacity|opacitySlider|opacityFieldType)$/,
            advancedPicker: /^(advancedPicker|advancedPickerIconClassName|advancedPickerArrowIconClassName|advancedPickerSVGIconId|advancedPickerArrowSVGIconId|advancedPickerButtonLabel|advancedPickerOptions)$/
          };
          this._opts[optionName] = value;

          for (var mod in regex) {
            if (regex[mod].test(optionName)) {
              this._changedAttrs.push(mod);

              this._domChanged = true;

              if (optionName === 'opacity') {
                // No I18N
                if (!value) {
                  this._setValue(this._currentColor);
                }
              }
            }
          }
        }
      }
    }, {
      key: "name",
      get: function get() {
        return "zcolorpicker";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          defaultValue: 'rgba(0,0,0,1)',
          // No I18N
          defaultColorButton: true,
          // defaultColorButtonLabel: "Default Color", //No I18N
          defaultColorButtonLabel: null,
          noColorButton: true,
          // noColorButtonLabel: "No Fill", //No I18N
          noColorButtonLabel: null,
          noColorIconClass: null,
          noColorSVGIconId: null,
          // defaultPaletteHeading:"Preset Colors", //No I18N
          defaultPaletteHeading: null,
          defaultPaletteType: 'preset',
          // No I18N
          customPalette: null,
          standardColors: true,
          // standardColorsHeading:"Standard Colors", //No I18N
          standardColorsHeading: null,
          standardColorsPalette: 'ms-office',
          // No I18N
          colorField: false,
          opacity: false,
          opacityFieldType: 'percent',
          // No I18N
          advancedPicker: true,
          // advancedPickerButtonLabel: "More Colors", //No I18N
          advancedPickerButtonLabel: null,
          advancedPickerIconClass: null,
          advancedPickerSVGIconId: null,
          advancedPickerArrowIconClass: null,
          advancedPickerArrowSVGIconId: null,
          otherUsedColors: true,
          otherUsedColorsHasLimit: true,
          otherUsedColorsLimit: 10,
          // otherUsedColorsHeading:"Other Used Colors", //No I18N
          otherUsedColorsHeading: null,
          otherUsedColorsList: [],
          closeOnSelect: true // className: null,

        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          otherPalettes: [],
          advancedPickerOptions: {
            commandBar: {
              leftColumn: {
                commands: ['back'] // No I18N

              },
              rightColumn: {
                commands: ['cancel', 'OK'] // No I18N

              },
              middleColumn: false
            }
          },
          noColorIconClassName: null,
          advancedPickerIconClassName: null,
          advancedPickerArrowIconClassName: null,
          colorFieldOptions: {
            colorMode: 'auto',
            // No I18N
            readonly: false,
            preview: true
          },
          opacitySlider: {
            thumbIconClassName: null,
            thumbSVGIconId: null
          },
          labels: {
            noColor: 'No Fill',
            // No I18N
            defaultColor: 'Default Color',
            // No I18N
            defaultColorsHeading: 'Preset Colors',
            // No I18N
            standardColorsHeading: 'Standard Colors',
            // No I18N
            otherUsedColorsHeading: 'Other Used Colors',
            // No I18N
            advancedPicker: 'More Colors',
            // No I18N
            colorField: 'Color Field',
            // No I18N
            opacityField: 'Opacity Field' // No I18N

          }
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['beforeotherusedcoloradd', // No I18N
        'otherusedcoloradd', // No I18N
        'colorfieldlistchange' // No I18N
        ];
      }
    }, {
      key: "presetPalettes",
      get: function get() {
        return {
          preset: {
            colors: [{
              color: '#ffffff',
              // No I18N
              tones: [{
                'function': 'shade',
                // No I18N
                percent: 10
              }, {
                'function': 'shade',
                // No I18N
                percent: 20
              }, {
                'function': 'shade',
                // No I18N
                percent: 40
              }, {
                'function': 'shade',
                // No I18N
                percent: 60
              }, {
                'function': 'shade',
                // No I18N
                percent: 80
              }, {
                'function': 'shade',
                // No I18N
                percent: 90
              }, {
                'function': 'shade',
                // No I18N
                percent: 100
              }]
            }, '#ef1616', '#ef8216', '#efb116', '#5dc35a', '#38d7bb', '#16d0ef', '#398ef3', '#c516ef', 'ef166f'],
            // No I18N
            tones: [{
              'function': 'tint',
              // No I18N
              percent: 90
            }, {
              'function': 'tint',
              // No I18N
              percent: 80
            }, {
              'function': 'tint',
              // No I18N
              percent: 60
            }, {
              'function': 'tint',
              // No I18N
              percent: 40
            }, {
              'function': 'tint',
              // No I18N
              percent: 20
            }, {
              'function': 'shade',
              // No I18N
              percent: 30
            }, {
              'function': 'shade',
              // No I18N
              percent: 70
            }]
          },
          vga: {
            colors: [{
              color: '000000' // No I18N
              // title:"Black" //No I18N

            }, {
              color: '0000aa' // No I18N
              // title:"Blue" //No I18N

            }, {
              color: '00aa00' // No I18N
              // title:"Green" //No I18N

            }, {
              color: '00aaaa' // No I18N
              // title:"Cyan" //No I18N

            }, {
              color: 'aa0000' // No I18N
              // title:"Red" //No I18N

            }, {
              color: 'aa00aa' // No I18N
              // title:"Magenta" //No I18N

            }, {
              color: 'aa5500' // No I18N
              // title:"Brown" //No I18N

            }, {
              color: 'aaaaaa' // No I18N
              // title:"Gray" //No I18N

            }, {
              color: '555555' // No I18N
              // title:"Dark gray" //No I18N

            }, {
              color: '5555ff' // No I18N
              // title:"Bright blue" //No I18N

            }, {
              color: '55ff55' // No I18N
              // title:"Bright green" //No I18N

            }, {
              color: '#55ffff' // No I18N
              // title:"Bright cyan"  //No I18N

            }, {
              color: '#ff5555' // No I18N
              // title:"Bright red" //No I18N

            }, {
              color: '#ff55ff' // No I18N
              // title:"Bright magenta" //No I18N

            }, {
              color: '#ffff55' // No I18N
              // title:"Yellow" //No I18N

            }, {
              color: '#ffffff' // No I18N
              // title:"White" //No I18N

            }]
          },
          'ms-office': {
            // No I18N
            colors: [[192, 0, 0], [255, 0, 0], [255, 192, 0], [255, 255, 0], [146, 208, 80], [0, 176, 80], [0, 176, 240], [0, 112, 192], [0, 32, 96], [112, 48, 160]]
          }
        };
      }
    }]);

    return ZColorPicker;
  }(ZC.ZColorPickerBase);

  ZC.registerComponent('ZColorPicker', ZC.ZColorPickerBase, ZColorPicker);

  (function (ZC) {
    var template = ZC.zcolorpicker.Templates;
    var utilities = ZC.Templates.Utilities;
    var colorpickerBaseTemplate = ZC.zcolorpickerbase.Templates;

    template.children = function (data) {
      var returnTemplate = ZT.html(_templateObject159(), data.hasCallout && ZT.html(_templateObject160()), data.title && colorpickerBaseTemplate.title(data), data.noColorBtn && template.noColorBtn(data), data.defaultColor && template.defaultColorBtn(data), data.defaultPalette && colorpickerBaseTemplate.palette(data.defaultPalette), data.standardPalette && colorpickerBaseTemplate.palette(data.standardPalette), data.palettes && data.palettes.map(function (paletteData) {
        return colorpickerBaseTemplate.palette(paletteData);
      }), data.otherUsedColors && colorpickerBaseTemplate.palette(data.otherUsedColors), data.advancedPicker && ZT.html(_templateObject161(), data.moreColorBtn.id, data.moreColorBtn.label, utilities.icon(data.moreColorBtn.icon), data.moreColorBtn.label, utilities.icon(data.rightArrow)), (data.colorField || data.opacity) && ZT.html(_templateObject162(), data.colorField && template.colorField(data.colorField), data.opacity && template.opacity(data)), data.advancedPicker && ZC.createAdvancedColorPicker(data.advancedPicker));
      return returnTemplate;
    };

    template.colorField = function (data) {
      var returnTemplate = ZT.html(_templateObject163(), data.preview && ZT.html(_templateObject164(), data.rgb), data.id, data.readonly, data.label, data.readonly ? 'h-cursor' : '');
      return returnTemplate;
    };

    template.defaultColorBtn = function (data) {
      var returnTemplate = ZT.html(_templateObject165(), data.defaultColor.id, data.defaultColor.label, data.defaultColor.rgb, data.defaultColor.label);
      return returnTemplate;
    };

    template.noColorBtn = function (data) {
      var returnTemplate = ZT.html(_templateObject166(), data.noColorBtn.id, data.noColorBtn.label, utilities.icon(data.noColorBtn.icon), data.noColorBtn.label);
      return returnTemplate;
    };

    template.opacity = function (data) {
      var returnTemplate = ZT.html(_templateObject167(), colorpickerBaseTemplate.slider(data.opacitySlider), ZC.createNumberField(data.opacityField));
      return returnTemplate;
    };
  })(ZComponents);

  var ZComboBox =
  /*#__PURE__*/
  function (_ZC$ZSelect) {
    _inherits(ZComboBox, _ZC$ZSelect);

    function ZComboBox() {
      _classCallCheck(this, ZComboBox);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZComboBox).apply(this, arguments));
    }

    _createClass(ZComboBox, [{
      key: "_init",
      value: function _init(element, options) {
        options.showSearchField = options.multiple = false;

        _get(_getPrototypeOf(ZComboBox.prototype), "_init", this).call(this, element, options);
      }
    }, {
      key: "_storeRef",
      value: function _storeRef() {
        _get(_getPrototypeOf(ZComboBox.prototype), "_storeRef", this).call(this);

        this._arrowTarget = this.container.find('i.zselectbox__arrowicon'); // No I18N

        this._inputField = this.container.find('input'); // No I18N
      }
    }, {
      key: "_postRender",
      value: function _postRender() {
        _get(_getPrototypeOf(ZComboBox.prototype), "_postRender", this).call(this);

        this._inputField[0].id = this.listInstance._getID('searchbox'); // No I18N

        this._addEvents({
          inputMouseUp: 'mouseup' // No I18N

        }, this._inputField);
      }
    }, {
      key: "_inputMouseUpHandler",
      value: function _inputMouseUpHandler() {
        if (this._highlightText) {
          this._highlightContent();
        }
      }
    }, {
      key: "_preRender",
      value: function _preRender() {
        if (!this._data.tempRender) {
          return _get(_getPrototypeOf(ZComboBox.prototype), "_preRender", this).call(this);
        }

        return this._data;
      }
    }, {
      key: "_getListSettings",
      value: function _getListSettings() {
        var _this110 = this;

        var settings = _get(_getPrototypeOf(ZComboBox.prototype), "_getListSettings", this).call(this);

        var inputFieldSettings = settings.inputFieldSettings;
        var callbacks = settings.callbacks;
        settings.showAllItemsOnDOWNKeyPress = true;
        inputFieldSettings.autoFill = this._opts.autoFill;
        inputFieldSettings.showSearchField = false;
        callbacks.input = this._inputHandler.bind(this);
        callbacks.newvalue = this._newValueHandler.bind(this);

        callbacks.esckeypress = function () {
          return _this110._updateView();
        }; // To revert the selection


        settings.inputField = this._inputField;

        if (this._opts.autoComplete) {
          settings.search.criteria = 'startswith'; // No I18N
        }

        return settings;
      }
    }, {
      key: "_onAttrChange",
      value: function _onAttrChange(data) {
        _get(_getPrototypeOf(ZComboBox.prototype), "_onAttrChange", this).apply(this, arguments);

        if (data.isCustom) {
          data.isCustom = false;
          data.hasText = true;
        }

        data.attrs.tabindex = data.disabled ? null : -1;
      }
    }, {
      key: "_newValueHandler",
      value: function _newValueHandler(orgEvent) {
        if (this._altered && this.listInstance._noResults && this._opts.acceptNewValues) {
          this._setValue(this._inputField[0].value, orgEvent);
        } else {
          this._updateView();
        }

        this._opened && this._close(orgEvent);
      }
    }, {
      key: "_menuBeforeHideHandler",
      value: function _menuBeforeHideHandler(orgEvent) {
        var originalEvent = orgEvent.originalEvent;

        if (this._lastHoveredId) {
          var ZkeyCode = ZC.keyCode; // When the option is autofilled - it needs to be selected when ENTER or TAB key is pressed and there is no hover state on the item.
          // if (originalEvent && (originalEvent.keyCode === ZkeyCode.ENTER || originalEvent.keyCode === ZkeyCode.TAB)) {

          if (!originalEvent || originalEvent.keyCode !== ZkeyCode.ESCAPE) {
            $('#' + this._lastHoveredId).trigger('mouseup'); // No I18N

            return false;
          }

          this._lastHoveredId = undefined;
        }

        return _get(_getPrototypeOf(ZComboBox.prototype), "_menuBeforeHideHandler", this).apply(this, arguments);
      }
    }, {
      key: "_keyDownHandler",
      value: function _keyDownHandler() {}
    }, {
      key: "_keyPressHandler",
      value: function _keyPressHandler() {}
    }, {
      key: "_inputHandler",
      value: function _inputHandler(orgEvent) {
        this._lastHoveredId = undefined;
        this._altered = true;
        var autoComplete = this._opts.autoComplete;

        if (!autoComplete || !this._inputField[0].value) {
          this._iconShow('none'); // No I18N

        }

        if (autoComplete) {
          this._autoComplete(orgEvent);
        }

        var clearButton = this._data.clearButton;

        if (clearButton) {
          this._hideClrBtn(clearButton.mainElement);
        }
      }
    }, {
      key: "_iconShow",
      value: function _iconShow(display) {
        if (this._data.hasIcon) {
          this.container[0].querySelector('.zselectbox__icon').style.display = display; // No I18N
        }
      }
    }, {
      key: "_afterBlur",
      value: function _afterBlur(orgEvent) {
        if (!this._isFocussed()) {
          _get(_getPrototypeOf(ZComboBox.prototype), "_afterBlur", this).call(this, orgEvent);

          this._newValueHandler(orgEvent);

          this._altered = this._lastHoveredId = this._focussed = false; // Triggering blur for the container results in repeatedly calling blurHandler

          this.container.removeClass('has-focus has-mfocus has-kfocus'); // No I18N
        }
      }
    }, {
      key: "_updateView",
      value: function _updateView(optData) {
        var data = this._data;
        data.rendered && this._iconShow(''); // No I18N

        this._lastHoveredId = undefined;

        if (optData) {
          data.tempRender = true;
          this._lastHoveredId = this._getItemId(optData);

          this._setIconTextData(optData, data);
        }

        _get(_getPrototypeOf(ZComboBox.prototype), "_updateView", this).call(this);
      }
    }, {
      key: "_itemHoverHandler",
      value: function _itemHoverHandler(orgEvent, eventData) {
        if (eventData.keyEvent && this._opts.autoFill && eventData.listItemData.selectable) {
          this._updateView(eventData.data);
        }

        return _get(_getPrototypeOf(ZComboBox.prototype), "_itemHoverHandler", this).apply(this, arguments);
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender() {
        var data = this._data;

        _get(_getPrototypeOf(ZComboBox.prototype), "_postEachRender", this).apply(this, arguments);

        this._inputField[0].value = data.label;

        this._highlightContent();

        this._altered = data.tempRender;
        data.tempRender = false;
      }
    }, {
      key: "_getRenderText",
      value: function _getRenderText(optData) {
        return this._getLabel(optData, false);
      }
    }, {
      key: "_focusHandler",
      value: function _focusHandler() {
        if (document.activeElement !== this._inputField[0] && !this._manualFocus) {
          this._manualFocus = true;

          this._inputField.focus();
        }

        this._manualFocus = false;

        if (!this._altered && !this._focussed) {
          this._highlightContent();

          this._highlightText = true;
        }

        this._focussed = true;

        _get(_getPrototypeOf(ZComboBox.prototype), "_focusHandler", this).call(this);
      }
    }, {
      key: "_highlightContent",
      value: function _highlightContent() {
        if (this._isFocussed()) {
          this._inputField.select();
        }

        this._highlightText = false;
      }
    }, {
      key: "_setFocus",
      value: function _setFocus() {
        this._inputField.focusin();
      }
    }, {
      key: "_open",
      value: function _open(orgEvent) {
        this.listInstance.openDropdownList(orgEvent);
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        if (optionName === 'autoComplete') {
          // No I18N
          this._opts[optionName] = value;
          this._reInit = true;
        } else if (/^(multiple|selectionLimit|searchable)$/.test(optionName)) {
          return;
        }

        _get(_getPrototypeOf(ZComboBox.prototype), "_setAttribute", this).call(this, optionName, value);
      }
    }, {
      key: "_callMethod",
      value: function _callMethod(method) {
        this._skipRender = true;
        method();
        this._skipRender = false;

        this._updateView();
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this._callMethod(_get(_getPrototypeOf(ZComboBox.prototype), "setValue", this).bind(this, value));
      }
    }, {
      key: "deselectAllOptions",
      value: function deselectAllOptions(orgEvent) {
        this._callMethod(_get(_getPrototypeOf(ZComboBox.prototype), "deselectAllOptions", this).bind(this, orgEvent));
      }
    }, {
      key: "name",
      get: function get() {
        return "zcombobox";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          autoFill: true,
          autoComplete: false
        };
      }
    }, {
      key: "CLASSES",
      get: function get() {
        return {
          CONTAINER: 'zselectbox zcombobox' // No I18N

        };
      }
    }, {
      key: "SELECTORS",
      get: function get() {
        return {
          OPTIONSBODY: 'z-comboboxbody',
          // No I18N
          OPTIONSHEADER: 'z-comboboxheader',
          // No I18N
          OPTIONSFOOTER: 'z-comboboxfooter' // No I18N

        };
      }
    }]);

    return ZComboBox;
  }(ZC.ZSelect);

  ZC.registerComponent('ZComboBox', ZC.ZSelect, ZComboBox);

  (function (ZC) {
    var template = ZC.zcombobox.Templates;
    var utilities = ZC.Templates.Utilities;

    template.container = function () {
      return ZT.html(_templateObject168());
    };

    template.children = function (data) {
      return ZT.html(_templateObject169(), ZT.html(_templateObject170(), data.icon && utilities.icon(data.icon), ZT.html(_templateObject171(), data.disabled, data.tabindex, data.label, data.placeholder)), data.clearButton && ZC.createButton(data.clearButton), utilities.icon(data.arrow));
    };
  })(ZComponents);

  var ZDatePicker =
  /*#__PURE__*/
  function (_ZC$CoreComponent16) {
    _inherits(ZDatePicker, _ZC$CoreComponent16);

    function ZDatePicker() {
      _classCallCheck(this, ZDatePicker);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZDatePicker).apply(this, arguments));
    }

    _createClass(ZDatePicker, [{
      key: "_setFormat",
      value: function _setFormat() {
        this._dateFormat = this._opts.format;
      }
    }, {
      key: "_isBtnsExist",
      value: function _isBtnsExist() {
        return this._checkIfButtonsExist() || this._isColumnExists();
      }
    }, {
      key: "_setOKCancelBtns",
      value: function _setOKCancelBtns() {
        var opts = this._opts;
        opts.OKButton = !opts.immediateCommit;
        opts.cancelButton = !opts.immediateCommit && !opts.hideCancelButton;
      }
    }, {
      key: "_init",
      value: function _init(element, options, shouldRender) {
        this._todayDate = new Date();
        this._userOptions = $.extend({}, options);
        var navBar = options.navigationBar,
            forElement = options.forElement,
            value = options.value;

        this._validateFormat();

        if (this._invalidFormat) {
          return;
        }

        this._setFormat();

        options.locale = options.locale || ZC.locale;
        navBar && (this._yearNavigation = navBar.yearNavigationButtons);
        options.position && (this._isPositionModified = options.position);

        this._setSwitcherType(navBar);

        if (this._yearNavigation === undefined && /^(drilldown|none)$/.test(navBar.monthYearSwitcherType)) {
          this._yearNavigation = true;
        }

        this._rowsCount = [];

        this._setOKCancelBtns();

        (this._isBtns = this._isBtnsExist()) && this._setBtnProps();

        this._getLocaleValues();

        forElement && (this._forElement = $(forElement));
        this.element[0].setAttribute('tabindex', 0); //  No I18N

        var optVal = ['minDate', 'maxDate', 'value']; // No I18N

        this._monthsPerView = options.monthsPerView;
        this._selectedDates = [];
        (options.disabledDates.length || options.specialDates.length || options.disabledTimeList && options.disabledTimeList.length) && this._convertStringToObject({
          disabledDates: options.disabledDates,
          specialDates: options.specialDates,
          disabledTimeList: options.disabledTimeList
        });

        for (var i = 0, len = optVal.length; i < len; i++) {
          var part = optVal[i],
              _value = options[part],
              viewDate = void 0;

          if (_value) {
            this._parseValue(part, _value);

            options[part] instanceof Date && !this._checkTime && options[part].setHours(0, 0, 0, 0);

            if (part === 'value') {
              /**  revisit - try to reuse setValue() method
                   !== 'multiple' added instead of === 'single' to use it commonly for range picker
               */
              if (this._isNotNull(options.value) && this._dateWithInRange(options.value) && !this._getUniqueClass(options.value) && this._opts.selectionType !== 'multiple') {
                // No I18N
                this._currentSelected = new Date(+options.value);

                if (!this._viewDate) {
                  viewDate = this._viewDate = this._currentSelected;

                  this._changeMonth(false, viewDate, 1);
                }

                this._valueUpdate = true;
              } else {
                options[part] = undefined;
              }
            }
          }

          if (part === 'value') {
            !this._viewDate && this._setHours();
          } else {
            this['_' + part] = options[part];
          }
        }

        this._validateOpts();

        (options.minDate || options.maxDate) && this._processLimits();

        if (!value && options.values.length === 0) {
          (options.monthToBeShownOnOpen || options.yearToBeShownOnOpen) && this._setViewOnOpen();
        }

        options.selectionType === 'multiple' && this._setValues(); // No I18N

        options.value && (this._currentSelected = new Date(+options.value));
        !this._data.month && (this._data.month = []);
        this._elementId = this._getID(this.element); // No I18N

        this._buildData(shouldRender);

        var elem = this.element[0];
        options.width && (elem.style.width = options.width + 'px'); // No I18N

        options.height && (elem.style.height = options.height + 'px'); // No I18N

        return true;
      }
    }, {
      key: "_setSwitcherType",
      value: function _setSwitcherType(navBar) {
        var value = navBar.monthYearSwitcherType;
        this._isDrilldown = value === 'drilldown'; // No I18N

        this._isDropdown = value === 'dropdown'; // No I18N
      }
    }, {
      key: "_getLocaleValues",
      value: function _getLocaleValues() {
        var opts = this._opts,
            labels = opts.labels,
            locale = ZC.localeInfo[opts.locale];

        if (locale) {
          var arr = ['days', 'daysAbbreviated', 'monthsAbbreviated', 'months']; // No I18N

          for (var i = 0, len = arr.length; i < len; i++) {
            labels[arr[i]] = locale[arr[i]] || labels[arr[i]];
          }
        }

        opts.firstDayOfWeek = locale ? locale.firstDayOfWeek || 0 : 0;
      }
    }, {
      key: "_invokeOtherActions",
      value: function _invokeOtherActions() {
        var opts = this._opts,
            title = opts.title;

        if (opts.type === 'inline') {
          // No I18N
          this._display();
        } else if (title && title.length && opts.draggable) {
          this._initDraggable();
        }
      }
    }, {
      key: "_validateOpts",
      value: function _validateOpts() {
        var opts = this._opts,
            displayType = 'monthYearSwitcherType',
            // No I18N
        position = opts.position,
            navBar = opts.navigationBar,
            type = opts.displatype,
            yearNavigation = this._yearNavigation;
        opts.drilldownLevelOnOpen = opts.drilldownLevelOnOpen || 'dates'; // No I18N

        opts.format = opts.format || 'dd/MM/yyyy'; // No I18N

        position = opts.position = position === 'auto' ? type === 'callout' ? 'bottom' : 'bottom-left' : position; // No I18N

        (opts.minDate || opts.maxDate) && this._checkLimits();
        navBar[displayType] = ['dropdown', 'drilldown', 'none'].indexOf(navBar[displayType]) > -1 ? navBar[displayType] : 'none'; // No I18N

        if (['top', // No I18N
        'bottom', // No I18N
        'right', // No I18N
        'left', // No I18N
        'top-left', // No I18N
        'top-right', // No I18N
        'bottom-left', // No I18N
        'bottom-right' // No I18N
        ].indexOf(position) === -1) {
          opts.position = 'bottom'; // No I18N
        }

        if (!navBar.monthSwitcher && !navBar.yearSwitcher) {
          opts[displayType] = 'none'; // No I18N
        }

        type = opts.displayType;
        type = ['box', 'callout'].indexOf(type) > -1 ? type : 'box'; // No I18N

        if (this._data) {
          this._data.displayType = type;
        }

        navBar.yearNavigationButtons = yearNavigation === undefined ? !this._isDropdown : yearNavigation; // No I18N

        navBar.monthYearHeadingFormat = ['MMM yyyy', 'MMMM yyyy', 'yyyy MMM', 'yyyy MMMM'].indexOf(navBar.monthYearHeadingFormat) > -1 ? navBar.monthYearHeadingFormat : 'MMMM yyyy'; // No I18N
      }
    }, {
      key: "_constructData",
      value: function _constructData() {
        var data = this._data,
            opts = this._opts,
            navBar = opts.navigationBar; // No I18N

        if (opts.title && !data.title) {
          data.title = this._getTitleData();
        }

        this._viewMode === undefined && (this._viewMode = this._isDrilldown ? this._getViewMode() : 0); // No I18N

        data.dropdownCls = this._isDropdown && navBar.monthNavigationButtons && navBar.yearNavigationButtons; // No I18N

        for (var i = 0; i < this._monthsPerView; i++) {
          var month = data.month[i] = data.month[i] || {},
              newDate = new Date(+this._viewDate);
          month.className = '';
          month.weekTitle = opts.weekHeading || 'Week'; // No I18N

          newDate = this._moveMonth(this._viewDate, i);

          this._fillDayOfWeek(month);

          this._fillDates(month, newDate, opts.monthsPerView > 1 ? i : undefined);

          month.monthsPerView = opts.monthsPerView;
          month.displayWeekNumbers = opts.displayWeekNumbers;

          this._constructNavBar(month, i, newDate);

          (i === 0 || i === this._monthsPerView - 1) && (month.viewDate = newDate);
        }

        var cls = 'zdatetimepicker__month '; // No I18N

        if (!opts.allowSelectionOfAdjacentMonthDates) {
          cls += 'zdatetimepicker--adjacentmonthdatereadonly'; // No I18N
        }

        this._setMonthVal('className', cls); // No I18N


        opts.drilldownLevelOnOpen !== 'dates' && this._isDrilldown && this._generateContent(this.element); // No I18N

        if (!this._data.rendered && this._isBtns) {
          this._createButtons();
        }
      }
    }, {
      key: "_isColumnExists",
      value: function _isColumnExists() {
        var commandBar = this._opts.commandBar;

        if (commandBar) {
          var columns = ['leftColumn', 'centerColumn', 'rightColumn']; // No I18N

          for (var i = 0; i < columns.length; i++) {
            if (commandBar[columns[i]]) {
              var commands = commandBar[columns[i]].commands;

              for (var _i4 = 0; _i4 < commands.length; _i4++) {
                this._opts[commands[_i4] + 'Button'] = true; // No I18N
              }

              return true;
            }
          }

          return false;
        }
      }
    }, {
      key: "_buildData",
      value: function _buildData(shouldRender) {
        var disabledCls = 'zdatetimepicker--disabledcalendar'; // No I18N

        this._rowsCount = [];
        this._viewMode === 0 && this.element.find('.' + disabledCls).removeClass(disabledCls); // No I18N

        this._constructData();

        this._data._isRenderedAgain = true;
        shouldRender && this._render();
      }
    }, {
      key: "_postRender",
      value: function _postRender(elem, data) {
        var pickerCls = ' zdatetimepicker'; // No I18N

        this._invokeOtherActions();

        this._data.className += pickerCls + (data.monthsPerView === 1 ? '' : '--group ') + (data.dropdownCls ? pickerCls + '--dropdownyearbutton ' : ''); // No I18N

        data.appendTo && elem.appendTo($(data.appendTo));
        elem[0].setAttribute('id', this._elementId); // No I18N

        (data.customHTMLAboveCalendar || data.customHTMLAboveNavigationBar || data.customHTMLBelowCalendar) && this._setCustomHTML();
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender(elem) {
        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._data;
        var pickerCls = ' zdatetimepicker',
            // No I18N
        firstRender = !this._data.rendered,
            isRendered = firstRender || data._isRenderedAgain,
            // No I18N
        modifiedAttr = data.modifiedAttr,
            opts = this._opts,
            isDropdown = this._isDropdown,
            isNavButtons = opts.navigationBar.monthNavigationButtons || opts.navigationBar.yearNavigationButtons;

        if (isRendered || modifiedAttr) {
          if (firstRender || ['navBar', 'monthsPerView'].indexOf(modifiedAttr) > -1) {
            //  No I18N
            if (isDropdown) {
              this._assignHeaders();

              var bindHeaderEvents = this._bindHeaderEvents.bind(this);

              bindHeaderEvents('year', 'select'); // No I18N

              bindHeaderEvents('month', 'combobox'); // No I18N

              this._checkOptions();
            } else if (this._isDrilldown) {
              this._bindDrillDownClickEvent(); // need to do for setAttribute changes


              this._monthEventBinded = this._yearEventBinded = this._decadeEventBinded = undefined;
            }
          }

          if (firstRender || ['navBar', 'monthsPerView'].indexOf(modifiedAttr) > -1) {
            var className = this._data.className,
                cls = pickerCls + (this._monthsPerView === 1 ? '' : '--group') + (data.dropdownCls ? pickerCls + '--dropdownyearbutton' : ''); // to avoid duplication of classes everytime (for drilldownLevelOnOpen other than dates)

            cls !== this._data.className && (this._data.className = className ? className + cls : cls); // No I18N

            if (isNavButtons) {
              this._bindArrowEvents();

              for (var i = 0; i < this._monthsPerView; i++) {
                this._setArrowMainElement(data.month[i].navigationBar);
              }
            }
          }

          if ((firstRender || ['commandBar', 'monthsPerView'].indexOf(modifiedAttr) > -1) && this._isBtns) {
            this._updateCommandBar(elem);
          }

          if (isRendered || modifiedAttr === 'monthsPerView' || isDropdown) {
            var calendar = elem.find('.zdatetimepicker__month'); // No I18N

            if (opts.selectionType === 'multiple') {
              // No I18N
              calendar.attr('aria-multiselectable', true); // No I18N
            } else {
              calendar.removeAttr('aria-multiselectable'); // No I18N
            }
          }

          if (firstRender || modifiedAttr === 'displayType') {
            this._pointer = this._opts.displayType === 'callout' ? elem.find('.zdatetimepicker__pointer') : undefined; // No I18N
          }

          if (opts.title && (firstRender || modifiedAttr === 'title')) {
            this._enableDrag && this._initDraggable();

            this._setCloseEle();

            this._enableDrag = undefined;
          }
        }

        this._doesExist(this._clear) && this._setClearBtnCls(undefined, undefined, true); // offsetParent not working and hence changing it to visible

        this._setPosition && this.element.is(':visible') && this._positionPicker(); // No I18N

        if (isNavButtons) {
          for (var _i5 = 0; _i5 < this._monthsPerView; _i5++) {
            this._updateArrowState(data.month[_i5].viewDate, _i5);
          }
        }

        var viewMode = this._viewMode;

        if (this._isDrilldown && viewMode && (opts.navigationBar.monthSwitcher || opts.navigationBar.yearSwitcher)) {
          this._updateYearArrowState(viewMode, viewMode < 3 ? viewMode < 2 ? this._viewDate.getFullYear() : this._yearStart : this._decadeStart);
        }

        this._data.modifiedAttr = this._data._isRenderedAgain = this._setPosition = undefined;
      }
    }, {
      key: "_hasClosest",
      value: function _hasClosest(event, toFind, curTarget) {
        var target = curTarget ? event.currentTarget : event.target;
        return $(target).closest(toFind).length;
      }
    }, {
      key: "_clearValues",
      value: function _clearValues(event) {
        var opts = this._opts,
            immediateCommit = opts.immediateCommit,
            arr = ['zdatetimepicker__calendar', 'zdatetimepicker__drilldowncell']; // No I18N

        if (immediateCommit) {
          this._valueUpdate = false;
          opts.value = undefined;
          opts.values = [];
        }

        this._setHours(true);

        for (var i = 0; i < 2; i++) {
          var elems = this.element.find('.' + arr[i]).find(this._getSelector());

          this._select(false, elems, true);

          elems.removeAttr('aria-disabled'); // No I18N
        }

        this._setDateClass('is-disabled', false, this.element.find('.zdatetimepicker__calendar').find(this._getSelector()), true); // No I18N


        this._selectedDates = [];
        this._queryString = ''; // No I18N

        this._currentSelected = undefined;

        this._render();

        immediateCommit && this._dispatchEvent('change', event, this._getSelectedValue()); // No I18N
      }
    }, {
      key: "_cancelClickHandler",
      value: function _cancelClickHandler(orgEvent) {
        if (this._clearClickHandler) {
          // check is added for rangePickers, where clearValues() is not necessary
          this._clearClickHandler(orgEvent);
        } else {
          // Used in case if clearButton is false and values should be cleared
          this._clearValues(orgEvent);
        }

        this._closePicker(orgEvent);

        this._dispatchEvent('cancel', orgEvent, this._getSelectedValue()); // No I18N


        this._removeFocus(this._cancel);
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        this._addEvents({
          mousedown: 'mousedown',
          // No I18N
          mouseover: 'mouseover',
          // No I18N
          keydown: 'keydown' // No I18N

        });
      }
    }, {
      key: "_keydownHandler",
      value: function _keydownHandler(orgEvent) {
        if (orgEvent.keyCode === ZC.keyCode.ESCAPE) {
          this._closePicker(orgEvent);
        }
      }
    }, {
      key: "_mouseoverHandler",
      value: function _mouseoverHandler(orgEvent) {
        var arr = ['date', 'adjacentmonthdate'],
            // No I18N
        target = $(orgEvent.target),
            relatedTarget = $(orgEvent.relatedTarget),
            pickerCls = 'zdatetimepicker__',
            // No I18N
        isNotSpan; // No I18N
        // added because datemouseover is called two times for both span and td

        isNotSpan = !relatedTarget.hasClass("".concat(pickerCls, "text")) && !target.hasClass("".concat(pickerCls, "text")); // No I18N

        for (var i = 0; i < arr.length; i++) {
          if (isNotSpan && this._hasClosest(orgEvent, ".".concat(pickerCls) + arr[i])) {
            // No I18N
            this._dispatchEvent('datemouseover', orgEvent, {
              // No I18N
              cell: $(orgEvent.target)
            });

            break;
          }
        }
      }
    }, {
      key: "_placePicker",
      value: function _placePicker() {
        var element = this.element;

        if (element.finish) {
          element.finish();
        } else {
          element.stop(true, true);
        }

        this._display();

        this._positionPicker();
      }
    }, {
      key: "_validateFormat",
      value: function _validateFormat() {
        this._checkFormat(/h|H|m|t/g); // No I18N

      }
    }, {
      key: "_checkFormat",
      value: function _checkFormat(partsRegex) {
        this._invalidFormat = partsRegex.test(this._opts.format);
      }
    }, {
      key: "getElement",
      value: function getElement() {
        return this.element;
      }
    }, {
      key: "_reInitPicker",
      value: function _reInitPicker() {
        this._opts = $.extend(true, {}, this._DEFAULTS, this._userOptions);

        this._init(this.element, this._opts, true);
      }
    }, {
      key: "open",
      value: function open(forElement) {
        if (!ZC.Date.areDatesEqual(this._todayDate, new Date())) {
          this._reInitPicker();
        }

        forElement && this._setAttribute('forElement', forElement); // No I18N

        var opts = this._opts,
            isInline = opts.type === 'inline'; // No I18N

        if (!isInline && (opts.forElement || opts.offset) || isInline) {
          this._showPicker();
        }
      }
    }, {
      key: "close",
      value: function close() {
        this._manualClose = true;

        this._closePicker();

        this._manualClose = false;
      }
    }, {
      key: "_getBtnsArr",
      value: function _getBtnsArr() {
        return ['today', 'clear', 'cancel', 'OK']; // No I18N
      }
    }, {
      key: "_resetTime",
      value: function _resetTime(datesObject) {
        if (datesObject instanceof Date) {
          var date = new Date(+datesObject);
          date.setHours(0, 0, 0, 0);
          return date;
        }
      }
    }, {
      key: "_dispatchChangeEvent",
      value: function _dispatchChangeEvent(ev, type, val) {
        this._dispatchEvent(type + 'change', ev, {
          // No I18N
          viewDate: this._viewDate,
          value: this._opts.value,
          selectedValue: val === undefined ? this._viewDate.getFullYear() : val
        });
      }
    }, {
      key: "_arrowEventHandler",
      value: function _arrowEventHandler(ev) {
        var id = ev.currentTarget.id;

        if (id.indexOf('month') > -1) {
          // No I18N
          var _index = parseInt(id.slice(-1)),
              str = _index === 0 ? 'MonthArrow' : _index === 1 ? 'Year' : 'DecadeArrow'; // No I18N


          this['_handle' + str + 'Click'](ev); // No I18N
        } else {
          this._opts.navigationBar.yearNavigationButtons && this._handleYearArrowClick(ev);
        }
      }
    }, {
      key: "_checkIfButtonsExist",
      value: function _checkIfButtonsExist() {
        var opts = this._opts;
        return opts.OKButton || opts.todayButton || opts.cancelButton || opts.clearButton;
      }
    }, {
      key: "_isBig",
      value: function _isBig(part, date) {
        var isTrue = ZC.Date.isGreater(this['_' + part + 'Date'], date); // No I18N

        return part === 'max' ? !isTrue : isTrue; // No I18N
      }
    }, {
      key: "_moveMonth",
      value: function _moveMonth(date, moveBy) {
        if (!(date && !isNaN(+date)) || !moveBy) {
          return moveBy ? this._viewDate : date;
        }

        var newDate = new Date(date.valueOf()),
            day = newDate.getDate(),
            month = newDate.getMonth(),
            newMonth,
            monthVal,
            isTrue,
            lessThanZero = moveBy < 0;

        if (lessThanZero || moveBy >= 1) {
          newMonth = month + moveBy;
          newDate.setMonth(newMonth);
          newMonth = (newMonth + 12) % 12;
        }

        monthVal = newDate.getMonth();
        isTrue = date.getFullYear() === newDate.getFullYear();

        while (lessThanZero ? monthVal === month && isTrue : monthVal !== newMonth) {
          isTrue = true;
          newDate.setDate(--day);
          newDate.setMonth(newMonth);
          monthVal = newDate.getMonth();
        }

        return newDate;
      }
    }, {
      key: "_showPicker",
      value: function _showPicker() {
        var _this111 = this;

        var elem = this.element,
            dispatchEvent = this._dispatchEvent.bind(this),
            opts = this._opts,
            obj = this._getObj();

        this._dragEnd = false;

        if (dispatchEvent('beforeopen', undefined, obj)) {
          // No I18N
          if (opts.type !== 'inline' && ZC.bindDocumentEvents && opts.closeOnBodyClick) {
            // No I18N
            ZC.bindDocumentEvents({
              element: elem,
              forElement: this._forElement,
              ctype: this.name,
              closeMethodName: 'close',
              // No I18N
              closeEvent: 'close' // No I18N

            });
          }

          this._placePicker();

          Object.keys(opts.animation).length && this._setAnimation('open'); // No I18N

          elem.attr({
            'aria-hidden': false,
            // No I18N
            'aria-expanded': true // No I18N

          });

          if (dispatchEvent('beforefocus', {}, elem)) {
            // No I18N
            clearTimeout(this._focusTimeout);
            this._focusTimeout = setTimeout(function () {
              return _this111.element.focus();
            }, 100);
          }

          dispatchEvent('open', undefined, obj); // No I18N
        }
      }
    }, {
      key: "_positionPicker",
      value: function _positionPicker() {
        var $element = this.element,
            element = $element[0],
            opts = this._opts,
            offset = opts.offset;
        $element.width(opts.width || ''); // element.style.width = element.style.width || '';// No I18N

        if (opts.type === 'popup') {
          // No I18N
          if (this._monthsPerView === 3 && ZC._display === 'flex') {
            // No I18N
            $element.css('flex-direction', 'column'); // No I18N

            $element.width($element.width());
            $element.css('flex-direction', ''); // No I18N
          }

          if (offset) {
            $element.css(offset);
          } else if (opts.forElement) {
            var position = this._getPosition(),
                direction,
                pointerElem = this._pointer ? this._pointer[0] : null;

            if (position) {
              direction = position.direction;
              this._direction = direction;
              opts.displayType !== 'callout' && $element.addClass('zdatetimepicker--' + direction.replace('-', '')); // No I18N

              if (opts.margin) {
                position.elementPosition = this._retrieveMarginValues(position.elementPosition);
              }

              var posValue = position.elementPosition;
              element.style.top = posValue.top + 'px'; // No I18N

              element.style.left = posValue.left + 'px'; // No I18N

              if (pointerElem) {
                var arrowPos = position.arrowPosition;
                pointerElem.style.top = typeof arrowPos.top === 'number' ? arrowPos.top + 'px' : ''; // No I18N

                pointerElem.style.left = typeof arrowPos.left === 'number' ? arrowPos.left + 'px' : ''; // No I18N
              }
            }
          }
        }
      }
    }, {
      key: "_retrieveMarginValues",
      value: function _retrieveMarginValues(position) {
        var margin = this._opts.margin,
            arr = ['top', 'left'],
            // No I18N
        value;

        for (var i = 0; i < 2; i++) {
          value = position[arr[i]];
          value += typeof margin === 'number' ? margin : margin[arr[i]] || 0; // No I18N

          position[arr[i]] = value < 0 ? position[arr[i]] : value;
        }

        return position;
      }
    }, {
      key: "_arrowCallback",
      value: function _arrowCallback(element, direction) {
        var elem = this.element,
            pickerCls = 'zdatetimepicker--'; // No I18N

        elem.removeClass(pickerCls + 'top ' + pickerCls + 'bottom ' + pickerCls + 'left ' + pickerCls + 'right ' + pickerCls + 'topleft ' + pickerCls + 'topright ' + pickerCls + 'bottomleft ' + pickerCls + 'bottomright'); // No I18N

        elem.addClass(pickerCls + direction); // No I18N

        this._calloutDirection = direction;
      }
    }, {
      key: "_getPosition",
      value: function _getPosition() {
        var opts = this._opts,
            position = ZC.Position,
            positionAlterable = opts.positionAlterable;

        if (position && !this._dragEnd) {
          var base = this;
          return position.get(this._forElement, this.element, {
            direction: this._direction || opts.position,
            bufferSpace: 6,
            rtl: opts.rtl,
            positionAlterable: positionAlterable,
            arrow: {
              element: this._pointer,
              callback: this._arrowCallback.bind(base),
              margin: {
                left: -1,
                top: -1
              }
            }
          });
        }
      }
    }, {
      key: "_getSelector",
      value: function _getSelector() {
        return '.is-selected,.is-disabled:not(.zdisabled)'; // No I18N
      }
    }, {
      key: "_isGreater",
      value: function _isGreater(first, second) {
        return ZC.Date.isGreater(first, second) && !ZC.Date.areDatesEqual(first, second);
      }
    }, {
      key: "_setHours",
      value: function _setHours(notAssign) {
        !notAssign && (this._viewDate = new Date());

        this._viewDate.setHours(0, 0, 0, 0);
      }
    }, {
      key: "_updateValues",
      value: function _updateValues() {
        if (this._valueUpdate) {
          var opts = this._opts,
              value = opts.value,
              values = opts.values,
              minTime = this._minTime,
              date = new Date();

          if (opts.selectionType === 'multiple') {
            // No I18N
            this._handleMultipleSelectOnClose();
          }

          var selectedDates = this._selectedDates,
              selectedLen = selectedDates.length; // Revisit - later

          date.setHours(minTime ? minTime.getHours() : 0, minTime ? minTime.getMinutes() : 0, 0, 0);
          this._viewDate = value ? new Date(+value) : values && values.length && selectedLen ? new Date(+selectedDates[selectedLen - 1]) : date;
          (opts.minDate || opts.maxDate) && this._checkLimits();
        } else {
          this._resetValues();
        }
      }
    }, {
      key: "_resetValues",
      value: function _resetValues() {
        var opts = this._opts;
        this._valueUpdate = false;
        opts.value = this._currentSelected = this._selectedTime = undefined;
        opts.values = this._selectedDates = [];

        this._setDateClass(['is-disabled', 'is-selected'], false, this.element.find('.zdatetimepicker__calendar').find(this._getSelector()), true); // No I18N


        this.element.find('.zdatetimepicker__drilldowncell').find(this._getSelector()).removeClass('is-disabled', 'is-selected');
        this._queryString = ''; // No I18N
        // Added so that on picker close when the view date is modified, viewDate switches back to current date

        this._setHours();

        this._doesExist(this._clear) && this._traverseBtns('clearButton', 'is-disabled', true); // No I18N

        this._render();

        (this._minDate || this._maxDate) && this._checkViewDate(new Date(+this._viewDate));
        (opts.monthToBeShownOnOpen || opts.yearToBeShownOnOpen) && this._setViewOnOpen();
      }
    }, {
      key: "_getObj",
      value: function _getObj() {
        return {
          viewMode: this._viewMode,
          element: this.element
        };
      }
    }, {
      key: "_closePickerHandler",
      value: function _closePickerHandler(orgEvent) {
        if (this._dispatchEvent('beforeclose', orgEvent, this._getObj())) {
          // No I18N
          var animation = this._opts.animation;
          Object.keys(this._opts.animation).length && this._setAnimation('close', orgEvent); // No I18N

          if (!animation || animation && !animation.name) {
            this._closeHandler();
          }
        }
      }
    }, {
      key: "_changeMonth",
      value: function _changeMonth(isRender, date, val) {
        var opts = this._opts,
            selectedDateMonthViewIndex = opts.selectedDateMonthViewIndex;

        if (this._monthsPerView > 1 && selectedDateMonthViewIndex && selectedDateMonthViewIndex >= (val || 0)) {
          this._viewDate = this._moveMonth(date || opts.value, -selectedDateMonthViewIndex);
          isRender === undefined && (isRender = true);
        }

        isRender && this._buildData(true);
      }
    }, {
      key: "_refreshPicker",
      value: function _refreshPicker() {
        var isDrilldown = this._isDrilldown,
            // No I18N
        viewmode,
            viewdate = this._viewDate,
            sameYear = this._oldDate.getFullYear() === this._viewDate.getFullYear();

        viewmode = isDrilldown && this._getViewMode();

        if (viewmode !== this._viewMode || this._oldDate.getMonth() !== viewdate.getMonth() && sameYear || !sameYear) {
          isDrilldown && this._setViewMode(viewmode, true);
          this._doNotBuildTime = true;

          this._buildData(true);

          isDrilldown && this._addDisabledCls();
        }

        isDrilldown && this._removeEffects();
      }
    }, {
      key: "_closePicker",
      value: function _closePicker(orgEvent) {
        var viewdate = this._viewDate,
            opts = this._opts,
            value = opts.value,
            closepickerHandler = this._closePickerHandler.bind(this);

        if (viewdate) {
          if (opts.selectionType === 'multiple' && opts.values.length === 0 && opts.immediateCommit) {
            // No I18N
            this._valueUpdate = false;
          }

          var curSelected = this._currentSelected;

          if (curSelected && value && !ZC.Date.areDatesEqual(curSelected, value)) {
            this._select(false, this._currentSelectedEle, true, true);
          }

          this._oldDate = new Date(+viewdate);
          this._currentSelected = value ? new Date(+value) : undefined;

          this._updateValues();

          if (opts.type !== 'inline' || this._manualClose) {
            // No I18N
            closepickerHandler(orgEvent);
          }

          this._refreshPicker();

          opts.selectedDateMonthViewIndex !== undefined && opts.value && this._changeMonth();

          if (opts.value && this._viewDate) {
            // It's unary plus
            this._doesExist(this._clear) && this._traverseBtns('clearButton', 'is-disabled', false); // No I18N

            this._select(true, this.element.find('[data-time="' + +this._resetTime(opts.value) + '"]'), false, true); // No I18N

          }
        } else {
          closepickerHandler(orgEvent);
        }
      }
    }, {
      key: "_getBoolVal",
      value: function _getBoolVal(part, date) {
        var optVal = this['_' + part + 'Date'];

        if (optVal) {
          optVal = new Date(+optVal);
          !this._checkTime && optVal.setHours(0, 0, 0);
          var isEqual = ZC.Date.areDatesEqual(date, optVal);
          return (part === 'min' ? +date > +optVal : +date < +optVal) || isEqual; // No I18N
        }

        return true;
      }
    }, {
      key: "_dateWithInRange",
      value: function _dateWithInRange(date) {
        !this._checkTime && date.setHours(0, 0, 0);
        return this._getBoolVal('min', date) && this._getBoolVal('max', date); // No I18N
      }
    }, {
      key: "_getDateElem",
      value: function _getDateElem(date) {
        var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.element;
        // it is unary plus
        return elem.find("[data-time='" + +date + "']"); // No I18N
      }
    }, {
      key: "_getFirstDate",
      value: function _getFirstDate() {
        var dates = this._data.month[0].dates[0],
            i;

        for (i = 0; i < dates.length; i++) {
          if (dates[i].text !== '' && dates[i]["class"].indexOf('zdatetimepicker__date') > -1) {
            break;
          }
        }

        return dates[i].time;
      }
    }, {
      key: "_mousedownHandler",
      value: function _mousedownHandler(orgEvent) {
        var target = $(orgEvent.target),
            opts = this._opts,
            disabledCls = 'is-disabled',
            // No I18N
        dispatch,
            selectedVal,
            time,
            viewDate = this._viewDate,
            mode = this._viewMode,
            arr = ['date', 'adjacentmonthdate'],
            // No I18N
        pickerCls = 'zdatetimepicker__',
            // No I18N
        hasMonthCls,
            adjDates = opts.allowSelectionOfAdjacentMonthDates,
            hasYearCls,
            selectedDate,
            renderDate,
            allowSpan = target.is(".".concat(pickerCls, "text")) ? !(target.closest('.' + pickerCls + 'date').hasClass(disabledCls) ? true : adjDates && target.closest('.' + pickerCls + 'adjacentmonthdate').hasClass(disabledCls)) : true;

        if (!target.is(".".concat(pickerCls, "date:not(.").concat(disabledCls, "), .").concat(pickerCls, "text, .").concat(pickerCls, "adjacentmonthdate:not(.").concat(disabledCls, "), .").concat(pickerCls, "monthview:not(.").concat(disabledCls, "), .").concat(pickerCls, "year:not(.").concat(disabledCls, "), .").concat(pickerCls, "decade:not(.").concat(disabledCls, ")")) || !allowSpan) {
          // No I18N
          return;
        }

        orgEvent.preventDefault();

        for (var i = 0; i < 2; i++) {
          if (this._hasClosest(orgEvent, '.' + pickerCls + arr[i])) {
            // No I18N
            target = target.closest('.' + pickerCls + arr[i]); // No I18N

            break;
          }
        }

        selectedVal = this._translateAToE(target.text());
        hasYearCls = target.hasClass(pickerCls + 'year'); // No I18N

        hasMonthCls = target.hasClass(pickerCls + 'monthview'); // No I18N

        time = target.attr('data-time'); // No I18N

        time && (selectedDate = new Date(parseInt(time))); // No I18N

        if (target.hasClass('' + pickerCls + 'date') && selectedDate) {
          // No I18N
          this._setDate(orgEvent, target, selectedDate);
        } else if (adjDates && target.hasClass(pickerCls + 'adjacentmonthdate') && selectedDate) {
          // No I18N
          this._setDate(orgEvent, target, selectedDate);

          this._viewDate = new Date(+selectedDate);

          this._changeMonth(true);

          if (['single', 'multiple'].indexOf(opts.selectionType) > -1 && !target.hasClass('is-selected')) {
            this._select(true, this._getDateElem(selectedDate), true, true); // No I18N

          }
        } else if (hasMonthCls || hasYearCls) {
          // this event is added for a request by a team (to prevent date rendering after clicking a month with drilldownlevelonopen with months)
          // since they don't need dates and want to show something else while clicking a month
          renderDate = this._dispatchEvent('before' + (hasMonthCls ? 'month' : 'year') + 'change', orgEvent, {
            // No i18n
            viewDate: viewDate,
            value: opts.value,
            selectedValue: hasMonthCls ? parseInt(target.attr('data-value')) : parseInt(selectedVal) // No I18N

          });
          renderDate = renderDate !== false;
          renderDate && (dispatch = this._handleMousedownOnDrillDown(orgEvent, hasMonthCls, hasYearCls, selectedVal));
        } else if (target.hasClass(pickerCls + 'decade')) {
          // No I18N
          this._handleDecadeMousedown(orgEvent, mode, selectedVal);

          dispatch = 'decade'; // No I18N
        }

        renderDate && dispatch && this._dispatchEvent(dispatch + 'change', orgEvent, {
          // No I18N
          viewDate: viewDate,
          value: opts.value,
          selectedValue: hasMonthCls ? parseInt(target.attr('data-value')) : parseInt(selectedVal) // No I18N

        });
      }
    }, {
      key: "_select",
      value: function _select(doSelect, elem, doNotRender, addCls) {
        var type = doSelect ? 'add' : 'remove'; // No I18N

        for (var i = 0, len = elem.length; i < len; i++) {
          var ele = $(elem[i]);

          if (this._doesExist(ele)) {
            if (doSelect) {
              ele.attr('aria-selected', true); // No I18N
            } else {
              ele.removeAttr('aria-selected'); // No I18N
            }

            if (ele.hasClass('zdatetimepicker__date') || ele.hasClass('zdatetimepicker__adjacentmonthdate')) {
              // No I18N
              this._setDateClass('is-selected', doSelect, ele, doNotRender); // No I18N

            } else if (ele.is('.zdatetimepicker__year,.zdatetimepicker__monthview')) {
              this._setDrilldownClass(ele);
            } else {
              addCls = true;
            }

            addCls && ele[type + 'Class']('is-selected'); // No I18N
          }
        }
      }
    }, {
      key: "_getDateData",
      value: function _getDateData(ele) {
        var monthData = this._data.month,
            val = this._getDateEleIndex(ele),
            dateData;

        monthData[val[0]] && monthData[val[0]].dates[val[1]] && (dateData = monthData[val[0]].dates[val[1]][val[2]]); // (data-time value is checked because, for reinit case on mousedown, dates will be same but the element will be different)

        return dateData && dateData.time === +ele.attr('data-time') ? dateData : undefined; // No I18N
      }
    }, {
      key: "_getDateEleIndex",
      value: function _getDateEleIndex(ele) {
        return [this._monthsPerView === 1 ? 0 : ele.closest('.zdatetimepicker__list').index(), ele.closest('tr').index(), ele.index()]; // No I18N
      }
    }, {
      key: "_setDateClass",
      value: function _setDateClass(cls, add, elem, doNotRender) {
        _typeof(cls) !== 'object' && (cls = [cls]);

        for (var i = 0, len = elem.length; i < len; i++) {
          var ele = $(elem[i]),
              dateObj = this._getDateData(ele);

          if (dateObj) {
            // Trying to change the date object produces issue if the data is rebuilt. (clearSelection)
            var prevCls = dateObj["class"] + ' ';
            prevCls = add ? prevCls + cls.join(' ') : prevCls.replace(new RegExp(cls.join('|'), 'g'), '');
            dateObj["class"] = prevCls.trim();
          }
        }

        !doNotRender && this._render();
      }
    }, {
      key: "_setDate",
      value: function _setDate(orgEvent, target, date, valueSet) {
        var opts = this._opts,
            obj,
            immediateCommit = opts.immediateCommit,
            time = +date;
        immediateCommit && (this._valueUpdate = false); // Delayed commit doesn't reset value on date select

        this._limitReached = false;

        if (this._doesExist(this._clear)) {
          this._traverseBtns('clearButton', 'is-disabled', false); // No I18N


          this._disable(false, this._clear);
        }

        if (opts.selectionType === 'single') {
          // No I18N
          this._select(false, this.element.find('.is-selected')); // No I18N


          this._currentSelected = new Date(time);
          this._viewDate = new Date(time);
          this._currentSelectedEle = target;
          !target.closest('.zdatetimepicker__adjacentmonthdate').length && this._select(true, target); // No I18N

          if (immediateCommit) {
            opts.value = new Date(time);

            this._OKClickHandler(orgEvent, true, valueSet);
          }

          obj = {
            valueString: ZC.Date.formatDate(opts.value, opts.format),
            value: opts.value,
            selectedDate: this._viewDate
          };
        } else {
          obj = this._setMultipleDate.apply(this, arguments);
        }

        obj && this._dispatchEvent('dateselect', orgEvent, obj); // No I18N
      }
    }, {
      key: "_fillDates",
      value: function _fillDates(data, dateVal, index) {
        data.dates = [];
        data.weekNumbers = [];
        var opts = this._opts,
            element = this.element,
            value = new Date(dateVal || this._viewDate),
            year = value.getFullYear(),
            month = value.getMonth(),
            prevMonth = new Date(year, month),
            nextMonth,
            prevDate = prevMonth.getDate(),
            firstDay = prevMonth.getDay(),
            rowCount = 0,
            adjMonthDates = opts.displayAdjacentMonthDates,
            frstDayOfWeek = opts.firstDayOfWeek,
            monthsPerView = this._monthsPerView; // Added since Date Object considers two digit year in 1900's

        year < 100 && prevMonth.setFullYear(year);
        prevMonth.setDate(prevDate - (prevMonth.getDay() - frstDayOfWeek + 7) % 7);
        var list = element.closest('li.zdatetimepicker__list'); // No I18N

        index = typeof index === 'number' ? index : index === undefined ? list.length ? list.index() : -1 : index; // No I18N

        nextMonth = new Date(prevMonth);

        if ([-1, 1, 2].indexOf(index) > -1 || index === 0 && !adjMonthDates) {
          nextMonth.setDate(nextMonth.getDate() + 42);
        } else if (monthsPerView > 1 && adjMonthDates && index === 0) {
          var noOfDaysInPrev = new Date(year, prevMonth.getMonth() + 1, 0).getDate(),
              noOfDays = new Date(year, month + 1, 0).getDate();
          nextMonth.setDate((firstDay === frstDayOfWeek ? 0 : noOfDaysInPrev) + noOfDays + 1);
        }

        nextMonth.setHours(0, 0, 0, 0);
        prevMonth.setHours(0, 0, 0, 0);
        nextMonth = nextMonth.valueOf();
        var firstThursday,
            trArray = [];

        for (var i = prevMonth; i.valueOf() < nextMonth; i.setDate(i.getDate() + 1)) {
          var weekDay = i.getDay(),
              iYr = i.getFullYear(),
              iMonth = i.getMonth();
          i.setHours(0, 0, 0, 0);
          var shouldAddElement = adjMonthDates && ([-1, 0, 2].indexOf(index) > -1 || index === 1 && monthsPerView === 2) || iMonth <= month && iYr === year || iYr < year,
              totDays = new Date(iYr, iMonth + 1, 0).getDate(),
              lastDate = new Date(nextMonth),
              isTrue = void 0;
          lastDate.setDate(lastDate.getDate() - 1);
          isTrue = iMonth === month && i.getDate() === totDays && (!adjMonthDates || adjMonthDates && index === 1 && monthsPerView === 3) || ZC.Date.areDatesEqual(i, lastDate) && adjMonthDates;

          if (weekDay === frstDayOfWeek && shouldAddElement) {
            // Week number calculated as per IS0 8601 standard.
            var weekStart = new Date(+i + (frstDayOfWeek - weekDay - 7) % 7 * 86400000),
                thursdayWeek = new Date(+weekStart + (7 + 4 - weekStart.getDay()) % 7 * 86400000);
            firstThursday = new Date(Number(firstThursday = new Date(thursdayWeek.getFullYear(), 0, 1)) + (7 + 4 - firstThursday.getDay()) % 7 * 86400000);
            var weekNumber = (thursdayWeek - firstThursday) / 86400000 / 7 + 1;
            data.weekNumbers.push(this._translateEToA(weekNumber)); // length is checked or else extra row is created

            trArray.length && data.dates.push(trArray);
            trArray = [];
            rowCount++;
          }

          if (!adjMonthDates || index === 1 && index !== monthsPerView - 1 || index === monthsPerView - 1) {
            if (iMonth < month && iYr === year || iYr < year) {
              trArray.push({
                'class': '',
                // No I18N
                text: '' // No I18N

              });
              continue;
            } else if ((iMonth > month && iYr === year || iYr > year) && (index === -1 || adjMonthDates && (index === 0 || index === 1 && index !== monthsPerView - 1) || !adjMonthDates)) {
              break;
            }
          }

          var returnVal = this._getClasses(i, value),
              cellContent = {
            'class': (returnVal["class"] || returnVal).trim(),
            // No I18N
            time: +i,
            text: this._translateEToA(i.getDate()),
            title: returnVal.title || null,
            infoText: returnVal.infoText || null
          };

          this._dispatchEvent('beforedatecellrender', undefined, cellContent); // No I18N


          trArray.push(cellContent);
          isTrue && data.dates.push(trArray);
        }

        this._rowsCount.push(rowCount);
      }
    }, {
      key: "_setMonthVal",
      value: function _setMonthVal(name, val, add) {
        for (var i = 0; i < this._monthsPerView; i++) {
          var month = this._data.month[i];

          if (add === undefined) {
            month[name] = val;
          } else {
            month[name] = add ? month[name] + val : month[name].replace(/zdatetimepicker--adjacentmonthdatereadonly/g, '');
          }
        }
      }
    }, {
      key: "_constructNavBar",
      value: function _constructNavBar(month, i, newDate) {
        var navBar = this._opts.navigationBar,
            isDrilldown = this._isDrilldown,
            // No I18N
        isButtons = navBar.monthNavigationButtons || navBar.yearNavigationButtons;
        month.navigationBar = $.extend(true, {}, month.navigationBar || navBar);
        isButtons && this._getNavBtnProps(month, i, month.navigationBar);
        var curNav = month.navigationBar;
        !isButtons && (curNav["class"] = '');
        curNav.cursorCls = i === 0 && isDrilldown && (navBar.monthSwitcher || navBar.yearSwitcher) ? 'zh-cursorpointer' : ''; // No I18N

        if (this._isDropdown && i === 0) {
          this._constructDropdown(curNav);
        }

        if (this._data.modifiedAttr === 'navBar') {
          isButtons && this._setArrowMainElement(curNav); // No I18N

          this._isDropdown && this._assignHeaders();
        }

        var monthSwitch = navBar.monthSwitcher,
            yearSwitch = navBar.yearSwitcher,
            monthNav = month.navigationBar,
            isDropdown = this._isDropdown,
            isTrue = isDropdown && i !== 0;
        (!isDropdown || isTrue || i === 0 && !monthSwitch) && (monthNav.month = this._translateEToA(this._getI18NText('months' + (navBar.monthYearHeadingFormat.split(' ').indexOf('MMMM') > -1 ? '' : 'Abbreviated'))[newDate.getMonth()])); // No I18N

        (!isDropdown || isTrue || i === 0 && !yearSwitch) && (monthNav.year = this._translateEToA(newDate.getFullYear()));

        if (navBar.monthYearHeadingFormat[0] === 'y') {
          isDropdown && i === 0 && (monthNav.yrFirst = monthNav.monthSelect && monthNav.yearSelect);

          if (monthNav.month && monthNav.year) {
            var temp = monthNav.month;
            monthNav.month = monthNav.year;
            monthNav.year = temp;
          }
        }

        this._setConditions(monthNav);
      }
    }, {
      key: "_setConditions",
      value: function _setConditions(navBar) {
        navBar.isLMonthYear = navBar.lMonth || navBar.lYear;
        navBar.isRMonthYear = navBar.rMonth || navBar.rYear;
        navBar.isMonthYearNav = navBar.month || navBar.year;
        return navBar;
      }
    }, {
      key: "_OKClickHandler",
      value: function _OKClickHandler(orgEvent, isNotSubmit, valueSet) {
        var shouldClose,
            opts = this._opts,
            isZeroViewMode = this._viewMode === 0,
            currentSelected = this._currentSelected,
            okBtn = this._OK,
            isSingle = opts.selectionType === 'single',
            // No I18N
        limit = opts.selectionLimit,
            length = this._selectedDates.length,
            condtn = currentSelected || length,
            selectedTime = this._selectedTime;
        this._valueUpdate = !!condtn;

        if (isSingle) {
          var date = new Date();
          currentSelected && (date = new Date(+currentSelected));
          this._checkTime && selectedTime && date.setHours(selectedTime.getHours(), selectedTime.getMinutes(), 0, 0);
          opts.value = currentSelected ? date : undefined;
        } else {
          shouldClose = limit && limit === length && isZeroViewMode || this._hasClosest(orgEvent, '.OKButton-' + this.name); // No I18N

          this._handleOkOnMultiple(opts);
        }

        this._dispatchEvent('change', orgEvent, this._getSelectedValue()); // No I18N


        if (!valueSet && isSingle && (isNotSubmit && opts.closeOnDateSelect && isZeroViewMode || !isNotSubmit) || !isSingle && shouldClose) {
          this._closePicker(orgEvent);
        }

        this._valueUpdate = opts.value || opts.values.length;
        okBtn && this._removeFocus(okBtn);
      }
    }, {
      key: "_getSelectedValue",
      value: function _getSelectedValue() {
        return this._opts.selectionType === 'single' ? this._getSingleValue(this._opts.value) : this._getMultipleValues(); // No I18N
      }
    }, {
      key: "_removeFocus",
      value: function _removeFocus(elem) {
        // To remove the classes added by _handleFocus() in zgeneral-main.
        elem.removeClass('has-focus has-mfocus'); // No I18N
      }
    }, {
      key: "_isWeekend",
      value: function _isWeekend(date) {
        return (this._opts.weekendDays ? this._opts.weekendDays.split(',') : []).indexOf(date.getDay().toString()) > -1;
      }
    }, {
      key: "_getClasses",
      value: function _getClasses(date, dateToCompare) {
        var secondYear,
            secondMonth,
            isYrsEqual,
            isFrstYrBig,
            opts = this._opts,
            isEqual = ZC.Date.areDatesEqual.bind(ZC),
            selectedDates = this._selectedDates,
            len = selectedDates.length,
            curSelected = this._currentSelected,
            cls = ' zdatetimepicker',
            // No I18N
        firstYear = date.getFullYear(),
            firstMonth = date.getMonth(),
            classes = ''; // No I18N

        if (dateToCompare) {
          secondYear = dateToCompare.getFullYear();
          secondMonth = dateToCompare.getMonth();
          isYrsEqual = firstYear === secondYear;
          isFrstYrBig = firstYear > secondYear;
        }

        if (dateToCompare && !isFrstYrBig && !isYrsEqual || isYrsEqual && firstMonth < secondMonth || isYrsEqual && firstMonth > secondMonth || isFrstYrBig) {
          classes += cls + '__adjacentmonthdate'; // No I18N
        } else {
          classes += cls + '__date'; // No I18N
        }

        isEqual(date, new Date()) && (classes += cls + '--today'); // No I18N

        var condtn = curSelected && isEqual(date, curSelected);

        if (condtn || opts.value && isEqual(date, opts.value) && condtn) {
          classes += ' is-selected'; // No I18N
        }

        if (len && opts.selectionType === 'multiple') {
          // No I18N
          var isSelected = false;

          for (var i = 0; i < len; i++) {
            if (selectedDates[i] && isEqual(date, selectedDates[i])) {
              classes += ' is-selected'; // No I18N

              isSelected = true;
            }
          }

          if (!isSelected && opts.selectionLimit === len) {
            classes += ' is-disabled'; // No I18N
          }
        }

        if (this._isWeekend(date)) {
          classes += cls + '--weekend'; // No I18N
        }

        if (!this._dateWithInRange(date)) {
          classes += ' is-disabled zdisabled'; // No I18N
        }

        return this._getUniqueClass(date, classes, true) || classes;
      }
    }, {
      key: "_getUniqueClass",
      value: function _getUniqueClass(date, classes, checkBoth) {
        var _this112 = this;

        var arr = ['disabledDaysOfWeek', // No I18N
        'disabledDates', // No I18N
        'disabledMonths', // No I18N
        'disabledYears' // No I18N
        ];

        if (classes) {
          // since for value setting, these two need not to be used, classes check is added
          arr = [].concat(_toConsumableArray(arr), ['specialDates', 'specialDaysOfWeek']); // No I18N
        }

        arr = arr.map(function (val) {
          return !!_this112._opts[val].length;
        });
        return arr.indexOf(true) > -1 ? this._addUniqueClasses(date, classes, !checkBoth) : undefined;
      }
    }, {
      key: "_parseDateValue",
      value: function _parseDateValue(date, pattern) {
        return ZC.Date._parseDateValue(date, pattern, this._opts.otherInputFormats) || {};
      }
    }, {
      key: "_fillDayOfWeek",
      value: function _fillDayOfWeek(month) {
        month.days = [];

        var start = this._opts.firstDayOfWeek,
            classes = '',
            i18nTxt = this._getI18NText('daysAbbreviated'),
            // No I18N
        weekend = this._opts.weekendDays.split(','); // No I18N


        for (var i = start; i < start + 7; i++) {
          classes = '';

          if (i % 7 === parseInt(weekend[0]) || i % 7 === parseInt(weekend[1])) {
            classes += ' zdatetimepicker--weekend'; // No I18N
          }

          month.days.push({
            value: this._translateEToA(i18nTxt[i % 7]),
            // No I18N
            'class': ' zdatetimepicker__day ' + classes // No I18N

          });
        }
      }
    }, {
      key: "_doesExist",
      value: function _doesExist(element) {
        return element && element.length;
      }
    }, {
      key: "_parseValue",
      value: function _parseValue(optionName, value, format) {
        var isModified,
            opts = this._opts,
            parseDate = this._parseDateValue.bind(this),
            date;

        format = format || opts.format;

        if (typeof value === 'string') {
          // No I18N
          if (['TODAY', 'NOW'].indexOf(value) > -1) {
            // No I18N
            this['_' + optionName + 'HasTime'] = value === 'NOW' && optionName !== 'value'; // No I18N

            opts[optionName] = new Date();
          } else {
            date = parseDate(value, format).date || undefined;

            if (date) {
              opts[optionName] = date;
              this['_' + optionName + 'HasTime'] = true; // if datestring is given with time, then the date will be valid and so it is set true
            } else {
              date = parseDate(value, this._dateFormat).date || undefined;
              opts[optionName] = date || undefined;
            }
          }

          isModified = true;
        } else if (value instanceof Date) {
          opts[optionName] = value;
          this['_' + optionName + 'HasTime'] = true; // No I18N

          isModified = true;
        } else {
          this._oldValueOption && (isModified = true);
          opts[optionName] = undefined;
        }

        date = opts[optionName];

        if (date && !this._checkTime) {
          date.setHours(0, 0, 0, 0);
        }

        return isModified;
      }
    }, {
      key: "_setValue",
      value: function _setValue(value, shouldRender) {
        var opts = this._opts,
            isTrue = true;

        if (value === '' || !value) {
          this._setHours();

          (this._minDate || this._maxDate) && this._checkViewDate(new Date(+this._viewDate));

          this._clearValues();
        } else if (value) {
          this._parseValue('value', value, this._opts.format) && opts.value && !this._checkTime && opts.value.setHours(0, 0, 0, 0); // No I18N

          if (this._isNotNull(opts.value) && this._dateWithInRange(opts.value) && !this._getUniqueClass(opts.value)) {
            // No I18N
            this._currentSelected = new Date(+opts.value);
            this._viewDate = new Date(+opts.value);
            this._valueUpdate = true;
          } else {
            isTrue = false;
            opts.value = this._oldValueOption;
          }
        }

        shouldRender && isTrue && this._buildData(true);
        return isTrue;
      }
    }, {
      key: "_closeHandler",
      value: function _closeHandler(orgEvent) {
        this._display(true);

        this.element.attr({
          'aria-hidden': true,
          // No I18N
          'aria-expanded': false // No I18N

        });

        this._dispatchEvent('close', orgEvent, this._getObj()); // No I18N

      }
    }, {
      key: "getValue",
      value: function getValue() {
        return this._getSingleValue(this._opts.value);
      }
    }, {
      key: "_getSingleValue",
      value: function _getSingleValue(value) {
        var valueString = ZC.Date.formatDate(value, this._opts.format);
        return {
          value: value,
          valueString: valueString,
          translatedValue: this._translateEToA(valueString)
        };
      }
    }, {
      key: "setValue",
      value: function setValue(dateString) {
        this._opts.selectionType === 'single' && this._setValue(dateString, true); // No I18N
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value, pickerEle) {
        var _this113 = this;

        var opts = this._opts,
            isTrue = true,
            data = this._data,
            elem = this.element;
        this._oldValue = opts[optionName];
        this._oldValueOption = opts.value;

        if (opts[optionName] instanceof Array) {
          this._oldOpts = {};
          this._oldOpts[optionName] = opts[optionName].slice();
        }

        opts[optionName] = value;
        this._userOptions[optionName] = value;

        if (optionName === 'format') {
          // No I18N
          this._validateFormat();

          if (this._invalidFormat) {
            isTrue = false;
          } else {
            this._setFormat();

            opts.value && this._setDate(undefined, this._getDateElem(+this._resetTime(opts.value), pickerEle), opts.value); // No I18N
          }
        } else if (optionName === 'forElement') {
          // No I18N
          this._forElement = value ? $(value) : undefined;
        } else if (['monthsPerView', 'locale', 'navigationBar', 'drilldownLevelOnOpen', 'value', 'weekendDays'].indexOf(optionName) > -1) {
          // No I18N
          var shouldRender = true;

          if (optionName === 'value' && opts.selectionType === 'single') {
            // No I18N
            shouldRender = this._setValue(opts.value);
          }

          if (optionName === 'monthsPerView') {
            // No I18N
            data.modifiedAttr = 'monthsPerView'; // No I18N

            this._getBtnsArr().forEach(function (value) {
              _this113['_' + value] = null;
            });

            if (value > 0 && value <= 3) {
              // No I18N
              this._monthsPerView = value;
            } else {
              shouldRender = false;
            }
          }

          if (optionName === 'drilldownLevelOnOpen') {
            // No I18N
            this._viewMode = this._isDrilldown ? this._getViewMode() : 0; // No I18N

            this._data.modifiedAttr = 'drilldownLevel'; // No I18N

            if (value === 'dates') {
              var drillType = this._oldValue.slice(0, -1);

              elem.find('.zdatetimepicker__' + drillType + 'container')[0].style.display = 'none';
              elem.find('.zdatetimepicker__days')[0].style.display = 'flex';
            }
          }

          if (optionName === 'navigationBar') {
            // No I18N
            if (this._isDrilldown) {
              $(elem.find('.zdatetimepicker__monthyearnav')[0]).off('click.' + this.name);
            } else if (this._isDropdown) {
              this._destroyDropdown();
            }

            this._setSwitcherType(value);

            this._data.modifiedAttr = 'navBar'; // No I18N

            if (this._data.month.length) {
              for (var i = 0; i < this._monthsPerView; i++) {
                this._data.month[i].navigationBar = null;
              }
            }
          }

          this._reInit = shouldRender;
          isTrue = shouldRender;
        } else if (optionName === 'position') {
          // No I18N
          this._isPositionModified = true;

          this._validateOpts();
        } else {
          isTrue = this._setAttrs.apply(this, arguments);
        } // This line of code is added for calling positionPicker in postEachRender only when it is needed.


        !this._setPosition && (this._setPosition = ['monthsPerView', 'forElement', 'position', 'minDate', 'maxDate', 'displayType', 'customHTML', 'displayWeekNumbers', 'yearToBeShownOnOpen', 'monthToBeShownOnOpen', 'width', 'height', 'rtl'].indexOf(optionName) > -1 || ['commandBar', 'title'].indexOf(data.modifiedAttr) > -1); // No I18N

        this._domChanged = isTrue;
        return isTrue;
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        var setUndefined = this._setUndefined.bind(this),
            opts = this._opts;

        Object.keys(opts.animation).length && ZC.clearAnimationData(this.element); // if focusTimeout called after destroy() called

        clearTimeout(this._focusTimeout);

        if (this._isDropdown) {
          this._destroyDropdown();
        }

        this._data.customHTML && this._destroyCustomHTML();

        if (opts.draggable && this.element.data('zdraggable')) {
          // No I18N
          ZC.draggable(this.element).destroy();
        }

        if (this.isCE) {
          this.element.removeClass(this._data.className).empty();
        }

        this._rowsCount = this._selectedDates = [];
        setUndefined(['focusTimeout', 'forElement'], ''); // No I18N

        setUndefined(['view', 'min', 'max'], 'Date'); // No I18N

        setUndefined(['', 'month', 'year', 'dec ade'], 'navBar'); // No I18N

        setUndefined(['month', 'year', 'decade'], 'DrillDownElement'); // No I18N

        setUndefined(['month', 'year'], 'Header'); // No I18N

        setUndefined(this._getBtnsArr(), ''); // No I18N

        setUndefined(['monthsPerView', 'currentSelected', 'monthYearNav', 'leftNav', 'rightNav', 'closeButton', 'footer'], ''); // No I18N
      }
    }, {
      key: "_processLimits",
      value: function _processLimits() {
        var parts = ['_min', '_max']; // No I18N

        for (var i = 0, len = parts.length; i < len; i++) {
          var part = parts[i];

          if (this[part + 'DateHasTime']) {
            // No I18N
            this[part + 'Time'] = new Date(+this._opts[part.slice(1) + 'Date']); // No I18N
          }

          part = part + 'Date'; // No I18N

          !this._checkTime && this[part] && this[part].setHours(0, 0, 0, 0);
        }
      }
    }, {
      key: "_checkMax",
      value: function _checkMax(value, opt) {
        var optVal = this['_' + opt + 'Date'];
        return opt === 'min' ? this._isGreater(optVal, value) : this._isGreater(value, optVal); // No I18N
      }
    }, {
      key: "_checkLimits",
      value: function _checkLimits() {
        var min = this._minDate,
            max = this._maxDate,
            opts = this._opts,
            value = opts.value,
            todayDate = new Date();
        todayDate.setHours(0, 0, 0, 0);

        if (min && max && ZC.Date.isGreater(min, max)) {
          opts.maxDate = this._maxDate = undefined;
        }

        var arr = ['min', 'max']; // No I18N

        for (var i = 0; i < 2; i++) {
          var part = arr[i],
              optVal = this['_' + part + 'Date'];

          if (optVal) {
            var tempMin = new Date(+min);
            tempMin.setHours(0, 0, 0, 0); // Revisit

            if (value) {
              this._checkMax(value, part) && (opts.value = undefined);
            } else if (opts.selectionType === 'multiple' && this._selectedDates.length) {
              this._checkDates(part, tempMin);
            }

            if (this._checkMax(this._viewDate, part)) {
              this._viewDate = new Date(this._isBig(part, todayDate) ? +optVal : +todayDate);
            } else if (part === 'min') {
              // No I18N
              this._setViewDateIfNoVal(part);
            }
          }
        }
      }
    }, {
      key: "_checkViewDate",
      value: function _checkViewDate(date) {
        var maxDate = this._maxDate,
            minDate = this._minDate,
            opt;
        maxDate && this._isGreater(this._viewDate, maxDate) && (opt = 'max'); // No I18N

        minDate && this._isGreater(minDate, this._viewDate) && (opt = 'min'); // No I18N

        if (opt === undefined) {
          this._setViewDateIfNoVal(); // No I18N

        } else {
          this._viewDate = new Date(this._isBig(opt, date) ? minDate ? +minDate : opt === 'max' ? +maxDate : +date : +date); // No I18N
        }
      }
    }, {
      key: "_setViewDateIfNoVal",
      value: function _setViewDateIfNoVal() {
        var opts = this._opts,
            min = this._minDate,
            max = this._maxDate;

        if (!opts.value && !opts.values.length && min && (!max || this._isGreater(max, min)) && this._isGreater(min, new Date())) {
          this._viewDate = new Date(+min);
        }
      }
    }, {
      key: "_getViewMode",
      value: function _getViewMode() {
        var opts = this._opts,
            clsName = 'zdatetimepicker--disabledcalendar',
            // No I18N
        arr = ['dates', 'months', 'years', 'decades'],
            // No I18N
        valueUpdate = this._valueUpdate,
            index = arr.indexOf(opts.drilldownLevelOnOpen);
        valueUpdate && this.element.find('.' + clsName).removeClass(clsName); // No I18N

        return valueUpdate ? 0 : index > -1 ? index : undefined;
      }
    }, {
      key: "_generateContent",
      value: function _generateContent(element) {
        // used for drilldownLevelOnOpen option
        if (this._isDrilldown) {
          // No I18N
          var arr = ['Months', 'Years', 'Decades'],
              // No I18N
          fillType = arr[this._viewMode - 1];
          fillType && this['_fill' + fillType](true, element);
        }
      }
    }, {
      key: "_drilldownClickHandler",
      value: function _drilldownClickHandler(ev) {
        var target = $(ev.currentTarget),
            isRendered = false,
            cls = 'zdatetimepicker__',
            // No I18N
        containerCls = '.' + cls + 'monthcontainer',
            // No I18N
        len = this.element.find('.' + cls + 'days').length; // No I18N

        if (this._hasClosest(ev, containerCls, true)) {
          // No I18N
          var container = target.closest(containerCls); // No I18N

          if (target.hasClass(cls + 'monthyearnav')) {
            // No I18N
            if (container.hasClass(cls + 'monthdrilldown') && this._opts.navigationBar.yearSwitcher) {
              // No I18N
              this._fillYears(ev);

              isRendered = true;
            } else if (container.hasClass(cls + 'yeardrilldown')) {
              // No I18N
              this._fillDecades(ev);

              isRendered = true;
            }
          }
        } // Removing len === 1 check since when monthsPerView is 1 len will be 1 by default


        if (!isRendered && (this._monthsPerView === 1 || target.closest('li.' + cls + 'list').index() === 0 && (len === 3 || len === 2))) {
          // No I18N
          this._monthYearNavClickHandler(ev);
        }
      }
    }, {
      key: "_monthYearNavClickHandler",
      value: function _monthYearNavClickHandler(orgEvent, element) {
        var arr = ['month', 'Months', 'year', 'Years'],
            navBar = this._opts.navigationBar; // No I18N

        for (var i = 0; i < 4; i += 2) {
          var isTrue = this._viewMode === (arr[i] === 'month' ? 0 : navBar.monthSwitcher ? 1 : 0);

          if (isTrue && navBar[arr[i] + 'Switcher']) {
            // No I18N
            orgEvent.stopPropagation();
            this['_fill' + arr[i + 1]](orgEvent, element); // No I18N

            break;
          }
        }
      }
    }, {
      key: "_getDrilldownData",
      value: function _getDrilldownData(data, index) {
        this._viewMode = index;
        var view = data.view,
            month = this._data.month[0],
            fn = data.fn,
            width = this._opts.drilldownLevelOnOpen === 'dates' ? this._width || this.element.find('.zdatetimepicker__calendar').outerWidth() : null,
            // No I18N
        drilldown = {
          view: view,
          cells: this['_' + fn[0]](fn[1], fn[2], fn[3]),
          // No I18N
          style: "display:none;width:".concat(width, "px"),
          // No I18N
          navigationBar: this._getDrilldownNavBar(data, index, view)
        };
        month[view + 'Drilldown'] = drilldown; // No I18N

        return month[view + 'Drilldown'];
      }
    }, {
      key: "_setMainEle",
      value: function _setMainEle(navBar) {
        var lmonth = navBar.lMonthIcon,
            rMonth = navBar.rMonthIcon;
        lmonth.mainElement = $('#' + lmonth.id).length ? $('#' + lmonth.id) : null; // No I18N

        rMonth.mainElement = $('#' + rMonth.id).length ? $('#' + rMonth.id) : null; // No I18N
      }
    }, {
      key: "_buildDrilldownView",
      value: function _buildDrilldownView(data, index) {
        var view = data.view,
            drilldown = this._getDrilldownData.apply(this, arguments),
            isBinded = this['_' + view + 'EventBinded'],
            navBar = drilldown.navigationBar;

        if (!isBinded) {
          this._setMainEle(navBar);
        }

        this._render(); // No I18N


        if (!isBinded) {
          this['_' + view + 'EventBinded'] = true;
          view !== 'decade' && this._bindDrillDownClickEvent(view); // No I18N

          this._bindDrilldownNavBarEvent(index);

          this._setMainEle(navBar);

          this['_' + view + 'DrillDownElement'] = this.element.find('.zdatetimepicker__' + view + 'drilldown'); // No I18N
        }
      }
    }, {
      key: "_bindDrilldownNavBarEvent",
      value: function _bindDrilldownNavBarEvent(index) {
        var arrowId = ['-left-month-', '-right-month-']; // No I18N

        for (var i = 0; i < 2; i++) {
          this._addEvents({
            // No I18N
            arrowEvent: 'click' // No I18N

          }, $('#' + this._elementId + arrowId[i] + index)); // No I18N

        }
      }
    }, {
      key: "_bindDrillDownClickEvent",
      value: function _bindDrillDownClickEvent(view) {
        var elem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.element;
        elem = view ? elem.find('.zdatetimepicker__' + view + 'drilldown') : elem; // No I18N

        this._addEvents({
          // No I18N
          drilldownClick: 'click' // No I18N

        }, $(elem.find('.zdatetimepicker__monthyearnav')[0])); // No I18N

      }
    }, {
      key: "_getDrilldownNavBar",
      value: function _getDrilldownNavBar(data, index, view) {
        var navBar = this._data.month[0][view + 'Drilldown'] ? this._data.month[0][view + 'Drilldown'].navigationBar : null,
            lMonthIcon = $.extend(true, {}, navBar ? navBar.lMonthIcon : this._lMonthIcon),
            rMonthIcon = $.extend(true, {}, navBar ? navBar.rMonthIcon : this._rMonthIcon),
            isSplit = this._opts.navigationBar.navigationButtonsDisplayPattern === 'split',
            // No I18N
        labels = ['month', 'Year', 'Decade', 'Century'],
            // No I18N
        label;
        label = this._getI18NText('prev' + labels[index]);
        lMonthIcon = _objectSpread({}, lMonthIcon, {
          id: this._elementId + '-left-month-' + index,
          // No I18N
          customAttributes: {
            'aria-label': label,
            // No I18N
            title: label
          }
        });
        label = this._getI18NText('next' + labels[index]);
        rMonthIcon = _objectSpread({}, rMonthIcon, {
          id: this._elementId + '-right-month-' + index,
          // No I18N
          customAttributes: {
            'aria-label': label,
            // No I18N
            title: label
          }
        });
        return this._setConditions({
          year: this._translateEToA(data.year || this._viewDate.getFullYear()),
          monthYearSwitcherType: 'drilldown',
          // No I18N
          isSplit: isSplit,
          // No I18N
          lMonth: true,
          rMonth: true,
          cursorCls: view !== 'decade' && this._opts.navigationBar.yearSwitcher ? 'zh-cursorpointer' : '',
          // No I18N
          'class': isSplit ? '' : ' zdatetimepicker__navbaractionsonright',
          // No I18N
          navBtnCls: 'zdatetimepicker__navbutton',
          // No I18N
          lMonthIcon: lMonthIcon,
          rMonthIcon: rMonthIcon
        });
      }
    }, {
      key: "_updateYearArrowState",
      value: function _updateYearArrowState(viewMode, year) {
        year = year || this._viewDate.getFullYear();
        var factor,
            id = this._elementId;
        viewMode && (factor = Math.pow(10, viewMode - 1));
        var right = this._maxDate && year + factor > Math.floor(this._maxDate.getFullYear() / factor) * factor || false;
        $('#' + id + '-right-month-' + viewMode).toggleClass('is-disabled', right); // No I18N

        var left = year <= 1 || this._minDate && year - factor < Math.floor(this._minDate.getFullYear() / factor) * factor || false;
        $('#' + id + '-left-month-' + viewMode).toggleClass('is-disabled', left); // No I18N
      }
    }, {
      key: "_buildYearDecadeBody",
      value: function _buildYearDecadeBody(yearStart, yearEnd, incrementer) {
        var j = 1,
            cells = [];

        for (var i = yearStart; i < yearEnd; i = i + incrementer, j++) {
          cells.push({
            'class': this['_get' + (incrementer === 10 ? 'Decade' : 'Year') + 'Classes'](i, j),
            // No I18N
            value: i >= 1 ? this._translateEToA(i) : '',
            attr: i >= 1 ? i : ''
          });

          if (j !== 12 && j % 4 === 0) {
            cells.push({
              isTr: true
            });
          }
        }

        return cells;
      }
    }, {
      key: "_setViewMode",
      value: function _setViewMode(viewMode, preventAnimation, element) {
        var viewmode = this._prevViewMode,
            cls = 'zdatetimepicker',
            // No I18N
        elem = this.element,
            eleToAnimate,
            currentClass = this._getClass(viewmode);

        element = element || elem;
        var calendar = $(element.find('.' + cls + '__calendar')[0]);

        if (viewmode === 0 && elem.is(':visible') && calendar.is(':visible')) {
          // No I18N
          this._width = calendar.outerWidth(); // No I18N
        }

        if (viewmode === 0) {
          eleToAnimate = $(calendar[0]).find('table'); // No I18N
        } else {
          eleToAnimate = element.find('.' + cls + '__' + currentClass).find('.' + cls + '__drilldowncell'); // No I18N
        }

        eleToAnimate.removeClass('zeffects--zoomin'); // No I18N

        !preventAnimation && eleToAnimate.addClass('zeffects--zoomout'); // No I18N

        this._viewMode = viewMode;
        this._monthsPerView > 1 && elem.find('.zdatetimepicker__list').nextAll().find('.' + cls + '__month,.' + cls + '__weeknumbers,.' + cls + '__navbar').addClass(cls + '--disabledcalendar'); // No I18N

        clearTimeout(this._animationTimeout);

        if (preventAnimation) {
          this._animationHandler(element, preventAnimation);
        } else {
          this._animationTimeout = setTimeout(this._animationHandler.bind(this, element, preventAnimation), 300);
        }
      }
    }, {
      key: "_updateMonthClasses",
      value: function _updateMonthClasses() {
        var monthCells = this._data.month[0].monthDrilldown.cells;

        for (var i = 0, j = 0, len = monthCells.length; i < len; i++) {
          if (monthCells[i]["class"] && monthCells[i]["class"].indexOf('zdatetimepicker__monthview') > -1) {
            // No I18N
            monthCells[i]["class"] = this._getMonthClasses(j);
            j++;
          }
        }

        this._render(); // revisit


        this._updateYearArrowState(1);
      }
    }, {
      key: "_updateMonthDDNav",
      value: function _updateMonthDDNav() {
        this._data.month[0].monthDrilldown.navigationBar.year = this._translateEToA(this._viewDate.getFullYear());
      }
    }, {
      key: "_getClass",
      value: function _getClass(viewmode) {
        var currentClass,
            arr = ['days', 'month', 'year', 'decade']; // No I18N

        if (viewmode <= 4) {
          currentClass = arr[viewmode];
          viewmode === 0 && (this._rowsCount = []);
        }

        return currentClass + (viewmode === 0 ? '' : 'drilldown'); // No I18N
      }
    }, {
      key: "_animationHandler",
      value: function _animationHandler(element, preventAnimation) {
        var viewmode = this._viewMode,
            className = this._getClass(viewmode),
            elementToAnimate,
            pickercls = '.zdatetimepicker',
            // No I18N
        children = this._monthsPerView === 1 ? element.children('div:not(' + pickercls + '__commandbar):not(' + pickercls + '__titlebar):not(' + pickercls + '__pointer):not(' + pickercls + '__timebar):not(' + pickercls + '--custom)') // No I18N
        : $(this.element.find('.zdatetimepicker__container').find('.zdatetimepicker__list')[0]).find(pickercls).children(); // No I18N


        element = this._display(true, children).filter(pickercls + '__' + className); // No I18N

        elementToAnimate = viewmode === 0 ? $(element.find(pickercls + '__calendar')[0]).find('table') // No I18N
        : element.find(pickercls + '__drilldowncell'); // No I18N

        elementToAnimate.removeClass('zeffects--zoomout'); // No I18N

        !preventAnimation && elementToAnimate.addClass('zeffects--zoomin'); // No I18N

        this._display(undefined, element);

        this._positionPicker();
      }
    }, {
      key: "_addDisabledCls",
      value: function _addDisabledCls() {
        var pickerCls = 'zdatetimepicker'; // No I18N

        if (this._opts.drilldownLevelOnOpen !== 'dates' && this._viewMode !== 0) {
          // No I18N
          this.element.find('.zdatetimepicker__list').nextAll().find('.' + pickerCls + '__month,.' + pickerCls + '__weeknumbers,.' + pickerCls + '__navbar').addClass(pickerCls + '--disabledcalendar'); // No I18N
        }
      }
    }, {
      key: "_removeEffects",
      value: function _removeEffects() {
        this.element.find('.zeffects--zoomin').removeClass('zeffects--zoomin'); // No I18N

        this.element.find('.zeffects--zoomout').removeClass('zeffects--zoomout'); // No I18N
      }
    }, {
      key: "_handleMousedownOnDrillDown",
      value: function _handleMousedownOnDrillDown(orgEvent, hasMonthCls, hasYearCls, selectedVal) {
        var opts = this._opts,
            navBar = opts.navigationBar,
            viewDate = this._viewDate,
            target = $(orgEvent.target),
            mode = this._viewMode;
        hasMonthCls && viewDate.setMonth(parseInt(target.attr('data-value'))); // No I18N

        hasYearCls && viewDate.setFullYear(parseInt(selectedVal));
        navBar.updateDateOnMonthYearSwitch && opts.immediateCommit && this._OKClickHandler(orgEvent, true);

        if (mode !== 0) {
          var viewMode = mode - 1;
          hasYearCls && !navBar.monthSwitcher && (viewMode = 0);
          this._prevViewMode = this._viewMode;

          this._setViewMode(viewMode);

          mode = this._viewMode;
          this._doNotBuildTime = true;
          mode === 0 && this._buildData(true);

          if (mode === 1) {
            this._updateMonthDDNav();

            this._updateMonthClasses();
          }
        }

        return hasMonthCls ? 'month' : 'year'; // No I18N
      }
    }, {
      key: "_fireDrilldownEv",
      value: function _fireDrilldownEv(before, ev, viewElement) {
        this._prevViewMode = this._viewMode;

        var obj = this._getObj();

        this._dispatchEvent((before ? 'before' : '') + 'drilldown', ev, _objectSpread({}, obj, {
          viewElement: viewElement
        }));
      }
    }, {
      key: "_setDrilldownClass",
      value: function _setDrilldownClass(elem) {
        var month = this._data.month[0],
            type = elem.is('.zdatetimepicker__year') ? 'year' : 'month',
            // No I18N
        obj = month[type + 'Drilldown'].cells[elem.index()]; // No I18N

        obj["class"] = obj["class"].replace(/is-selected/g, ''); // No I18N
      }
    }, {
      key: "_fillMonths",
      value: function _fillMonths(firstView) {
        var orgEvent,
            element = this.element;
        firstView && firstView.type !== undefined && (orgEvent = firstView);

        this._fireDrilldownEv(true, orgEvent);

        this._buildDrilldownView({
          view: 'month',
          // No I18N
          fn: ['buildMonthNavBarBody'] // No I18N

        }, 1, orgEvent); // revisit - check if it works for option drilldownLevelOnOpen: 'months'


        this._setViewMode(1, typeof firstView === 'boolean', element); // No I18N


        this._fireDrilldownEv(false, orgEvent, this._monthDrillDownElement);
      }
    }, {
      key: "_buildMonthNavBarBody",
      value: function _buildMonthNavBarBody() {
        var monthCells = [];
        var months = this._opts.navigationBar.monthFormatInSwitcher.indexOf('MMMM') > -1 ? this._getI18NText('months') : this._getI18NText('monthsAbbreviated'); // No I18N

        for (var i = 0; i < 12; i++) {
          monthCells.push({
            'class': this._getMonthClasses(i),
            // No I18N
            value: this._translateEToA(months[i]),
            isTr: false,
            attr: i + ''
          });

          if (i + 1 !== 12 && (i + 1) % 4 === 0) {
            monthCells.push({
              isTr: true
            });
          }
        }

        return monthCells;
      }
    }, {
      key: "_getMonthClasses",
      value: function _getMonthClasses(month) {
        var pickerCls = 'zdatetimepicker',
            // No I18N
        isDisabled = this._checkDisabled.bind(this),
            classes = pickerCls + '__monthview ' + pickerCls + '__monthyeargrid',
            // No I18N
        today = new Date(),
            viewDate = this._viewDate,
            viewYear = viewDate.getFullYear(),
            min = this._minDate,
            currentSelected = this._currentSelected,
            max = this._maxDate,
            isSelect = currentSelected && currentSelected.getMonth() === month && currentSelected.getFullYear() === viewYear,
            opts = this._opts,
            value = opts.value;

        if (value && value.getMonth() === month && value.getFullYear() === viewYear && isSelect || isSelect) {
          classes += ' is-selected'; // No I18N
        }

        opts.selectionType === 'multiple' && (classes += this._addSelectClass('Month', month, viewYear)); // No I18N

        if (today.getMonth() === month && today.getFullYear() === viewYear) {
          classes += ' ' + pickerCls + '--currentcell'; // No I18N
        }

        if (min && (viewYear === min.getFullYear() && month < min.getMonth() || viewYear < min.getFullYear()) || max && (viewYear === max.getFullYear() && month > max.getMonth() || viewYear > max.getFullYear()) || isDisabled('Years', viewYear) || isDisabled('Months', month)) {
          // No I18N
          classes += ' is-disabled zdisabled'; // No I18N
        }

        return classes;
      }
    }, {
      key: "_checkDisabled",
      value: function _checkDisabled(type, val) {
        var arr = this._opts['disabled' + type];
        return arr instanceof Array && arr.indexOf(val) > -1;
      }
    }, {
      key: "_handleYearClick",
      value: function _handleYearClick(orgEvent, viewElement, viewDate) {
        this._rowsCount = [];
        var target = $(orgEvent.target),
            elemId = this._elementId,
            step = this._opts.navigationBar.yearNavigationStep,
            id = orgEvent.currentTarget.getAttribute('id'); // No I18N

        if (!target.closest('.zdatetimepicker__navbutton').hasClass('is-disabled')) {
          // No I18N
          var moveBy = step * (id.indexOf(elemId + '-right-year') > -1 || id.indexOf(elemId + '-right-month') > -1 && this._viewMode > 0 ? 1 : -1); // No I18N

          viewDate = viewDate || this._viewDate;
          viewDate.setFullYear(viewDate.getFullYear() + moveBy);
          this._viewDate = new Date(+viewDate);

          this._updateMonthDDNav();

          this._updateMonthClasses(viewElement || this.element);
        }
      }
    }, {
      key: "_fillYears",
      value: function _fillYears(firstView) {
        var orgEvent,
            element = this.element,
            viewMode = this._viewMode;

        if (firstView && firstView.type !== undefined) {
          firstView.stopPropagation();
          firstView.preventDefault();
          orgEvent = firstView;
        }

        !(this._monthDrillDownElement && viewMode === 1) && this._fillMonths(orgEvent);

        this._fireDrilldownEv(true, orgEvent); // No I18N


        var yrStart = Math.floor(this._viewDate.getFullYear() / 10) * 10,
            yrEnd = yrStart + 9;
        this._yearStart = yrStart;

        if (this._monthDrillDownElement) {
          this._buildDrilldownView({
            view: 'year',
            year: this._translateEToA(yrStart + ' - ' + yrEnd),
            fn: ['buildYearDecadeBody', yrStart - 1, yrEnd + 2, 1] // No I18N

          }, 2, orgEvent);
        }

        this._setViewMode(2, typeof firstView === 'boolean', element); // No I18N


        this._fireDrilldownEv(false, orgEvent, this._yearDrillDownElement);
      }
    }, {
      key: "_getYearClasses",
      value: function _getYearClasses(year, index) {
        var clsName = ' zdatetimepicker',
            // No I18N
        opts = this._opts,
            disabledYrs = opts.disabledYears,
            classes = clsName + '__year ' + clsName + (index === 1 || index === 12 ? '__drilldownnearlevelcell' : '__monthyeargrid'),
            // No I18N
        min = this._minDate,
            max = this._maxDate,
            isSelect = this._currentSelected && this._currentSelected.getFullYear() === year,
            value = opts.value;

        if (value && value.getFullYear() === year && isSelect || isSelect) {
          classes += ' is-selected'; // No I18N
        }

        opts.selectionType === 'multiple' && (opts.values.length || this._selectedDates.length) && (classes += this._addSelectClass('FullYear', year)); // No I18N

        if (new Date().getFullYear() === year) {
          classes += clsName + '--currentcell'; // No I18N
        }

        if (year < 1 || min && year < min.getFullYear() || max && year > max.getFullYear() || disabledYrs && disabledYrs.indexOf(year) > -1) {
          classes += ' is-disabled zdisabled'; // No I18N
        }

        return classes;
      }
    }, {
      key: "_handleDecadeArrowClick",
      value: function _handleDecadeArrowClick(orgEvent) {
        orgEvent.stopPropagation();
        var target = $(orgEvent.target),
            viewDate = this._viewDate,
            id = orgEvent.currentTarget.getAttribute('id'),
            viewMode = this._viewMode,
            isViewMode2 = viewMode === 2;

        if (!target.closest('.zdatetimepicker__navbutton').hasClass('is-disabled')) {
          // No I18N
          var moveBy,
              view = isViewMode2 ? 'year' : 'decade',
              // No I18N
          startFactor = 10,
              year,
              curYear,
              yearStart,
              endFactor = 9,
              yearEnd,
              incrementer = isViewMode2 ? 1 : 10; // No I18N

          moveBy = (id.indexOf(this._elementId + '-right-month') > -1 ? 1 : -1) * incrementer; // No I18N

          year = (isViewMode2 ? this._yearStart : this._decadeStart) || viewDate.getFullYear(); // No I18N

          var yearVal = year + startFactor * moveBy;
          curYear = typeof yearVal === 'number' ? yearVal : this._viewDate.getFullYear(); // No I18N

          this._data.month[0][view + 'Drilldown'].cells = null;
          yearStart = Math.floor(curYear / (startFactor * incrementer)) * (startFactor * incrementer);
          yearEnd = yearStart + endFactor * incrementer;

          this._buildDrilldownView({
            view: view,
            year: this._translateEToA(yearStart + ' - ' + yearEnd),
            fn: ['buildYearDecadeBody', yearStart - incrementer, yearEnd + 2 * incrementer, incrementer],
            // No I18N
            placeholder: isViewMode2 ? 'month' : 'year' // No I18N

          }, viewMode, orgEvent); // No I18N


          this._display(undefined, this['_' + view + 'DrillDownElement']);

          this['_' + (isViewMode2 ? 'year' : 'decade') + 'Start'] = yearStart; // No I18N

          this._updateYearArrowState(viewMode, yearStart);
        }

        this._dispatchEvent((isViewMode2 ? 'decade' : 'century') + 'change', orgEvent, {
          // No I18N
          viewDate: this._viewDate,
          value: this._opts.value
        });
      }
    }, {
      key: "_fillDecades",
      value: function _fillDecades(firstView) {
        // Revisit - If you have time combine _fillYears & fillDecades in to a single function
        var element = this.element,
            orgEvent,
            yearEle = this._yearDrillDownElement;

        if (firstView.type !== undefined) {
          firstView.stopPropagation();
          firstView.preventDefault();
          orgEvent = firstView;
        }

        !yearEle && this._fillYears(orgEvent);

        this._fireDrilldownEv(true, orgEvent); // No I18N


        var yearStart = Math.floor(this._viewDate.getFullYear() / 100) * 100,
            yearEnd = yearStart + 90;

        if (this._yearDrillDownElement) {
          this._buildDrilldownView({
            view: 'decade',
            // No I18N
            year: this._translateEToA(yearStart + ' - ' + yearEnd),
            fn: ['buildYearDecadeBody', yearStart - 10, yearEnd + 20, 10] // No I18N

          }, 3, orgEvent);
        }

        this._setViewMode(3, typeof firstView === 'boolean', element); // No I18N


        this._decadeStart = yearStart;

        this._fireDrilldownEv(false, orgEvent, this._decadeDrillDownElement);
      }
    }, {
      key: "_getDecadeClasses",
      value: function _getDecadeClasses(decade, index) {
        var cls = ' zdatetimepicker__',
            // No I18N
        classes = cls + (index === 1 || index === 12 ? 'drilldownnearlevelcell' : 'monthyeargrid') + cls + 'decade ',
            // No I18N
        min = this._minDate,
            max = this._maxDate; // No I18N

        if (decade < 10 || min && decade < Math.floor(min.getFullYear() / 10) * 10 || max && decade > Math.floor(max.getFullYear() / 10) * 10) {
          classes += ' is-disabled zdisabled'; // No I18N
        }

        return classes;
      }
    }, {
      key: "_handleDecadeMousedown",
      value: function _handleDecadeMousedown(orgEvent, mode, selectedVal) {
        this._viewDate.setFullYear(parseInt(selectedVal));

        if (mode !== 0) {
          this._setViewMode(mode - 1); // re-assigned because viewmode changes when setViewMode() is called


          mode = this._viewMode;
          mode === 2 && this._fillYears(orgEvent);
        }
      }
    }, {
      key: "_bindArrowEvents",
      value: function _bindArrowEvents() {
        var id = this._elementId,
            elems = ('#' + id + '-left-year,#' + id + '-right-year,#' + id + '-left-month-0,#' + id + '-right-month-0').split(',');

        for (var i = 0, len = elems.length; i < len; i++) {
          var elem = $(elems[i]);
          elem.length && this._addEvents({
            arrowEvent: 'click' // No I18N

          }, elem);
        }
      }
    }, {
      key: "_getIconProps",
      value: function _getIconProps(navBar, svgId, btn, id, label) {
        label = this._getI18NText(label);
        return {
          className: 'zdatetimepicker__navbutton',
          // No I18N
          isCE: this.isCE,
          customAttributes: {
            'aria-label': label,
            // No I18N
            title: label
          },
          defaultIconClassName: 'zdatetimepicker__icon',
          // No I18N
          SVGIconId: navBar[btn + 'ButtonSVGIconId'],
          // No I18N
          defaultSVGIconId: '#zc__svg--' + svgId + ' zh-arrowicon',
          // No I18N
          iconClassName: navBar[btn + 'ButtonIconClassName'],
          // No I18N
          templateRender: true,
          id: this._elementId + id
        };
      }
    }, {
      key: "_getNavBtnProps",
      value: function _getNavBtnProps(month, i, curNav) {
        var navBar = this._opts.navigationBar,
            isLast = i === this._monthsPerView - 1,
            monthButtons = navBar.monthNavigationButtons,
            yearButtons = navBar.yearNavigationButtons;
        curNav.isSplit = navBar.navigationButtonsDisplayPattern === 'split'; // No I18N

        curNav["class"] = curNav.isSplit ? '' : ' zdatetimepicker__navbaractionsonright'; // No I18N

        monthButtons && this._getMonthNavBtnProps(curNav, navBar);
        yearButtons && this._getYrNavBtnProps(curNav, navBar);

        if (curNav.isSplit) {
          month.navigationBar = _objectSpread({}, curNav, {
            lMonth: monthButtons && !i,
            lYear: yearButtons && !i,
            rMonth: monthButtons && isLast,
            rYear: yearButtons && isLast
          });
        } else {
          curNav.lMonth = curNav.rMonth = monthButtons && isLast;
          curNav.lYear = curNav.rYear = yearButtons && isLast;
        }
      }
    }, {
      key: "_setArrowMainElement",
      value: function _setArrowMainElement(curNav) {
        var arr = [];
        curNav.monthNavigationButtons && (arr = ['-left-month-0', // No I18N
        'lMonthIcon', // No I18N
        '-right-month-0', // No I18N
        'rMonthIcon' // No I18N
        ]);
        curNav.yearNavigationButtons && (arr = [].concat(_toConsumableArray(arr), ['-left-year', // No I18N
        'lYearIcon', // No I18N
        '-right-year', // No I18N
        'rYearIcon' // No I18N
        ]));

        for (var i = 0, len = arr.length; i < len; i += 2) {
          var elem = $('#' + this._elementId + arr[i]);
          curNav[arr[i + 1]].mainElement = elem ? elem[0] : null;
        }
      }
    }, {
      key: "_arrowClickHandler",
      value: function _arrowClickHandler(moveBy, monthsChanged, yearChanged) {
        var newDate,
            count = this._monthsPerView,
            navBar = this._opts.navigationBar,
            viewDate = this._viewDate,
            oldDate;
        oldDate = new Date(+viewDate);
        var elem = this.element;

        for (var i = 1; i <= count; i++) {
          var isOne = i === 1;

          if (monthsChanged) {
            if (moveBy > 1) {
              newDate = this._moveMonth(oldDate, isOne ? moveBy : 1);
            } else {
              newDate = this._moveMonth(viewDate, isOne ? moveBy : i - 1);
            }
          }

          if (yearChanged) {
            if (count > 1) {
              newDate = new Date(this._getFirstDate()); // No I18N
            } else {
              !newDate && (newDate = new Date(viewDate));
            }

            newDate.setFullYear(newDate.getFullYear() + moveBy);
          }

          if (navBar.monthNavigationStep > 1 || navBar.yearNavigationStep > 1) {
            var arr = ['min', 'max'],
                // No I18N
            isTrue = void 0;

            for (var _i6 = 0; _i6 < 2; _i6++) {
              isTrue = this._isBig(arr[_i6], newDate);
              this['_' + arr[_i6] + 'Date'] && isTrue && (newDate = new Date(+this['_' + arr[_i6] + 'Date'])); // No I18N
            }
          }

          isOne && newDate && (viewDate = this._viewDate = new Date(+newDate));
        }

        this._doNotBuildTime = true;
        this._setPosition = true;

        this._buildData(true);

        if (this._isDropdown) {
          // No I18N
          this._checkOptions();

          this._buildDropdownNavElement(viewDate.getMonth(), viewDate.getFullYear());
        } else if (yearChanged && this._viewMode === 1) {
          this._updateMonthClasses(elem);
        }
      }
    }, {
      key: "_updateArrowState",
      value: function _updateArrowState(date, index) {
        var updateInBatch = this._monthsPerView > 1,
            disable = this._disable.bind(this);

        date = date || this._viewDate;
        var id = this._elementId,
            minDate = this._minDate,
            maxDate = this._maxDate,
            year = date.getFullYear(),
            month = date.getMonth(),
            minMonth,
            minYear,
            maxMonth,
            maxYear,
            isValidValue,
            prev,
            next,
            yearPrev,
            yearNext;

        if (minDate) {
          minYear = minDate.getFullYear();
          minMonth = minDate.getMonth();
        }

        if (maxDate) {
          maxYear = maxDate.getFullYear();
          maxMonth = maxDate.getMonth();
        }

        var isFirstMonth = year === 1;
        isValidValue = isFirstMonth || minMonth || minYear || maxMonth || maxYear;
        prev = isFirstMonth && month === 0 || year < minYear || year === minYear && month - 1 < minMonth;
        next = year > maxYear || year === maxYear && month + 1 > maxMonth;
        yearPrev = year === 1 || year - 1 < minYear || year - 1 === minYear && month < minMonth;
        yearNext = year + 1 > maxYear || year + 1 === maxYear && month > maxMonth;
        var condtn = isValidValue && !updateInBatch;

        if (condtn || updateInBatch && index === 0) {
          disable(prev, $('#' + id + '-left-month-0')); // No I18N

          disable(yearPrev, $('#' + id + '-left-year')); // No I18N
        }

        if (condtn || updateInBatch && index === this._monthsPerView - 1) {
          disable(next, $('#' + id + '-right-month-0')); // No I18N

          disable(yearNext, $('#' + id + '-right-year')); // No I18N
        }

        if (!isValidValue && !(prev && isFirstMonth && month === 0)) {
          $('#' + id + '-left-month-0,#' + id + '-left-year,#' + id + '-right-month-0,#' + id + '-right-year').removeClass('is-disabled').removeAttr('aria-disabled disabled'); // No I18N
        }
      }
    }, {
      key: "_getYrNavBtnProps",
      value: function _getYrNavBtnProps(curNav, navBar) {
        !curNav.lYearIcon && (curNav.lYearIcon = this._getIconProps(navBar, 'fastbackward', 'previousYear', '-left-year', 'prevYear')); // No I18N

        !curNav.rYearIcon && (curNav.rYearIcon = this._getIconProps(navBar, 'fastforward', 'nextYear', '-right-year', 'nextYear')); // No I18N
      }
    }, {
      key: "_handleYearArrowClick",
      value: function _handleYearArrowClick(orgEvent) {
        this._rowsCount = [];
        var opts = this._opts,
            target = $(orgEvent.target),
            id = orgEvent.currentTarget.getAttribute('id'),
            // No I18N
        yearStep = opts.navigationBar.yearNavigationStep,
            str;

        if (!target.closest('.zdatetimepicker__navbutton').hasClass('is-disabled')) {
          // No I18N
          str = this._elementId + '-right-'; // No I18N

          this._arrowClickHandler(id.indexOf(str + 'year') > -1 || id.indexOf(str + 'month') > -1 && this._viewMode > 0 ? yearStep : -yearStep, // No I18N
          undefined, true);
        }

        this._dispatchChangeEvent(orgEvent, 'year', this._viewDate.getFullYear()); // No I18N

      }
    }, {
      key: "_getMonthNavBtnProps",
      value: function _getMonthNavBtnProps(curNav, navBar) {
        !curNav.lMonthIcon && (this._lMonthIcon = curNav.lMonthIcon = this._getIconProps(navBar, 'backward', 'previousMonth', '-left-month-0', 'prevMonth')); // No I18N

        !curNav.rMonthIcon && (this._rMonthIcon = curNav.rMonthIcon = this._getIconProps(navBar, 'forward', 'nextMonth', '-right-month-0', 'nextMonth')); // No I18N
      }
    }, {
      key: "_handleMonthArrowClick",
      value: function _handleMonthArrowClick(orgEvent) {
        // console.time("Month arrow click");
        var target = $(orgEvent.target),
            opts = this._opts,
            pickerCls = '.zdatetimepicker__',
            // No I18N
        id = orgEvent.currentTarget.getAttribute('id'),
            // No I18N
        monthStep = opts.navigationBar.monthNavigationStep; // No I18N

        this._rowsCount = [];

        if (!target.closest(pickerCls + 'navbutton').hasClass('is-disabled')) {
          // No I18N
          if (this._monthsPerView > 1 && this._currentSelected) {
            this._viewDate = new Date(+this._getFirstDate());
          }

          this._arrowClickHandler(monthStep * (id.indexOf(this._elementId + '-right-month') > -1 ? 1 : -1), true); // No I18N

        }

        this._dispatchChangeEvent(orgEvent, 'month', this._viewDate.getMonth()); // No I18N
        // console.timeEnd("Month arrow click");

      }
    }, {
      key: "_setBtnProps",
      value: function _setBtnProps() {
        var btns = this._getBtnsArr(),
            label,
            opts = this._opts; // No I18N


        for (var i = 0; i < btns.length; i++) {
          label = btns[i] + 'ButtonLabel'; // No I18N

          this['_' + label] = opts[label] || this._getI18NText(label);
        }

        opts.buttonsAlignment = ZC.buttonsAlignment || 'right'; // No I18N
      }
    }, {
      key: "_setBtnVal",
      value: function _setBtnVal() {
        var btns = this._getBtnsArr(),
            footer = this._footer;

        for (var i = 0; i < btns.length; i++) {
          var btn = '_' + btns[i],
              handler = btns[i] + 'Click',
              // No I18N
          elem = footer.find('.' + btns[i] + 'Button-' + this.name); // No I18N

          if (elem.length) {
            this[btn] = elem;

            this._handleFocus(this[btn]);

            this._addEvents(_defineProperty({}, handler, 'mousedown'), elem);
          }
        }

        this._OK && (this._OKButton = !!this._OK.length);
      }
    }, {
      key: "_createButtons",
      value: function _createButtons() {
        this._data.cBar = {};

        if (this._isColumnExists()) {
          this._generateCustomCols();
        } else {
          this._autoGenSingleColBtns();
        }

        var obj = this._traverseBtns('clearButton', undefined, undefined, true); // No I18N


        if (this._opts.clearButton && obj) {
          this._setClearBtnCls(obj);
        }
      }
    }, {
      key: "_updateCommandBar",
      value: function _updateCommandBar(elem) {
        (!this._footer || !this._footer.length) && (this._footer = elem.find('.zdatetimepicker__commandbar')); // No I18N

        this._isBtns && this._setBtnVal();

        this._traverseBtns();
      }
    }, {
      key: "_traverseBtns",
      value: function _traverseBtns(name, cls, shoudlAdd, returnObj) {
        var isGreaterThan1 = this._monthsPerView > 1,
            cBar = this._data.cBar;

        for (var pos in cBar) {
          var posArr = cBar[pos];

          if (Array.isArray(posArr)) {
            for (var i = 0, l = posArr.length; i < l; i++) {
              var arr = posArr[i],
                  btnObj = isGreaterThan1 ? arr.left || arr.right || arr.center || arr : arr; // No I18N

              if (btnObj) {
                if (isGreaterThan1 && btnObj instanceof Array) {
                  for (var j = 0, len = btnObj.length; j < len; j++) {
                    var obj = btnObj[j];

                    if (returnObj && obj.name && obj.name === name) {
                      return obj;
                    } else if (!returnObj) {
                      this._setBtnMainElement(name, cls, shoudlAdd, obj);
                    }
                  }
                } else if (returnObj && btnObj.name && btnObj.name === name) {
                  return btnObj;
                } else if (!returnObj) {
                  this._setBtnMainElement(name, cls, shoudlAdd, btnObj);
                }
              }
            }
          }
        }
      }
    }, {
      key: "_setBtnMainElement",
      value: function _setBtnMainElement(name, cls, shoudlAdd, obj) {
        var btn = obj.name ? obj.name.replace('Button', '') : undefined; // No I18N

        if (btn) {
          var elem = this['_' + btn]; // No I18N

          if (shoudlAdd !== undefined && name === obj.name) {
            var clsName = obj.className + ' ',
                regExp = new RegExp(cls, 'g');
            obj.className = shoudlAdd ? clsName + cls : clsName.replace(regExp, '');
          } else {
            this._doesExist(elem) && (obj.mainElement = this['_' + btn][0]);
          }
        }
      }
    }, {
      key: "_autoGenSingleColBtns",
      value: function _autoGenSingleColBtns() {
        var cBar = this._getCommandBarData.bind(this),
            opts = this._opts,
            count = 0,
            buttons,
            index,
            alignment = opts.buttonsAlignment,
            isToday = opts.todayButton,
            isOK = opts.OKButton,
            getIndex = this._getIndex.bind(this);

        if (this._monthsPerView < 3) {
          buttons = this._getBtnsArr().map(function (val) {
            return val + 'Button';
          }); // No I18N

          for (var i = 0; i < buttons.length; i++) {
            count += +opts[buttons[i]];
          }

          if (count === 1) {
            index = getIndex(0);
            var value = buttons[index];
            cBar(value === 'todayButton' ? 'center' : 'right', value); // No I18N
          } else if (count === 2) {
            index = getIndex(1);
            var _value2 = buttons[index];

            if (isToday) {
              cBar('left', 'todayButton'); // No I18N

              cBar('right', _value2); // No I18N
            } else if (isOK && index !== 3) {
              if (opts.clearButton) {
                cBar('left', _value2); // No I18N

                cBar('right', 'OKButton'); // No I18N
              } else {
                cBar('right', [_value2, 'OKButton']); // No I18N
              }
            } else {
              cBar('left', 'clearButton'); // No I18N

              cBar('right', 'cancelButton'); // No I18N
            }
          } else if (count === 3) {
            buttons = ['today', 'OK', 'clear', 'cancel']; // No I18N

            index = getIndex(2, buttons); // No I18N

            if (isOK) {
              cBar('right', 'OKButton'); // No I18N

              if (isToday) {
                cBar('right', buttons[index] + 'Button', 0); // No I18N
              }
            }

            if (isToday) {
              cBar('left', 'todayButton'); // No I18N
            } else {
              cBar('left', 'clearButton'); // No I18N

              this._data.cBar.right.length && cBar('right', 'cancelButton', 0); // No I18N
            }
          } else if (count === 4) {
            cBar('left', 'clearButton'); // No I18N

            cBar('center', 'todayButton'); // No I18N

            cBar('right', ['cancelButton', 'OKButton']); // No I18N
          }
        } else {
          buttons = ['clear', 'today', 'cancel', 'OK']; // No I18N

          alignment !== 'right' && (buttons = buttons.reverse()); // No I18N

          getIndex(0, buttons, alignment);
        }
      }
    }, {
      key: "_getIndex",
      value: function _getIndex(start, arr, alignment) {
        arr = arr || this._getBtnsArr();
        var buttons = arr.map(function (val) {
          return val + 'Button';
        }); // No I18N

        for (var i = start; i < buttons.length; i++) {
          if (this._opts[buttons[i]]) {
            if (alignment) {
              this._getCommandBarData(alignment, buttons[i]);
            } else {
              return i;
            }
          }
        }
      }
    }, {
      key: "_getCommandBarData",
      value: function _getCommandBarData(position, button, index, column) {
        var _this114 = this;

        var isCol,
            cBar = this._data.cBar;
        isCol = cBar && cBar.cols && cBar.cols.length !== 0;
        var commandBar = isCol ? column : cBar;

        if (typeof index === 'number') {
          commandBar[position].splice(index, 0, this._getbtnAttr(button)); // No I18N
        } else {
          var _commandBar$position;

          if (!(button instanceof Array)) {
            button = [button];
          }

          button = button.map(function (value) {
            return _this114._getbtnAttr(value);
          }); // No I18N

          !commandBar[position] && (commandBar[position] = []);

          (_commandBar$position = commandBar[position]).push.apply(_commandBar$position, _toConsumableArray(button));
        }
      }
    }, {
      key: "_getbtnAttr",
      value: function _getbtnAttr(btn) {
        var btnName = btn.replace('Button', ''),
            label = this['_' + btn + 'Label']; // ## revisit

        return {
          customAttributes: {
            name: btn,
            'aria-label': label // No I18N

          },
          name: btn,
          className: (btnName === 'today' ? 'zdatetimepicker__todaylink ' : ' ') + btn + '-' + this.name,
          // No I18N
          text: label,
          // No I18N
          appearance: btn === 'OKButton' ? 'primary' : 'normal',
          // No I18N
          size: 'small',
          // No I18N
          isCE: this.isCE,
          templateRender: true
        };
      }
    }, {
      key: "_clearClickHandler",
      value: function _clearClickHandler(orgEvent) {
        var clearBtn = this._clear,
            doesExist = this._doesExist(clearBtn);

        if (orgEvent && !$(orgEvent.target).closest(clearBtn).hasClass('is-disabled') || !orgEvent) {
          // No I18N
          doesExist && this._removeFocus(clearBtn);
          /* setting class through traverseBtns() is removed since it is handled in posteachrender */

          this._clearValues(orgEvent);

          doesExist && this._dispatchEvent('clear', orgEvent, {
            // No I18N
            valuesObject: [],
            values: []
          });
        }
      }
    }, {
      key: "_setClearBtnCls",
      value: function _setClearBtnCls(obj, noVal, set) {
        obj = obj || this._traverseBtns('clearButton', undefined, undefined, true); // No I18N

        noVal = noVal === undefined ? this._opts.selectionType === 'single' ? !this._currentSelected : this._selectedDates && this._selectedDates.length === 0 : noVal; // No I18N

        var clearbtn = this._clear;

        if (this._doesExist(clearbtn)) {
          if (noVal) {
            obj.className.indexOf('is-disabled') === -1 && (obj.className += ' is-disabled'); // No I18N
          } else {
            obj.className.replace(/is-disabled/g, '');
          }

          set && this._disable(!!noVal, clearbtn);
        }
      }
    }, {
      key: "_setAttrs",
      value: function _setAttrs(optionName, value, pickerEle) {
        var _this115 = this;

        var data = this._data,
            opts = this._opts,
            navBar = opts.navigationBar,
            isTrue = true,
            isDropdown = this._isDropdown,
            isRendered,
            buttonOptions = ['todayButton', 'clearButton', 'hideCancelButton', 'immediateCommit', 'commandBar'],
            // No I18N
        labels = ['todayButtonLabel', 'cancelButtonLabel', 'clearButtonLabel', 'OKButtonLabel'],
            // No I18N
        specialDays = ['disabledDaysOfWeek', 'specialDaysOfWeek', 'specialDates', 'disabledDates']; // No I18N

        pickerEle = pickerEle || this.element;
        ['minDate', 'maxDate'].indexOf(optionName) < -1 && (opts[optionName] = value);

        if (this._yearNavigation === undefined) {
          this._yearNavigation = navBar.yearNavigationButtons = !isDropdown;
        }

        if (optionName === 'values') {
          // No I18N
          var values = opts.values;

          if (!values || values instanceof Array && values.length === 0) {
            this.clearAll();
          } else {
            this.setValues(values);
          }

          isTrue = false;
        } else if (['minDate', 'maxDate'].indexOf(optionName) > -1) {
          // No I18N
          this['_' + optionName + 'HasTime'] = false;

          this._parseValue(optionName, value);

          if (value) {
            this['_' + optionName] = new Date(opts[optionName].getTime()); // No I18N
          } else {
            this['_' + optionName] = null;
            this['_' + optionName + 'HasTime'] = false; // No I18N
          }

          var isNotValid = !opts.value && opts.values.length === 0;
          isNotValid && this._setHours();

          this._processLimits();

          this._checkLimits();

          if (isNotValid) {
            opts.monthToBeShownOnOpen && this._setView('month', true); // No I18N

            opts.yearToBeShownOnOpen && this._setView('year'); // No I18N
          }

          this._resetValues();

          isRendered = true;
        } else if (['closeButton', 'closeSVGIconId', 'closeIconClassName', 'title'].indexOf(optionName) > -1) {
          // No I18N
          this._closeButton = undefined;
          data.title = this._getTitleData();

          if (optionName === 'title') {
            if (opts.title) {
              this._enableDrag = opts.draggable;
            } else if (opts.draggable) {
              this.element.data('zdraggable') && ZC.draggable(this.element).destroy(); // No I18N
            }
          }

          data.modifiedAttr = 'title'; // No I18N
        } else if (optionName === 'displayType') {
          // No I18N
          this._validateOpts();

          if (value === 'box' && this._pointer) {
            // No I18N
            !this._isPositionModified && (opts.position = 'bottom-left'); // No I18N
          }

          data.modifiedAttr = 'displayType'; // No I18N
        } else if (optionName.indexOf('customHTML') > -1) {
          // No I18N
          this._setCustomHTML();

          isTrue = false;
        } else if (optionName === 'displayWeekNumbers') {
          // No I18N
          this._setMonthVal(optionName, value);
        } else if (optionName === 'weekHeading' && opts.displayWeekNumbers) {
          // No I18N
          this._setMonthVal('weekTitle', value); // No I18N

        } else if (optionName === 'type') {
          // No I18N
          if (opts.type === 'popup') {
            // No I18N
            // updated again if changed through setAttribute
            data.title.closeButton = opts.closeButton;
            (opts.forElement || opts.offset) && this._showPicker();
          } else if (this._closeButton) {
            data.title.closeButton = false;
          }

          if (opts.type === 'inline') {
            // No I18N
            this._display();
          }
        } else if (optionName === 'selectionType') {
          // No I18N
          this._resetValues();

          isRendered = true;
        } else if (buttonOptions.indexOf(optionName) > -1) {
          // No I18N
          this._setOKCancelBtns();

          this._isBtns = this._isBtnsExist();

          if (this._isBtns) {
            this._setBtnProps();

            this._createButtons();
          } else {
            this._data.cBar = null;
          }

          this._getBtnsArr().forEach(function (value) {
            if (!opts[value + 'Button']) {
              _this115['_' + value] = null;
            }
          });

          data.modifiedAttr = 'commandBar'; // No I18N
        } else if (labels.indexOf(optionName) > -1) {
          var name = optionName.replace('Label', ''),
              btnObj = this._traverseBtns(name, undefined, undefined, true),
              btn = this['_' + name.replace('Button', '')];

          btnObj.text = btnObj.customAttributes['aria-label'] = value; // No I18N

          btnObj.mainElement = btn && btn.length ? btn[0] : undefined;

          if (name === 'todayButton') {
            // No I18N
            this._domChanged = true;
          } else {
            this._setBtnValue({
              text: value
            }, btnObj); // No I18N

          }

          this['_' + optionName] = value || this._getI18NText(optionName);
        } else if (optionName === 'draggable') {
          // No I18N
          if (opts.title && opts.draggable) {
            this._enableDrag = true;
            data.modifiedAttr = 'title'; // No I18N
          } else {
            this.element.data('zdraggable') && ZC.draggable(this.element).destroy(); // No I18N
          }
        } else if (optionName === 'monthToBeShownOnOpen' || optionName === 'yearToBeShownOnOpen') {
          // No I18N
          var _isTrue = optionName.indexOf('month') > -1; // No I18N


          this._setView(_isTrue ? 'month' : 'year', _isTrue); // No I18N


          (this._minDate || this._maxDate) && this._checkViewDate(this._viewDate);
          isRendered = true;
        } else if (specialDays.indexOf(optionName) > -1) {
          if (['disabledDates', 'specialDates'].indexOf(optionName) > -1) {
            // No I18N
            this._convertStringToObject(_defineProperty({}, optionName, opts[optionName]));
          }

          var isSpecial = optionName.indexOf('special') > -1; // refreshClassNames can be called only for the option which is changed. Hence, the check is added.

          this._refreshClassNames(isSpecial ? 'zdatetimepicker--special' : 'is-disabled zdisabled', isSpecial ? ['specialDaysOfWeek', 'specialDates'] : ['disabledDaysOfWeek', 'disabledDates']); // No I18N

        } else if (optionName === 'disabledMonths') {
          // No I18N
          if (opts.disabledMonths.indexOf(this._viewDate.getMonth()) > -1) {
            pickerEle.find('td').addClass('is-disabled zdisabled').attr('aria-disabled', true); // No I18N
          } else if (isDropdown) {
            // No I18N
            if (this._monthHeader) {
              var monthInstance = ZC.select(this._monthHeader);
              monthInstance.setOptionAttributes(this._oldValue, 'disabled', false); // No I18N

              monthInstance.setOptionAttributes(opts.disabledMonths, 'disabled', true); // No I18N
            }
          } else {
            this._monthDrillDownElement && this._monthDrillDownElement.find('td').addClass('is-disabled').attr('aria-disabled', true); // No I18N
          }
        } else if (optionName === 'selectionLimit' && opts.selectionType === 'multiple') {
          // No I18N
          var selectedDates = this._selectedDates,
              _values = this._opts.values,
              len = selectedDates.length;

          if (value === len || len > value) {
            this._limitReached = true;

            _values.splice(value, _values.length);

            var extraElems = selectedDates.splice(value, selectedDates.length);

            for (var i = 0, _len2 = extraElems.length; i < _len2; i++) {
              this._setDateClass('is-selected', false, this._getDateElem(extraElems[i]), true); // No I18N

            }

            this._queryString = ':not('; // No I18N

            this._getQueryString();

            this._setDateClass('is-disabled', true, this.element.find('.zdatetimepicker__date,.zdatetimepicker__adjacentmonthdate').filter(this._queryString), true); // No I18N

          } else {
            isRendered = true;
          }
        } else if (optionName === 'disabledYears') {
          // No I18N
          if (opts.disabledYears.indexOf(this._viewDate.getFullYear()) > -1) {
            isRendered = true;
          } else if (isDropdown) {
            // No I18N
            if (this._yearHeader) {
              var yearInstance = ZC.combobox(this._yearHeader);
              yearInstance.setOptionAttributes(this._oldValue, 'disabled', false); // No I18N

              yearInstance.setOptionAttributes(opts.disabledYears, 'disabled', true); // No I18N
            }
          } else {
            this._yearDrillDownElement && this._yearDrillDownElement.find('td').addClass('is-disabled').attr('aria-disabled', true); // No I18N
          }
        } else if (optionName === 'displayAdjacentMonthDates') {
          // No I18N
          isRendered = true;
          data.modifiedAttr = 'adjacentMonthDates'; // No I18N
        } else if (optionName === 'selectedDateMonthViewIndex' && opts.value) {
          // No I18N
          this._viewDate = new Date(opts.value.getTime());

          this._changeMonth(false);

          isRendered = true;
        } else if (optionName === 'allowSelectionOfAdjacentMonthDates') {
          // No I18N
          this._setMonthVal('className', ' zdatetimepicker--adjacentmonthdatereadonly', !value); // No I18N


          this._domChanged = true;
          data.modifiedAttr = 'adjacentMonthDates'; // No I18N
        } else if (optionName === 'width') {
          // No I18N
          value && this.element.width(value);
        } else if (optionName === 'height') {
          // No I18N
          value && this.element.height(value);
        } else if (optionName === 'className') {
          // No I18N
          this.element.removeClass(this._oldValue);
          value && this.element.addClass(value);
        } else if (optionName === 'offset') {
          // No I18N
          this.element.css(value);
          isTrue = false;
        } else if (optionName === 'margin' && this.element.is(':visible')) {
          // No I18N
          var position = {
            left: parseInt(this.element.css('left')),
            // No I18N
            top: parseInt(this.element.css('top')) // No I18N

          };
          position = this._retrieveMarginValues(position);
          this.element.css(position);
        } else if (optionName === 'zclassName' && this.isCE) {
          // No I18N
          this._oldValue && this.element.removeClass(this._oldValue);
          this.element.addClass(value);
        } else if (optionName === 'rtl' && this._monthHeader || this._yearHeader) {
          var val = {
            rtl: value
          };
          this._monthHeader && ZC.select(this._monthHeader).setAttributes(val);
          this._yearHeader && ZC.combobox(this._yearHeader).setAttributes(val);
        }

        !this._reInit && (this._reInit = isRendered);
        return isTrue;
      }
    }, {
      key: "_refreshClassNames",
      value: function _refreshClassNames(className, optionsArray) {
        var base = this,
            isDisabled = className.indexOf('disabled') > -1,
            opts = this._opts,
            // No I18N
        classes = className.split(' ');

        for (var i = 0; i < this._monthsPerView; i++) {
          var monthData = this._data.month[i].dates;

          for (var week = 0, len = monthData.length; week < len; week++) {
            var weekData = monthData[week];

            for (var d = 0, l = weekData.length; d < l; d++) {
              var dateObj = weekData[d],
                  prevCls = dateObj["class"];
              dateObj["class"] = prevCls.replace(classes[0], '').replace(classes[1], ''); // No I18N

              dateObj.title = dateObj.infoText = '';
              var returnValue = void 0,
                  date = new Date(parseInt(dateObj.time)),
                  addDisabled = isDisabled ? !base._dateWithInRange(date) : false;

              if (dateObj.text && (addDisabled || (returnValue = this._shouldAddClass(date, optionsArray)) || this._shouldAddClass(date, optionsArray, opts.selectionType === 'multiple' && this._limitReached))) {
                // No I18N
                if (_typeof(returnValue) === 'object') {
                  // No I18N
                  dateObj["class"] += returnValue.className ? ' ' + returnValue.className : '';
                  dateObj.title = returnValue.title || null;
                  dateObj.infoText = returnValue.informativeText || opts.specialDatesInformativeText || opts.disabledDateInformativeText || null;
                }

                dateObj["class"] += ' ' + className; // When selection limit is reached and if disabledDates are removed, disabled classes were not included properly.

                if (!returnValue && !addDisabled) {
                  dateObj["class"] = dateObj["class"].replace('zdisabled', ''); // No I18N

                  dateObj["class"].indexOf('is-selected') > -1 && (dateObj["class"] = dateObj["class"].replace('is-disabled', '')); // No I18N
                }
              }
            }
          }
        }
      }
    }, {
      key: "_shouldAddClass",
      value: function _shouldAddClass(date, options, takeOldVal) {
        var areDatesEqual = ZC.Date.areDatesEqual.bind(ZC);

        for (var i = 0, len = options.length; i < len; i++) {
          var optionVal = takeOldVal ? this._oldOpts[options[i]] : this._opts[options[i]];

          if (optionVal) {
            if (optionVal.indexOf(date.getDay()) > -1) {
              return true;
            }

            for (var j = 0, size = optionVal.length; j < size; j++) {
              var value = optionVal[j],
                  dateVal = value.date;

              if (_typeof(value) === 'object') {
                // No I18N
                if (dateVal instanceof Date && areDatesEqual(dateVal, date)) {
                  return true;
                } else if (dateVal) {
                  var dateToCheck = new Date(+dateVal.date);

                  this._setYearAndMonth(dateToCheck, date, value);

                  if (areDatesEqual(dateToCheck, date)) {
                    return value;
                  }
                } else if (value.startDate && value.endDate) {
                  var arr = ['startDate', 'endDate']; // No I18N

                  for (var _i7 = 0; _i7 < 2; _i7++) {
                    arr[_i7] = new Date(+value[arr[_i7]].date);

                    this._setYearAndMonth(arr[_i7], date, value);
                  }

                  if ((ZC.Date.isGreater(date, arr[0]) || areDatesEqual(arr[0], date)) && ZC.Date.isGreater(arr[1], date)) {
                    return value;
                  }
                }
              }
            }
          }
        }
      }
    }, {
      key: "_setYearAndMonth",
      value: function _setYearAndMonth(dateToCheck, date, value) {
        value.repeatEveryYear && dateToCheck.setFullYear(date.getFullYear());
        value.repeatEveryMonth && dateToCheck.setMonth(date.getMonth());
      }
    }, {
      key: "_convertStringToObject",
      value: function _convertStringToObject(datesObject) {
        var _this116 = this;

        var _loop3 = function _loop3(option) {
          var optVal = datesObject[option],
              opts = _this116._opts,
              format = _this116._dateFormat;

          if (_this116._isNotNull(optVal)) {
            if (typeof optVal === 'string') {
              // No I18N
              datesObject[option] = opts[option] = _this116._parseDateValue(optVal, format);
            } else if (optVal instanceof Array) {
              datesObject[option] = opts[option] = optVal.map(function (d) {
                if (_typeof(d) === 'object' && !(d instanceof Date)) {
                  // No I18N
                  var dateVal = d.date,
                      checkDate = _this116._checkDate.bind(_this116),
                      parseVal = _this116._parseVal.bind(_this116);

                  if (checkDate(dateVal, d) || checkDate(dateVal) || checkDate(d.startDate) || checkDate(d.endDate)) {
                    // No I18N
                    return d;
                  }

                  if (dateVal) {
                    d.date = parseVal(dateVal);
                  } else if (d.startDate && d.endDate) {
                    d.startDate = parseVal(d.startDate);
                    d.endDate = parseVal(d.endDate);
                  }

                  return d;
                }

                var isTimeList = option === 'disabledTimeList',
                    // No I18N
                date = _this116._parseDateValue(d, isTimeList ? _this116._timeFormat : format); // No I18N


                if (isTimeList) {
                  date.date.setSeconds(0, 0);
                } else {
                  date.date.setHours(0, 0, 0, 0);
                }

                return date;
              });
            }
          }
        };

        for (var option in datesObject) {
          _loop3(option);
        }
      }
    }, {
      key: "_checkDate",
      value: function _checkDate(date, obj) {
        date = obj ? date : date ? date.date : undefined;
        obj = obj || date;
        return date && date instanceof Date && obj.hasOwnProperty('isValid'); // No I18N
      }
    }, {
      key: "_parseVal",
      value: function _parseVal(dateVal) {
        // hasOwnProperty is used to avoid getting error when accessed from a date object
        dateVal = this._parseDateValue(dateVal && dateVal.hasOwnProperty('isValid') && dateVal.isValid && dateVal.date || dateVal, this._dateFormat); // No I18N

        dateVal.date.setHours(0, 0, 0, 0);
        return dateVal;
      }
    }, {
      key: "_addUniqueClasses",
      value: function _addUniqueClasses(date, cls, onlyDisabled) {
        var opts = this._opts,
            classes = cls ? cls + ' ' : '',
            monthsDis = opts.disabledMonths,
            yearsDis = opts.disabledYears,
            returnValue;
        returnValue = this._shouldAddClass(date, ['disabledDaysOfWeek', 'disabledDates']); // No I18N

        if (returnValue || monthsDis && monthsDis.indexOf(date.getMonth()) > -1 || yearsDis && yearsDis.indexOf(date.getFullYear()) > -1) {
          classes += 'is-disabled zdisabled'; // No I18N
        }

        if (!returnValue && !onlyDisabled) {
          returnValue = this._shouldAddClass(date, ['specialDaysOfWeek', 'specialDates']); // No I18N

          if (returnValue) {
            classes += 'zdatetimepicker--special'; // No I18N
          }
        }

        return returnValue && this._getCustomProps(returnValue, classes);
      }
    }, {
      key: "_getCustomProps",
      value: function _getCustomProps(returnValue, classes) {
        var infoText,
            cls = classes + ' ',
            obj,
            title;

        if (_typeof(returnValue) === 'object') {
          // No I18N
          cls += returnValue.className ? ' ' + returnValue.className : '';
          title = returnValue.title || null;
        }

        var disabledInfo = this._opts.disabledDateInformativeText,
            highlightInfo = this._opts.specialDatesInformativeText;

        if (returnValue && returnValue.informativeText || typeof returnValue === 'boolean' && disabledInfo || highlightInfo) {
          // No I18N
          if (classes.indexOf('is-disabled') > -1 && disabledInfo) {
            infoText = disabledInfo;
          } else if (classes.indexOf('zdatetimepicker--special') > -1 && highlightInfo) {
            infoText = highlightInfo;
          } else if (returnValue && returnValue.informativeText) {
            infoText = returnValue.informativeText;
          }

          infoText = infoText || undefined;
        }

        obj = {
          'class': cls,
          // No I18N
          infoText: infoText,
          title: title
        };
        return obj;
      }
    }, {
      key: "name",
      get: function get() {
        return "zdatepicker";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          forElement: null,
          offset: null,
          title: null,
          position: 'auto',
          // No I18N
          format: 'dd/MM/yyyy',
          // No I18N
          displayType: 'box',
          // No I18N
          type: 'popup',
          // No I18N
          minDate: null,
          maxDate: null,
          displayWeekNumbers: false,
          weekHeading: 'Week',
          // No I18N
          selectionType: 'single',
          // No I18N
          todayButtonLabel: 'Today',
          // No I18N
          clearButtonLabel: 'Clear',
          // No I18N
          OKButtonLabel: 'OK',
          // No I18N
          closeSVGIconId: null,
          closeIconClass: null,
          cancelButtonLabel: 'Cancel',
          // No I18N
          selectionLimit: null,
          monthToBeShownOnOpen: null,
          yearToBeShownOnOpen: null,
          drilldownLevelOnOpen: null,
          isTitleHTMLEncoded: false,
          selectedDateMonthViewIndex: null,
          todayButtonAction: 'navigate-only',
          // No I18N
          displayAdjacentMonthDates: false,
          allowSelectionOfAdjacentMonthDates: true,
          hideCancelButton: false,
          monthsPerView: 1,
          immediateCommit: true,
          value: null,
          draggable: false,
          height: null,
          width: null,
          weekendDays: '0,6',
          // No I18N
          closeButton: false,
          closeOnDateSelect: true,
          closeOnBodyClick: true,
          todayButton: false,
          clearButton: false,
          locale: 'en-US',
          // No I18N
          positionAlterable: true
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          closeIconClassName: null,
          commandBar: {},
          margin: {},
          animation: {},
          customHTMLAboveNavigationBar: null,
          customHTMLAboveCalendar: null,
          customHTMLBelowCalendar: null,
          navigationBar: {
            monthSwitcher: true,
            yearSwitcher: true,
            monthYearHeadingFormat: 'MMM yyyy',
            // No I18N
            monthYearSwitcherType: 'drilldown',
            // No I18N
            monthFormatInSwitcher: 'MMM',
            // No I18N
            navigationButtonsDisplayPattern: 'split',
            // No I18N
            togetherTypeNavigationButtonsPosition: 'right',
            // No I18N
            monthNavigationStep: 1,
            yearNavigationStep: 1,
            yearNavigationButtons: true,
            monthNavigationButtons: true,
            previousMonthButtonSVGIconId: null,
            dropdownStartYear: 'THIS_YEAR-10',
            // No I18N
            dropdownEndYear: 'THIS_YEAR+10' // No I18N

          },
          otherInputFormats: [],
          fixedTimeOptions: [],
          specialDates: [],
          disabledDates: [],
          disabledMonths: [],
          disabledYears: [],
          specialDaysOfWeek: [],
          disabledDaysOfWeek: [],
          disabledDateInformativeText: null,
          values: [],
          labels: {
            OKButtonLabel: 'OK',
            // No I18N
            cancelButtonLabel: 'Cancel',
            // No I18N
            todayButtonLabel: 'Today',
            // No I18N
            clearButtonLabel: 'Clear',
            // No I18N
            days: ['Sunday', // No I18N
            'Monday', // No I18N
            'Tuesday', // No I18N
            'Wednesday', // No I18N
            'Thursday', // No I18N
            'Friday', // No I18N
            'Saturday' // No I18N
            ],
            daysAbbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            // No I18N
            months: ['January', // No I18N
            'February', // No I18N
            'March', // No I18N
            'April', // No I18N
            'May', // No I18N
            'June', // No I18N
            'July', // No I18N
            'August', // No I18N
            'September', // No I18N
            'October', // No I18N
            'November', // No I18N
            'December' // No I18N
            ],
            monthsAbbreviated: ['Jan', // No I18N
            'Feb', // No I18N
            'Mar', // No I18N
            'Apr', // No I18N
            'May', // No I18N
            'Jun', // No I18N
            'Jul', // No I18N
            'Aug', // No I18N
            'Sep', // No I18N
            'Oct', // No I18N
            'Nov', // No I18N
            'Dec' // No I18N
            ],
            close: 'Close',
            // No I18N
            nextMonth: 'Next Month',
            // No I18N
            nextYear: 'Next Year',
            // No I18N
            prevMonth: 'Previous Month',
            // No I18N
            prevYear: 'Previous Year',
            // No I18N
            nextDecade: 'Next Decade',
            // No I18N
            prevDecade: 'Previous Decade',
            // No I18N
            nextCentury: 'Next Century',
            // No I18N
            prevCentury: 'Previous Century' // No I18N

          }
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['beforefocus', // No I18N
        'beforeopen', // No I18N
        'open', // No I18N
        'beforeclose', // No I18N
        'close', // No I18N
        'dateselect', // No I18N
        'todaybuttonclick', // No I18N
        'change', // No I18N
        'cancel', // No I18N
        'clear', // No I18N
        'beforedrilldown', // No I18N
        'drilldown', // No I18N
        'datemouseover', // No I18N
        'monthchange', // No I18N
        'yearchange', // No I18N
        'decadechange', // No I18N
        'beforedatecellrender', // No I18N
        'dragstart', // No I18N
        'drag', // No I18N
        'dragend' // No I18N
        ];
      }
    }, {
      key: "SELECTORS",
      get: function get() {
        var isCE = this.isCE;
        return {
          option: isCE ? 'z-' : 'option',
          // No I18N
          select: "".concat(isCE ? 'z-combobox' : 'select') // No I18N

        };
      }
    }]);

    return ZDatePicker;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZDatePicker', ZDatePicker);

  (function (ZC) {
    var template = ZC.zdatepicker.Templates,
        utilities = ZC.Templates.Utilities;

    template.children = function (data) {
      return ZT.html(_templateObject172(), data.displayType === 'callout' && ZT.html(_templateObject173()), data.title && template.title(data.title), data.monthsPerView > 1 ? ZT.html(_templateObject174(), ZC.iterateData(data.monthsPerView, function (item, i) {
        return ZT.html(_templateObject175(), template.month(data.month[i]), template.drilldownView(data.month[i]));
      })) : ZT.html(_templateObject176(), template.month(data.month[0]), template.drilldownView(data.month[0])), data.cBar && !data.isCBar && utilities.commandBar(data.cBar));
    };

    template.drilldownView = function (data) {
      return ZT.html(_templateObject177(), data.monthDrilldown && template.drilldown(data.monthDrilldown), data.yearDrilldown && template.drilldown(data.yearDrilldown), data.decadeDrilldown && template.drilldown(data.decadeDrilldown));
    };

    template.month = function (data) {
      return ZT.html(_templateObject178(), data.style, template.navBar(data.navigationBar), data.displayWeekNumbers && template.weekNumbers(data), data.className, data.days.map(function (day) {
        return ZT.html(_templateObject179(), day["class"], day.value);
      }), data.dates.map(function (row) {
        return ZT.html(_templateObject180(), row.map(function (cell) {
          return ZT.html(_templateObject181(), cell["class"], cell.time, cell.title, cell.text, cell.infoText && ZT.html(_templateObject182(), cell.infoText));
        }));
      }));
    };

    var icon = ZC.createButton;

    template.navBar = function (data) {
      return ZT.html(_templateObject183(), data["class"], data.isLMonthYear && data.isSplit ? ZT.html(_templateObject184(), data.lYear && icon(data.lYearIcon), data.lMonth && icon(data.lMonthIcon)) : '', data.monthSelect && !data.month && (data.yrFirst ? ZC.createComboBox(data.yearSelect) : ZC.createSelect(data.monthSelect)), data.isMonthYearNav && ZT.html(_templateObject185(), data.cursorCls, data.month && ZT.html(_templateObject186(), data.month), data.year && ZT.html(_templateObject187(), data.year)), data.yearSelect && !data.year && (data.yrFirst ? ZC.createSelect(data.monthSelect) : ZC.createComboBox(data.yearSelect)), data.isRMonthYear ? ZT.html(_templateObject188(), !data.isSplit && data.lYear && icon(data.lYearIcon), !data.isSplit && data.lMonth && icon(data.lMonthIcon), data.rMonth && icon(data.rMonthIcon), data.rYear && icon(data.rYearIcon)) : '');
    };

    template.drilldown = function (data) {
      return ZT.html(_templateObject189(), data.view, data.style, template.navBar(data.navigationBar), data.cells && ZT.html(_templateObject190(), data.cells.map(function (cell) {
        return cell.isTr ? ZT.html(_templateObject191()) : ZT.html(_templateObject192(), cell["class"], cell.attr, cell.value);
      })));
    };
  })(ZComponents);

  var ZDateInput =
  /*#__PURE__*/
  function (_ZC$ZInputField2) {
    _inherits(ZDateInput, _ZC$ZInputField2);

    function ZDateInput() {
      _classCallCheck(this, ZDateInput);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZDateInput).apply(this, arguments));
    }

    _createClass(ZDateInput, [{
      key: "_postRender",
      value: function _postRender() {
        if (this._invalidFormat) {
          return;
        }

        _get(_getPrototypeOf(ZDateInput.prototype), "_postRender", this).apply(this, arguments);

        var opts = this._opts,
            value = opts.value,
            optionType = ['value', 'min', 'max'],
            // No I18N
        inputElem = this._input; // No I18N
        // Added since the text values were constantly rotating if direction is rtl

        if (opts.rtl) {
          inputElem.css({
            direction: 'ltr' // No I18N

          }); // No I18N
        }

        if (opts.locale === 'ar') {
          // No I18N
          inputElem.addClass('zh-bidioverride'); // No I18N
        }

        value && (this._viewDate = new Date(value.getTime()));

        for (var i = 0; i < optionType.length; i++) {
          var optn = optionType[i];

          if (opts[optn]) {
            inputElem.attr('aria-value' + (optn === 'value' ? 'now' : optn), ZC.Date.formatDate(opts[optn], opts.format)); // No I18N
          }
        }

        this._updateElementValue();
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender(elem, data) {
        var modified = this._data.modifiedAttr;

        if (!data.isVertical && (!modified || modified.indexOf('spinButtons') > -1)) {
          this._data.className += ' zdatetimefield'; // No I18N
        }

        _get(_getPrototypeOf(ZDateInput.prototype), "_postEachRender", this).call(this);

        !this._data.rendered && this._disableSpinBtns();
      }
    }, {
      key: "_init",
      value: function _init(element, options) {
        this._format = this._opts.format;

        this._setFormat();

        _get(_getPrototypeOf(ZDateInput.prototype), "_init", this).call(this, element, options);

        this._performValidations();

        this._oldDateValue = new Date(this._viewDate.getTime());
        this._isInit = undefined;
      }
    }, {
      key: "_disableSpinBtns",
      value: function _disableSpinBtns() {
        var opts = this._opts,
            cls = 'is-disabled',
            // No I18N
        btnPane = this._buttonPane;

        if (opts.spinButtons !== 'none') {
          // No I18N
          btnPane.find('.zh-down')[(opts.min && +opts.value === +opts.min ? 'add' : 'remove') + 'Class'](cls); // No I18N

          btnPane.find('.zh-up')[(opts.max && +opts.value === +opts.max ? 'add' : 'remove') + 'Class'](cls); // No I18N
        }
      }
    }, {
      key: "_setFormatVal",
      value: function _setFormatVal(regExp, part, defaultFormat) {
        var format = this._format,
            opts = this._opts,
            isFormatSpecifier = regExp.test(format),
            labels = opts.labels,
            locale = opts.locale,
            ZLocale = ZC.localeInfo[locale];

        if (isFormatSpecifier) {
          var props = ['days', 'daysAbbreviated', 'months', 'monthsAbbreviated']; // No I18N

          for (var i = 0; i < props.length; i++) {
            labels[props[i]] = ZLocale[props[i]];
          }

          if (part.indexOf('time') > -1) {
            var arr = ['AM', 'PM']; // No I18N

            for (var _i8 = 0; _i8 < arr.length; _i8++) {
              labels[arr[_i8]] = ZLocale[arr[_i8]] || this._DEFAULTS.labels[arr[_i8]];
            }
          }

          var parts = format.split('-'); // No I18N

          if (parts[0] === part) {
            format = format.replace(part, (part === 'datetime' ? 'dateTime' : part) + 'Format'); // No I18N
          }

          parts = format.split('-'); // No I18N

          var type = ZLocale[parts[0]];
          format = type[parts[1]];
          opts.format = ZLocale && type && format ? format : defaultFormat; // No I18N
        }
      }
    }, {
      key: "_performValidations",
      value: function _performValidations(stepValues, parts) {
        var value,
            options = ['min', 'max', 'value'],
            // No I18N
        opts = this._opts; // No I18N

        this._validateStep(stepValues); // No I18N


        this._validateFormat();

        for (var i = 0, len = options.length; i < len; i++) {
          var optn = options[i];
          value = opts[optn];
          value && (opts[optn] = typeof value === 'string' ? this._getStringValue(value, opts) : value instanceof Date ? value : undefined); // No I18N

          optn === 'value' && (this._viewDate = opts[optn] ? new Date(opts[optn].getTime()) : this._resetViewDate()); // No I18N
        }

        var compareDates = this._compareDates.bind(this);

        compareDates(opts.max, opts.min) && (opts.max = undefined);
        compareDates(opts.max, opts.value) && (opts.value = opts.max);
        compareDates(opts.value, opts.min) && (opts.value = opts.min);

        this._setBoolValue(parts, true, 'Modified'); // No I18N


        this._checkForModification(opts.value);
      }
    }, {
      key: "_getStringValue",
      value: function _getStringValue(value, opts) {
        var format = opts.format;

        if (value === 'TODAY' || value === 'NOW') {
          // No I18N
          return new Date();
        }

        var dateInfo = this._parseDateValue(value, format);

        if (format.indexOf('h') < 0 && format.indexOf('H') < 0 && dateInfo && dateInfo.isValid) {
          dateInfo.date.setHours(0, 0, 0, 0);
        }

        return dateInfo && dateInfo.isValid ? dateInfo.date : undefined;
      }
    }, {
      key: "_resetViewDate",
      value: function _resetViewDate() {
        var date = new Date(new Date().getFullYear(), 0, 1, 0, 0, 0),
            compareDates = this._compareDates.bind(this),
            opts = this._opts,
            min = opts.min,
            max = opts.max;

        if (min && compareDates(date, min)) {
          return new Date(+min);
        }

        if (max && compareDates(max, date)) {
          return new Date(+max);
        }

        return date;
      }
    }, {
      key: "_selectText",
      value: function _selectText(character) {
        var format = this._dateFormat;
        this._oldSegment = this._currentSegment;
        var end = format.lastIndexOf(character) + 1,
            start = format.indexOf(character);

        if (start < 0) {
          start = 0;
        }

        this._currentSegment = character;
        this._opts.spinButtons !== 'none' && this._addDisabledClass(character); // No I18N

        this._selectCaretPosition(this._input[0], start, end);
      }
    }, {
      key: "_compareDates",
      value: function _compareDates(firstDate, secondDate) {
        if (firstDate && secondDate) {
          return firstDate.getTime() < secondDate.getTime();
        }
      } // call directly if not reused

    }, {
      key: "_parseDateValue",
      value: function _parseDateValue(date, pattern) {
        return ZC.Date._parseDateValue(date, pattern, this._opts.otherInputFormats);
      }
    }, {
      key: "_selectCaretPosition",
      value: function _selectCaretPosition(element, start, end) {
        var isPositioned = start !== undefined;
        end === undefined && (end = start);

        if (isPositioned && element.disabled) {
          return;
        }

        try {
          if (element.selectionStart !== undefined) {
            if (isPositioned) {
              !this._isInit && element.focus();
              element.setSelectionRange(start, end);
            } else {
              start = [element.selectionStart, element.selectionEnd];
            }
          }
        } catch (e) {
          throw e;
        }

        return start;
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        if (this._invalidFormat) {
          return;
        }

        this._bindButtonEvents();

        var isIE9 = ZC.Browser.isIE && ZC.Browser.getIEVersion() === 9,
            clickEvent = ZC.Browser.isFirefox ? 'click' : 'mouseup'; // No I18N

        this._addEvents({
          containerMouseUp: clickEvent
        }, this.container);

        var keyUp = isIE9 ? 'keyup' : 'input',
            // No I18N
        focusIn = isIE9 ? 'focus' : 'focusin',
            // No I18N
        focusOut = isIE9 ? 'blur' : 'focusout'; // No I18N

        this._addEvents({
          focus: 'focus',
          // No I18N
          mouseup: clickEvent,
          // No I18N
          keyUp: keyUp,
          // No I18N
          change: 'change',
          // No I18N
          keydown: 'keydown',
          // No I18N
          spinKeyup: 'keyup',
          // No I18N
          focusIn: focusIn,
          // No I18N
          focusOut: focusOut,
          // No I18N
          paste: 'paste',
          // No I18N
          mouseWheel: 'mousewheel DOMMouseScroll MozMousePixelScroll' // No I18N

        }, this._input);

        this._input.on('contextmenu.' + this.name, function (event) {
          return event.preventDefault();
        });
      }
    }, {
      key: "_bindButtonEvents",
      value: function _bindButtonEvents() {
        if (this._opts.clearButton === 'focus' || this._opts.spinButtons === 'focus') {
          // No I18N
          this._addEvents({
            mouseEnter: 'mouseenter',
            // No I18N
            mouseLeave: 'mouseleave' // No I18N

          }, this.container);
        }
      }
    }, {
      key: "_checkFormat",
      value: function _checkFormat(partsRegex) {
        this._invalidFormat = partsRegex.test(this._opts.format);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        var clearButton = this._clearButton,
            componentName = this.name;
        ZC.$window.off("keyup.".concat(componentName, " keydown.").concat(componentName)); // No I18N

        this.container.find('.zh-up,.zh-down').off("mousedown.".concat(componentName, " mouseup.").concat(componentName)); // No I18N

        clearButton && clearButton.off("mousedown.".concat(componentName, " mouseup.").concat(componentName)); // No I18N

        _get(_getPrototypeOf(ZDateInput.prototype), "_destroy", this).call(this);

        this._buttonPane = this._keyUp = this._keyUpTime = this._isFastInput = undefined;
      }
    }, {
      key: "getValue",
      value: function getValue() {
        return {
          dateObject: this._opts.value,
          dateString: this._opts.value ? this._input[0].value : undefined
        };
      }
    }, {
      key: "_checkForModification",
      value: function _checkForModification(value) {
        var format = this._opts.format;

        for (var i = 0; i < format.length; i++) {
          this._isPartModified(format[i], !!value);
        }
      }
    }, {
      key: "setValue",
      value: function setValue(dateString) {
        if (dateString) {
          this._validateValue('value', dateString); // No I18N


          this._viewDate = this._checkMinMaxLimit(this._viewDate);

          this._checkForModification(this._viewDate);

          this._updateElementValue();
        } else {
          this._clearActionHandler();

          this._input[0].setSelectionRange(0, 0);
        }

        !this.container.hasClass('has-focus') && this._input.trigger('change'); // No I18N
      }
    }, {
      key: "formatDate",
      value: function formatDate(dateObject, dateFormat) {
        return ZC.Date.formatDate(dateObject, dateFormat || this._opts.format);
      }
    }, {
      key: "parseDate",
      value: function parseDate(dateString, dateFormat) {
        return this._parseDateValue(dateString, dateFormat || this._opts.format);
      }
    }, {
      key: "_resetValues",
      value: function _resetValues(character, value) {
        if (!isNaN(value) && ['y', 'H', 'm', 's'].indexOf(character) > -1) {
          var chars = {
            y: 'Fullyear',
            // No I18N
            H: 'Hours',
            // No I18N
            m: 'Minutes',
            // No I18N
            s: 'Seconds' // No I18N

          }; // No I18N

          this._viewDate["set".concat(chars[character])](0); // No I18N

        }
      }
    }, {
      key: "_validateValue",
      value: function _validateValue(optionName, value) {
        var isModified = true,
            opts = this._opts,
            format = opts.format;

        if (typeof value === 'string') {
          // No I18N
          opts[optionName] = this._getStringValue(value, opts);
        } else if (value instanceof Date) {
          opts[optionName] = value;
        } else {
          isModified = !!this._oldValueOption;
          opts[optionName] = undefined;
        }

        value = opts.value;

        if (format.indexOf('h') < 0 && format.indexOf('H') < 0 && value) {
          value.setHours(0, 0, 0, 0);
        } else if (value) {
          value.setHours(value.getHours(), value.getMinutes(), format.indexOf('s') < 0 ? 0 : value.getSeconds(), 0);
        }

        if (optionName === 'value') {
          // No I18N
          if (value) {
            this._viewDate = new Date(value.getTime());
          }

          if (this._hasPicker) {
            ZC[this._pickerMethods.instance](this._picker).setValue(value);
          }
        }

        return isModified;
      }
    }, {
      key: "_windowKeyupHandler",
      value: function _windowKeyupHandler(orgEvent) {
        if ((orgEvent.keyCode === ZC.keyCode.TAB && orgEvent.shiftKey || this._reverseShiftKey) && !this._reverseFocusset) {
          this._reverseFocusset = this._focusout = true;

          this._selectText(this._dateFormat.slice(-1));
        } else if ((orgEvent.keyCode === ZC.keyCode.TAB || this._tabKey) && !this._focusset) {
          this._focusset = this._focusout = true;
          ZC.OS.isLinux() && this._input[0].setSelectionRange(0, 0);

          this._mouseupHandler();
        }

        ZC.$window.off("keyup.".concat(this.name, " keydown.").concat(this.name)); // No I18N
      }
    }, {
      key: "_updateElementValue",
      value: function _updateElementValue() {
        var dateFormatRegExp = this._getRegEx();

        var format = this._opts.format;
        this._retursFormat = false;
        var newValue = format.replace(dateFormatRegExp, this._replaceMatchedText.bind(this));
        this._retursFormat = true;
        this._dateFormat = format.replace(dateFormatRegExp, this._replaceMatchedText.bind(this));
        this._oldValue = this._input[0].value = newValue;
        this._opts.value = this._getDateValue() ? new Date(this._viewDate.getTime()) : undefined;
      }
    }, {
      key: "_windowKeydownHandler",
      value: function _windowKeydownHandler(orgEvent) {
        var tabKeyCode = ZC.keyCode.TAB,
            keyCode = orgEvent.keyCode;
        this._reverseShiftKey = keyCode === tabKeyCode && orgEvent.shiftKey;
        this._tabKey = keyCode === tabKeyCode;
      }
    }, {
      key: "_focusTimeoutHandler",
      value: function _focusTimeoutHandler() {
        this._addEvents({
          windowKeydown: 'keydown',
          // No I18N
          windowKeyup: 'keyup' // No I18N

        }, ZC.$window);
      }
    }, {
      key: "_toggleBtnDisplay",
      value: function _toggleBtnDisplay(hide, isClear, both, eventType) {
        var clearHide = hide,
            showOrHide = this._showOrHideBtn.bind(this);

        if (isClear) {
          (clearHide === null || eventType) && (clearHide = this._checkForPartModification());
          (eventType === 'mouseleave' || !eventType && this._opts.clearButton === 'focus') && !this.container.hasClass('has-focus') && (clearHide = true); // No I18N

          this._clearBtnShown = !clearHide;
        }

        if (clearHide === hide) {
          showOrHide.apply(void 0, arguments);
        } else {
          isClear && showOrHide(clearHide, true);
          both && showOrHide(hide);
        }
      }
    }, {
      key: "_showOrHideBtn",
      value: function _showOrHideBtn(hide, isClear, both) {
        var className = (isClear ? 'zinputfield--withclrbtn' : '') + (both || !isClear ? (isClear ? hide ? '|' : ' ' : '') + 'zinputfield--spinbtnonfocus' : ''); // No I18N

        if (hide) {
          this._updateClass('', className);
        } else {
          this._data.className += ' ' + className;
        }

        _get(_getPrototypeOf(ZDateInput.prototype), "_toggleBtnDisplay", this).apply(this, arguments);
      }
    }, {
      key: "_spinTimeoutHandler",
      value: function _spinTimeoutHandler(orgEvent) {
        this._changeHandler(orgEvent, 'spin'); // No I18N

      }
    }, {
      key: "_focusInHandler",
      value: function _focusInHandler() {
        if (this._opts.disabled) {
          return false;
        }

        this.container.addClass('has-focus'); // No I18N

        this._input[0].setSelectionRange(0, 0);

        this._focusTimeout = setTimeout(this._focusTimeoutHandler.bind(this), 10);
      }
    }, {
      key: "_setBoolValue",
      value: function _setBoolValue(array, value, txt) {
        var len = array.length;

        while (--len >= 0) {
          this['_' + array[len] + (txt || '')] = value;
        }
      }
    }, {
      key: "_focusOutHandler",
      value: function _focusOutHandler(orgEvent) {
        if (this._hasPicker) {
          var relTarget = $(orgEvent.relatedTarget);

          if (relTarget && relTarget.is('.zselectbox')) {
            return;
          }
        }

        var opts = this._opts;

        this._setBoolValue(['focusset', 'longPress', 'reverseFocusset', 'reverseShiftKey', 'tabKey'], false); // No I18N


        this._focusout = true;
        window.getSelection().removeAllRanges();
        this._viewDate = this._checkMinMaxLimit(this._viewDate, undefined, undefined, false);
        this.container.removeClass('has-focus'); // No I18N

        this._disableSpinBtns();

        this._updateElementValue(); // Setting selectionStart sets focus on the element in the below browsers. So preventing it.


        if (!(ZC.Browser.isIE || ZC.Browser.isSafari || ZC.OS.isLinux)) {
          this._input[0].selectionStart = 0;
        }

        this._checkForChange(orgEvent, 'change'); // No I18N


        this._checkButtonsOptn(opts.clearButton === 'focus', opts.spinButtons === 'focus', 'hide', 'add', 'focusOut'); // No I18N


        this._changeHandler(orgEvent, 'blur'); // No I18N


        this._isCleared = false;
      }
    }, {
      key: "_validateStep",
      value: function _validateStep(stepOptions) {
        for (var i = 0, len = stepOptions.length; i < len; i++) {
          if (Number(this._opts[stepOptions[i]]) <= 0) {
            this._opts[stepOptions[i]] = 1;
          }
        }
      }
    }, {
      key: "_focusHandler",
      value: function _focusHandler(orgEvent) {
        var opts = this._opts;

        if (opts.disabled) {
          return false;
        } // if (ZC.Browser.isFirefox || ZC.Browser.isSafari || ZC.OS.isLinux()) {
        //     setTimeout(this._selectionFocusHandler.bind(this), 0);
        // } else {
        //     this._input[0].setSelectionRange(0, 0);
        // }


        this._input[0].setSelectionRange(0, 0);

        if (!opts.readonly) {
          this._checkButtonsOptn(opts.clearButton === 'focus', opts.spinButtons !== 'none'); // No I18N

        }

        this._clearBtnShown = false;
        clearTimeout(this._clearButtonTimeout);
        this._clearButtonTimeout = setTimeout(this._isClearVisible.bind(this), 1000);

        this._changeHandler(orgEvent, 'focus'); // No I18N

      }
    }, {
      key: "_checkButtonsOptn",
      value: function _checkButtonsOptn(isClearButton, isSpinButtons, effect, clsFn, event) {
        var clrBtn = this._clearButton;
        clsFn = (clsFn || 'remove') + 'Class'; // No I18N

        if (isClearButton) {
          // No I18N
          event !== 'focusOut' && clrBtn && this._toggleBtnDisplay(null, true, null, event); // No I18N

          effect && this._toggleBtnDisplay(effect === 'hide', true); // No I18N
        }

        if (isSpinButtons) {
          // No I18N
          if (this._buttonPane) {
            this._toggleBtnDisplay(effect === 'hide', false); // No I18N


            this._opts.calendarIcon && this.container[clsFn]('zdatetimefield--buttonsonhover');
            clrBtn && clrBtn[clsFn]('zh-right'); // No I18N
          }
        }
      }
    }, {
      key: "_mouseEnterHandler",
      value: function _mouseEnterHandler() {
        var opts = this._opts;

        if (document.activeElement !== this._input[0] && !opts.readonly && !opts.disabled) {
          this._checkButtonsOptn(opts.clearButton === 'focus', opts.spinButtons === 'focus', null, null, 'mouseenter'); // No I18N

        }
      }
    }, {
      key: "_addEffect",
      value: function _addEffect() {
        this._input.addClass('zeffects--skew'); // No I18N


        clearTimeout(this._effectTimeout);
        this._effectTimeout = setTimeout(this._effectTimeoutHandler.bind(this), 1000);
      }
    }, {
      key: "_effectTimeoutHandler",
      value: function _effectTimeoutHandler() {
        this._input.removeClass('zeffects--skew'); // No I18N

      }
    }, {
      key: "_getSegment",
      value: function _getSegment() {
        var inputElem = this._input[0];
        this._segment = this._checkForSegment(inputElem.selectionStart, inputElem.selectionEnd - 1);
      }
    }, {
      key: "_getPlaceholder",
      value: function _getPlaceholder(match) {
        switch (this._opts.placeholderType) {
          case 'date-format':
            // No I18N
            return match;

          case 'date-format-in-upper':
            // No I18N
            return match.toUpperCase();

          case 'date-format-in-lower':
            // No I18N
            return match.toLowerCase();

          case 'underscore':
            // No I18N
            return new Array(match.length + 1).join('_ ');

          case 'custom':
            // No I18N
            return this._getCustomMatch(match);
        }
      }
    }, {
      key: "_addDisabledClass",
      value: function _addDisabledClass(character) {
        var opts = this._opts,
            btn = ['down', 'up'],
            // No I18N
        offset = [-1, 1]; // No I18N

        if (opts.value) {
          for (var i = 0; i < btn.length; i++) {
            !this._getDisabledValue(opts.min, opts.max, character, offset[i]) && this.container.find(".zh-".concat(btn[i])).removeClass('is-disabled'); // No I18N
          }
        }
      }
    }, {
      key: "_getDisabledValue",
      value: function _getDisabledValue(min, max, character, offset) {
        var value,
            updateDisabledState = this._updateDisabledState.bind(this),
            newDate = this._modifyPartValue(character, offset, true);

        value = min && offset === -1 ? updateDisabledState(min, newDate, undefined, offset) : undefined;
        !value && (value = max && offset === 1 ? updateDisabledState(max, newDate, true, offset, value) : undefined);
        return value;
      }
    }, {
      key: "_checkPart",
      value: function _checkPart(part) {
        var parts = this['_get' + (this.name.indexOf('date') > -1 ? 'Date' : 'Time') + 'Parts'](); // No I18N

        return parts[part] && this["_".concat(parts[part], "Modified")]; // No I18N
      }
    }, {
      key: "_checkForPartModification",
      value: function _checkForPartModification() {
        var values = [],
            j = 0,
            format = this._opts.format,
            valModified = false;

        for (var i = 0; i < format.length; i++) {
          values[j++] = this._checkPart(format[i]);
        }

        while (--j >= 0) {
          if (values[j]) {
            valModified = true;
            break;
          }
        }

        this._isClearVisible();

        return !valModified;
      } // _selectionFocusHandler() {
      //     this._input[0].setSelectionRange(0, 0);
      // }

    }, {
      key: "_parseValue",
      value: function _parseValue(character, currentChar) {
        if (!currentChar) {
          this._isPartModified(character, false);

          return true;
        }

        var newDate = new Date(this._viewDate.getTime());

        this._parseSegment(character, currentChar, newDate); // this._oldDateValue = new Date(this._viewDate.getTime());


        this._viewDate = newDate;
        return true;
      }
    }, {
      key: "_updateDisabledState",
      value: function _updateDisabledState(value, newDate, isMax, offset, isDisabled) {
        var element = this.container.find(".zh-".concat(offset === 1 ? 'up' : 'down')),
            newDateTime = newDate.getTime(),
            time,
            isMore; // No I18N

        if (value) {
          !this._checkTime && value.setHours(0, 0, 0, 0);
          time = value.getTime();
        }

        isMore = isMax && value ? newDateTime >= time : newDateTime <= time;

        if (value && isMore) {
          element.addClass('is-disabled');
          return true;
        }

        return isDisabled;
      }
    }, {
      key: "_containerMouseUpHandler",
      value: function _containerMouseUpHandler(orgEvent) {
        var target = $(orgEvent.target);

        if (target.closest('.zdatetimefield__icon').length || target.closest('.zdatetimefield__iconbutton').length) {
          // No I18N
          orgEvent.preventDefault();

          if (this._currentSegment) {
            this._selectText(this._currentSegment);
          } else {
            this._selectCaretPosition(this._input[0], 0, 0);

            this._mouseupHandler();
          }
        }
      }
    }, {
      key: "_mouseLeaveHandler",
      value: function _mouseLeaveHandler() {
        var opts = this._opts,
            clrBtn = this._clearButton,
            buttonPane = this._buttonPane;

        if (document.activeElement !== this._input[0]) {
          if (opts.spinButtons === 'focus') {
            // No I18N
            buttonPane && this._toggleBtnDisplay(true);
            clrBtn && clrBtn.addClass('zh-right'); // No I18N

            opts.calendarIcon && this.container.addClass('zdatetimefield--buttonsonhover');
          }

          if (opts.clearButton === 'focus') {
            // No I18N
            clrBtn && this._toggleBtnDisplay(true, true, undefined, 'mouseleave'); // No I18N
          }
        }
      }
    }, {
      key: "_spinKeyupHandler",
      value: function _spinKeyupHandler(orgEvent) {
        this._keyUp = true;
        var evKeyCode = orgEvent.keyCode;
        evKeyCode !== ZC.keyCode.LEFT && evKeyCode !== ZC.keyCode.RIGHT && this._checkForChange(orgEvent, 'spinend'); // No I18N
      }
    }, {
      key: "_replaceMatchedText",
      value: function _replaceMatchedText(match) {
        var result = this._replaceText(match);

        result = result === undefined ? match.slice(1, match.length - 1) : result;

        if (this._retursFormat) {
          var formattedResult = '',
              i = result.length; // No I18N

          match = this._getMatch(match);

          while (i--) {
            formattedResult += match[0];
          }

          return formattedResult;
        }

        return result;
      }
    }, {
      key: "_pasteTimeoutHandler",
      value: function _pasteTimeoutHandler(pastedText, orgEvent) {
        var dateInfo = this._parseDateValue(pastedText, this._opts.format);

        dateInfo && dateInfo.isValid && (this._viewDate = dateInfo.date);

        this._checkForModification(dateInfo.isValid);

        this._updateElementValue();

        this._selectCaretPosition(this._input[0], 0, 0);

        this._mouseupHandler(orgEvent);

        this._pasteAction = false;
      }
    }, {
      key: "_mouseWheelHandler",
      value: function _mouseWheelHandler(orgEvent) {
        var inputElem = this._input,
            originalEvent = orgEvent.originalEvent;

        if (document.activeElement === inputElem[0]) {
          var newEvent = {
            preventDefault: function preventDefault() {},
            type: 'mousewheel' // No I18N

          }; // No I18N

          if (!this._keyUp && !this._mousewheelTriggered) {
            this._keyUp = true;
          }

          this._mousewheelTriggered = true;
          var name = "".concat(this.name, "timer"),
              base = this;
          clearTimeout($.data(inputElem, name));
          $.data(inputElem, name, setTimeout(function () {
            return base._checkForChange(orgEvent, 'spinend');
          }, 250)); // No I18N

          orgEvent.preventDefault();
          orgEvent.stopPropagation();
          newEvent.keyCode = (originalEvent.detail === 0 ? originalEvent.wheelDelta < 0 : originalEvent.detail > 0) ? 38 : 40;

          this._keydownHandler(newEvent);
        }
      }
    }, {
      key: "_pasteHandler",
      value: function _pasteHandler(orgEvent) {
        this._pasteAction = false;

        var pastedText = orgEvent.originalEvent.clipboardData.getData('Text'),
            // No I18N
        caretPosition = this._selectCaretPosition(this._input[0]),
            selectedTextLen; // No I18N
        // as it can take its value as zero, checked with undefined


        caretPosition[0] !== undefined && caretPosition[1] !== undefined && (selectedTextLen = caretPosition[1] - caretPosition[0]);

        if (selectedTextLen && selectedTextLen === this._input[0].value.length) {
          this._pasteAction = true;
          orgEvent.stopPropagation();
          orgEvent.preventDefault();
          this._input[0].value = pastedText;
          clearTimeout(this._pasteTimeout);
          this._pasteTimeout = setTimeout(this._pasteTimeoutHandler.bind(this, pastedText, orgEvent), 500);
        } else {
          orgEvent.preventDefault();
        }
      }
    }, {
      key: "_modifyPartValue",
      value: function _modifyPartValue(character, offset, disabledCheck) {
        var newDate = new Date(this._viewDate.getTime()),
            part = this._modifyValue(newDate, character, offset, this._getDateValue());

        if (!disabledCheck) {
          newDate = this._checkMinMaxLimit(newDate, part, offset);

          this._isPartModified(character, true);

          this._oldDateValue && this._setOldDate();
          this._viewDate = newDate;
          !this._oldDateValue && this._setOldDate();
        }

        if (this._hasPicker && (this._opts.pickerOptions.disabledDaysOfWeek || this._opts.pickerOptions.disabledDates)) {
          this._oldDateValue && this._setOldDate();
          this._viewDate = this._checkForDisabledDates(this._viewDate, offset);
          !this._oldDateValue && this._setOldDate();
        }

        return newDate;
      }
    }, {
      key: "_setOldDate",
      value: function _setOldDate() {
        var oldValue = this._oldDateValue;

        if (!oldValue || !ZC.Date.areDatesEqual(oldValue, this._viewDate) && !ZC.Date.areTimesEqual(oldValue, this._viewDate)) {
          this._oldDateValue = new Date(+this._viewDate);
        }
      }
    }, {
      key: "_mouseupHandler",
      value: function _mouseupHandler(orgEvent) {
        this._isClearVisible();

        var caretPosition = this._selectCaretPosition(this._input[0]); // selecting the text based on the caretPosition


        if (caretPosition[0] === caretPosition[1]) {
          this._selectText(this._checkForSegment(caretPosition[0], caretPosition[0] - 1));
        } else {
          orgEvent && orgEvent.type === 'mouseup' && window.getSelection().removeAllRanges(); // No I18N
        }
      }
    }, {
      key: "_checkForSegment",
      value: function _checkForSegment(i, j) {
        var allowedChars = this._allowedChars,
            format = this._dateFormat;

        for (var len = format.length; i < len || j >= 0; i++, j--) {
          if (allowedChars.indexOf(format[i]) !== -1) {
            return format[i];
          }

          if (j >= 0 && allowedChars.indexOf(format[j]) !== -1) {
            return format[j];
          }
        }
      }
    }, {
      key: "_getStringDiff",
      value: function _getStringDiff(oldText, oldFormat, newText, caretPosition) {
        this._isNewValue = false;
        var txtLen = caretPosition + oldText.length - newText.length,
            i,
            diff = [];
        oldText = oldText.substring(0, txtLen);
        newText = newText.substring(0, caretPosition);
        var newTxtLen = newText.length,
            formatPart = oldFormat[caretPosition - 1];

        if (oldText === newText && caretPosition > 0) {
          return [[formatPart, newText[caretPosition - 1]]];
        } // checks whether the letter is removed


        if (oldText.indexOf(newText) === 0 && (newTxtLen === 0 || oldFormat[newTxtLen - 1] !== oldFormat[newTxtLen])) {
          var removedChar = ''; // No I18N

          for (i = newTxtLen; i < oldText.length; i++) {
            if (oldText[i] !== removedChar && this._allowedChars.indexOf(oldFormat[i]) >= 0) {
              removedChar = oldFormat[i];
              diff.push([removedChar, '']); // No I18N
            }

            this._resetToFirst(removedChar);
          }

          return diff;
        }

        var navigationChar = newText[newTxtLen - 1];

        if (/[ |/|.|-|;]/.test(navigationChar) || navigationChar === oldText[txtLen]) {
          return [[oldFormat[caretPosition - 1], navigationChar]];
        }

        if (this._focusout) {
          this._resetOnBlur(formatPart);

          this._focusout = false;
        }

        this._isNewValue = true;
        return [[formatPart, newText[caretPosition - 1]]];
      }
    }, {
      key: "_checkForChange",
      value: function _checkForChange(orgEvent, eventName) {
        var notFullyModified = this._getDateValue() === undefined,
            changed,
            viewDate = this._viewDate,
            oldDate = this._oldDateValue;

        if (!notFullyModified) {
          if (viewDate.getDate() === 1 && viewDate.getMonth() === 0 && viewDate.getFullYear() === new Date().getFullYear() && viewDate.getHours() === 0 && viewDate.getMinutes() === 0 && viewDate.getSeconds() === 0) {
            changed = true;
          }
        }

        if (this._isCleared || !notFullyModified && (changed || viewDate && oldDate && +oldDate !== +viewDate)) {
          if (eventName === 'spin') {
            // No I18N
            clearTimeout(this._spinTimeout);
            this._spinTimeout = setTimeout(this._spinTimeoutHandler.bind(this, orgEvent), this._opts.spinEventTriggerDelay);
          } else {
            this._changeHandler(orgEvent, eventName);
          }
        }
      }
    }, {
      key: "_changeHandler",
      value: function _changeHandler(orgEvent, eventName) {
        (eventName || orgEvent.type) === 'change' && this._setOldDate(); // No I18N

        return this._dispatchEvent(eventName || 'change', orgEvent, {
          // No I18N
          value: this._opts.value ? this._input[0].value : '',
          dateValue: this._opts.value
        });
      }
    }, {
      key: "_keydownHandler",
      value: function _keydownHandler(orgEvent) {
        if (this._opts.disabled || this._opts.readonly) {
          return false;
        }

        var selection,
            keyCodes = ZC.keyCode,
            tabKeyCode = keyCodes.TAB,
            eventKeyCode = orgEvent.keyCode,
            isShiftPressed = orgEvent.shiftKey,
            selectCaretPosition = this._selectCaretPosition.bind(this),
            inputElem = this._input[0],
            dateFormat = this._dateFormat;

        if (eventKeyCode === tabKeyCode && !(inputElem.selectionStart === 0 && isShiftPressed || inputElem.selectionEnd === inputElem.value.length && !isShiftPressed)) {
          orgEvent.stopImmediatePropagation();
        }

        if ([keyCodes.RIGHT, keyCodes.LEFT, tabKeyCode].indexOf(eventKeyCode) > -1) {
          eventKeyCode !== tabKeyCode && orgEvent.preventDefault();
          selection = selectCaretPosition(inputElem);
          this._viewDate = this._checkMinMaxLimit(this._viewDate);

          if (this._isModified) {
            this._updateElementValue();

            selectCaretPosition(inputElem, selection[0], selection[1]);
          }

          if (selection[0] !== selection[1]) {
            this._mouseupHandler();
          }

          var direction = eventKeyCode === keyCodes.LEFT ? -1 : 1;

          if (eventKeyCode === tabKeyCode && isShiftPressed) {
            this._focusout = true;
            direction = -1;
          }

          selection = selectCaretPosition(inputElem);
          var currentIndex = direction === -1 ? selection[0] - 1 : selection[1] + 1,
              format = this._opts.format;

          while (currentIndex >= 0 && currentIndex < dateFormat.length) {
            var character = dateFormat[currentIndex],
                lastIndex = format.lastIndexOf(character);

            if (this._allowedChars.indexOf(character) >= 0) {
              if (eventKeyCode === tabKeyCode && (lastIndex !== format.length || lastIndex + 1 !== format.length)) {
                orgEvent.preventDefault();
                this._focusout = true;
              }

              this._reverseFocusset = direction === -1;

              this._selectText(dateFormat[currentIndex]);

              break;
            }

            currentIndex += direction;
          }
        }

        if (eventKeyCode === keyCodes.UP || eventKeyCode === keyCodes.DOWN) {
          orgEvent.preventDefault();
          selection = selectCaretPosition(inputElem);
          var _character = dateFormat[selection[0]];

          if (this._allowedChars.indexOf(_character) >= 0) {
            this._modifyPartValue(_character, eventKeyCode === keyCodes.UP ? 1 : -1);

            this._updateElementValue();

            this._clearButton && this._toggleBtnDisplay(null, true);

            this._selectText(_character);
          }

          this._checkForChange(orgEvent, this._keyUp ? 'spinstart' : 'spin'); // No I18N


          this._keyUp = false;
        }

        if (orgEvent.metaKey || orgEvent.ctrlKey) {
          var caretPosition = selectCaretPosition(inputElem),
              length;
          caretPosition[0] !== undefined && caretPosition[1] !== undefined && (length = caretPosition[1] - caretPosition[0]);

          if (eventKeyCode === 88 && length !== inputElem.value.length || eventKeyCode === 90) {
            orgEvent.preventDefault();
          }
        }
      }
    }, {
      key: "_checkMinMaxLimit",
      value: function _checkMinMaxLimit(newDate, part, offset, shouldAddClass) {
        var min = this._opts.min,
            max = this._opts.max;
        shouldAddClass = shouldAddClass === undefined || shouldAddClass;
        this._isModified = false;
        max && (newDate = this._validateValues(max, newDate, part, offset, shouldAddClass, true));
        min && (newDate = this._validateValues(min, newDate, part, offset, shouldAddClass));
        return newDate;
      }
    }, {
      key: "_validateValues",
      value: function _validateValues(value, newDate, part, offset, shouldAddClass, isMax) {
        if (value) {
          var currentTime = new Date().getTime(),
              time,
              newDateTime,
              isMore,
              isValueMore,
              opts = this._opts,
              classfn;
          time = value.getTime();
          newDateTime = newDate.getTime();
          isMore = isMax ? time < currentTime : time > currentTime;
          isValueMore = isMax ? newDateTime >= time : newDateTime <= time;

          if (isValueMore || part && !this[part] && isMore && !offset) {
            classfn = opts.value ? 'add' : undefined; // No I18N

            this._isModified = true;
            newDate = new Date((offset && newDateTime !== time ? this._viewDate : value).getTime());
          } else {
            classfn = isValueMore ? undefined : 'remove'; // No I18N
          }

          classfn && shouldAddClass && opts.spinButtons !== 'none' && this.container.find(".zh-".concat(isMax ? 'up' : 'down'))["".concat(classfn, "Class")]('is-disabled'); // No I18N
        }

        return newDate;
      }
    }, {
      key: "_keyUpHandler",
      value: function _keyUpHandler(orgEvent, doNotTrigger) {
        // Check for IE9
        var keyCodes = [32, 8, 46],
            keycode = orgEvent.keyCode;

        if (orgEvent.type === 'input' || orgEvent.type === 'keyup' && (keycode >= 186 && keycode <= 192 || keycode >= 219 && keycode <= 222 || keycode >= 48 && keycode <= 57 || keycode >= 65 && keycode <= 90 || keyCodes.indexOf(keycode) > -1)) {
          // No I18N
          var currentTime = new Date().getTime(),
              dateFormat = this._dateFormat;
          this._isFastInput = !!(this._keyUpTime && currentTime - this._keyUpTime < 500);
          this._keyUpTime = currentTime;

          if (document.activeElement !== this._input[0]) {
            return;
          }

          var i,
              diff = this._getStringDiff(this._oldValue, dateFormat, this._input[0].value, this._selectCaretPosition(this._input[0])[0]),
              diffLen = diff.length,
              separatorMatch = /[ |/|.|-|;]/.test(diff[0][1]),
              isNavigation = diffLen === 1 && separatorMatch;

          if (this._isNewValue && this._allowedChars.indexOf(diff[0][0]) > -1 && this._currentSegment !== this._oldSegment) {
            this._resetValues(diff[0][0], diff[0][1]);
          }

          if (isNavigation) {
            this._viewDate = this._checkMinMaxLimit(this._viewDate);
          } else {
            for (i = 0; i < diffLen; i++) {
              var char1 = this._translateAToE(diff[i][0]),
                  char2 = this._translateAToE(diff[i][1]);

              this._parseValue(char1, char2);
            }
          }

          !this._pasteAction && this._updateElementValue();
          separatorMatch = /[ |/|.|-|;]/.test(diff[0][0]);

          if (diffLen && !separatorMatch) {
            this._selectText(diff[0][0]);

            if (this._isNextSegment) {
              var _index2 = dateFormat.lastIndexOf(diff[0][0]) + 1;

              if (_index2 < dateFormat.length) {
                while (this._allowedChars.indexOf(dateFormat[_index2]) === -1 && _index2 < dateFormat.length) {
                  _index2 += 1;
                }

                this._isNextSegment = false;
                this._viewDate = this._checkMinMaxLimit(this._viewDate);
                !this._pasteAction && this._updateElementValue();

                this._selectText(dateFormat[_index2]);
              }
            }
          }

          if (isNavigation) {
            this._keydownHandler({
              keyCode: ZC.keyCode.RIGHT,
              preventDefault: function preventDefault() {}
            });
          } else if (!doNotTrigger) {
            this._checkForChange(orgEvent, 'spin'); // No I18N

          }

          if (this._opts.clearButton !== 'none') {
            // No I18N
            this._toggleBtnDisplay(null, true);
          }
        }
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        var componentName = this.name,
            // No I18N
        opts = this._opts,
            updateElementValue = this._updateElementValue.bind(this),
            // No I18N
        inputElem = this._input,
            isFormat = optionName === "format",
            isValue = optionName === "value",
            // No I18N
        placeHolder = ["date-format", "underscore", "date-format-in-upper", "date-format-in-lower", "custom"],
            // No I18N
        setAttribute = _get(_getPrototypeOf(ZDateInput.prototype), "_setAttribute", this).bind(this),
            shouldCheck,
            oldFormat = this._format;

        this._opts[optionName] = value;

        if (isFormat || isValue) {
          isValue && this._setValue(value);

          this._setBoolValue(["month", "year", "minutes", "seconds", "hours"], true, "Modified"); // No I18N


          if (isFormat) {
            // No I18N
            this._format = value;

            this._setFormat();

            this._validateFormat();

            if (this._invalidFormat) {
              this._format = opts.format = oldFormat;
              return;
            }

            this._picker && this._getPicker()._setAttribute("format", opts.format); // No I18N
          }

          var dateValue = opts.value;

          this._checkForModification(dateValue);

          this._viewDate = this._checkMinMaxLimit(dateValue ? new Date(dateValue.getTime()) : this._resetViewDate());
          shouldCheck = true;
          updateElementValue();
          isValue && !this.container.hasClass('has-focus') && this._input.trigger('change'); // No I18N

          isValue && !value && (this._isCleared = true);
        } else if (optionName === "min" || optionName === "max") {
          // No I18N
          this._validateValue(optionName, value);

          this._performValidations();

          this._viewDate = this._checkMinMaxLimit(this._viewDate);
          shouldCheck = true;

          if (this._picker) {
            ZC[this._pickerMethods.instance](this._picker).setAttribute(optionName + "Date", opts[optionName]);
          }

          updateElementValue();
        } else if (/increment|decrement|spinButtons/g.test(optionName)) {
          optionName === "spinButtonsOrientation" && this._updateClass("zinputfield--split", value === 'vertical'); // No I18N

          setAttribute(optionName, value);
          value && this._reConstructSpinButtons(value);
        } else if (optionName === "placeholderType") {
          // No I18N
          opts.placeholerType = placeHolder.indexOf(value) === -1 ? "date-format" : value; // No I18N

          !opts.value && updateElementValue();
        } else if (optionName === "locale") {
          // No I18N
          this._setFormat();

          updateElementValue();
          inputElem[(value === "ar" ? "add" : "remove") + "Class"]("zh-bidioverride"); // No I18N
        } else if (optionName === "disabled") {
          // No I18N
          setAttribute(optionName, value);
          inputElem[(value ? "remove" : "add") + "Class"]("zh-hidecursor"); // No I18N

          opts.clearButton !== "none" && (value ? this._clearButton.off("mouseup.".concat(componentName, " mousedown.").concat(componentName)) : this._bindClearBtnEvents()); // No I18N
        } else if (optionName === "rtl") {
          // No I18N
          inputElem[(opts.locale === "ar" ? "add" : "remove") + "Class"]("zh-bidioverride"); // No I18N

          inputElem.css("direction", "ltr"); // No I18N
        } else {
          setAttribute(optionName, value);
        }

        if (shouldCheck) {
          this._disableSpinBtns();

          this._domChanged = true;
        }
      }
    }, {
      key: "_setValue",
      value: function _setValue(value) {
        var opts = this._opts,
            inputElem = this._input,
            // No I18N
        isModified = this._validateValue("value", value); // No I18N


        value = opts.value;

        this._performValidations();

        if (isModified && value) {
          this._setOldDate();

          this._viewDate = new Date(value.getTime());
          inputElem.attr("aria-valuenow", ZC.Date.formatDate(value, opts.format)); // No I18N
        }

        !value && inputElem.removeAttr("aria-valuenow"); // No I18N

        this._clearButton && this._toggleBtnDisplay(null, true);
        return isModified;
      }
    }, {
      key: "_updateClearBtn",
      value: function _updateClearBtn() {
        _get(_getPrototypeOf(ZDateInput.prototype), "_updateClearBtn", this).call(this);

        if (this._opts.value) {
          this._clearBtnShown = true;
          this._opts.spinButtons === 'focus' && this._clearButton.addClass('zh-right'); // No I18N
        }

        this._toggleBtnDisplay(null, true);
      }
    }, {
      key: "_bindClearBtnEvents",
      value: function _bindClearBtnEvents() {
        this._addEvents({
          clearButtonClick: 'mouseup',
          // No I18N
          clearButtonMousedown: 'mousedown' // No I18N

        }, this._clearButton);
      }
    }, {
      key: "_clearButtonMousedownHandler",
      value: function _clearButtonMousedownHandler(orgEvent) {
        orgEvent.stopPropagation();
        orgEvent.preventDefault();
        clearInterval(this._mouseDownTimer);
        this._mouseDown = false;

        this._getSegment();
      }
    }, {
      key: "_clearActionHandler",
      value: function _clearActionHandler() {
        this._opts.value = null;
        this._isCleared = true;

        if (this._immediateCommit) {
          this._lastValue = undefined;
        }

        var inputElem = this._input;
        inputElem[0].value = ''; // No I18N

        if (document.activeElement !== inputElem[0]) {
          inputElem.focus();
        }

        this._keyUpHandler({
          type: 'input',
          // No I18N
          keyCode: ZC.keyCode.BACKSPACE,
          preventDefault: function preventDefault() {}
        }, true);

        this._selectText(this._segment);

        this._mouseupHandler();

        this._data.spinButtons && this._buttonPane.find('.zh-up,.zh-down').removeClass('is-disabled'); // No I18N
      }
    }, {
      key: "_isClearVisible",
      value: function _isClearVisible() {
        this._clearBtnShown = this._opts.clearButton !== 'none' && this._clearButton && this._clearButton.is(':visible'); // No I18N
      }
    }, {
      key: "_clearButtonClickHandler",
      value: function _clearButtonClickHandler(orgEvent) {
        if (this._clearBtnShown) {
          orgEvent.preventDefault();
          clearInterval(this._mouseDownTimer);
          this._mouseDown = false;

          this._clearActionHandler();

          return false;
        }

        this._mouseupHandler();
      }
    }, {
      key: "_spinButtonsMousedownHandler",
      value: function _spinButtonsMousedownHandler(orgEvent) {
        orgEvent.preventDefault();

        if (this._opts.disabled || orgEvent.which > 1 || this._opts.readonly || $(orgEvent.target).closest('.zinputfield__spinbutton').hasClass('is-disabled')) {
          return;
        }

        this._mouseDown = true;
        this.container.addClass('has-focus'); // No I18N

        this._checkForChange(orgEvent, 'spinstart'); // No I18N


        if (this._input[0].selectionStart === (0 || this._input[0].value.length) && this._input[0].selectionEnd === this._input[0].value.length) {
          this._selectCaretPosition(this._input[0], 0, 0);

          this._mouseupHandler(orgEvent);
        }

        var ev = this._assignEventProps(orgEvent);

        this._keyUp = true;

        this._keydownHandler(ev);

        clearTimeout(this._mouseDownTimer);
        this._mouseDownTimer = setInterval(this._repetitiveMouseDownHandler.bind(this, orgEvent), 200);
        ZC.$document.off("mouseup.".concat(this.name)).on("mouseup.".concat(this.name), this._documentMouseUpHandler.bind(this));
      }
    }, {
      key: "_repetitiveMouseDownHandler",
      value: function _repetitiveMouseDownHandler(orgEvent) {
        if (this._mouseDown) {
          this._keydownHandler(this._assignEventProps(orgEvent));
        } else {
          clearInterval(this._mouseDownTimer);
        }
      }
    }, {
      key: "_assignEventProps",
      value: function _assignEventProps(event) {
        return {
          keyCode: $(event.target).closest('.zh-up').length ? ZC.keyCode.UP : ZC.keyCode.DOWN,
          preventDefault: function preventDefault() {}
        };
      }
    }, {
      key: "_documentMouseUpHandler",
      value: function _documentMouseUpHandler() {
        clearInterval(this._mouseDownTimer);
        ZC.$document.off("mouseup.".concat(this.name));
        this._mouseDown = false;
      }
    }, {
      key: "_updateSpinButtons",
      value: function _updateSpinButtons() {
        var data = this._data;

        if (this._opts.spinButtons === 'focus') {
          // No I18N
          data.className += ' zdatetimefield--buttonsonhover'; // No I18N
        }

        _get(_getPrototypeOf(ZDateInput.prototype), "_updateSpinButtons", this).call(this);
      }
    }, {
      key: "_bindSpinButtonEvents",
      value: function _bindSpinButtonEvents() {
        this._addEvents({
          // No I18N
          spinButtonsMouseup: 'mouseup',
          // No I18N
          spinButtonsMousedown: 'mousedown' // No I18N

        }, this.container.find('.zh-up,.zh-down'));
      }
    }, {
      key: "_spinButtonsMouseupHandler",
      value: function _spinButtonsMouseupHandler(orgEvent) {
        this._mouseUp = true;

        this._checkForChange(orgEvent, 'spinend'); // No I18N

      }
    }, {
      key: "_reConstructSpinButtons",
      value: function _reConstructSpinButtons(value) {
        var containerCls = ' zdatetimefield',
            // No I18N
        opts = this._opts,
            data = this._data;

        if (data.spinButtons) {
          if (value === 'focus') {
            // No I18N
            this._addEvents({
              mouseEnter: 'mouseenter',
              // No I18N
              mouseLeave: 'mouseleave' // No I18N

            }, this.container);
          }

          this.container.attr('role', 'spinbutton'); // No I18N

          data.isVertical && !opts.calendarIcon && this._updateClass(containerCls, true);
          opts.spinButtons === 'always' && this._updateClass('zdatetimefield--buttonsonhover', true); // No I18N
        } // else{
        //     this._opts.calendarIcon && this.container.removeClass(containerCls);
        // }

      }
    }, {
      key: "name",
      get: function get() {
        return "zdateinput";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          placeholderType: 'date-format',
          // No I18N
          jumpOnComplete: true,
          locale: 'en-US',
          // No I18N
          spinButtonsOrientation: 'vertical',
          // No I18N
          incrementOnWrapAround: true
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          otherInputFormats: []
        };
      }
    }]);

    return ZDateInput;
  }(ZC.ZInputField);

  ZC.registerComponent('ZDateInput', ZC.ZInputField, ZDateInput);

  var ZTimeField =
  /*#__PURE__*/
  function (_ZC$ZDateInput) {
    _inherits(ZTimeField, _ZC$ZDateInput);

    function ZTimeField() {
      _classCallCheck(this, ZTimeField);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZTimeField).apply(this, arguments));
    }

    _createClass(ZTimeField, [{
      key: "_validateFormat",
      value: function _validateFormat() {
        this._checkFormat(/d|M|y/g); // No I18N

      }
    }, {
      key: "_init",
      value: function _init() {
        this._allowedChars = 'Hhmstz'; // No I18N

        _get(_getPrototypeOf(ZTimeField.prototype), "_init", this).apply(this, arguments);

        this._opts.templateName = 'zinputfield'; // No I18N

        this._opts.incrementOnWrapAround = false;
      }
    }, {
      key: "_setFormat",
      value: function _setFormat() {
        this._setFormatVal(/^(time-short|time-long|time-medium)$/, 'time', 'hh:mm tt'); // No I18N

      }
    }, {
      key: "_getDateValue",
      value: function _getDateValue() {
        return this._hoursModified && this._minutesModified && this._secondsModified ? new Date(this._viewDate.getTime()) : undefined;
      }
    }, {
      key: "_getMatch",
      value: function _getMatch(match) {
        return match;
      }
    }, {
      key: "_getRegEx",
      value: function _getRegEx() {
        return /HH|H|hh|h|mm|m|ss|s|tt|zz{0,2}|"[^"]*"|'[^']*'/g;
      }
    }, {
      key: "_resetToFirst",
      value: function _resetToFirst(removedChar) {
        this._resetTimeToFirst(removedChar);
      }
    }, {
      key: "_resetTimeToFirst",
      value: function _resetTimeToFirst(removedChar) {
        var obj = {
          H: 'Hours',
          // No I18N
          m: 'Minutes',
          // No I18N
          s: 'Seconds' // No I18N

        };

        if (removedChar && 'Hms'.indexOf(removedChar) > -1) {
          this._viewDate["set".concat(obj[removedChar])](0);
        }
      }
    }, {
      key: "_resetOnBlur",
      value: function _resetOnBlur(_char2) {
        this._resetTimeOnBlur(_char2);
      }
    }, {
      key: "_resetTimeOnBlur",
      value: function _resetTimeOnBlur(_char3) {
        _char3 === 'm' && this._viewDate.setMinutes(0); // No I18N
      }
    }, {
      key: "_parseSegment",
      value: function _parseSegment(character, currentChar, newDate) {
        return this._parseTime(character, currentChar, newDate);
      }
    }, {
      key: "_replaceTime",
      value: function _replaceTime(match) {
        var result,
            viewDate = this._viewDate,
            hoursModified = this._hoursModified,
            minutesModified = this._minutesModified,
            secondsModified = this._secondsModified,
            getPlaceholder = this._getPlaceholder.bind(this);

        if (['h', 'hh', 'H', 'HH'].indexOf(match) > -1) {
          // No I18N
          result = hoursModified ? viewDate.getHours() : getPlaceholder(match);

          if (hoursModified) {
            ['h', 'hh'].indexOf(match) > -1 && (result = result % 12 || 12); // No I18N

            result = ['h', 'H'].indexOf(match) > -1 ? result.toString() : (result < 10 ? '0' : '') + result; // No I18N
          }
        } else if (['m', 'mm', 's', 'ss'].indexOf(match) > -1) {
          // No I18N
          var parts = match.indexOf('m') > -1 ? ['Minutes', minutesModified] : ['Seconds', secondsModified]; // No I18N

          result = parts[1] ? viewDate["get".concat(parts[0])]() : getPlaceholder(match);
          parts[1] && (result = match.length === 1 ? result.toString() : (result < 10 ? '0' : '') + result); // No I18N
        } else if (['tt'].indexOf(match) > -1) {
          result = hoursModified ? viewDate.getHours() < 12 ? this._getI18NText('AM') : this._getI18NText('PM') : this._opts.placeholder.period; // No I18N

          if (this._opts.placeholderType !== 'underscore') {
            // No I18N
            result = getPlaceholder(result);
          }
        } else if (['z', 'zz', 'zzz'].indexOf(match) > -1) {
          // No I18N
          result = viewDate.toString().split(' ')[5]; // No I18N
        }

        return this._translateEToA(result);
      }
    }, {
      key: "_replaceText",
      value: function _replaceText(match) {
        return this._replaceTime(match);
      }
    }, {
      key: "_performValidations",
      value: function _performValidations() {
        _get(_getPrototypeOf(ZTimeField.prototype), "_performValidations", this).call(this, ['hourStep', 'minuteStep', 'secondStep'], ['hours', 'minutes', 'seconds']); // No I18N

      }
    }, {
      key: "_getCustomMatch",
      value: function _getCustomMatch(match) {
        return this._getTimeMatch(match);
      }
    }, {
      key: "_getTimeMatch",
      value: function _getTimeMatch(match) {
        var part = this._getTimeParts()[match[0]];

        part = ['h', 'hh', 'H', 'HH', 'm', 'mm', 's', 'ss'].indexOf(match) > -1 ? this._opts.placeholder[part.slice(0, -1)] : ''; // No I18N

        return part || !this._hoursModified && this._opts.placeholder.period || match;
      }
    }, {
      key: "_getTimeParts",
      value: function _getTimeParts() {
        return {
          H: 'hours',
          // No I18N
          h: 'hours',
          // No I18N
          m: 'minutes',
          // No I18N
          s: 'seconds' // No I18N

        };
      }
    }, {
      key: "_modifyValue",
      value: function _modifyValue(newDate, character, offset, isValueComplete) {
        return this._modifyTime(newDate, character, offset, isValueComplete);
      }
    }, {
      key: "_modifyTime",
      value: function _modifyTime(newDate, character, offset, isValueComplete) {
        var part;

        if (['h', 'H'].indexOf(character) > -1) {
          // No I18N
          part = '_hoursModified'; // No I18N

          offset *= this._opts.hourStep;
          var hourValue = newDate.getHours() + offset;

          if (!this._opts.incrementOnWrapAround || !isValueComplete) {
            hourValue > 23 && (hourValue %= 24);
            hourValue < 0 && (hourValue += 24);
          }

          (this._hoursModified || offset < 0) && newDate.setHours(hourValue);
        } else if (['m', 's'].indexOf(character) > -1) {
          // No I18N
          part = this._minuteSecondUpdate(character, offset, newDate, isValueComplete);
        } else if (character === 't') {
          // No I18N
          newDate.setHours((newDate.getHours() + 12) % 24);
        }

        return part;
      }
    }, {
      key: "_updateDisabledState",
      value: function _updateDisabledState(value, newDate, isMax) {
        var element = this.container.find(".zh-".concat(isMax ? 'up' : 'down')),
            newDateTime = newDate.getTime(),
            time,
            isDisabled,
            isMore; // No I18N

        if (value) {
          time = +value;
        }

        isMore = isMax && value ? newDateTime > time : newDateTime < time;

        if (value && isMore) {
          element.addClass('is-disabled'); // No I18N

          isDisabled = true;
        }

        !isDisabled && element.removeClass('is-disabled'); // No I18N

        return isDisabled;
      }
    }, {
      key: "_parseTime",
      value: function _parseTime(character, currentChar, newDate) {
        var jumpOnComplete = this._opts.jumpOnComplete,
            viewDate = this._viewDate,
            hourString,
            hoursModified = this._hoursModified,
            newValue;

        if (character === 'h') {
          // No I18N
          newValue = (hoursModified ? newDate.getHours() % 12 * 10 : 0) + parseInt(currentChar);

          if (isNaN(newValue)) {
            return;
          }

          hourString = newValue.toString();

          if (!jumpOnComplete && newValue > 12) {
            newValue = this._isFastInput ? parseInt(hourString[0]) : parseInt(hourString.slice(-1));
          } else if (jumpOnComplete) {
            while (newValue > 12) {
              newValue = parseInt(newValue.toString().slice(1));
            }
          }

          newValue = viewDate.getHours() >= 12 ? newValue + 12 : newValue % 12 === 0 ? 0 : newValue;

          if (jumpOnComplete && hoursModified && currentChar !== '1') {
            // No I18N
            this._isNextSegment = true;
          }

          newValue > 23 && (newValue = 12);
        } else if (character === 'H') {
          // No I18N
          newValue = (this._isNewValue && this._oldSegment !== this._currentSegment ? 0 : hoursModified ? newDate.getHours() * 10 : 0) + parseInt(currentChar);

          if (isNaN(newValue)) {
            return;
          }

          hourString = newValue.toString();
          var strLen = hourString.length;

          if (jumpOnComplete && (newValue >= 23 || strLen === 2 && hourString[1] !== '0')) {
            // No I18N
            this._isNextSegment = true;
          }

          if (!jumpOnComplete && newValue > 23 && this._isFastInput) {
            if (strLen === 2) {
              newValue = viewDate.getHours();
            } else if (strLen >= 3) {
              newValue = parseInt(newValue.toString().slice(1));

              if (newValue > 23) {
                newValue = parseInt(newValue.toString()[0]);
              }
            }
          } else {
            newValue > 23 && (newValue = jumpOnComplete ? parseInt(hourString[0]) : parseInt(hourString.slice(-1)));
          }
        } else if (['m', 's'].indexOf(character) > -1) {
          // No I18N
          this._parseMinuteSecond(character, currentChar, newDate);
        } else if (character === 't') {
          // No I18N
          if (hoursModified) {
            this._typedPeriodChar += currentChar.toLowerCase();

            while (this._typedPeriodChar.length > 0) {
              var AMKey = this._getI18NText('AM'),
                  // No I18N
              PMKey = this._getI18NText('PM'),
                  // No I18N
              typedChar = this._typedPeriodChar; // No I18N


              if (AMKey.toLowerCase().indexOf(typedChar) === 0 && newDate.getHours() >= 12 || PMKey.toLowerCase().indexOf(typedChar) === 0 && newDate.getHours() < 12) {
                newDate.setHours((newDate.getHours() + 12) % 24);
                this._oldDateValue = new Date(viewDate.getTime());
                this._viewDate = newDate;
                return true;
              }

              this._typedPeriodChar = typedChar.substring(1, typedChar.length);
            }

            this._hoursModified = true;
            return true;
          }
        }

        ['H', 'h'].indexOf(character) > -1 && newDate.setHours(newValue); // No I18N

        ['m', 's'].indexOf(character) === -1 && (this._hoursModified = true); // No I18N

        return newDate;
      }
    }, {
      key: "_parseMinuteSecond",
      value: function _parseMinuteSecond(character, currentChar, newDate) {
        var suffix = character === 'm' ? 'Minutes' : 'Seconds',
            // No I18N
        part = "_".concat(this._getTimeParts()[character], "Modified"),
            // No I18N
        newValue = (this["".concat(part)] ? newDate["get".concat(suffix)]() * 10 : 0) + parseInt(currentChar),
            // No I18N
        jumpOnComplete = this._opts.jumpOnComplete;

        if (!isNaN(newValue)) {
          var str = newValue.toString();

          if (jumpOnComplete && (newValue >= 59 || str.length === 2 && str[1] !== '0')) {
            // No I18N
            this._isNextSegment = true;
          }

          if (!jumpOnComplete && newValue > 59 && this._isFastInput) {
            if (str.length === 2) {
              newValue = this._viewDate["get".concat(suffix)](); // No I18N
            } else if (str.length >= 3) {
              newValue > 59 && (newValue = parseInt(newValue.toString().slice(1)));

              if (newValue > 59) {
                newValue = parseInt(newValue.toString()[0]);
              }
            }
          } else {
            newValue > 59 && (newValue = jumpOnComplete ? parseInt(str[0]) : parseInt(str.slice(-1)));
          }

          newDate["set".concat(suffix)](newValue); // No I18N

          this[part] = true;
        }
      }
    }, {
      key: "_minuteSecondUpdate",
      value: function _minuteSecondUpdate(character, offset, newDate, isValueComplete) {
        var part = "_".concat(this._getTimeParts()[character], "Modified"),
            // No I18N
        step = "".concat(part.slice(1, 7), "Step"),
            // No I18N
        methodSuffix = character === 'm' ? 'Minutes' : 'Seconds'; // No I18N

        offset *= this._opts[step];
        var value = newDate["get".concat(methodSuffix)]() + offset; // No I18N

        if (!this._opts.incrementOnWrapAround || !isValueComplete) {
          value > 59 && (value %= 60);
          value < 0 && (value += 60);
        }

        (this[part] || offset < 0) && newDate["set".concat(methodSuffix)](value); // No I18N

        return part;
      }
    }, {
      key: "_isPartModified",
      value: function _isPartModified(character, value) {
        this._isTimeModified(character, value);
      }
    }, {
      key: "_isTimeModified",
      value: function _isTimeModified(character, value) {
        var obj = this._getTimeParts(); // No I18N


        this["_".concat(obj[character], "Modified")] = value; // No I18N

        ['h', 'H'].indexOf(character) > -1 && !value && (this._typedPeriodChar = ''); // No I18N
      }
    }, {
      key: "name",
      get: function get() {
        return "ztimefield";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          format: 'hh:mm tt',
          // No I18N
          hourStep: 1,
          minuteStep: 1,
          secondStep: 1,
          placeholder: {
            hour: 'hour',
            // No I18N
            minute: 'minute',
            // No I18N
            second: 'second',
            // No I18N
            period: 'AM/PM' // No I18N

          },
          labels: {
            period: 'AM/PM',
            // No I18N
            AM: 'AM',
            // No I18N
            PM: 'PM' // No I18N

          }
        };
      }
    }]);

    return ZTimeField;
  }(ZC.ZDateInput);

  ZC.registerComponent('ZTimeField', ZC.ZDateInput, ZTimeField);

  var ZTimeInput =
  /*#__PURE__*/
  function (_ZC$CoreComponent17) {
    _inherits(ZTimeInput, _ZC$CoreComponent17);

    function ZTimeInput() {
      _classCallCheck(this, ZTimeInput);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZTimeInput).apply(this, arguments));
    }

    _createClass(ZTimeInput, [{
      key: "_init",
      value: function _init(ele, opts) {
        this._is12HourFormat = opts.format.indexOf('h') > -1;
        opts.viewDate = new Date();
        opts.viewDate.setHours(0, 0, 0, 0);
        opts.selectedTime = this._getDateVal(opts.selectedTime);

        this._validateTimeOpts();

        this._buildData();
      }
    }, {
      key: "update",
      value: function update() {
        this._checkForTime && this._checkForTime();
      }
    }, {
      key: "_validateLimits",
      value: function _validateLimits(tempDate) {
        var opts = this._opts,
            options = ['minTime', 'maxTime']; // No I18N

        for (var i = 0; i < 2; i++) {
          var opt = options[i];

          if (opts[opt]) {
            this['_' + opt] = opts[opt] = this._parseTimeVal(opt);
          }
        }

        var minTime = opts.minTime,
            maxTime = opts.maxTime;

        if (minTime && maxTime && ZC.Date.isGreater(minTime, maxTime)) {
          maxTime = opts.maxTime = undefined;
        }

        if (maxTime && tempDate && ZC.Date.isGreater(tempDate, maxTime)) {
          opts.selectedTime.setHours(maxTime.getHours(), maxTime.getMinutes(), 0, 0);
        }

        if (minTime && tempDate && ZC.Date.isGreater(minTime, tempDate)) {
          opts.selectedTime.setHours(minTime.getHours(), minTime.getMinutes(), 0, 0);
        }
      }
    }, {
      key: "_checkHourMinLimit",
      value: function _checkHourMinLimit(h, minute, hrCheck) {
        var min = this._opts.minTime,
            max = this._opts.maxTime;
        return min && (hrCheck && h < min.getHours() || h === min.getHours() && minute < min.getMinutes()) || max && (hrCheck && h > max.getHours() || h === max.getHours() && minute > max.getMinutes());
      }
    }, {
      key: "_checkPeriod",
      value: function _checkPeriod(tempDate, hours, isAM) {
        var tempHours = tempDate.getHours();
        var condition = !!((isAM ? tempHours >= 12 : tempHours < 12) && this._checkHourMinLimit(hours, tempDate.getMinutes(), true));
        this._opts.disabledTimeList.length && (condition = this._checkIfDisabled(tempDate, tempDate.getMinutes(), condition, hours));
        ZC.select(this._periodEle).setOptionAttributes(isAM ? 'AM' : 'PM', 'disabled', condition); // No I18N
      }
    }, {
      key: "_disableTime",
      value: function _disableTime(tempDate, i, min) {
        var condition = !!this._checkHourMinLimit(tempDate.getHours(), min || i);
        this._opts.disabledTimeList.length && (condition = this._checkIfDisabled(tempDate, i, condition));
        return condition;
      }
    }, {
      key: "_parseTimeVal",
      value: function _parseTimeVal(opt) {
        var value = ZC.Date.parseDate(this._opts[opt], this._opts.format).date;
        value.setSeconds(0, 0);
        return value;
      }
    }, {
      key: "_validateTimeOpts",
      value: function _validateTimeOpts() {
        var opts = this._opts,
            list = opts.disabledTimeList,
            tempDate,
            value = opts.selectedTime,
            minTime = this._minTime;

        if (value) {
          tempDate = new Date();
          tempDate.setHours(value.getHours(), value.getMinutes(), 0, 0);
        }

        this._opts.selectedTime = tempDate || (minTime ? new Date(minTime.getTime()) : this._opts.selectedTime);

        if (list && list.length && typeof list[0] === 'string') {
          // No I18N
          this._convertStringToObject({
            disabledTimeList: list
          });
        }

        (opts.minTime || opts.maxTime) && this._validateLimits(tempDate);
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender(elem, data) {
        var opts = this._opts,
            modifiedAttr = data.modifiedAttr;

        if (modifiedAttr === 'timeFieldType' || !this._hourEle || !this._input || !this._singleSelect || !this._combinedEle) {
          // No I18N
          this._updateTimeInputs();
        }

        if (this._timeElemRendered || this._valueReset) {
          // if (this._timeElemRendered) {
          //     if (opts.timeFieldType === 'input') { // No I18N
          //         let elem = this.element.find('.zinputfield'); // No I18N
          //         this._input = this.isCE ? elem : elem.prev();// No I18N
          //         timeProps.inputProps.mainElement = this._input[0];
          //     } else {
          //         this._setSelectElement(...arguments);
          //     }
          // }
          if (opts.timeFieldType === 'multiple-select-box' && modifiedAttr !== 'singleSelect') {
            // No I18N
            this._checkForTime();
          }

          this._updateSelectedTime(opts.timeFieldType, this._timeElemRendered);
        }
      }
    }, {
      key: "_postRender",
      value: function _postRender() {
        this._data.className += ' ';

        this._updateTimeInputs();
      }
    }, {
      key: "_updateTimeInputs",
      value: function _updateTimeInputs() {
        var opts = this._opts,
            id = this._opts.id,
            element = this.element,
            fieldType = opts.timeFieldType;

        if (fieldType === 'input') {
          // No I18N
          this._input = element.find('#' + id + '-type-input'); // No I18N
        } else if (fieldType === 'multiple-select-box') {
          // No I18N
          if (opts.timeMultipleSelectBoxType === 'h-m-t') {
            // No I18N
            this._hourEle = element.find('#' + id + '-hour'); // No I18N

            this._minuteEle = element.find('#' + id + '-minute'); // No I18N

            if (this._is12HourFormat) {
              this._periodEle = element.find('#' + id + '-period'); // No I18N
            }
          } else {
            this._combinedEle = element.find('#' + id + '-time-combined');

            if (this._is12HourFormat) {
              this._periodEle = element.find('#' + id + '-combined-period');
            }
          }
        } else {
          this._singleSelect = element.find('#' + id + '-single-time-select');
        }
      }
    }, {
      key: "_buildData",
      value: function _buildData() {
        this.buildTimePicker();
      }
    }, {
      key: "_validateOpts",
      value: function _validateOpts() {
        var opts = this._opts,
            options = options = ['hourStep', 'minuteStep']; // No I18N

        for (var i = 0; i < options.length; i++) {
          var stepVal = Number(opts[options[i]]);
          opts[options[i]] = stepVal <= 0 ? 1 : stepVal;
        }
      }
    }, {
      key: "buildTimePicker",
      value: function buildTimePicker() {
        var opts = this._opts,
            fieldType = opts.timeFieldType;
        opts.timeLabelType !== 'none' && this._buildLabel(); // No I18N

        if (fieldType === 'input') {
          // No I18N
          this._buildInputElement();
        } else if (fieldType !== 'none') {
          // No I18N
          this._buildSelectElement(opts);
        }

        this._timeElemRendered = true;
      }
    }, {
      key: "_buildLabel",
      value: function _buildLabel() {
        var opts = this._opts,
            type = opts.timeLabelType;

        if (type !== 'none') {
          // No I18N
          this._data.timeLabel = {};

          if (['icon', 'icon-text'].indexOf(type) > -1) {
            this._getTimeIconProps();
          }

          if (['text', 'icon-text'].indexOf(type) > -1) {
            this._data.timeLabel.text = opts.timeLabel;
          }
        }
      }
    }, {
      key: "getAttribute",
      value: function getAttribute(optionName) {
        if (optionName === 'value') {
          var optionVal,
              time,
              fieldType = this._opts.timeFieldType;

          if (fieldType === 'input') {
            // No I18N
            optionVal = ZC.timefield(this._input).getValue().dateObject;
          } else if (fieldType === 'multiple-select-box') {
            // No I18N
            if (this._opts.timeMultipleSelectBoxType === 'h-m-t') {
              // No I18N
              optionVal = this._setSelectTimeForMultiple();
            } else {
              time = ZC.select(this._combinedEle).getAttribute('selectedValue');
              var period = ''; // No I18N

              if (this._is12HourFormat) {
                period = ZC.select(this._periodEle).getAttribute('selectedValue'); // No I18N
              }

              time = time + ' ' + period; // No I18N

              optionVal = ZC.Date.parseDate(time, this._opts.format).date;
            }
          } else if (fieldType === 'single-select-box') {
            // No I18N
            time = ZC.select(this._singleSelect).getAttribute('selectedValue'); // No I18N

            optionVal = new Date(+time);
          }

          return optionVal;
        }

        return _get(_getPrototypeOf(ZTimeInput.prototype), "getAttribute", this).apply(this, arguments);
      }
    }, {
      key: "_getTimeIconProps",
      value: function _getTimeIconProps() {
        var opts = this._opts,
            labelProps = {
          defaultIconClassName: 'zdatetimepicker__timeicon',
          // No I18N
          iconClassName: opts.timeLabelIconClassName,
          SVGIconClassName: 'zdatetimepicker__time',
          // No I18N
          SVGIconId: opts.timeLabelSVGIconId,
          defaultSVGIconId: 'zc__svg--time',
          // No I18N
          isCE: this.isCE
        };
        this._data.timeLabel.icon = ZC._getIconInfo(opts.timeLabelIconClassName, opts.timeLabelSVGIconId, '#zc__svg--time', 'zdatetimepicker__timeicon', labelProps); // No I18N
      }
    }, {
      key: "_triggerChange",
      value: function _triggerChange(ev, ui) {
        var selectedTime = this.getAttribute('value');
        this._opts.selectedTime = selectedTime;

        this._dispatchEvent('timechange', ev, {
          selectedTime: selectedTime
        }, undefined, !!ev);
      }
    }, {
      key: "_updateSelectedTime",
      value: function _updateSelectedTime(type, isRendered) {
        if (type === 'input') {
          // No I18N
          this._opts.selectedTime = ZC.timefield(this._input).getValue().dateObject;
          isRendered && (this._initialVal = new Date(+this._opts.selectedTime));
        } else {
          this._checkSelectedTime.apply(this, arguments);
        }
      }
    }, {
      key: "setTime",
      value: function setTime(value) {
        var fieldType = this._opts.timeFieldType,
            minTime = this._opts.minTime,
            tempDate = new Date(); // Need to handle cases where value is present

        if (value) {
          value = this._getDateVal(value);

          if (value) {
            tempDate.setHours(value.getHours());
            tempDate.setMinutes(value.getMinutes());
            tempDate.setSeconds(0, 0);
          }
        } else if (minTime) {
          tempDate = new Date(+minTime);
        } else {
          tempDate.setHours(0, 0, 0, 0);
        }

        this._opts.viewDate = new Date(+tempDate);

        if (fieldType === 'input') {
          // No I18N
          ZC.timefield(this._input).setAttribute('value', tempDate || this._initialVal); // No I18N
        } else if (fieldType === 'multiple-select-box') {
          // No I18N
          this._setTimeOnMultipleSelect(!this._opts.valueUpdate, tempDate);
        } else {
          var date;

          if (value) {
            date = new Date();
            date.setHours(value.getHours(), value.getMinutes(), 0, 0);
            date = this._sortSingleSelectValues(date);
          }

          if (date) {
            ZC.select(this._singleSelect).setAttribute('selectedValue', (+date).toString() || this._getSingleSelectFirstVal()); // No I18N
          }
        }

        this._triggerChange();
      }
    }, {
      key: "clearTime",
      value: function clearTime() {
        var fieldType = this._opts.timeFieldType; // Need to handle cases where value is present

        if (fieldType === 'input') {
          ZC.timefield(this._input).setAttribute('value', this._is12HourFormat ? '12:00 AM' : '00:00'); // No I18N
        } else if (fieldType === 'multiple-select-box') {
          this._setTimeOnMultipleSelect(true);
        } else {
          ZC.select(this._singleSelect).setAttribute('selectedValue', this._getSingleSelectFirstVal()); // No I18N
        }

        this._triggerChange();
      }
    }, {
      key: "refresh",
      value: function refresh() {
        this._refresh = true;
        this._opts.valueUpdate = true;
        this._checkForTime && this._checkForTime();
        this._refresh = false;
      }
    }, {
      key: "_getDateVal",
      value: function _getDateVal(value, format) {
        // revisit - move to datetimepicker if not used here
        return ZC.Date.parseDate(value, format || this._opts.format).date;
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        var fieldType = this._opts.timeFieldType,
            inputElem = this._input;

        if (fieldType === 'input' && inputElem && inputElem.length) {
          // No I18N
          if (this.isCE) {
            inputElem.remove();
          } else {
            ZC.timefield(inputElem).destroy();
          }

          this._input = undefined;
        } else if (fieldType !== 'none') {
          // No I18N
          this._destorySelectElement(fieldType);
        }
      }
    }, {
      key: "_checkTimeOptions",
      value: function _checkTimeOptions(valueCheck, date) {
        this._opts.valueUpdate = true;
        var opts = this._opts,
            tempDate = new Date(),
            // setMin = this._checkToUnSetVal('_minTime'), // No I18N
        // setMax = this._checkToUnSetVal('_maxTime'), // No I18N
        hourInstance = ZC.select(this._hourEle),
            minuteInstance = ZC.select(this._minuteEle),
            min = this._minTime,
            max = this._maxTime;
        date = date || this._opts.viewDate;
        tempDate.setHours(date.getHours(), date.getMinutes(), 0, 0);
        var viewHr = tempDate.getHours();

        if (this._is12HourFormat) {
          this._setMinuteVal(tempDate);

          var trueVal = [],
              falseVal = [],
              curValue = hourInstance.getAttribute('selectedValue');

          for (var i = 1; i <= 12; i = i + opts.hourStep) {
            var hour = i,
                selectedMin = parseInt(minuteInstance.getAttribute('selectedValue')),
                isGreater = void 0; // No I18N

            if (viewHr >= 12) {
              isGreater = true;
              hour = i === 12 ? i : i + 12;
            } else {
              hour = i % 12;
            }

            var condition = !!this._checkHourMinLimit(hour, selectedMin, true);
            opts.disabledTimeList.length && (condition = this._checkIfDisabled(tempDate, tempDate.getMinutes(), condition, hour));
            condition = isGreater ? hour <= 23 && condition : condition;
            (condition ? trueVal : falseVal).push(i);
            condition && +curValue === i && (curValue = false);
          }

          hourInstance.setOptionAttributes(trueVal, 'disabled', true); // No I18N

          hourInstance.setOptionAttributes(falseVal, 'disabled', false); // No I18N

          curValue = curValue === false || curValue === '' ? falseVal[0] : curValue;
          hourInstance.setAttribute('selectedValue', curValue); // tempDate.setHours(+curValue);

          var hours = viewHr - 12;

          this._checkPeriod(tempDate, hours, true);

          hours = viewHr + 12;

          this._checkPeriod(tempDate, hours);

          this.setTime(tempDate);
        } else {
          this._setMinuteVal(tempDate);

          min && hourInstance.setOptionAttributes(min.getHours(), 'disabled', tempDate.getMinutes() < min.getMinutes()); // No I18N

          max && hourInstance.setOptionAttributes(max.getHours(), 'disabled', tempDate.getMinutes() > max.getMinutes()); // No I18N
        } // (setMin || setMax) && this._setMinMaxVal(setMin, setMax);

      }
    }, {
      key: "_setMinuteVal",
      value: function _setMinuteVal(tempDate) {
        var step = this._opts.minuteStep,
            minuteInstance = ZC.select(this._minuteEle),
            curValue = minuteInstance.getAttribute('selectedValue'),
            trueVal = [],
            falseVal = [];

        for (var i = 0; i <= 59; i = i + step) {
          var disabled = this._disableTime(tempDate, i);

          (disabled ? trueVal : falseVal).push(i + '');
          +curValue === i && disabled && (curValue = false);
        } // should Check with false, since 0 is also a value


        curValue = curValue === false ? falseVal[0] : curValue;
        minuteInstance.setOptionAttributes(trueVal, 'disabled', true); // No I18N

        minuteInstance.setOptionAttributes(falseVal, 'disabled', false); // No I18N

        minuteInstance.setAttribute('selectedValue', curValue);
        tempDate.setMinutes(+curValue);
      }
    }, {
      key: "_checkCombinedTimeOptions",
      value: function _checkCombinedTimeOptions(orgEvent, ui) {
        var isPM,
            options,
            opts = this._opts,
            curValue,
            curPeriod,
            is12hr = this._is12HourFormat,
            disabledLen = opts.disabledTimeList.length,
            disabled,
            date,
            timeInstance = ZC.select(this._combinedEle),
            periodInstance;

        if (is12hr) {
          periodInstance = ZC.select(this._periodEle);
          curPeriod = periodInstance.getAttribute('selectedValue');
          isPM = curPeriod === 'PM'; // No I18N
        }

        var min = this._minTime,
            minHr,
            maxHr,
            max = this._maxTime;
        min && (minHr = min.getHours());
        max && (maxHr = max.getHours());

        if (!ui || this._isFromUI.apply(this, arguments)) {
          options = this._data.combinedProps.options;
          curValue = timeInstance.getAttribute('selectedValue'); // No I18N

          var trueVal = [],
              falseVal = [];

          for (var i = 0, len = options.length; i < len; i++) {
            var value = options[i].value;
            date = this._getDateVal(value + ' ' + (curPeriod || ''));

            if (curPeriod) {
              disabled = !!(min && (isPM ? minHr > 12 : minHr < 12) && +date < +min || max && (isPM ? maxHr > 12 : maxHr < 12) && +date > +max);
              disabledLen && (disabled = this._checkIfDisabled(date, date.getMinutes(), disabled));
            }

            options[i].disabled = disabled;
            (disabled ? trueVal : falseVal).push(value);
            curValue === value && disabled && (curValue = false);
          }

          timeInstance.setOptionAttributes(trueVal, 'disabled', true); // No I18N

          timeInstance.setOptionAttributes(falseVal, 'disabled', false); // No I18N

          curValue = curValue || falseVal[0];
          !orgEvent && timeInstance.setAttribute('selectedValue', curValue); // No I18N

          if (is12hr) {
            date = this._getDateVal(curValue + ' ' + curPeriod); // No I18N

            date.setHours(date.getHours() + (isPM ? -12 : 12));

            if (date) {
              disabled = !!(min && +date < +min || max && +date > +max);
              disabledLen && (disabled = this._checkIfDisabled(date, date.getMinutes(), disabled, date.getHours()));
              periodInstance.setOptionAttributes(isPM ? 'AM' : 'PM', 'disabled', disabled); // No I18N
            }
          }
        }
      }
    }, {
      key: "_buildInputElement",
      value: function _buildInputElement() {
        var opts = this._opts,
            value = opts.selectedTime,
            is12Hr = this._is12HourFormat;
        this._data.inputProps = {
          rtl: opts.rtl,
          templateRender: true,
          locale: opts.locale,
          format: is12Hr ? 'hh:mm tt' : 'HH:mm',
          // No I18N
          value: value || (is12Hr ? '12:00 AM' : '00:00'),
          // No I18N
          min: opts.minTime,
          max: opts.maxTime,
          hourStep: opts.hourStep,
          minuteStep: opts.minuteStep,
          id: this._opts.id + '-type-input',
          // No I18N
          clearButton: 'none',
          // No I18N
          spinend: this._spinEndHandler.bind(this),
          isCE: this.isCE,
          width: 100,
          change: this._timeFieldChangeHandler.bind(this),
          mainElement: this._input ? this._input[0] : null
        };
      }
    }, {
      key: "_spinEndHandler",
      value: function _spinEndHandler(orgEvent, ui) {
        ui = !ui && orgEvent ? orgEvent.detail : ui;
        var value = ui.dateValue;
        this._timeModified = true;
        this._opts.selectedTime = value;

        if (value !== undefined && this._opts.viewDate) {
          this._opts.viewDate.setHours(value.getHours(), value.getMinutes(), 0, 0);

          this._triggerChange(orgEvent);
        }
      }
    }, {
      key: "_timeFieldChangeHandler",
      value: function _timeFieldChangeHandler(orgEvent, ui) {
        ui = ui || orgEvent && orgEvent.detail;

        if (this.isCE) {
          orgEvent.stopPropagation();
        }

        this._dispatchEvent('timechange', orgEvent, {
          // No I18N
          selectedTime: this.getAttribute('value'),
          value: ZC.timefield(this._input).getAttribute('value'),
          // No I18N
          valueString: ZC.Date.formatDate(ui.dateValue, this._opts.format)
        });
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        var domChange = true,
            opts = this._opts;

        if (optionName === 'timeFieldType' || optionName === 'timeMultipleSelectBoxType' || optionName === 'fixedTimeOptions') {
          // No I18N
          this._data.modifiedAttr = 'timeFieldType'; // No I18N

          domChange = optionName !== 'fixedTimeOptions'; // No I18N
        }

        if (optionName === 'timeLabelType') {
          // No I18N
          opts[optionName] = value;

          if (value === 'none') {
            // No I18N
            this._data.timeLabel = null;
          } else {
            this._buildLabel();
          }
        } else if (['timeLabel', 'timeLabelIconClassName', 'timeLabelSVGIconId'].indexOf(optionName) > -1) {
          // No I18N
          opts[optionName] = value;

          this._buildLabel();
        } else if (optionName === 'rtl') {
          // No I18N
          opts[optionName] = value;

          if (opts.timeFieldType === 'input') {
            // No I18N
            ZC.timefield(this._input).setAttribute('rtl', value); // No I18N
          } else {
            var keys = ['_hourEle', '_minuteEle', '_periodEle', '_singleSelect', '_combinedEle']; // No I18N

            for (var i = 0; i < keys.length; i++) {
              var element = this[keys[i]];

              if (element && element.length) {
                ZC.select(element).setAttribute('rtl', value); // No I18N
              }
            }
          }
        } else if (['minTime', 'maxTime', 'hourStep', 'minuteStep'].indexOf(optionName) > -1) {
          // No I18N
          if (optionName === 'minTime' || optionName === 'maxTime') {
            // No I18N
            if (typeof value === 'string') {
              value = this._getDateVal(value);
              var today = new Date();
              today.setHours(value.getHours(), value.getMinutes(), 0, 0);
              value = new Date(+today);
            }

            this['_' + optionName] = this._opts[optionName] = value; // No I18N

            if (opts.timeFieldType === 'input') {
              // No I18N
              ZC.timefield(this._input).setAttribute(optionName.replace('Time', ''), value); // No I18N
            } else if (opts.timeFieldType === 'single-select-box') {
              // No I18N
              this._destroy();

              this._reInit = true;
            } else {
              var tempDate = opts.selectedTime ? +opts.selectedTime < +value ? value : opts.selectedTime : value;

              if (optionName === 'minTime') {
                // No I18N
                this._opts.viewDate.setHours(tempDate.getHours(), tempDate.getMinutes(), 0, 0);
              }

              opts[optionName] = value;

              this._checkForTime(undefined, true);
            }
          } else if (opts.timeFieldType === 'input') {
            // No I18N
            ZC.timefield(this._input).setAttribute(optionName.replace('Time', ''), value); // No I18N
          } else {
            this._destroy();

            this._reInit = true;
          }

          opts[optionName] = value;
        } else if (optionName !== 'viewDate' && optionName !== 'valueUpdate' || optionName === 'format') {
          // No I18N
          if (optionName === 'format') {
            opts[optionName] = value;
            this._is12HourFormat = opts.format.indexOf('h') > -1;
          }

          this._destroy();

          this._reInit = true;
          opts[optionName] = value;
        } else {
          opts[optionName] = value;
        }

        if (this._reInit) {
          var data = this._data;
          data.isCombined = data.multiSelect = data.singleSelect = data.inputProps = data.hourProps = data.minuteProps = data.periodProps = data.combinedProps = data.combinedPeriodProps = null;
        }

        this._domChanged = domChange;
      }
    }, {
      key: "name",
      get: function get() {
        return "ztimeinput";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          timeFieldType: 'input',
          minTime: null,
          maxTime: null,
          id: null,
          selectedTime: '12:00 AM',
          // No I18N
          valueUpdate: false,
          timeLabelType: 'icon',
          // No I18N
          timeLabel: 'Time',
          // No I18N
          timeMultipleSelectBoxType: 'h-m-t',
          // No I18N
          timeLabelIconClass: null,
          timeLabelSVGIconId: null,
          format: 'hh:mm tt',
          hourStep: 1,
          minuteStep: 5
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          fixedTimeOptions: [],
          disabledTimeList: []
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['hourchange', 'minutechange', 'periodchange', 'timechange']; // No I18N
      }
    }]);

    return ZTimeInput;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZTimeInput', ZTimeInput);

  (function (ZC) {
    var utilities = ZC.Templates.Utilities,
        template = ZC.ztimeinput.Templates,
        select = ZC.createSelect;

    template.children = function (data) {
      return ZT.html(_templateObject193(), data.timeLabel && ZT.html(_templateObject194(), data.timeLabel.icon && utilities.icon(data.timeLabel.icon), data.timeLabel.text && ZT.html(_templateObject195(), data.timeLabel.text)), data.inputProps ? ZC.createTimeField(data.inputProps) : data.singleSelect ? select(data.singleSelect) : data.multiSelect && ZT.html(_templateObject196(), data.isCombined ? ZT.html(_templateObject197(), select(data.combinedProps), data.combinedPeriodProps && select(data.combinedPeriodProps)) : ZT.html(_templateObject198(), data.hourProps && select(data.hourProps), data.minuteProps && select(data.minuteProps), data.periodProps && select(data.periodProps))));
    };
  })(ZComponents);

  var ZDateTimePicker =
  /*#__PURE__*/
  function (_ZC$ZDatePicker) {
    _inherits(ZDateTimePicker, _ZC$ZDatePicker);

    function ZDateTimePicker() {
      _classCallCheck(this, ZDateTimePicker);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZDateTimePicker).apply(this, arguments));
    }

    _createClass(ZDateTimePicker, [{
      key: "_init",
      value: function _init() {
        this._checkTime = true;

        _get(_getPrototypeOf(ZDateTimePicker.prototype), "_init", this).apply(this, arguments);

        return true;
      }
    }, {
      key: "_validateFormat",
      value: function _validateFormat() {
        var format = this._opts.format;
        this._invalidFormat = !(format.indexOf('d') > -1 && (format.indexOf('h') > -1 || format.indexOf('H') > -1));
      }
    }, {
      key: "_getTimeSettings",
      value: function _getTimeSettings() {
        var _this117 = this;

        var timeOpts = ['timeFieldType', 'timeMultipleSelectBoxType', 'minTime', 'maxTime', 'hourStep', 'minuteStep', 'timeLabelType', 'timeLabel', 'fixedTimeOptions', 'disabledTimeList'],
            // No I18N
        finalOpts = {};
        timeOpts.forEach(function (opt) {
          return finalOpts[opt] = _this117._opts[opt];
        });
        finalOpts.isCE = this.isCE;
        finalOpts.templateRender = true;
        finalOpts.format = this._timeFormat;
        finalOpts.viewDate = this._viewDate;
        finalOpts.id = this._elementId + '-timeinput';
        finalOpts.timechange = this._changeHandler.bind(this);
        finalOpts.className = ' zdatetimepicker__timebar zh-align' + (this._monthsPerView === 3 && this._isBtnsExist() ? this._opts.buttonsAlignment === 'left' ? 'right' : 'left' : 'center'); // No I18N

        if (this._opts.value) {
          finalOpts.selectedTime = this._opts.value;
        }

        this._data.timeProps = finalOpts;
      }
    }, {
      key: "_changeHandler",
      value: function _changeHandler(ev, ui) {
        ui = ui || ev.detail;
        this._selectedTime = ui.selectedTime;
        this._opts.selectionType === 'multiple' && this._setTimeForMultiple(ui.selectedTime); // No I18N

        this._triggerChange(ev);
      }
    }, {
      key: "_validateOpts",
      value: function _validateOpts() {
        var _this118 = this;

        _get(_getPrototypeOf(ZDateTimePicker.prototype), "_validateOpts", this).call(this);

        ['hourStep', 'minuteStep'].forEach(function (value) {
          // No I18N
          var val = +_this118._opts[value];
          _this118._opts[value] = val > 0 ? val : 1;
        });
      }
    }, {
      key: "_setFormat",
      value: function _setFormat() {
        var format = this._opts.format,
            hourIndex = Math.max(format.indexOf('h'), format.indexOf('H')),
            // No I18N
        dateIndex = Math.min(Math.min(format.indexOf('d'), format.indexOf('M')), format.indexOf('y')),
            // No I18N
        lastIndex,
            first;
        this._is12HourFormat = format.indexOf('h') > -1;

        if (hourIndex > dateIndex) {
          this._timeFormat = format.substring(hourIndex); // No I18N

          format = format.replace(this._timeFormat, ''); // No I18N

          lastIndex = Math.max(Math.max(format.lastIndexOf('d'), format.lastIndexOf('M')), format.lastIndexOf('y')); // No I18N

          first = '_date'; // No I18N
        } else {
          // if timeFormat comes before dateFormat
          this._dateFormat = format.substring(dateIndex);
          format = format.replace(this._dateFormat, ''); // No I18N

          lastIndex = Math.max(format.lastIndexOf('m'), format.lastIndexOf('t')); // No I18N

          first = '_time'; // No I18N
        }

        this[first + 'Format'] = format.substring(0, lastIndex + 1); // No I18N
      }
    }, {
      key: "_buildData",
      value: function _buildData(shouldRender) {
        _get(_getPrototypeOf(ZDateTimePicker.prototype), "_buildData", this).call(this);

        !this._doNotBuildTime && this._buildTimeElem();
        this._data.isCBar = true;
        shouldRender && this._render();
        this._doNotBuildTime = undefined;
      }
    }, {
      key: "_buildTimeElem",
      value: function _buildTimeElem() {
        var min, max;

        if (this._minDateHasTime || this._maxDateHasTime) {
          min = this._checkToUnSetVal('_minTime'); // No I18N

          max = this._checkToUnSetVal('_maxTime'); // No I18N
        }

        this._getTimeSettings();

        (min || max) && this._setMinMaxVal(min, max);
      }
    }, {
      key: "_addTripleCls",
      value: function _addTripleCls() {
        var clsName = 'zdatetimepicker--triplecalendar',
            // No I18N
        data = this._data;

        if (this._monthsPerView === 3 && Object.keys(data.cBar).length) {
          data.className.indexOf(clsName) < 0 && (data.className += ' ' + clsName); // No I18N
        } else {
          data.className = data.className.replace(/zdatetimepicker--triplecalendar/g, '');
        }
      }
    }, {
      key: "_postRender",
      value: function _postRender() {
        _get(_getPrototypeOf(ZDateTimePicker.prototype), "_postRender", this).apply(this, arguments);

        this._timeInstance = ZC.timeinput($('#' + this._elementId + '-timeinput'));
        this._selectedTime = this._timeInstance.getAttribute('value');
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender(elem, data) {
        var firstRender = !data.rendered,
            modifiedAttr = data.modifiedAttr;

        if (firstRender || ['commandBar, monthsPerView'].indexOf(modifiedAttr) > -1) {
          // No I18N
          this._isBtnsExist() && this._addTripleCls();
        }

        _get(_getPrototypeOf(ZDateTimePicker.prototype), "_postEachRender", this).apply(this, arguments); // if (this._timeElemRendered || this._valueReset) { // No I18N
        //     if (this._timeElemRendered) {
        //         if (opts.timeFieldType === 'input') { // No I18N
        //             let elem = this.element.find('.zinputfield'); // No I18N
        //             this._input = this.isCE ? elem : elem.prev();// No I18N
        //             timeProps.inputProps.mainElement = this._input[0];
        //         } else {
        //             this._setSelectElement(...arguments);
        //         }
        //     }
        //     if (opts.timeFieldType === 'multiple-select-box' && modifiedAttr !== 'singleSelect') { // No I18N
        //         this._checkForTime();
        //     }
        //     this._updateSelectedTime(opts.timeFieldType, this._timeElemRendered);
        //     this._time._postEachRender(...arguments);
        // }
        // this._timeElemRendered = this._valueReset = undefined;

      }
    }, {
      key: "_setSelectedTime",
      value: function _setSelectedTime() {
        var minTime = this._minTime;
        var value = this._selectedTime = minTime ? new Date(+minTime) : undefined;

        this._timeInstance.setAttribute('viewDate', new Date(+value));

        return value;
      }
    }, {
      key: "_setValue",
      value: function _setValue(dateString) {
        var shouldRender = _get(_getPrototypeOf(ZDateTimePicker.prototype), "_setValue", this).call(this, dateString, false);

        this._setTimeValues(undefined, true);

        this._doNotBuildTime = true;
        shouldRender && this._buildData(true);
      }
    }, {
      key: "_triggerChange",
      value: function _triggerChange(orgEvent) {
        this._opts.immediateCommit && (this._currentSelected || this._selectedDates.length) && this._OKClickHandler(orgEvent, true);
      }
    }, {
      key: "_OKClickHandler",
      value: function _OKClickHandler() {
        if (!this._selectedTime) {
          var date = this._timeInstance.getAttribute('value');

          this._viewDate.setHours(date.getHours(), date.getMinutes(), 0, 0);

          this._selectedTime = new Date(+date);
        }

        !(this._currentSelected || this._selectedDates.length) && this._setSelectedTime();

        _get(_getPrototypeOf(ZDateTimePicker.prototype), "_OKClickHandler", this).apply(this, arguments);
      }
    }, {
      key: "_updateValues",
      value: function _updateValues() {
        _get(_getPrototypeOf(ZDateTimePicker.prototype), "_updateValues", this).call(this);

        var opts = this._opts,
            setTimeVal = this._setTimeValues.bind(this);

        this._timeInstance.setAttribute('valueUpdate', this._valueUpdate); // No I18N


        if (!this._valueUpdate) {
          if (opts.timeFieldType === 'multiple-select-box') {
            // No I18N
            this._timeInstance.update();

            setTimeVal(true, true);
          } else {
            setTimeVal();
          }
        } else if (this._valueUpdate && !opts.immediateCommit) {
          setTimeVal();
        }
      }
    }, {
      key: "_clearValues",
      value: function _clearValues(orgEvent, doNotCallSuper) {
        !doNotCallSuper && _get(_getPrototypeOf(ZDateTimePicker.prototype), "_clearValues", this).call(this, orgEvent); // Since, if clearButton clicked, clearClickHandler will call clearValues of datepicker twice.

        this._timeInstance.clearTime();

        this._timeInstance.refresh();
      }
    }, {
      key: "_setDate",
      value: function _setDate(orgEvent, target, date) {
        var opts = this._opts;

        if (opts.selectionType === 'single') {
          // No I18N
          this._viewDate = new Date(+date);
        }

        if (this._minDateHasTime || this._maxDateHasTime) {
          this._setBoundaryValuesForTimeInput(); // No I18N

        }

        this._selectedTime = ZC.timeinput($('#' + this._elementId + '-timeinput')).getAttribute('selectedTime'); // this._valueReset && this._updateSelectedTime(opts.timeFieldType);
        // let selected = this._selectedTime;
        // this._viewDate.setHours(selected.getHours(), selected.getMinutes(), selected.getSeconds());

        _get(_getPrototypeOf(ZDateTimePicker.prototype), "_setDate", this).call(this, orgEvent, target, opts.selectionType === 'single' ? this._viewDate : date); // No I18N


        if (this._selectedDates.length === 0 && opts.selectionType === 'multiple') {
          // No I18N
          this._setTimeValues();
        }
      }
    }, {
      key: "_resetValues",
      value: function _resetValues() {
        this._valueReset = true;

        _get(_getPrototypeOf(ZDateTimePicker.prototype), "_resetValues", this).call(this, true);

        var min, max;

        if (this._minDateHasTime || this._maxDateHasTime) {
          min = this._checkToUnSetVal('_minTime'); // No I18N

          max = this._checkToUnSetVal('_maxTime'); // No I18N
        }

        if (this._minTime) {
          this._viewDate.setHours(this._minTime.getHours(), this._minTime.getMinutes(), 0, 0);
        }

        (min || max) && this._setMinMaxVal(min);
      }
    }, {
      key: "_setTimeValues",
      value: function _setTimeValues(forceReset, valueCheck, doNotReset) {
        var opts = this._opts,
            minTime,
            maxTime,
            viewDate = this._viewDate;

        if (!doNotReset && (this._minDateHasTime || this._maxDateHasTime)) {
          minTime = this._checkToUnSetVal('_minTime'); // No I18N

          maxTime = this._checkToUnSetVal('_maxTime'); // No I18N
        }

        var value = valueCheck === false ? undefined : opts.selectionType === 'single' || opts.value ? viewDate : opts.values.length ? this._getDateVal(opts.values[0], opts.format) : undefined,
            // No I18N
        date;

        if (value && !forceReset) {
          date = new Date(viewDate.getTime());
          date.setHours(viewDate.getHours(), viewDate.getMinutes(), 0, 0);
        }

        this._timeInstance.setAttribute('valueUpdate', this._valueUpdate); // No I18N


        this._timeInstance.setTime(date);

        (minTime || maxTime) && this._setMinMaxVal(minTime, maxTime);
      }
    }, {
      key: "_getDateVal",
      value: function _getDateVal(value) {
        return ZC.Date.parseDate(value, this._timeFormat).date;
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        var inputElem = this._input;

        if (inputElem && inputElem.length && this.isCE) {
          inputElem.remove();
        }

        this._timeInstance.destroy();

        _get(_getPrototypeOf(ZDateTimePicker.prototype), "_destroy", this).call(this);

        this._timeInstance = undefined;
        this._footer = this._input = undefined;
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        var pickerEle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.element;
        var timeOptions = ['timeFieldType', 'timeLabelType', 'timeLabel', 'timeMultipleSelectBoxType', 'minTime', 'maxTime', 'hourStep', 'minuteStep', 'disabledTimeList', 'fixedTimeOptions'],
            // No I18N
        opts = this._opts,
            domChange = true;
        ['minTime', 'maxTime', 'timeFieldType'].indexOf(optionName) < 0 && (opts[optionName] = value); // No I18N       

        if (timeOptions.indexOf(optionName) > -1) {
          var isDate = value instanceof Date;

          if (['minTime', 'maxTime'].indexOf(optionName) > -1) {
            // No I18N
            if (value) {
              this['_' + optionName] = isDate ? new Date(+value) : this._getDateVal(value);
            } else {
              this['_' + optionName] = null;
            }
          }

          this._opts[optionName] = value;

          this._buildTimeElem();

          if (this.isCE) {
            var oldValue = this._timeInstance._opts[optionName];
            this._timeInstance._opts = this._data.timeProps;
            this._timeInstance._opts[optionName] = oldValue;
          }

          this._timeInstance.setAttribute(optionName, value);
        } else {
          domChange = _get(_getPrototypeOf(ZDateTimePicker.prototype), "_setAttribute", this).call(this, optionName, value, pickerEle);
        }

        if (['monthsPerView', 'commandBar', 'immediateCommit'].indexOf(optionName) > -1) {
          // No I18N
          this._isBtnsExist() && this._addTripleCls();
        } else if (optionName === 'format') {
          // No I18N
          this._validateFormat();

          if (!this._invalidFormat) {
            this._timeInstance.setAttribute('format', value);
          }
        }

        this._domChanged = domChange;
      } // Revisit
      // _addAprropriateClasses  () {
      //     if (this._doesExist(this._footer)) {
      //         if (this._doesExist(this._timeElement)) {
      //             this.element.addClass(this._CLASSES.triple);
      //         } else {
      //             this.element.removeClass(this._CLASSES.triple);
      //         }
      //     } else if (this._doesExist(this._timeElement)) {
      //         this.element.removeClass(this._CLASSES.triple);
      //     }
      // }
      // _undefineTimeElems  () {
      //     this._singleSelect = this._input = this._combinedEle = this._hourEle = this._minuteEle = this._periodEle = undefined;
      // }

    }, {
      key: "name",
      get: function get() {
        return "zdatetimepicker";
      }
    }, {
      key: "props",
      get: function get() {
        return {
          timeLabelIconClassName: null,
          fixedTimeOptions: [],
          disabledTimeList: [],
          labels: {
            timeLabel: 'Time' // No I18N

          },
          closeOnDateSelect: false
        };
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          timeMultipleSelectBoxType: 'h-m-t',
          // No I18N
          timeFieldType: 'input',
          // No I18N
          timeLabelType: 'icon',
          // No I18N
          timeLabel: 'Time',
          // No I18N
          timeLabelIconClass: null,
          timeLabelSVGIconId: null,
          hourStep: 1,
          minTime: null,
          maxTime: null,
          format: 'dd/MM/yyyy, hh:mm tt',
          // No I18N
          minuteStep: 5,
          className: ''
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['hourchange', 'minutechange', 'periodchange', 'timechange']; // No I18N
      }
    }]);

    return ZDateTimePicker;
  }(ZC.ZDatePicker);

  ZC.registerComponent('ZDateTimePicker', ZC.ZDatePicker, ZDateTimePicker);

  (function (ZC) {
    var template = ZC.zdatetimepicker.Templates,
        datepickerTemplate = ZC.zdatepicker.Templates,
        utilities = ZC.Templates.Utilities;

    template.children = function (data) {
      return ZT.html(_templateObject199(), datepickerTemplate.children(data), ZC.createTimeInput(data.timeProps), data.cBar && utilities.commandBar(data.cBar));
    };
  })(ZComponents);

  var ZTokenfield =
  /*#__PURE__*/
  function (_ZC$ZSuggestfield) {
    _inherits(ZTokenfield, _ZC$ZSuggestfield);

    function ZTokenfield() {
      _classCallCheck(this, ZTokenfield);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZTokenfield).apply(this, arguments));
    }

    _createClass(ZTokenfield, [{
      key: "_init",
      value: function _init() {
        _get(_getPrototypeOf(ZTokenfield.prototype), "_init", this).apply(this, arguments);

        this._dataMapping = this._opts.dataMapping;
        this._isCheckboxType = this._opts.dropdownList.itemType === 'checkbox'; // No I18N

        this._data.tokens = [];
        this._data.id = this._id;
        this._data.pasteStyle = ZC.Browser.isIE ? 'width:0;height:0;opacity:0' : 'position:absolute; top: -10000000px'; // No I18N

        this._prevValues = [];
        this._performed = [];
        this._recall = [];
        this._uniqueIndex = 0;

        this._setValues();
      }
      /**
       * TODO: M-- AllowDuplicateValues check is not done here.
       * TODO: M-- maxAllowedValues check is excluded.
      */

    }, {
      key: "_setValues",
      value: function _setValues() {
        var _this119 = this;

        this._opts.values.forEach(function (value) {
          return _this119._data.tokens.push(_this119._getTokenData(value));
        });
      }
    }, {
      key: "_getEditInput",
      value: function _getEditInput() {
        var editInput = $('#' + this._id + '-edit-input'); // No I18N

        return editInput.length ? editInput : undefined;
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender(ele, data) {
        if (data.editMode) {
          var editInput = this._getEditInput();

          if (editInput) {
            editInput.focus();
            editInput.val(this._editedToken.editText).select();
          }

          this._input.val('');

          this._fixInput();
        }
      }
    }, {
      key: "_postRender",
      value: function _postRender() {
        var opts = this._opts,
            container = this.container;
        this._data.className += ' ztokenfield' + (opts.disabled ? ' is-disabled' : '') + (opts.tokens.showRemoveButtonOnHover ? '' : ' ztokenfield--closeshown'); // No I18N

        this._data.attrs = {
          'aria-disabled': opts.disabled,
          // No I18N
          id: this._id + '-container' // No I18N

        };
        this._pasteInput = $('#' + this._id + '-copy-helper'); // No I18N

        this._prevHeight = container.css('height'); // No I18N

        _get(_getPrototypeOf(ZTokenfield.prototype), "_postRender", this).apply(this, arguments);

        this._input = container.find('.ztokenfield__textbox'); // No I18N

        var forElement = opts.dropdownList.forElement = this[opts.dropdownList.position === 'after-cursor' ? '_input' : 'container']; // No I18N

        this._listInstance.setAttributes({
          forElement: forElement
        });

        this._fixInput();
      }
    }, {
      key: "_getListSettings",
      value: function _getListSettings() {
        var settings = _get(_getPrototypeOf(ZTokenfield.prototype), "_getListSettings", this).call(this),
            inputSettings = settings.inputFieldSettings;

        inputSettings.updateOnSelect = inputSettings.handleEvents = false;
        return settings;
      }
    }, {
      key: "_setRemoveProps",
      value: function _setRemoveProps(data) {
        var tokens = this._opts.tokens;
        data.removeButton = {
          className: 'ztokenfield__close',
          // No I18N
          customAttributes: {
            tabindex: -1
          },
          title: this._getI18NText('remove'),
          // No I18N
          defaultSVGIconId: 'zc__svg--close ztokenfield__svg',
          // No I18N
          defaultIconClassName: 'ztokenfield__icon',
          // No I18N
          defaultClassName: 'ztokenfield__close',
          // No I18N
          templateRender: true,
          iconClassName: tokens.removeSVGIconClassName,
          SVGIconId: tokens.removeSVGIconId
        };
      }
    }, {
      key: "_changeHandler",
      value: function _changeHandler(ev) {
        var current = this._opts.values,
            curLen = current.length,
            prev = this._prevValues,
            prevLen = prev.length,
            identifier = this._dataMapping.id,
            flag = false;

        if (curLen) {
          if (curLen === prevLen) {
            for (var i = 0; i < curLen; i++) {
              for (var j = 0; j < prevLen; j++) {
                if (this._mapJSONToData(current[i], identifier) === this._mapJSONToData(prev[j], identifier)) {
                  flag = true;
                  break;
                }
              }
            }
          }

          if (!flag || curLen !== prevLen) {
            this._dispatchEvent('change', ev, {
              // No I18N
              prevTokenList: prev,
              currentTokenList: current
            });

            this._prevValues = _toConsumableArray(current);
          }
        }
      }
    }, {
      key: "_getObj",
      value: function _getObj(mapperName, value, obj) {
        mapperName = this._dataMapping[mapperName];

        if (mapperName) {
          var keys = mapperName.split('.');
          keys.forEach(function (key) {
            if (key in obj) {
              obj = obj[key];
            } else if (key === keys[keys.length - 1]) {
              obj[key] = value;
            } else {
              obj[key] = {};
              obj = obj[key];
            }
          });
        }
      }
    }, {
      key: "_getListCallbacks",
      value: function _getListCallbacks() {
        var callbacks = _get(_getPrototypeOf(ZTokenfield.prototype), "_getListCallbacks", this).call(this),
            dropdownList = this._opts.dropdownList,
            isCheckbox = this._isCheckboxType,
            position = dropdownList.position;

        callbacks.menucreation = this._onMenuCreation.bind(this);
        callbacks.beforelistupdate = this._onChange.bind(this);

        if (position === 'after-cursor' || isCheckbox) {
          // No I18N
          callbacks.listupdate = this._onListUpdate.bind(this);

          if (isCheckbox) {
            callbacks.beforeitemchecked = this._beforeItemChecked.bind(this);
          }
        }

        return callbacks;
      }
    }, {
      key: "_onMenuCreation",
      value: function _onMenuCreation(ev, data) {
        this._menu = data.menu;
        this._menuInstance = ZC.menu(this._menu);
      }
    }, {
      key: "_getSelected",
      value: function _getSelected() {
        return this.container.find('.ztokenfield__token.is-selected'); // No I18N
      }
    }, {
      key: "_enterKeyHandler",
      value: function _enterKeyHandler(orgEvent) {
        var noResultExists = $('#' + this._menuId + '-noresults').length,
            target = $(orgEvent.target),
            dataValidation = this._opts.dataValidation;
        /* this._enterKey is not used */

        if (!this._isMenuShown() || noResultExists) {
          var val = this._input.val(),
              editInput = this._getEditInput();

          if (this._opts.tokens.editable && this._pasteInput && this._isPasteInput(target)) {
            // No I18N
            var activeToken = this._getSelected(); // No I18N


            activeToken.length === 1 && this._editHandler(undefined, activeToken);
          } else if (this._opts.acceptNewValues) {
            this._validateText(val, orgEvent);
          } else if (dataValidation) {
            target[0] === this._input[0] && val.length && this._addErrorToken(val); // No I18N
          }

          if (editInput && (dataValidation || this._isEditInput(target))) {
            this._reformToken(orgEvent);

            this._focusInput();
          }

          if (noResultExists) {
            this.closeDropdownList();
          }
        }
      }
    }, {
      key: "_docClickHandler",
      value: function _docClickHandler(ev) {
        var target = $(ev.target),
            item = target.closest('.zmenu__item'),
            // No I18N
        activeElement = $(document.activeElement),
            actualContainer = target.closest('.ztokenfield'),
            // No I18N
        editInput = this._getEditInput(),
            menu = this._menu,
            opts = this._opts,
            query = this._getQuery(),
            itemInside = menu && menu[0].contains(item[0]);

        if (actualContainer[0] !== activeElement.closest('.ztokenfield')[0] && actualContainer[0] !== this.container[0] && (!menu || menu && target.closest('.zmenu')[0] !== menu[0])) {
          // No I18N
          var val = this._input.val();

          this._setFocusClass(false);

          this._changeHandler(ev);

          this._clickReset = true;

          if (opts.dropdownList.closeOnSelect || !itemInside) {
            this.closeDropdownList(); // No I18N
          } else {
            this._search(query, ev); // No I18N

          }

          if (editInput && !this._isEditInput(target)) {
            // No I18N
            this._reformToken(ev);

            this.closeDropdownList(); // No I18N
          } else if (!itemInside && !opts.acceptNewValues && opts.dataValidation && val.length) {
            this._addErrorToken(val, ev);
          } else if (this._opts.acceptNewValues) {
            this._validateText(val, ev);
          } else {
            this._input[0].value = '';

            this._fixInput();
          }

          this._removeSelected();
        }

        if (!opts.dropdownList.closeOnSelect && itemInside) {
          this._search(query, ev);
        }
      }
    }, {
      key: "_removeSelected",
      value: function _removeSelected() {
        this._getSelected().removeClass('is-selected'); // No I18N

      }
    }, {
      key: "_getActiveInput",
      value: function _getActiveInput() {
        var editInput = $(this._getEditInput());
        return editInput.length ? editInput : this._input;
      }
    }, {
      key: "_isPasteInput",
      value: function _isPasteInput(target) {
        return target[0] === this._pasteInput[0];
      }
    }, {
      key: "_getQuery",
      value: function _getQuery() {
        return this._listInstance.params.query;
      }
    }, {
      key: "_arrrowNavigation",
      value: function _arrrowNavigation(ev, isLeft) {
        var selectedClass = 'is-selected',
            // No I18N
        allElements = this.container.find('.' + selectedClass),
            // No I18N
        index = isLeft ? 0 : allElements.length - 1,
            element = $(allElements[index]),
            adjacentEle,
            ele,
            adjacentPosition = isLeft ? 'prev' : 'next'; // No I18N

        if (allElements.length && !this._isSpecialKeys(ev)) {
          allElements.removeClass(selectedClass);
          this._clickReset = true;
        }

        if (ev.shiftKey) {
          if (!this._clickReset) {
            if (element.length) {
              ele = element[adjacentPosition]();
            }
          } else if (this._element && allElements.length > 1) {
            adjacentEle = this._element[adjacentPosition]();

            if (adjacentEle.hasClass(selectedClass)) {
              this._element.removeClass(selectedClass);

              this._element = adjacentEle;
            } else {
              ele = adjacentEle;
            }
          } else if (element.length) {
            ele = element[adjacentPosition]();
          }

          this._clickReset = true;
        } else if (element.length) {
          ele = element[adjacentPosition]();
        }

        if (ele && ele.length) {
          if (ele.hasClass('ztokenfield__token')) {
            // No I18N
            this._focusEle(ele, !isLeft);
          } else {
            this._focusInput();

            if (!isLeft && ev.shiftKey) {
              this._removeSelected();
            }
          }
        } else if (isLeft && !adjacentEle) {
          ele = this._input.prev();

          if (ele.hasClass('ztokenfield__token')) {
            // No I18N
            this._focusEle(ele);
          }
        }

        this.closeDropdownList(); // No I18N

        ev.preventDefault();
      }
    }, {
      key: "_focusEle",
      value: function _focusEle(ele, doNotFocus) {
        this._element = ele.addClass('is-selected');

        if (!doNotFocus) {
          this._element.focus();
        }

        this._saveSelectedVal();
      }
    }, {
      key: "_isMenuShown",
      value: function _isMenuShown() {
        return this._menu && this._menu.is(':visible'); // No I18N
      }
    }, {
      key: "_getTokens",
      value: function _getTokens() {
        return this.container.find('.ztokenfield__token').toArray();
      }
    }, {
      key: "getValues",
      value: function getValues(value) {
        var _this120 = this;

        var tokens = [],
            values = this._opts.values;

        if (value instanceof Array && values && values.length) {
          value.forEach(function (identifier) {
            return tokens.push(_this120._getValues(_this120._data.tokens, identifier));
          });
          return tokens;
        }
      }
    }, {
      key: "getValue",
      value: function getValue(value) {
        var returnValue = this.getValues([value]);

        if (returnValue) {
          return returnValue[0];
        }
      }
    }, {
      key: "getAllValues",
      value: function getAllValues() {
        return this._opts.values;
      }
    }, {
      key: "search",
      value: function search(query) {
        this._input[0].value = query;

        this._fixInput();

        this._search(query);
      }
    }, {
      key: "_getValues",
      value: function _getValues(selectedItems, value) {
        for (var j = 0; j < selectedItems.length; j++) {
          if (selectedItems[j].id === value) {
            return selectedItems[j].actualData;
          }
        }
      }
    }, {
      key: "_keydownHandler",
      value: function _keydownHandler(ev) {
        var _this121 = this;

        this._metaKey = false;

        this._checkMaxLimitReach(ev);

        var keyCodes = ZC.keyCode,
            opts = this._opts,
            menu = this._menu,
            dsInstance = this._listInstance,
            activeInput = this._getActiveInput(),
            keyCode = ev.keyCode,
            target = $(ev.target),
            isMenuVisible = this._isMenuShown(),
            isLeft = keyCode === keyCodes.LEFT,
            isLeftOrRight = isLeft || keyCode === keyCodes.RIGHT,
            input = this._input,
            inputVal = input.val(),
            selected = this._selected,
            isInput = target[0] === input[0],
            isLenZero = isInput && inputVal.length === 0,
            editInput = this._getEditInput(),
            isPasteInput = this._isPasteInput(target);

        if (activeInput.val().length < 1) {
          if (isLeftOrRight) {
            this._arrrowNavigation(ev, isLeft);
          }
        } else {
          var query = activeInput.val(),
              selStart = activeInput[0].selectionStart,
              selEnd = activeInput[0].selectionEnd,
              cursorPos = selStart === 0 && selEnd === query.length ? query.length - 1 : selStart;

          if (query.length < opts.search.maxKeywordLength) {
            query = isLeftOrRight ? query.substring(0, cursorPos + (isLeft ? -1 : 1)) : undefined;
            query !== undefined && this._search(query, ev);

            if (query !== undefined && query.length === cursorPos && !opts.rtl) {
              ev.preventDefault();
            }
          }
        }

        if (keyCode === keyCodes.BACKSPACE || keyCode === keyCodes.DELETE) {
          // Added to prevent default action for backspace when focus is on token
          if (this._getSelected().length) {
            return false;
          }

          var _query = target.is('input') && !isPasteInput && target.val(); // No I18N


          this._hasInput = !!(_query !== undefined && _query.length);
        }

        if (this._isCtrl(ev)) {
          this._metaKey = true;

          if (this._isCheckboxType && [65, 89, 88, 90].indexOf(keyCode) > -1 || !this._isCheckboxType) {
            this.closeDropdownList();
          }

          if (keyCode === 65) {
            if (isPasteInput || isLenZero) {
              // No I18N
              ev.preventDefault();

              this._getTokens().forEach(function (token) {
                return $(token).addClass('is-selected').focus();
              });

              this._saveSelectedVal();
            }
          } else if (keyCode === 89 || keyCode === 90) {
            var isUndo = keyCode === 90;

            if (!inputVal.length && !editInput) {
              ev.preventDefault();
              var arr = this['_' + (isUndo ? 'performed' : 'recall')]; // No I18N

              if (arr.length) {
                var poppedData = arr.pop();

                if (poppedData) {
                  var action = poppedData.action,
                      method = action;

                  if (isUndo) {
                    method = action === 'create' ? 'remove' : 'create'; // No I18N
                  }

                  this['_' + method + 'Token'](method === 'remove' ? $('#' + poppedData.tokenId) : poppedData.data, ev, poppedData.index); // No I18N
                }
              }
            } else {
              this._fixInput();
            }
          } else if (keyCode === 88 && !isInput && selected.length) {
            // Commented since default action is required to paste tokens
            // ev.preventDefault();
            selected.forEach(function (token) {
              return _this121._removeToken($('#' + token));
            }, ev); // No I18N

            setTimeout(this._undoHandler.bind(this), 500);
          }
        }

        if (editInput) {
          if (keyCode === keyCodes.ESCAPE) {
            this._escKey = true;

            this._reformToken(ev);

            this._focusInput();
          }

          if (keyCode === keyCodes.TAB) {
            this._reformToken(ev);
          }
        }
        /* On TAB press, dropdownlist needs to be closed even when there is not editable Input */


        if (keyCode === keyCodes.TAB) {
          this.closeDropdownList();
        }

        if ((!isMenuVisible || menu && menu.find('.zmenu__noresults').length) && this._checkMaxLimit()) {
          // No I18N
          if (keyCode === keyCodes.DOWN && !dsInstance._ajaxSource && !this.container.find('.ztokenfield__token').hasClass('is-selected')) {
            this._search(this._getQuery(), ev);
          }

          if (keyCode === keyCodes.ENTER) {
            ev.preventDefault(); // if(!dsInstance.isNewQuery){

            this._enterKeyHandler(ev); // }

          }

          return true;
        }

        if (menu && this._checkMaxLimit() && [keyCodes.UP, keyCodes.DOWN, keyCodes.ENTER, keyCodes.ESCAPE].indexOf(keyCode) > -1) {
          ev.preventDefault(); //  if(!dsInstance.isNewQuery){

          !dsInstance._loading && this._menuInstance.handleKeyCode(ev); // }

          if (!menu.find('.on-hover').length && this._getEditInput()) {
            this._reformToken(ev);
          }
        }
      }
    }, {
      key: "_isEditInput",
      value: function _isEditInput(target) {
        var editInput = this._getEditInput();

        if (editInput) {
          return target[0].id === editInput[0].id;
        }

        return false;
      }
    }, {
      key: "_checkMaxLimitReach",
      value: function _checkMaxLimitReach(ev) {
        var target = $(ev.target),
            charInput = target.is('input') && !this._isPasteInput(target) && !this._isEditInput(target) && this._isAlphaNumericKey(ev); // No I18N


        if (charInput && this._opts.maxAllowedValues && this._opts.values.length >= this._opts.maxAllowedValues) {
          ev.preventDefault();
        }
      }
    }, {
      key: "_isCtrl",
      value: function _isCtrl(ev) {
        return ev && (ev.metaKey || ev.ctrlKey);
      }
    }, {
      key: "_keyUpHandler",
      value: function _keyUpHandler(ev) {
        if (this.element.attr('disabled')) {
          // No I18N
          return false;
        }

        var target = $(ev.target),
            opts = this._opts,
            query,
            keyCode = ev.keyCode,
            keyCodes = ZC.keyCode,
            maxLen = opts.search.maxKeywordLength,
            isValidInput = target.is('input') && !this._isPasteInput(target); // No I18N

        if (isValidInput && !this._isCtrl(ev) && (this._isAlphaNumericKey(ev) || keyCode === keyCodes.SPACE) && this._checkMaxLimit()) {
          // No I18N
          this._removeSelected();

          this._clickReset = true;

          this._fixInput();

          query = target.val();

          if (query.charCodeAt(query.length - 1) === opts.delimiter.charCodeAt(0)) {
            var menuitem,
                hasEditInput = this._getEditInput();

            if (this._isMenuShown()) {
              menuitem = this._menu.find(this._SELECTORS.li + ':not(.zmenu__title)'); // No I18N
            }

            if (this._isValidItem(menuitem)) {
              var menuInstance = this._menuInstance;
              opts.autoComplete && menuInstance.hoverMenuItem($(menuitem[0]));
              menuInstance.selectHoveredMenuItem();
            } else {
              query = query.substring(0, query.length - 1);

              if (opts.acceptNewValues) {
                if (hasEditInput) {
                  this._reformToken(ev);
                } else {
                  this._validateText(query);
                }
              } else {
                if (opts.dataValidation && query) {
                  this._addErrorToken(query);
                }

                hasEditInput && this._reformToken(ev);
              }
            }

            opts.dropdownList.closeOnSelect && this.closeDropdownList();
          } else if (query.length < maxLen && !this._metaKey) {
            // this._dsInstance.isNewQuery = true;
            this._search(query, ev);
          }
        }

        if (keyCode === keyCodes.BACKSPACE || keyCode === keyCodes.DELETE) {
          if (isValidInput) {
            query = target.val();

            this._fixInput();
          } // query !== undefined check is added since query && query.length will fail.


          if (query !== undefined && query.length < maxLen) {
            if (!this._hasInput && !query) {
              this._tokenRemoveHandler(ev);
            } else {
              this._search(query, ev);
            }
          } else {
            this._getSelected().length && this._tokenRemoveHandler(ev); // No I18N
          }

          if (target[0] === this._input[0] && !query) {
            this._fixInput();
          }
        }
      }
    }, {
      key: "_mousedownHandler",
      value: function _mousedownHandler(ev) {
        var val = this._getActiveInput().val(),
            target = $(ev.target),
            editInput = this._getEditInput(),
            activeElement = $(document.activeElement),
            token = target.closest('.ztokenfield__token'); // No I18N


        if (token.length) {
          this._isFocusOutside = activeElement.closest('.ztokenfield').length === 0; // No I18N
        } else if ((!editInput || !this._isEditInput(activeElement)) && val.length < this._opts.search.maxKeywordLength && this._checkMaxLimit()) {
          // No I18N
          this._search(val, ev);
        }

        if (editInput && !this._isEditInput(target)) {
          // No I18N
          this._reformToken(ev);

          this.closeDropdownList();
        }

        if (!this._isSpecialKeys(ev)) {
          this._removeSelected();

          this._clickReset = true;
        }
      }
    }, {
      key: "_windowKeyUpHandler",
      value: function _windowKeyUpHandler(orgEvent) {
        if (orgEvent.keyCode === ZC.keyCode.TAB) {
          this._reverseTab = orgEvent.shiftKey;
          this.closeDropdownList();
        }
      }
    }, {
      key: "_pasteEventHandler",
      value: function _pasteEventHandler(ev) {
        if (this._checkMaxLimit()) {
          this._pasteTimeout && clearTimeout(this._pasteTimeout);
          this._pasteTimeout = setTimeout(this._pasteHandler.bind(this, ev), 100);
        } else {
          ev.preventDefault();
        }
      }
    }, {
      key: "_contextMenuHandler",
      value: function _contextMenuHandler(ev) {
        ev.preventDefault();
      }
    }, {
      key: "_inputFocusHandler",
      value: function _inputFocusHandler(orgEvent) {
        this._setFocusClass();

        this._removeSelected();

        if (this._opts.suggestOnFieldFocus && this._opts.search.minKeywordLength === 0 && !this._focussed) {
          this._search('', orgEvent); // No I18N


          this._focussed = false;

          this._dispatchEvent('focus', orgEvent); // No I18N

        }
      }
    }, {
      key: "_inputBlurHandler",
      value: function _inputBlurHandler(orgEvent) {
        var val = this._input.val(),
            target = orgEvent.relatedTarget || document.activeElement,
            opts = this._opts,
            tabCode = ZC.keyCode.TAB,
            methodName,
            isFF45 = ZC.Browser.isFirefox && ZC.Browser.getFirefoxVersion() <= 45;

        if (val && val.length) {
          if (!this._menu || this._menu.is(':hidden') || !this._menu.find('.zmenu__body ' + this._SELECTORS.li + ':first:not(.zmenu__noresults)')[0]) {
            // No I18N
            if (opts.acceptNewValues) {
              if ($(target).closest('.ztokenfield').length === 0) {
                // No I18N
                methodName = 'validateText'; // No I18N
              }
            } else if (opts.dataValidation) {
              methodName = 'addErrorToken'; // No I18N
            }

            if (methodName) {
              this['_' + methodName](val, {
                // No I18N
                keyCode: tabCode
              });
            }
          }
        }

        if (!isFF45 && target && $(target).closest('.zmenu').length === 0) {
          // No I18N
          this.closeDropdownList();
        }

        this._setFocusClass(false); // The following beahvior need to be confirmed.
        // clearTimeout(this._blurTimer);
        // if (val) {
        //     this._blurTimer = setTimeout(() => {
        //         let activeElement = $(document.activeElement);
        //         if (!activeElement.closest('.ztokenfield').length) {// No I18N
        //             this._input.val(''); // No I18N
        //         }
        //     }, 300);
        // }

      }
    }, {
      key: "_isSpecialKeys",
      value: function _isSpecialKeys(ev) {
        return ev.metaKey || ev.ctrlKey || ev.shiftKey;
      }
    }, {
      key: "_clickHandler",
      value: function _clickHandler(ev) {
        var target = $(ev.target),
            ele = target.closest('.ztokenfield__token'); // No I18N

        if (target.closest('.ztokenfield__close').length) {
          this._removeToken(ele, ev);

          this._focusInput();
        } else if (ele.length) {
          this._clickReset = false;

          if (this._isFocusOutside) {
            this._dispatchEvent('focus', ev); // No I18N

          }

          this._setFocusClass();

          var selected = this._getSelected();

          if (!this._isSpecialKeys(ev)) {
            selected.removeClass('is-selected'); // No I18N

            this._clickReset = true;
          }

          if (ev.shiftKey) {
            for (var i = this._getIndex($(selected[0]), 'input'); i <= this._getIndex($(selected[selected.length - 1]), 'input'); i++) {
              $('#' + this._id + '-token-' + i).addClass('is-selected'); // No I18N
            }

            this._clickReset = false;
          }

          ele.addClass('is-selected');
          ele.focus();

          this._saveSelectedVal();
        }
      }
    }, {
      key: "_setFocusClass",
      value: function _setFocusClass() {
        var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this._active = active;
        this.container[active ? 'addClass' : 'removeClass']('has-focus'); // No I18N
      }
    }, {
      key: "_eleFocusHandler",
      value: function _eleFocusHandler() {
        this._addEvents({
          docClick: 'mousedown' // No I18N

        }, ZC.$document);
      }
    }, {
      key: "_eleBlurHandler",
      value: function _eleBlurHandler() {
        var _this122 = this;

        clearTimeout(this._blurTimer);
        this._blurTimer = setTimeout(function () {
          if (!_this122._active) {
            ZC.$document.off('.' + _this122.name); // No I18N
          }
        });
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        if (!this._opts.disabled) {
          this._addEvents({
            eleFocus: 'focusin',
            // No I18N
            eleBlur: 'focusout' // No I18N

          });

          this._addEvents({
            keydown: 'keydown',
            // No I18N
            keyUp: 'keyup',
            // No I18N
            mousedown: 'mousedown',
            // No I18N
            click: 'click',
            // No I18N
            mouseup: 'mouseup',
            // No I18N
            pasteEvent: 'paste',
            // No I18N
            contextMenu: 'contextmenu' // No I18N

          });

          this._bindEditHandler();

          this._addEvents({
            inputFocus: 'focus',
            // No I18N
            inputBlur: 'blur' // No I18N

          }, this._input);
        }
      }
    }, {
      key: "_bindEditHandler",
      value: function _bindEditHandler() {
        if (this._opts.tokens.editable) {
          this._addEvents({
            edit: 'dblclick' // No I18N

          });
        }
      }
    }, {
      key: "_mouseupHandler",
      value: function _mouseupHandler(orgEvent) {
        var token = $(orgEvent.target).closest('.ztokenfield__token'),
            editInput = this._getEditInput(),
            activeElement = document.activeElement;

        if (token.length) {
          token.addClass('is-selected').focus();
          this.closeDropdownList();
        } else if (activeElement !== this._input[0] && (!editInput || editInput && !this._isEditInput($(activeElement)))) {
          this._input.focus();
        }
      }
    }, {
      key: "_undoHandler",
      value: function _undoHandler() {
        this._saveSelectedVal();

        this._focusInput();
      }
    }, {
      key: "_pasteHandler",
      value: function _pasteHandler(ev) {
        var _this123 = this;

        var target = $(ev.target),
            inputVal = target.is('input') && !this._isPasteInput(target) ? target.val() : undefined; // No I18N

        this._paste = true;

        if (inputVal) {
          inputVal.length && this._fixInput();
          var tokenValues = inputVal.split(this._opts.delimiter);

          var _loop4 = function _loop4(i) {
            var value = tokenValues[i],
                nameMatch = value.match(/"(.*)"/),
                name = nameMatch && nameMatch.pop(),
                keyMatch = value.match(/<(.*)>/),
                key = keyMatch && keyMatch.pop(),
                jsonObj = {};

            if (key !== null && name !== null) {
              ['id', 'value', 'text', 'titleText'].forEach(function (val) {
                return _this123._getObj(val, val === 'text' ? name : key, jsonObj);
              }); // No I18N

              _this123._createToken(jsonObj, ev, _this123._isEditInput(target) ? _this123._getIndex(target) : undefined);
            } else {
              // this._dsInstance.isNewQuery = true;
              // let value = this._searchTimeout(value, orgEvent, 0);
              !_this123._isMenuShown() && _this123._opts.acceptNewValues && _this123._validateText(value.trim(), ev); // No I18N
              // Commented since value is not defined. Should revisit. Need to find the reason for including this. Promise provided for searchTimeout is removed in datasourcehelper.
              // if(value == false){
              //     return false;
              // }
            }
          };

          for (var i = 0; i < tokenValues.length; i++) {
            _loop4(i);
          }

          this._removeEditInput && this._removeEditInput();
        }

        this._paste = false;
      }
    }, {
      key: "_focusInput",
      value: function _focusInput() {
        this._focussed = true;

        this._input.focus();
      }
    }, {
      key: "_tokenRemoveHandler",
      value: function _tokenRemoveHandler(ev) {
        var _this124 = this;

        var textbox = this._getActiveInput(),
            element = this._getSelected();

        if (element.length) {
          element.toArray().map(function (token) {
            return token.id;
          }).forEach(function (id) {
            _this124._removeToken($('#' + id), ev);

            textbox.focus();
          });
        } else {
          var ele = textbox.prev();

          if (ele.hasClass('ztokenfield__token')) {
            ele.addClass('is-selected');
            this._element = ele;

            this._removeToken(ele, ev);

            textbox.focus();
          }

          if (this._getEditInput()) {
            this._focusInput();
          }

          this._removeEditInput && this._removeEditInput();
        }

        !this._isCheckboxType && this.closeDropdownList(); // No I18N

        if (textbox[0] === this._input[0]) {
          this._fixInput();
        }
      }
    }, {
      key: "_search",
      value: function _search(query, orgEvent, delay) {
        delay = typeof delay === 'number' ? delay : this._opts.search.delay; // No I18N

        if (this._checkMaxLimit()) {
          this._listInstance.searchWithDelay(query, orgEvent, delay);
        }
      }
    }, {
      key: "_getIndex",
      value: function _getIndex(element, selector) {
        return this.container.children(selector ? ':not(' + selector + ')' : '*').filter('input, .ztokenfield__token').index(element); // No I18N
      }
    }, {
      key: "_onItemClick",
      value: function _onItemClick(ev, ui) {
        var _this125 = this;

        if (!ui) {
          ui = ev.detail;
        }

        var item = ui.listItem,
            dropdownList = this._opts.dropdownList,
            editInput = this._getEditInput(),
            isCheckboxType = this._isCheckboxType; // No I18N


        this._focusInput();

        if (this._isValidItem(item)) {
          var itemData = ui.listItemData.originalData;

          if (!dropdownList.closeOnSelect || isCheckboxType) {
            // No I18N
            ev.preventDefault();
          }

          this._lastSelected = item;

          if (isCheckboxType && !item.prop('checked')) {
            // No I18N
            this._data.tokens.forEach(function (token) {
              if (!token.editInput && _this125._getMappedData(token.actualData).id === _this125._getMappedData(itemData).id) {
                _this125._removeToken($('#' + token.tokenId), ev); // No I18N

              }
            });
          } else if (this._dispatchEvent('listitemselect', ev, {
            // No I18N
            value: item
          })) {
            var _index3;

            if (editInput) {
              _index3 = this._getIndex(editInput);
              this._data.editMode = false;
            }

            this._buildToken(itemData, ev, undefined, _index3);

            this._removeEditInput && this._removeEditInput();
          }

          if (isCheckboxType && dropdownList.position === 'after-cursor') {
            // No I18N
            this._focusInput();

            this._positionMenu(true);
          }
        } else if (item.hasClass('zmenu__moreresults')) {
          // No I18N
          var action = dropdownList.moreResultsAction;

          if (action && typeof action === 'function') {
            // No I18N
            action();
          }

          this._dispatchEvent('moreactionclick', ev, {
            // No I18N
            value: item,
            query: this._getQuery()
          });
        } // Temporarily commented
        // this._input[0].scrollIntoView();

      }
    }, {
      key: "_onItemHover",
      value: function _onItemHover(ev, ui) {
        if (!ui) {
          ui = ev.detail;
        }

        if (this._opts.autoComplete) {
          var data = ui.listItemData;

          if (this._isValidItem(ui.listItem) && data) {
            this._input.val(this._getMappedData(data.originalData).text);
          }

          this._fixInput();
        }
      }
    }, {
      key: "_isValidItem",
      value: function _isValidItem(item) {
        return item && item.length && !item.is('.zmenu__noresults, .zmenu__title, .zmenu__moreresults, .zmenu__servererror'); // No I18N
      }
    }, {
      key: "_beforeRender",
      value: function _beforeRender() {
        return true;
      }
    }, {
      key: "_onListUpdate",
      value: function _onListUpdate() {
        this._menu.attr('tabIndex', -1); // No I18N


        this._opts.dropdownList.position === 'after-cursor' && this._positionMenu(); // No I18N

        this._isCheckboxType && this._updateCheckedState();
      }
    }, {
      key: "_buildToken",
      value: function _buildToken(itemData, ev, newValue, index) {
        var opts = this._opts,
            maxAllowed = this._opts.maxAllowedValues,
            itemIdentifier = this._dataMapping.id,
            isValid = false,
            dataSource = this._opts.data,
            preventCreation,
            failureType;

        if (newValue && dataSource && itemData.type !== 'error') {
          // No I18N
          for (var i = 0; i < dataSource.length; i++) {
            if (dataSource[i][itemIdentifier] === this._mapJSONToData(itemData, itemIdentifier)) {
              isValid = true;
              break;
            }
          }

          preventCreation = !opts.acceptNewValues && !isValid;
        }

        if (newValue && !isValid && opts.acceptNewValues && opts.dropdownList.acceptNewValues && dataSource instanceof Array) {
          dataSource.push(itemData);
        }

        if (itemData.type === 'error') {
          // No I18N
          this._addErrorToken(itemData.errorValue, ev);
        } else if (this._checkMaxLimit()) {
          this._createToken(itemData, ev, index);
        } else if (maxAllowed && opts.values.length >= maxAllowed) {
          failureType = opts.messages.limitReach;
        } else if (preventCreation) {
          failureType = opts.messages.denyValue;
        }

        if (failureType) {
          this._dispatchEvent('tokenaddfail', ev, {
            // No I18N
            failureType: failureType
          });
        }
      }
    }, {
      key: "_getDataKeys",
      value: function _getDataKeys() {
        var keys = _get(_getPrototypeOf(ZTokenfield.prototype), "_getDataKeys", this).call(this);

        return keys.concat(['id']);
      }
    }, {
      key: "_checkMaxLimit",
      value: function _checkMaxLimit() {
        var maxAllowed = this._opts.maxAllowedValues;
        return !maxAllowed || maxAllowed && this._opts.values.length < maxAllowed;
      }
    }, {
      key: "_getTokenData",
      value: function _getTokenData(itemData) {
        var opts = this._opts,
            mappedData = this._getMappedData(itemData),
            id = this._id + '-token-' + this._uniqueIndex++; // No I18N


        mappedData = _objectSpread({}, mappedData, {
          tokenId: id,
          invalidToken: itemData.invalidToken,
          errorValue: itemData.errorValue,
          disabled: itemData.disabled,
          isSprite: !!opts.dataMapping.iconClassName
        });
        mappedData.hasImage = !itemData.invalidToken && opts.tokens.contentType === 'image-text' && (!itemData.newToken || mappedData.image || mappedData.iconClassName); // No I18N

        mappedData.zdata = mappedData.actualData = itemData;

        this._setRemoveProps(mappedData);

        return mappedData;
      }
    }, {
      key: "_createToken",
      value: function _createToken(itemData, ev, index) {
        var opts = this._opts;

        if (!opts.allowDuplicateValues) {
          if (this._isDuplicate(itemData)) {
            this._addErrorToken(this._mapJSONToData(itemData, this._dataMapping.text), ev, index);

            return;
          }
        }

        var mappedData = this._getTokenData(itemData),
            input = this._input,
            indexExists = typeof index === 'number',
            // No I18N
        activeInput = this._getActiveInput(),
            value = activeInput.val(),
            isCheckboxType = this._isCheckboxType;

        (!isCheckboxType && opts.dropdownList.closeOnSelect || this._paste) && activeInput.val(''); // No I18N

        if (this._dispatchEvent('beforetokenadd', ev, {
          // No I18N
          tokenData: mappedData
        }) && this._checkMaxLimit()) {
          if (this._data.tokens.length === 0) {
            input.attr('placeholder') && input.removeAttr('placeholder'); // No I18N
          }

          if (indexExists) {
            this._data.tokens.splice(index, 0, mappedData);

            opts.values.splice(index, 0, itemData);
          } else {
            this._data.tokens.push(mappedData);

            opts.values.push(itemData);
          }

          this._render();

          var token = $('#' + mappedData.tokenId); // No I18N

          this._dispatchEvent('tokenadd', ev, {
            // No I18N
            tokenData: mappedData,
            token: token
          });

          this._fixInput();

          ev && ev.keyCode !== ZC.keyCode.TAB && this._focusInput();

          this._adjustHeight();

          if (this._getEditInput()) {
            token.focus().addClass('is-selected'); // No I18N
          }

          if (isCheckboxType && this._isMenuShown() && value.length) {
            // No I18N
            this._search(activeInput[0].id === this._id + '-edit-input' ? '' : this._getQuery(), ev);
          }

          if (opts.tokens.sortable) {
            this._initSortable();
          }

          var isInsert = false,
              tokenData = {
            data: itemData,
            tokenId: mappedData.tokenId,
            index: opts.values.length - 1
          };

          if (indexExists) {
            if (this._isCtrl(ev)) {
              isInsert = ev.keyCode === 89;

              if (ev.keyCode === 90) {
                this._recall.push(_objectSpread({}, tokenData, {
                  index: index,
                  action: 'remove' // No I18N

                }));

                this._performed.splice(index, 0, _objectSpread({}, tokenData, {
                  action: 'create' // No I18N

                }));
              }
            }
          } else {
            isInsert = true;
          }

          if (isInsert) {
            this._performed.push(_objectSpread({}, tokenData, {
              action: 'create' // No I18N

            }));
          }
        }
      }
    }, {
      key: "_getTextValue",
      value: function _getTextValue() {
        var values = this._data.tokens;
        return values && values.length ? this._getActiveInput().val() : this._opts.placeholder;
      }
    }, {
      key: "_onChange",
      value: function _onChange(ev, data) {
        var _this126 = this;

        var opts = this._opts;
        var allowDuplicates = opts.allowDuplicateValues || this._isCheckboxType;

        this._data.tokens.forEach(function (tokenData) {
          if (!tokenData.editInput) {
            var selectedVal = tokenData.value;

            if (selectedVal) {
              selectedVal = selectedVal.toString();
              data.results = data.results.filter(function (result) {
                var val = _this126._mapJSONToData(result, _this126._dataMapping.value);

                if (val) {
                  if (selectedVal === val.toString()) {
                    result.disabled = tokenData.disabled;
                    return allowDuplicates;
                  }

                  return true;
                }
              });
            }
          }
        });
      }
    }, {
      key: "_getTokenIndex",
      value: function _getTokenIndex(tokenId) {
        var tokens = this._data.tokens;

        for (var i = 0; i < tokens.length; i++) {
          if (tokens[i].tokenId === tokenId) {
            return i;
          }
        }

        return -1;
      }
    }, {
      key: "_removeToken",
      value: function _removeToken(ele, ev, tokenIndex) {
        var _this127 = this;

        var token = ele.closest('.ztokenfield__token'); // No I18N

        if (token.length) {
          var canBeRemoved = this._dispatchEvent('beforetokenremove', ev, token); // No I18N


          if (canBeRemoved) {
            /* BUGFIX -- Issue faced when removeAllTokens method is called and animateOnRemove = true */
            var _index4 = this._getTokenIndex(token[0].id),
                values = this._data.tokens,
                tokenData = values[_index4],
                nextToken = values[_index4 + 1] ? values[_index4 + 1] : undefined;

            values.splice(_index4, 1);

            this._opts.values.splice(_index4, 1);

            if (this._opts.tokens.animateOnRemove && (ev && ev.type !== 'dblclick' || !ev)) {
              // No I18N
              var transitionClass = 'ztokenfield--transition'; // No I18N

              token.width(token.width()).addClass(transitionClass);
              setTimeout(function () {
                token.off(ZC._transitionEnd).on(ZC._transitionEnd, function () {
                  token.removeClass(transitionClass).off(ZC._transitionEnd);

                  _this127._onRemove(tokenData, ev, token, tokenIndex, _index4, nextToken && nextToken.tokenId);
                }).css({
                  opacity: 0.01,
                  width: 0
                });
              }); // token.addClass('on-remove').animate({
              //     opacity: 0.01
              // }, 'fast', () => { // No I18N
              //     token.animate({
              //         width: 0
              //     }, 'fast', () => this._onRemove(tokenData, ev, token, tokenIndex, index, nextToken && nextToken.tokenId)); // No I18N
              // });
            } else {
              this._onRemove(tokenData, ev, token, tokenIndex, _index4);
            }
          }
        }

        this._fixInput();
      }
    }, {
      key: "_preRender",
      value: function _preRender(data) {
        this._data.tokens.forEach(function (token) {
          if (token.tokenId) {
            var ele = $('#' + token.tokenId);
            token.removeButton.mainElement = ele.length ? ele.find('.zbutton')[0] : null;
          }
        });

        return data;
      }
    }, {
      key: "_onRemove",
      value: function _onRemove(tokenData, ev, token, index, currentIndex, nextTokenId) {
        token.removeClass('on-remove'); // No I18N

        this._render();

        if (nextTokenId) {
          var nextToken = $('#' + nextTokenId)[0]; // No I18N

          if (nextToken) {
            nextToken.style = ''; // No I18N
          }
        }

        var data = {
          data: tokenData.actualData,
          tokenId: tokenData.tokenId
        },
            isCtrl = this._isCtrl(ev);

        data.index = typeof index === 'number' ? index : currentIndex; // No I18N

        if (!this._getEditInput()) {
          if (typeof index === 'number') {
            // No I18N
            if (isCtrl && ev.keyCode === 90) {
              data.action = 'create'; // No I18N

              this._recall.push(data);
            }
          } else if (!index || isCtrl && ev.keyCode === 89) {
            this._performed.splice(data.index, 1);

            data.action = 'remove'; // No I18N

            this._performed.push(data);
          }
        }

        this._adjustHeight();

        if (this._opts.dropdownList.position === 'after-cursor') {
          // No I18N
          this._focusInput();

          this._positionMenu(true);
        }

        this._fixInput();

        this._dispatchEvent('tokenremove', ev, tokenData); // No I18N

      }
    }, {
      key: "_setPasteVal",
      value: function _setPasteVal() {
        var _this128 = this;

        this._selected = [];
        return this._getSelected().toArray().map(function (token, j) {
          _this128._selected[j] = token.id;
          var data = token.zdata;

          if (data && data.invalidToken !== true) {
            return _this128._CONSTANTS.pattern.replace(/#value#/g, _this128._mapJSONToData(data, _this128._dataMapping.text)).replace(/#id#/g, _this128._mapJSONToData(data, _this128._dataMapping.id));
          }
        }).join(this._opts.delimiter);
      }
    }, {
      key: "_saveSelectedVal",
      value: function _saveSelectedVal() {
        this._pasteInput.val(this._setPasteVal()).select();
      }
    }, {
      key: "_resizeInput",
      value: function _resizeInput(textbox, value) {
        var dupDiv,
            containerWidth = this.container.outerWidth(),
            inputWidth,
            styleBlock = 'position:absolute; left: -1000px; top: -1000px; display:none;',
            // No I18N
        width; // Simulate the textbox to calculate width

        ['font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing'].forEach(function (prop) {
          return styleBlock += prop + ':' + textbox.css(prop) + ';';
        }); // No I18N

        dupDiv = $('<div />');
        dupDiv.attr({
          style: styleBlock
        });
        dupDiv.text(value || textbox.val());
        $('body').append(dupDiv);
        var dupWidth = dupDiv.width();

        if (textbox.attr('id') === this._id + '-edit-input') {
          // No I18N
          inputWidth = dupWidth + 30;
          width = inputWidth;
        } else {
          inputWidth = dupWidth + 50;
          dupDiv.text(textbox.val()); // Width calculated after setting text value

          var inputWidth1 = dupDiv.width() + 50;
          width = inputWidth > inputWidth1 ? inputWidth : inputWidth1; // Checking whether input width is greater or placeholder
        }

        dupDiv.remove();

        if (this.container.is(':visible') && width > containerWidth - 10) {
          // No I18N
          width = containerWidth - 10;
        }

        return textbox.css('width', width + 'px'); // No I18N
      }
    }, {
      key: "_adjustHeight",
      value: function _adjustHeight() {
        var currentHeight = this.container.css('height'); // No I18N

        if (currentHeight !== this._prevHeight && this._isMenuShown()) {
          var menuItems = this._menu.find(this._SELECTORS.li);

          if (this._lastSelected || menuItems.length) {
            var menuInstance = this._menuInstance;
            menuInstance.show({
              mustBeShown: true,
              preventHover: true,
              positionAlterable: true
            });
            menuInstance.hoverMenuItem(this._lastSelected || $(menuItems[this._dataMapping.groupLabel ? 1 : 0]));
          }
        }

        this._prevHeight = currentHeight;
      }
    }, {
      key: "_onBeforeSearch",
      value: function _onBeforeSearch(orgEvent, _ref2) {
        var params = _ref2.params;
        params.previousQuery = undefined;
        this._repositioned = true;
        return _get(_getPrototypeOf(ZTokenfield.prototype), "_onBeforeSearch", this).apply(this, arguments);
      }
    }, {
      key: "_fixInput",
      value: function _fixInput() {
        var placeholder = this._opts.placeholder,
            activeInput = this._getActiveInput();

        if (this._data.tokens.length) {
          if (activeInput[0].id === this._id + '-input') {
            // No I18N
            this._input.removeAttr('placeholder'); // No I18N

          }
        } else if (placeholder) {
          this._input[0].placeholder = placeholder; // No I18N
        }

        this._resizeInput(activeInput, this._getTextValue());
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        if (this._opts.tokens.sortable) {
          this._destroySortable();
        }

        this._input.off('.' + this.name); // No I18N


        this._listInstance.destroy();

        ZC.$document.off('.' + this.name); // No I18N

        this._listInstance = this._input = this._pasteInput = undefined;
      }
    }, {
      key: "removeTokens",
      value: function removeTokens(value) {
        var _this129 = this;

        if (value instanceof Array) {
          value.forEach(function (identifier) {
            return _this129._removeTokens(_this129._getTokens(), identifier);
          });
        }

        this._fixInput();
      }
    }, {
      key: "removeToken",
      value: function removeToken(value, ev) {
        this._removeTokens(this._getTokens(), value, ev);
      }
    }, {
      key: "_removeTokens",
      value: function _removeTokens(tokens, value, ev) {
        for (var j = 0; j < tokens.length; j++) {
          var tokenOpts = tokens[j].zdata,
              itemKey = this._mapJSONToData(tokenOpts, this._dataMapping.id);

          if (itemKey === value) {
            this._removeToken($('#' + tokens[j].id), ev);

            if (!this._opts.allowDuplicateValues) {
              break;
            }
          }
        }
      }
    }, {
      key: "removeAllTokens",
      value: function removeAllTokens() {
        var _this130 = this;

        this._getTokens().forEach(function (token) {
          return _this130._removeToken($('#' + token.id));
        });
      }
    }, {
      key: "addTokens",
      value: function addTokens(values) {
        var _this131 = this;

        if (values && values instanceof Array) {
          values.forEach(function (value) {
            return _this131.addToken(value);
          });
        }
      }
    }, {
      key: "addToken",
      value: function addToken(value) {
        if (value && !(value instanceof Array)) {
          this._buildToken(value, undefined, true);
        }
      }
    }, {
      key: "_editHandler",
      value: function _editHandler(ev, target) {
        var tokenOptions = this._opts.tokens;

        if (tokenOptions.editable) {
          if (!target) {
            target = $(ev.target).closest('.ztokenfield__token');
          }

          var dataMapping = this._dataMapping,
              data = this._data;

          if (target.hasClass('ztokenfield__token')) {
            var value,
                tokenData = target[0].zdata,
                _index5 = this._getIndex(target, 'input'),
                // No I18N
            editedData = this._data.tokens[_index5];

            if (tokenData.invalidToken) {
              value = tokenData.errorValue; // Revisit editInput has invalid class
            } else {
              var pattern = tokenOptions.editable.pattern || this._CONSTANTS.pattern;

              if (/#value#|#id#/g.test(pattern)) {
                value = pattern.replace(/#value#/g, this._mapJSONToData(tokenData, dataMapping.text)).replace(/#id#/g, this._mapJSONToData(tokenData, dataMapping.id));
              }
            }

            editedData.index = _index5;
            editedData.editText = value;
            this._editedToken = editedData;
            data.editMode = true;
            data.tokens.splice(_index5, 1);

            this._opts.values.splice(_index5, 1);

            data.tokens.splice(_index5, 0, {
              editInput: true
            });

            this._render();

            this._fixInput();

            this._setPasteVal(); // if (matchFound) {
            //     this._editInput.off('focus.' + this.name).on('focus.' + this.name, () => this.container.addClass('has-focus'));	// No I18N
            // }

          }
        }
      }
    }, {
      key: "_reformToken",
      value: function _reformToken(ev) {
        var itemData = this._editedToken,
            editInput = this._getEditInput(),
            editVal = editInput.val(),
            invalidToken;
        /* Fix - Editing the error token not getting updated and the unnecessary code is removed. */


        if (itemData) {
          var tokenData = itemData.actualData;

          if (this._escKey) {
            editVal = itemData.errorValue;
          } else {
            if (!editVal) {
              return;
            }

            var data = {
              textboxValue: editVal,
              itemData: tokenData
            };

            this._dispatchEvent('tokenedit', ev, data); // No I18N


            tokenData = data.itemData;
            invalidToken = tokenData.invalidToken;
          }

          this._data.editMode = this._editedToken = false;
          var tokenIndex = itemData.index;

          if (invalidToken) {
            this._addErrorToken(editVal, ev, tokenIndex);
          } else {
            delete tokenData.errorValue;
            delete tokenData.type;

            this._createToken(tokenData, ev, tokenIndex);
          }
        }

        this._removeEditInput();

        this._escKey = false;
      }
    }, {
      key: "_removeEditInput",
      value: function _removeEditInput() {
        var editInput = this._getEditInput();

        if (editInput) {
          this._data.tokens.splice(this._getIndex(editInput, this._data.id + '-input'), 1); // No I18N


          this._render();
        }
      }
    }, {
      key: "_addErrorToken",
      value: function _addErrorToken(value, ev, index) {
        value = value.trim();

        if (value.length) {
          this._assignValue(value, {
            invalidToken: true,
            newToken: true,
            errorValue: value,
            type: 'error' // No I18N

          }, ev, index);

          this._input.val(''); // No I18N

        }
      }
    }, {
      key: "_assignValue",
      value: function _assignValue(value, obj, ev, index) {
        var _this132 = this;

        ['id', 'text', 'titleText'].forEach(function (val) {
          return _this132._getObj(val, value, obj);
        }); // No I18N

        this._createToken(obj, ev, index);
      }
    }, {
      key: "hasInvalidTokens",
      value: function hasInvalidTokens() {
        var values = this._opts.values;

        if (this._opts.dataValidation) {
          for (var i = 0; i < values.length; i++) {
            if (values[i].type === 'error') {
              return true;
            }
          }
        }
      }
    }, {
      key: "_validateText",
      value: function _validateText(value, ev) {
        var opts = this._opts,
            acceptNewValues = opts.acceptNewValues,
            patternVal = opts.newValuePattern,
            pattern = !!patternVal,
            isValidRegex = patternVal && patternVal instanceof RegExp;

        if (isValidRegex) {
          patternVal.lastIndex = 0;
        }

        if (value && value.length && acceptNewValues) {
          var tokenData = {};

          if (isValidRegex && patternVal.test(value) || !pattern) {
            tokenData.newToken = true;

            this._assignValue(value, tokenData, ev);

            if (opts.dropdownList.acceptNewValues && opts.data instanceof Array) {
              opts.data.push(tokenData);
            }
          } else {
            opts.dataValidation && this._addErrorToken(value, ev);
          }
        }
      }
    }, {
      key: "_duplicateElement",
      value: function _duplicateElement(domElement) {
        var duplicateDiv = $('<div>').css({
          position: 'absolute',
          // No I18N
          left: -9999,
          top: 0,
          zIndex: -20000
        });
        ['borderBottomWidth', // No I18N
        'borderLeftWidth', // No I18N
        'borderRightWidth', // No I18N
        'borderTopStyle', // No I18N
        'borderRightStyle', // No I18N
        'borderBottomStyle', // No I18N
        'borderLeftStyle', // No I18N
        'borderTopWidth', // No I18N
        'boxSizing', // No I18N
        'fontFamily', // No I18N
        'fontSize', // No I18N
        'fontWeight', // No I18N
        'height', // No I18N
        'letterSpacing', // No I18N
        'lineHeight', // No I18N
        'marginBottom', // No I18N
        'marginLeft', // No I18N
        'marginRight', // No I18N
        'marginTop', // No I18N
        'outlineWidth', // No I18N
        'overflow', // No I18N
        'overflowX', // No I18N
        'overflowY', // No I18N
        'paddingBottom', // No I18N
        'paddingLeft', // No I18N
        'paddingRight', // No I18N
        'paddingTop', // No I18N
        'textAlign', // No I18N
        'textOverflow', // No I18N
        'textTransform', // No I18N
        'whiteSpace', // No I18N
        'wordBreak', // No I18N
        'wordWrap', // No I18N
        'height'].forEach(function (prop) {
          return duplicateDiv[0].style[prop] = window.getComputedStyle(domElement[0])[prop];
        });
        return duplicateDiv;
      }
    }, {
      key: "_positionMenu",
      value: function _positionMenu(reposition) {
        if (this._menu && this._menu.is(':visible')) {
          // No I18N
          if (reposition) {
            this._listInstance.positionList();

            this._repositioned = true;
          }

          if (this._repositioned) {
            var inputField = this._input;

            var carretPosition = this._positionInput(inputField);

            if (carretPosition) {
              var _this$_menu$0$style = this._menu[0].style,
                  top = _this$_menu$0$style.top,
                  left = _this$_menu$0$style.left;

              var menuDir = this._menu.data('direction'); // No I18N


              if (/^(top)/.test(menuDir)) {
                top = parseInt(top) + carretPosition.top;
              } else if (/^(bottom)/.test(menuDir)) {
                top = parseInt(top) - inputField.outerHeight() + carretPosition.top + carretPosition.height;
              }

              left = parseInt(left) + carretPosition.left;

              this._menu.css({
                top: top,
                left: left
              });
            }
          }

          this._repositioned = false;
        }
      }
    }, {
      key: "_positionInput",
      value: function _positionInput(domElement) {
        var startPos = domElement[0].value.slice(0, domElement[0].selectionStart),
            spanElement,
            spanRelativePosition,
            elementWithCaret,
            dimensions,
            duplicateElement;
        spanElement = '<span style="position: relative; display: inline-block;vertical-align:middle;">' + this._removeSpecialChar(startPos) + '</span>'; // No I18N

        spanElement += '<span id=\'caret\' style=\'position: relative; display: inline-block;vertical-align:middle;\'>|</span>'; // No I18N

        spanElement += '<span style=\'position: relative; display: inline-block;vertical-align:middle;height:100%\'></span>'; // No I18N

        duplicateElement = this._duplicateElement(domElement);
        elementWithCaret = duplicateElement.html(spanElement).insertAfter(domElement).find('#caret'); // No I18N

        spanRelativePosition = elementWithCaret.position();
        dimensions = {
          left: spanRelativePosition.left,
          top: spanRelativePosition.top,
          height: elementWithCaret.height()
        };
        duplicateElement.remove();
        return dimensions;
      }
    }, {
      key: "_removeSpecialChar",
      value: function _removeSpecialChar(value) {
        value = value.replace(/<|>|`|"|&/g, '?').replace(/\r\n|\r|\n/g, '<br/>'); // No I18N

        if (ZC.Browser.isFirefox) {
          value = value.replace(/\s/g, '&nbsp;'); // No I18N
        }

        return value;
      }
    }, {
      key: "_isDuplicate",
      value: function _isDuplicate(tokenData) {
        var isDuplicate = false,
            tokens = this._data.tokens;

        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];

          if (!token.editInput) {
            var uniqueKey = this._mapJSONToData(tokenData, this._dataMapping.id);

            if (this._isNotNull(uniqueKey)) {
              if (!token.invalidToken && !tokenData.invalidToken && uniqueKey === this._getMappedData(token.zdata).id) {
                isDuplicate = true;
                break;
              }
            }
          }
        }

        return isDuplicate;
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        var callSuper = false,
            opts = this._opts;

        if (optionName === 'values') {
          // No I18N
          this.removeAllTokens();
          opts[optionName] = value;

          this._setValues(value);

          if (value.length) {
            this._fixInput();
          }

          this._domChanged = true;
        } else {
          opts[optionName] = value;

          if (optionName === 'dataMapping' || optionName === 'rtl') {
            // No I18N
            this._dataMapping = opts.dataMapping;
            callSuper = true;
          } else if (optionName === 'placeholder') {
            // No I18N
            this._fixInput();
          } else if (optionName === 'tokens') {
            // No I18N
            this._bindEditHandler();

            this._updateClass('ztokenfield--closeshown', opts[optionName].showRemoveButtonOnHover); // No I18N


            this['_' + (opts[optionName].sortable ? 'init' : 'destroy') + 'Sortable'](); // No I18N
          } else if (optionName === 'dropdownList') {
            // No I18N
            this._isCheckboxType = opts[optionName].itemType === 'checkbox'; // No I18N

            callSuper = true;
          } else {
            callSuper = true;
          }
        }

        if (callSuper) {
          _get(_getPrototypeOf(ZTokenfield.prototype), "_setAttribute", this).apply(this, arguments);
        }
      }
    }, {
      key: "_disable",
      value: function _disable(value) {
        var opts = this._opts;
        var container = this.container;
        container[value ? 'addClass' : 'removeClass']('is-disabled'); // No I18N

        if (value) {
          container.off('.' + this.name); // No I18N

          this._input.off('.' + this.name); // No I18N

        } else {
          this._bindEvents();
        }

        this._input.attr('disabled', value); // No I18N


        if (opts.tokens.sortable && container.data('zsortable')) {
          // No I18N
          ZC.sortable(container)[value ? 'disable' : 'enable'](); // No I18N
        }
      }
    }, {
      key: "name",
      get: function get() {
        return "ztokenfield";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          allowDuplicateValues: false,
          dataValidation: false,
          delimiter: ',',
          // No I18N
          acceptNewValues: false,
          maxAllowedValues: null
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          newValuePattern: null,
          dropdownList: {
            itemType: 'none',
            // No I18N
            closeOnSelect: true
          },
          tokens: {
            contentType: 'text',
            // No I18N
            sortable: false,
            editable: false,
            animateOnRemove: false,
            showRemoveButtonOnHover: false
          },
          values: [],
          messages: {
            remove: 'Remove',
            // No I18N
            maxTokenLimitReached: 'Max token limit reached',
            // No I18N
            limitReach: 'Limit Exceeded',
            // No I18N
            denyValue: 'Deny new value' // No I18N

          }
        };
      }
    }, {
      key: "SELECTORS",
      get: function get() {
        return {
          li: this.isCE ? 'z-menuitem' : 'li' // No I18N

        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['beforetokenadd', 'beforetokenremove', 'tokenadd', 'tokenremove', 'tokenedit', 'tokendrag', 'tokenaddfail']; // No I18N
      }
    }, {
      key: "_CONSTANTS",
      get: function get() {
        return {
          pattern: '"#value#" <#id#>',
          // No I18N
          minKeywordLength: 20,
          maxResults: 10
        };
      }
    }]);

    return ZTokenfield;
  }(ZC.ZSuggestfield);

  ZC.registerComponent('ZTokenfield', ZC.ZSuggestfield, ZTokenfield);

  (function (ZC) {
    var template = ZC.ztokenfield.Templates;

    template.container = function (data) {
      return ZT.html(_templateObject200(), data.children && template.children(data));
    };

    template.children = function (data) {
      return ZT.html(_templateObject201(), data.tokens.map(function (token) {
        return ZT.html(_templateObject202(), token.editInput ? ZT.html(_templateObject203(), data.id) : ZT.html(_templateObject204(), token.disabled ? 'is-disabled' : '', token.invalidToken ? ' has-error' : '', token.tokenId, token.zdata, token.style, token.hasImage && (token.isSprite ? ZT.html(_templateObject205(), token.iconClassName) : ZT.html(_templateObject206(), token.image)), ZT.html(_templateObject207(), token.title, token.text), ZC.createButton(token.removeButton)));
      }), data.id, data.id, data.tabindex, data.disabled, data.pasteStyle, data.id);
    };
  })(ZComponents);
  /* $Id$ */

  /* eslint-disable */


  ZComponents.Position = function (ZC) {
    var $ = ZC.DOMUtil,
        $window = ZC.$window;
    var floatingElement, options, within, floatingElemDim, targetDim, availableHeight, availableWidth, win, callout, hiddenParents, prevStylesOfHiddenParents, correctionOffset, finalCorrectionOffset;
    var defaultOptions = {
      direction: 'bottom-left',
      // No I18N
      showWithinTarget: false,
      within: $window,
      computeElementDim: true,
      computeTargetDim: true,
      computeWithinDim: true,
      arrow: {
        minSpace: 0,
        margin: {
          left: 0,
          top: 0
        },
        callback: undefined
      },
      callbacks: {
        beforeComputingDir: {
          dimensionModifier: $.noop,
          directionModifier: $.noop
        },
        beforeComputingPos: {
          dimensionModifier: $.noop,
          directionModifier: $.noop
        }
      },
      withinPadding: 8,
      customDimensions: false,
      positionAlterable: 'flipallfit' // 'flipside'|flipsidefit'|flipall'|flipfit'|'fit'|false //No I18N

      /* newly added flipside, flipsideallfit */

    };
    var calloutPositions = {
      'top-right': 'bottom-right',
      // No I18N
      'top-left': 'bottom-left',
      // No I18N
      'bottom-right': 'top-right',
      // No I18N
      'bottom-left': 'top-left',
      // No I18N
      top: 'bottom',
      // No I18N
      bottom: 'top',
      // No I18N
      left: 'right',
      // No I18N
      right: 'left',
      // No I18N
      'left-top': 'right-bottom',
      // No I18N
      'left-bottom': 'right-top',
      // No I18N
      'right-top': 'left-bottom',
      // No I18N
      'right-bottom': 'left-top' // No I18N

    };
    var regex = {
      relDirections: /^(top|top-right|top-left|bottom|bottom-right|bottom-left|left|left-top|left-bottom|right|right-top|right-bottom|top-left-corner|top-right-corner|bottom-left-corner|bottom-right-corner)$/,
      withinDirections: /^(top|bottom|left|right|top-left|top-right|bottom-left|bottom-right|center)$/,
      fit: /^(fit|flipfit|flipallfit|flipsidefit|flipsideallfit|true)$/,
      flip: /^(flip|flipfit|flipall|flipallfit|flipside|flipsidefit|flipsideall|flipsideallfit|true)$/,
      flipside: /^(flipside|flipsidefit|flipsideall|flipsideallfit|flipsideonlyfit|true)$/,
      flipall: /^(flipall|flipallfit|flipsideall|flipsideallfit|true)$/
    };

    function getCorrectionOffset() {
      if (!correctionOffset) {
        correctionOffset = {
          left: 0,
          top: 0
        }; // Correction in mobile browsers. --> Issue : https://github.com/jquery/jquery/issues/3187

        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
          var $body = $('body'); // No I18N

          var temp = $('<span>').css({
            position: 'absolute',
            // No I18N
            height: '20px',
            // No I18N
            width: '20px',
            // NO I18N
            top: '0px',
            // No I18N
            left: '0px' // No I18N

          }).appendTo($body);
          correctionOffset = temp.offset();
          correctionOffset.left = correctionOffset.left - parseFloat($body.css('margin-left')) - parseFloat($body.css('border-left-width')); // No I18N

          correctionOffset.top = correctionOffset.top - parseFloat($body.css('margin-top')) - parseFloat($body.css('border-top-width')); // No I18N

          temp.remove();
        }
      }

      return correctionOffset;
    }

    function getDimensions(element) {
      if (element.preventDefault) {
        return {
          width: 0,
          height: 0,
          isEvent: true,
          offset: {
            left: element.pageX,
            top: element.pageY
          }
        };
      }

      element = $(element);

      if (element[0].nodeType === 9) {
        return {
          width: element.width(),
          height: element.height(),
          offset: {
            left: 0,
            top: 0
          }
        };
      }

      if (element[0] === window) {
        return {
          width: element.width(),
          height: element.height(),
          offset: {
            left: element.scrollLeft(),
            top: element.scrollTop()
          }
        };
      }

      var dimension = {
        width: getDimension(element[0], 'outerWidth'),
        // No I18N
        height: getDimension(element[0], 'outerHeight'),
        // No I18N
        offset: getOffset(element)
      };
      return dimension;
    }

    function getOffset(element) {
      var offset = element.offset();
      var excessoffset = getCorrectionOffset();
      offset.left -= excessoffset.left;
      offset.top -= excessoffset.top;
      return offset;
    }
    /* Direction if alterable is fixed based on within element */


    function fixDirection(direction) {
      var dir = direction.split('-'); // No I18N

      /* To filp in case of insufficient space
      	top-left =>  bottom-left
      	bottom-left => top-left
      	left-top => right-top
      	right-top => left-top
       */

      if (/^(top|bottom)$/.test(dir[0]) || /^corner$/.test(dir[2])) {
        callout && callout.callback.call(this, callout.element, calloutPositions[dir[0]]);
        var collisionWidth = floatingElemDim.width + (callout ? callout.width ? callout.width : callout.element.outerWidth() : 0);
        var collisionHeight = floatingElemDim.height + (callout ? callout.height ? callout.height : callout.element.outerHeight() : 0);
        var dirInfo = flip.top(direction, collisionHeight);
        direction = dirInfo.direction;

        if (dirInfo.overTop > 0 && regex.flipall.test(options.positionAlterable)) {
          var newDirInfo = flip.left('right', collisionWidth); // No I18N

          /* check - if space in top/bottom is inefficient left/right space is checked, if available left/right position is taken, else top/bottom position is fixed */

          if (newDirInfo.overLeft <= 0) {
            direction = newDirInfo.direction;
          }
        }
      }

      dir = direction.split('-'); // No I18N

      if (/^(left|right)$/.test(dir[0]) || /^corner$/.test(dir[2])) {
        callout && callout.callback.call(this, callout.element, calloutPositions[dir[0]]);
        var collisionWidth = floatingElemDim.width + (callout ? callout.width ? callout.width : callout.element.outerWidth() : 0);
        var collisionHeight = floatingElemDim.height + (callout ? callout.height ? callout.height : callout.element.outerHeight() : 0);
        var dirInfo = flip.left(direction, collisionWidth);
        direction = dirInfo.direction;

        if (dirInfo.overLeft > 0 && regex.flipall.test(options.positionAlterable)) {
          var newDirInfo = flip.top('bottom', collisionHeight); // No I18N

          /* check - if space in left or right is inefficient, element is displayed in top/bottom */

          direction = newDirInfo.direction;
        }
      }

      return direction;
    }
    /* To filp in case of insufficient space
    	top-left =>  top-right
    	bottom-left => bottom-right
    	left-top => left-bottom
    	right-top => right-bottom
     */


    function fixAlternateDirection(direction) {
      var dir = direction.split('-'),
          // No I18N
      calloutWidthLeft = 0,
          calloutHeightLeft = 0;

      if (targetDim.isEvent && callout) {
        /* If target is an event, callout must point the mouse pointer, so collisionWidth is reduced */
        calloutWidthLeft = 2 * callout.width + callout.width / 2;
        calloutHeightLeft = 2 * callout.height + callout.height / 2;
      }

      if (/^(left|right)$/.test(dir[1])) {
        // var dirInfo = flip.left(dir[1], floatingElemDim.width - targetDim.width - calloutHeightLeft);
        // Since top-left && top-right, bottom-left && bottom-right positions are inverted.
        var secondDir = dir[1] === 'left' ? 'right' : 'left'; // No I18N

        var dirInfo = flip.left(secondDir, floatingElemDim.width - (dir[0] === 'corner' ? 0 : targetDim.width) - calloutHeightLeft);
        direction = direction.replace(dir[1], dirInfo.direction === 'left' ? 'right' : 'left'); // No I18N
      } else if (/^(top|bottom)$/.test(dir[1])) {
        var dirInfo = flip.top(dir[1], floatingElemDim.height - targetDim.height - calloutWidthLeft);
        direction = direction.replace(dir[1], dirInfo.direction);
      }

      return direction;
    }
    /* To initiate callout element */


    function initCallout(elementDir) {
      if (options.arrow && options.arrow.element) {
        var callout = {};
        var element = options.arrow.element;

        if (typeof element === 'string' || element instanceof $ || element.nodeType) {
          // No I18N
          element = $(element);

          if (element.length) {
            callout.element = element;
          }
        }

        if (callout.element && callout.element.css('position') !== 'static') {
          // No I18N
          callout.centeredToTarget = !!(/^(center|undefined)$/.test(options.arrow.direction) && !targetDim.isEvent);
          callout.callback = typeof options.arrow.callback === 'function' ? options.arrow.callback : typeof options.arrowCallback === 'function' ? options.arrowCallback : $.noop; // No I18N

          callout.direction = calloutPositions[elementDir];
          callout.callback.call(this, callout.element, callout.direction.split('-')[0]); // No I18N

          callout.height = typeof options.arrow.height === 'number' ? options.arrow.height : 0; // No I18N

          callout.width = typeof options.arrow.height === 'number' ? options.arrow.width : 0; // No I18N

          callout.minSpace = options.arrow.minSpace;
          callout.margin = options.arrow.margin || {
            left: 0,
            top: 0
          };
          return callout;
        }

        options.arrow = undefined;
      }
    }

    function getElementHeight() {
      var direction = options.direction;

      if (floatingElemDim.height > getAvailableHeight(direction)) {
        return getAvailableHeight(direction);
      }

      return floatingElemDim.height;
    }

    function getElementWidth() {
      var direction = options.direction;

      if (floatingElemDim.width > getAvailableWidth(direction)) {
        return getAvailableWidth(direction);
      }

      return floatingElemDim.width;
    }

    function fitCalloutPosition(callout, calloutPosition) {
      var dir = callout.direction.split('-'); // No I18N

      var maxValue,
          tempDir = dir[1],
          minValue = 0;
      var elemWidth1 = getElementWidth();
      var elemHeight1 = getElementHeight();

      if (/^(left|right)$/.test(dir[1])) {
        maxValue = elemWidth1 - callout.width;
      } else if (/^(top|bottom)$/.test(dir[1])) {
        maxValue = elemHeight1 - callout.height;
      } else if (/^(top|bottom)$/.test(dir[0])) {
        maxValue = elemWidth1 - callout.width;
        tempDir = 'left'; // No I18N
      } else if (/^(left|right)$/.test(dir[0])) {
        maxValue = elemHeight1 - callout.height;
        tempDir = 'top'; // No I18N
      }

      if (calloutPosition[tempDir] > maxValue) {
        calloutPosition[tempDir] = maxValue;
      }

      if (calloutPosition[tempDir] < minValue) {
        calloutPosition[tempDir] = minValue;
      }
    }
    /* Function to get the callout position `for a given direction */


    function getCalloutPosition(callout, correctionPixel) {
      var pos = {};
      var dir = callout.direction.split('-'); // No I18N

      if (/^(top|bottom)$/.test(dir[0])) {
        pos[dir[0]] = -callout.height;

        if (!dir[1]) {
          pos.left = floatingElemDim.width / 2 - callout.width / 2 - correctionPixel.left;
        }
      } else if (/^(left|right)$/.test(dir[0])) {
        pos[dir[0]] = -callout.width;

        if (!dir[1]) {
          pos.top = floatingElemDim.height / 2 - callout.height / 2 - correctionPixel.top;
        }
      }

      if (/^(left|right)$/.test(dir[1])) {
        var cPix = correctionPixel.left;

        if (dir[1] === 'left') {
          // No I18N
          cPix = -cPix;
          pos.right = 'auto'; // No I18N
        } else {
          pos.left = 'auto'; // No I18N
        }

        if (targetDim.width && floatingElemDim.width > targetDim.width) {
          pos[dir[1]] = targetDim.width / 2 - callout.width / 2 + cPix;
        } else {
          pos.left = floatingElemDim.width / 2 - callout.width / 2;
        }
      } else if (/^(top|bottom)$/.test(dir[1])) {
        var cPix = correctionPixel.top;

        if (dir[1] === 'top') {
          // No I18N
          cPix = -cPix;
          pos.bottom = 'auto'; // No I18N
        } else {
          pos.top = 'auto'; // No I18N
        }

        if (targetDim.height && floatingElemDim.height > targetDim.height) {
          pos[dir[1]] = targetDim.height / 2 - callout.height / 2 + cPix;
        } else {
          pos.top = floatingElemDim.height / 2 - callout.height / 2;
        }
      }

      var doesHaveBoxShadow = floatingElement.css('box-shadow') !== 'none'; // No I18N

      /* This correction is done because the pointer always sits on the element rather than attached to the element */

      if (dir[0] === 'top') {
        // No I18N
        pos.top = pos.top + (parseFloat(floatingElement.css('border-top-width')) || doesHaveBoxShadow ? 1 : 0); // No I18N
      } else if (dir[0] === 'bottom') {
        // No I18N
        pos.bottom = pos.bottom + (parseFloat(floatingElement.css('border-bottom-width')) || doesHaveBoxShadow ? 1 : 0); // No I18N
      } else if (dir[0] === 'right') {
        // No I18N
        pos.right = pos.right + (parseFloat(floatingElement.css('border-right-width')) || doesHaveBoxShadow ? 1 : 0); // No I18N
      } else if (dir[0] === 'left') {
        // No I18N
        pos.left = pos.left + (parseFloat(floatingElement.css('border-left-width')) || doesHaveBoxShadow ? 1 : 0); // No I18N
      }

      if (/^(bottom|top)/.test(callout.direction)) {
        pos.top = pos.bottom = ''; // No I18N
      } else {
        pos.left = pos.right = ''; // No I18N
      }

      return pos;
    }

    var flip = {
      /* Filp north south position incase of insufficient height in the given direction */
      top: function top(direction, collisionHeight) {
        var dir = direction.split('-')[0],
            response = {
          direction: direction
        },
            availHeight = getAvailableHeight(direction);
        response.overTop = collisionHeight - availHeight;

        if (response.overTop > 0) {
          var newdir = dir === 'top' ? 'bottom' : 'top'; // No I18N

          var newAvailableHeight = getAvailableHeight(direction.replace(dir, newdir));

          if (newAvailableHeight > availHeight) {
            response.direction = direction.replace(dir, newdir);
            response.overTop = collisionHeight - newAvailableHeight;
          }
        }

        return response;
      },

      /* Flip the left right position incase of insufficient width in the given direction */
      left: function left(direction, collisionWidth) {
        var dir = direction.split('-'),
            response = {
          direction: direction
        },
            finalDir,
            newdir;
        var availWidth = getAvailableWidth(direction);
        response.overLeft = collisionWidth - availWidth;

        if (response.overLeft > 0) {
          finalDir = dir[0];

          if (dir[2] === 'corner') {
            finalDir = dir[1];
          }

          newdir = finalDir === 'left' ? 'right' : 'left'; // No I18N

          var newAvailableWidth = getAvailableWidth(direction.replace(finalDir, newdir));

          if (newAvailableWidth > availWidth) {
            response.direction = direction.replace(finalDir, newdir);
            response.overLeft = collisionWidth - newAvailableWidth;
          }
        }

        return response;
      }
    };
    /* Fit the element position based on the viewport */

    function fitPosition(position, direction) {
      var newPosition = $.extend({}, position),
          // collisionWidth = floatingElemDim.width + callout ? callout.width : 0,
      // collisionHeight = floatingElemDim.height + callout ? callout.height : 0,
      dir = direction.split('-'); // No I18N

      dir[1] = dir[1] === undefined ? /^(top|bottom)$/.test(dir[0]) ? 'left' : 'top' : dir[1]; // No I18N
      // var offset = within.isWindow ? {
      //     left: win.scrollLeft,
      //     top: win.scrollTop
      // } : within.offset;

      if (/^(top|bottom)$/.test(dir[1]) || targetDim.isEvent) {
        var overTop = within.scrollTop - newPosition.top;

        if (overTop > 0) {
          newPosition.top += overTop;
        }

        var overBottom = newPosition.top + floatingElemDim.height - (within.scrollTop + getAvailableHeight().complete);

        if (overBottom > 0) {
          newPosition.top -= overBottom;
        }
      }

      if (/^(left|right)$/.test(dir[1]) || targetDim.isEvent) {
        var overLeft = within.scrollLeft - newPosition.left;

        if (overLeft > 0) {
          newPosition.left += overLeft;
        }

        var overRight = newPosition.left + floatingElemDim.width - (within.scrollLeft + getAvailableWidth().complete) + 1;

        if (overRight > 0) {
          newPosition.left -= overRight;
        }
      }

      return newPosition;
    }

    function calculatePosition(newDirection) {
      var newPosition, position, recalculated;

      if (newDirection) {
        recalculated = true;
        options.direction = newDirection;
      }

      options.callbacks.beforeComputingDir.dimensionModifier(targetDim, floatingElemDim, within, options);

      if (!/corner/.test(options.direction)) {
        callout = initCallout(options.direction);
      }

      if (regex.flip.test(options.positionAlterable) && !recalculated) {
        options.direction = fixDirection(options.direction);
      }
      /* Setting Callout properties */


      if (callout) {
        callout.direction = calloutPositions[options.direction];
        callout.callback.call(this, callout.element, callout.direction.split('-')[0]); // No I18N

        if (!callout.height) {
          callout.height = callout.element.outerHeight();
        }

        if (!callout.width) {
          callout.width = callout.element.outerWidth();
        }
      }

      if (regex.flipside.test(options.positionAlterable)) {
        options.direction = fixAlternateDirection(options.direction);
      }

      options.callbacks.beforeComputingPos.dimensionModifier(targetDim, floatingElemDim, within, options);
      position = fixPosition(options.direction);
      newPosition = $.extend({}, position);

      if (regex.fit.test(options.positionAlterable)) {
        newPosition = fitPosition(position, options.direction);
      }

      if (newPosition.top < within.scrollTop) {
        newPosition.top = within.scrollTop;
      }

      if (newPosition.left < within.scrollLeft) {
        newPosition.left = within.scrollLeft;
      }

      if (callout && regex.flipall.test(options.positionAlterable) && !recalculated && !targetDim.isEvent) {
        /* Calculate whether calloutminspace is available */
        // CALLOUTMINSPACE
        if (callout.minSpace !== undefined) {
          var dir = options.direction.split('-'); // No I18N

          var minElemLeft, minElemTop, maxEleLeft, maxEleTop;
          var elemWidth1 = getElementWidth();
          var elemHeight1 = getElementHeight();
          var newdir;
          minElemLeft = targetDim.offset.left - elemWidth1 + callout.width;
          minElemTop = targetDim.offset.top - elemHeight1 + callout.height;
          maxEleLeft = targetDim.offset.left + targetDim.width - callout.width;
          maxEleTop = targetDim.offset.top + targetDim.height - callout.height;

          if (/^(top|bottom)$/.test(dir[0])) {
            if (newPosition.left < minElemLeft) {
              newdir = 'left'; // No I18N
            }

            if (newPosition.left > maxEleLeft) {
              newdir = 'right'; // No I18N
            }
          } else if (/^(left|right)$/.test(dir[0])) {
            if (newPosition.top < minElemTop) {
              newdir = 'top'; // No I18N
            }

            if (newPosition.top > maxEleTop) {
              newdir = 'bottom'; // No I18N
            }
          }

          if (newdir) {
            return calculatePosition(newdir);
          }
        }
      }

      var correctedPosition = {
        left: newPosition.left - finalCorrectionOffset.left,
        top: newPosition.top - finalCorrectionOffset.top
      };

      if (callout) {
        callout.direction = calloutPositions[options.direction];
        var correctionPixel = {
          left: newPosition.left - position.left,
          top: newPosition.top - position.top
        };
        callout.position = getCalloutPosition(callout, correctionPixel);
        fitCalloutPosition(callout, callout.position);
      }

      return correctedPosition;
    }
    /* Function to get the available height in the given direction */


    function getAvailableHeight(direction) {
      if (!availableHeight) {
        if (within.isWindow || within.isDocument) {
          availableHeight = {
            top: targetDim.offset.top - within.scrollTop,
            bottom: within.height - (targetDim.offset.top + targetDim.height - within.scrollTop),
            complete: within.height
          };
        } else {
          availableHeight = {};

          if (within.offset.top < win.scrollTop) {
            availableHeight.top = targetDim.offset.top - win.scrollTop;
          } else {
            availableHeight.top = targetDim.offset.top - within.scrollTop;
          }

          availableHeight.bottom = within.offset.top + within.height - (targetDim.offset.top + targetDim.height);
          var diffHeight = win.height + win.scrollTop - (within.offset.top + within.height);

          if (diffHeight < 0) {
            availableHeight.bottom += diffHeight;
          }

          availableHeight.complete = availableHeight.top + availableHeight.bottom + targetDim.height;
        }
      }

      if (!direction) {
        return availableHeight;
      }

      direction = direction.split('-')[0]; // No I18N

      if (direction === 'top') {
        // No I18N
        return availableHeight.top;
      } else if (direction === 'bottom') {
        // No I18N
        return availableHeight.bottom;
      }

      return availableHeight.complete;
    }
    /* Function to get the available width in the given direction */


    function getAvailableWidth(direction) {
      if (!availableWidth) {
        if (within.isWindow || within.isDocument) {
          availableWidth = {
            left: targetDim.offset.left - within.scrollLeft,
            right: within.width - (targetDim.offset.left + targetDim.width - within.scrollLeft),
            complete: within.width
          };
        } else {
          availableWidth = {};

          if (within.offset.left < win.scrollLeft) {
            availableWidth.left = targetDim.offset.left - win.scrollLeft;
          } else {
            availableWidth.left = targetDim.offset.left - within.scrollLeft;
          }

          availableWidth.right = within.offset.left + within.width - (targetDim.offset.left + targetDim.width);
          var diffWidth = win.width + win.scrollLeft - (within.offset.left + within.width);

          if (diffWidth < 0) {
            availableWidth.right += diffWidth;
          }

          availableWidth.complete = availableWidth.left + availableWidth.right + targetDim.width;
        }
      }

      if (!direction) {
        return availableWidth;
      }

      var dir = direction.split('-'),
          // No I18N
      finaldir = dir[2] === 'corner' ? dir[1] : dir[0];

      if (finaldir === 'left') {
        // No I18N
        return availableWidth.left;
      } else if (finaldir === 'right') {
        // No I18N
        return availableWidth.right;
      }

      return availableWidth.complete;
    }
    /* Function to get element position for the given direction */


    function fixPosition(direction) {
      var dir = direction.split('-'); // No I18N

      var basePosition = $.extend({}, targetDim.offset);

      if (dir[0] === 'top') {
        // No I18N
        basePosition.top -= floatingElemDim.height + (callout ? callout.height : 0);
      } else if (dir[0] === 'bottom') {
        // No I18N
        basePosition.top += targetDim.height + (callout ? callout.height : 0);
      } else if (dir[0] === 'left') {
        // No I18N
        basePosition.left -= floatingElemDim.width + (callout ? callout.width : 0);
      } else if (dir[0] === 'right') {
        // No I18N
        basePosition.left += targetDim.width + (callout ? callout.width : 0);
      }

      if (dir[1] === undefined) {
        if (dir[0].match(/^left|right$/)) {
          basePosition.top = basePosition.top - floatingElemDim.height / 2 + targetDim.height / 2;
        } else {
          basePosition.left = basePosition.left - floatingElemDim.width / 2 + targetDim.width / 2;
        }
      } else if (dir[1] === 'top') {
        // No I18N
        basePosition.top = basePosition.top + targetDim.height - floatingElemDim.height;
      } else if (dir[1] === 'right') {
        // No I18N
        basePosition.left = basePosition.left - floatingElemDim.width + (dir[2] === 'corner' ? 0 : targetDim.width); // No I18N
      } else if (dir[1] === 'left' && dir[2] === 'corner') {
        // No I18N
        basePosition.left = basePosition.left + targetDim.width;
      }

      return basePosition;
    }

    function showHiddenParent(element) {
      element = $(element);

      if (element.is(':hidden')) {
        // No I18N
        var i = 1;
        var parent = element;

        while (i && parent && !parent.is('body')) {
          // No I18N
          if (parent.css('display') === 'none') {
            // No I18N
            hiddenParents.push(parent);
            prevStylesOfHiddenParents.push(parent.attr('style') || ''); // No I18N

            parent.css({
              display: 'block',
              // No I18N
              position: 'absolute',
              // No I18N
              opacity: 1,
              visibility: 'hidden' // No I18N

            });
            i = parent.is(':hidden'); // No I18N
          }

          parent = parent.parent();
        }
      }
    }

    function resetParent() {
      if (hiddenParents && hiddenParents.length) {
        hiddenParents.forEach(function (parent, i) {
          parent.attr('style', prevStylesOfHiddenParents[i]); // No I18N
        });
        hiddenParents = [];
        prevStylesOfHiddenParents = [];
      }
    }
    /* Function to get the corrected element position based on the element positioning and relative parent positioning */


    function getCorrection(element) {
      // var offsetNew = $.extend({}, calculatedOffset);
      var position = element.css('position'); // No I18N

      var parent = element.parent()[0]; // Dummy element is used to find the correction pixel. Actual element is not used as the offset(), position(), offsetTop, offsetLeft are not relevant when the actual element is being transformed or when there is margin for the element.

      var temp = $('<span>').css({
        position: position,
        height: '20px',
        // No I18N
        width: '20px',
        // NO I18N
        top: '0px',
        // No I18N
        left: '0px',
        // No I18N
        transform: 'none',
        // No I18N
        margin: '0px',
        // No I18N
        display: '',
        // No I18N
        visibility: 'hidden' // No I18N

      });
      parent.appendChild(temp[0]);
      var curOffset = temp.offset();
      parent.removeChild(temp[0]); // offsetNew.top = offsetNew.top - curOffset.top;
      // offsetNew.left = offsetNew.left - curOffset.left;

      return curOffset;
    }

    function getScrollBarWidth() {
      var scrollEle = document.createElement('div');
      var styleProps = 'width:100px;height:100px;overflow:scroll;'; // No I18N

      var body = document.querySelector('body'); //No I18N

      body.appendChild(scrollEle); // No I18N

      scrollEle.style.cssText = styleProps;
      var scrollWidth = $(scrollEle).width() - scrollEle.scrollWidth;
      body.removeChild(scrollEle); // No I18N

      return scrollWidth || 0;
    }
    /* Function to get the dimensions of within container */


    function getWithinDimensions(element) {
      element = element.length ? element : $window;
      var isWindow = element[0] === window;
      var isDocument = !!element[0] && element[0].nodeType === 9;
      var offset = isWindow || isDocument ? {
        left: 0,
        top: 0
      } : getOffset(element) || {
        left: 0,
        top: 0
      };
      var scrollLeft = isWindow || isDocument ? win.scrollLeft : offset.left < win.scrollLeft ? win.scrollLeft : offset.left;
      var scrollTop = isWindow || isDocument ? win.scrollTop : offset.top < win.scrollTop ? win.scrollTop : offset.top;
      /* For window, documentElements.clienWidth is used instead of window.innerWidth ==> because
         When mouse is scrollBar is shown permanently, window.innerWidth gives (width + scrollbarwidth)
         documentElement.clientWidth gives width excluding scrollbar width.
      */

      var width, height, scrollEle;

      if (isWindow) {
        width = win.width;
        height = win.height;
        /* width = window.innerWidth;
        height = window.innerHeight; */
        // scrollEle = $('body'); //No I18N
      } else if (isDocument) {
        width = document.documentElement.scrollWidth;
        height = document.documentElement.scrollHeight;
      } else {
        width = element.outerWidth();
        height = element.outerHeight();
        scrollEle = element;
      }

      if (scrollEle) {
        var overflowX = scrollEle.css('overflow-x'); // No I18N

        var overflowY = scrollEle.css('overflow-y'); // No I18N

        var hasOverflowX = overflowX === 'scroll' || (overflowX === 'auto' || scrollEle.is('body') && overflowX === 'visible') && width < scrollEle[0].scrollWidth; // No I18N

        var hasOverflowY = overflowY === 'scroll' || (overflowY === 'auto' || scrollEle.is('body') && overflowY === 'visible') && height < scrollEle[0].scrollHeight; // No I18N

        var scrollWidth;

        if (hasOverflowY) {
          width -= scrollWidth = getScrollBarWidth();
        }

        if (hasOverflowX) {
          height -= scrollWidth === undefined ? getScrollBarWidth() : scrollWidth;
        }
      }
      /*
      	For window|document, to find with and height, javascript functions are used, becos jquery produces buggy results in some cases
      */


      return {
        element: element,
        isWindow: isWindow,
        isDocument: isDocument,
        offset: offset,
        scrollLeft: scrollLeft,
        scrollTop: scrollTop,
        width: width,
        height: height
      };
    }

    function getDimension(element, dimension) {
      var value; // When an element is on transformation,  Boundingrect gives the transformed width and height. So inorder to get actual width and ht inspite of transformation we use jquery which uses offsetWidth, offsetHeight to calculate height and width of the element.This gives the original size of the element.

      var transform = window.getComputedStyle(element).transform; // var methodName = "getBoundingClientRect"; //No I18N

      var isSVG;

      if (element instanceof SVGElement) {
        isSVG = true; // methodName = "getBBox"; //No I18N
      }

      if (
      /* element[methodName] &&  */
      isSVG || !transform || transform === 'none') {
        // No I18N
        var styles = element.getBoundingClientRect();

        if (styles) {
          switch (dimension) {
            case 'outerWidth':
              // No I18N
              value = styles.width;
              break;

            case 'outerHeight':
              // No I18N
              value = styles.height;
              break;
          }
        }
      }

      if (isNaN(value) || !value) {
        value = $(element)[dimension]();
      }

      return value;
    }

    function getPosition(targetElement, elementPositioned, opt) {
      options = $.extend(true, {}, defaultOptions, opt); // make a copy of options

      floatingElement = $(elementPositioned);

      if (!options.showWithinTarget) {
        var oldDirection = options.direction; // To retain its previous position

        var previousStyle = floatingElement.attr('style'); // No I18N
        // This is included becos the floatingElement that are at the edge of the window results in incorrect dimension calculation

        floatingElement.css({
          top: '-99999px',
          // No I18N
          left: '-99999px' // No I18N

        });
        /* Element Dimensions */

        floatingElemDim = options.computeElementDim ? getDimensions(floatingElement) : {};
        floatingElement[0].style.overflow = 'hidden'; // No I18N
        // If the floating floatingElement size exceeds the document size, it results in incorrect within dimension calculation hence the floating floatingElement is hidden and then the within dimension is calculated.
        // if (floatingElemDim.height > document.documentElement.clientHeight && regex.flip.test(options.positionAlterable)) {
        //     previousStyle.display = floatingElement[0].style.display;
        //     floatingElement[0].style.display = 'none'; //No I18N
        // } else {
        //     previousStyle.overflow = floatingElement[0].style.overflow;
        //     floatingElement[0].style.overflow = 'hidden'; //No I18N
        // }

        win = {
          scrollLeft: $window.scrollLeft() + options.withinPadding,
          scrollTop: $window.scrollTop() + options.withinPadding,
          height: document.documentElement.clientHeight - options.withinPadding * 2,
          width: document.documentElement.clientWidth - options.withinPadding * 2
        }; // Target Dimension

        targetDim = options.customDimensions ? targetElement : options.computeTargetDim ? getDimensions(targetElement) : {}; // Within Dimension

        within = options.computeWithinDim ? getWithinDimensions($(options.within)) : {};
        finalCorrectionOffset = getCorrection(floatingElement); // Revert the floatingElement to original position

        floatingElement.attr('style', previousStyle); // No I18N

        if (!regex.relDirections.test(options.direction)) {
          options.direction = 'bottom-left'; // No I18N
        }

        options.direction = ZC.getRTLBasedDir(options.direction, options.rtl);
        var position = calculatePosition();
        var response = {
          elementPosition: position || {
            left: 0,
            top: 0
          },
          oldDirection: oldDirection,
          actualDirection: options.direction,
          direction: ZC.getRTLBasedDir(options.direction, options.rtl),
          arrowPosition: callout ? callout.position : {
            left: 0,
            top: 0
          },
          arrowDirection: calloutPositions[options.direction] && calloutPositions[options.direction].split('-')[0] // No I18N

        };
        var dir = options.direction.split('-'); // No I18N

        if (/^(top|bottom)$/.test(dir[0])) {
          response.availableHeight = getAvailableHeight(dir[0]) - (callout ? callout.height : 0);
          response.availableWidth = getAvailableWidth(dir[0]);
        } else if (/^(left|right)$/.test(dir[0])) {
          response.availableHeight = getAvailableHeight(dir[0]);
          response.availableWidth = getAvailableWidth(dir[0]) - (callout ? callout.width : 0);
        }

        return response;
      }

      return getWithinTargetPosition(targetElement, elementPositioned);
    }

    function getWithinTargetPosition(targetElement) {
      /* Elements with position 'absolute'|'fixed' are preferred to be  */
      targetElement = $(targetElement);
      var isWindow,
          position = {};

      if (!targetElement.length || targetElement[0] === window || targetElement[0].nodeType === 9
      /* document */
      ) {
        targetElement = $(window);
        isWindow = true;
      }

      if (!regex.withinDirections.test(options.direction)) {
        options.direction = 'bottom-left'; // No I18N
      }

      var containerProps = {
        width: targetElement.outerWidth() - (isWindow ? 0 : parseFloat(targetElement.css('border-right-width')) + parseFloat(targetElement.css('border-left-width'))),
        // No I18N
        height: targetElement.outerHeight() - (isWindow ? 0 : parseFloat(targetElement.css('border-top-width')) - parseFloat(targetElement.css('border-bottom-width'))) // No I18N

      };
      /* Container Properties */

      containerProps.offset = isWindow ? {
        left: window.scrollX,
        top: window.scrollY
      } : getOffset(targetElement) || {
        left: 0,
        top: 0
      };
      /* Element Properties */

      var floatingEleProps = {
        width: floatingElement.outerWidth(),
        height: floatingElement.outerHeight()
      };
      var centerDirections = ['center', 'left', 'right', 'top', 'bottom']; // No I18N

      var directionPropertObj = {
        left: 'width',
        // No I18N
        top: 'height' // No I18N

      };

      for (var dir in directionPropertObj) {
        var oppDir = dir === 'left' ? 'right' : 'bottom'; // No I18N

        var prop = directionPropertObj[dir];

        if (options.direction.indexOf(dir) !== -1) {
          position[dir] = containerProps.offset[dir];
        } else if (options.direction.indexOf(oppDir) !== -1) {
          position[dir] = containerProps.offset[dir] + containerProps[prop] - floatingEleProps[prop];
        } else if (centerDirections.indexOf(options.direction) !== -1) {
          position[dir] = containerProps.offset[dir] + containerProps[prop] / 2 - floatingEleProps[prop] / 2;
        }
      } // position = getCorrection(position, element);


      return {
        elementPosition: position
      };
    }

    return {
      get: function get(targetElement, elementPositioned, opt) {
        if (targetElement && $(elementPositioned).length) {
          if (targetElement instanceof $) {
            targetElement = targetElement[0];
          }

          if (elementPositioned instanceof $) {
            elementPositioned = elementPositioned[0];
          }

          opt = opt || {};

          if (elementPositioned.nodeType === 1 && (targetElement.nodeType === 1 || opt.showWithinTarget && (targetElement === window || targetElement === document) || targetElement.preventDefault || opt.customDimensions)) {
            hiddenParents = [];
            prevStylesOfHiddenParents = [];
            !targetElement.preventDefault && showHiddenParent(targetElement);
            showHiddenParent(elementPositioned);
            var positionObject = getPosition(targetElement, elementPositioned, opt);
            resetParent();
            floatingElement = targetDim = callout = options = within = floatingElemDim = availableHeight = availableWidth = win = correctionOffset = finalCorrectionOffset = hiddenParents = prevStylesOfHiddenParents = undefined;
            return positionObject;
          }
        }
      }
    };
  }(ZComponents);

  var ZTooltip =
  /*#__PURE__*/
  function (_ZC$CoreComponent18) {
    _inherits(ZTooltip, _ZC$CoreComponent18);

    function ZTooltip() {
      _classCallCheck(this, ZTooltip);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZTooltip).apply(this, arguments));
    }

    _createClass(ZTooltip, [{
      key: "_create",
      value: function _create() {
        var _namespace = '.' + this.name; // No I18N


        this._eventSuffix = _namespace + '-temp'; // No I18N

        this.element.on('mouseenter' + _namespace + ' mousemove' + _namespace, this._targetEnter.bind(this)); // No I18N

        this._scrollHandlerBinded = this._scrollHandler.bind(this);
      }
    }, {
      key: "_scrollHandler",
      value: function _scrollHandler() {
        this._hide();
      }
    }, {
      key: "_handleEvents",
      value: function _handleEvents(listen) {
        var _this133 = this;

        var _namespace = this._eventSuffix;
        ZC.$document.off(_namespace);
        window.removeEventListener('scroll', this._scrollHandlerBinded, true); // No I18N

        if (listen) {
          ZC.$document.on('keydown' + _namespace + ' mousedown' + _namespace, function () {
            // No I18N
            _this133._hide();
          });
          window.addEventListener('scroll', this._scrollHandlerBinded, true); // No I18N
        }
      }
    }, {
      key: "_targetEnter",
      value: function _targetEnter(origEvent, customTarget, opt) {
        var _this134 = this;

        var target,
            disabledSelector = 'button[disabled], input[disabled], textarea[disabled], fieldset[disabled], select[disabled], keygen[disabled] , output[disabled], option[disabled]'; // No I18N

        this.custom = false; // Disabled form elements are omitted becos some browsers doesnt trigger events for disabled elements.

        if (this.target && (this.target.is(':hidden') || this.target.is(disabledSelector))) {
          // No I18N
          this._hide();

          return;
        }

        if (origEvent) {
          if (!origEvent.originalEvent) {
            return;
          }

          this.pageX = origEvent.pageX;
          this.pageY = origEvent.pageY;
          target = $(origEvent.target).closest('[title],[data-title-content-id]'); // No I18N

          if (this.target && this.target.is(':hover') && !this.target.find(target).length) {
            // No I18N
            if (!this._refreshed && (this._lastTip || this._hiddenOnTimeOut)) {
              return;
            }

            target = this.target;
          } else if (!target.length || !(target.attr('title') || target.attr('data-title-content-id')) || this._opts.selector && !target.is(this._opts.selector)) {
            /*
            1. If not a DOM Element
            2. If there is no content in title/content-id attribute
            3. If it does'nt match the given selector,
            tooltip is not shown.
            */
            return;
          }
        } else if (customTarget) {
          this.custom = true;
          this.pageX = this.pageY = undefined;
          target = $(customTarget);
        } else {
          return;
        }

        this._hiddenOnTimeOut = false; // clear previous title.

        this.target && this._clearTitle(true, this.target);
        this.target = target; // Saving the options of the target so retrival will be easy

        this.targetOpt = this._getOptions(target, opt); // @deprecated

        if (this.custom) {
          this.targetOpt.showDelay = 0;
        }

        this._clearTitle();

        this.target.off(this._eventSuffix).on('mouseleave' + this._eventSuffix, function () {
          // No I18N
          _this134._hiddenOnTimeOut = false;

          _this134._hide();
        });
        this._lastEvent = origEvent;

        this._show(origEvent);
      }
    }, {
      key: "_hide",
      value: function _hide(immediate) {
        if (this.target) {
          var clearTitle = !this.target.is(':hover'); // No I18N

          clearTitle && this._clearTitle(true);

          this._clearShowTimer();

          this._clearHideTimer();

          if (this.container) {
            this._removeTip(immediate, clearTitle); // No I18N

          }

          this._handleEvents();
        }
      }
    }, {
      key: "_show",
      value: function _show(origEvent) {
        var _this135 = this;

        var targetOpt = this.targetOpt;
        var target = this.target;

        if (targetOpt.showDelay && targetOpt.reshowDelay === undefined) {
          this.targetOpt.reshowDelay = targetOpt.showDelay / 5;
        }

        if (this.targetOpt.hideOnTargetClick) {
          target.on('mousedown' + this._eventSuffix, function () {
            // No I18N
            _this135._clearShowTimer();

            _this135._removeTip(true);
          });
        }

        this._showTooltip(origEvent);
      }
    }, {
      key: "_clearShowTimer",
      value: function _clearShowTimer() {
        clearTimeout(this.showTimer);
      }
    }, {
      key: "_clearHideTimer",
      value: function _clearHideTimer() {
        clearTimeout(this.hideTimer);
      }
    }, {
      key: "_setTimer",
      value: function _setTimer(target, opt) {
        var _this136 = this;

        if (opt.maxDisplayTime) {
          this._clearHideTimer();

          this.hideTimer = setTimeout(function () {
            _this136._hiddenOnTimeOut = true;

            _this136._removeTip(true);
          }, opt.maxDisplayTime);
        }
      }
    }, {
      key: "_showHandler",
      value: function _showHandler(origEvent, animation) {
        var _this137 = this;

        if (!this.target.is(':visible')) {
          // No I18N
          return;
        }

        this._clearHideTimer();

        var options = this.targetOpt;
        /* validating the position */

        if (!/^(auto|top|bottom|right|left|top-left|top-right|bottom-left|bottom-right|at-cursor|follow-cursor)$/.test(options.position)) {
          options.position = this._DEFAULTS.position;
        }
        /* set displayType = "box" for at-cursor/follow-cursor */


        if (this._isAtCursorPos()) {
          if (this.pageX === undefined || this.pageY === undefined) {
            options.position = 'top'; // No I18N
          } else {
            options.displayType = 'box'; // No I18N
          }
        }

        this._includeContent();

        this._createTooltip();

        this._setTimer(this.target, options);

        if (options.position === 'follow-cursor') {
          // No I18N
          this.target.on('mousemove' + this._eventSuffix, function (origEvent) {
            // No I18N
            _this137._positionElement(origEvent);
            /* When the tooltip is on move, its hidetimer is reset */


            _this137._setTimer(_this137.target, options);
          });
        }

        this._positionElement(origEvent);

        this._handleEvents(true);

        this._animate(this.container, animation, 'show', function () {
          // No I18N
          _this137._trigger('show', origEvent); // No I18N

        });
      }
    }, {
      key: "_showTooltip",
      value: function _showTooltip(origEvent) {
        var options = this.targetOpt;
        var delay = options.showDelay;
        var animation = options.animation;

        if (this.container) {
          if (this.target.is(this._lastTip)) {
            animation = delay = undefined;
          } else {
            delay = options.reshowDelay;

            this._trigger('hide', undefined, this._lastTip); // No I18N

          }
        }
        /* When the tooltip is about to be displayed, current target is set as last target */


        this._lastTip = this.target;

        this._clearShowTimer();

        if (delay) {
          this.showTimer = setTimeout(this._showHandler.bind(this, origEvent, animation), delay);
        } else {
          this._showHandler(origEvent, animation);
        }
      }
    }, {
      key: "_animate",
      value: function _animate(element, animation, action, animationCallback) {
        var callback = function callback() {
          element.css('display', action === 'hide' ? 'none' : ''); // No I18N

          animationCallback && animationCallback();
        };

        if (animation && ZC.animationHandler && !$.isEmptyObject(animation)) {
          var animationObject = {
            element: element,
            action: action,
            callback: callback,
            ctype: this.name,
            animation: animation
          };
          ZC.animationHandler(animationObject);
        } else {
          callback();
        }
      }
    }, {
      key: "_includeContent",
      value: function _includeContent() {
        var targetOptions = this.targetOpt;

        if (_typeof(targetOptions) === 'object') {
          // No I18N
          var content = targetOptions.title = targetOptions.content || targetOptions.title || ''; // No I18N

          if (typeof targetOptions.innerHTML === 'string') {
            // No I18N
            content = this._populateTemplate(targetOptions.innerHTML, targetOptions);
          } else if (typeof targetOptions.contentId === 'string') {
            // No I18N
            content = document.getElementById(targetOptions.contentId).innerHTML;
          } else {
            content = this._encodeContent(content);
          }

          if (targetOptions.showShortcutKey && window.ZShortCut) {
            content = this._appendShortCut(targetOptions, content);
          }

          this._setContent(targetOptions, content);
        }
      }
    }, {
      key: "_setContent",
      value: function _setContent(options, content) {
        this._opts.content = content;
      }
    }, {
      key: "_encodeContent",
      value: function _encodeContent(htmlContent) {
        return this.targetOpt.isMessageHTMLEncoded ? htmlContent : ZC.encodeHTML(htmlContent);
      }
    }, {
      key: "_populateTemplate",
      value: function _populateTemplate(template, data) {
        var _this138 = this;

        if (typeof template === 'string') {
          // No I18N
          return template.replace(/(#?#[^# ]+#?#)/g, function (match) {
            var content = data[match.replace(/#/g, '')]; // No I18N

            return _this138._isNotNull(content) ? _this138._encodeContent(content) : match; // No I18N
          });
        } else if (typeof template === 'function') {
          // No I18N
          return template(data);
        }
      }
    }, {
      key: "_isAtCursorPos",
      value: function _isAtCursorPos() {
        return /^(at-cursor|follow-cursor)$/.test(this.targetOpt.position);
      }
    }, {
      key: "_positionElement",
      value: function _positionElement(origEvent) {
        var positionObject = this._getPosition(origEvent);

        var direction = positionObject.direction.split('-')[0]; // No I18N

        this.container.removeClass('class').addClass('ztooltip ztooltip--' + direction); // No I18N

        var margin = this.targetOpt.margin;

        if (this._isAtCursorPos() || margin && _typeof(margin) === 'object') {
          // No I18N
          this._updateMargin(margin, positionObject, direction);
        }

        this.container.css(positionObject.elementPosition);

        if (this._callout) {
          this._callout.css(positionObject.arrowPosition);
        }
      }
    }, {
      key: "_getPosition",
      value: function _getPosition(origEvent) {
        var opt = this.targetOpt;
        var eventTarget = this.target,
            position = opt.position,
            positionAlterable = opt.positionAlterable;
        this.container.css({
          left: 'auto',
          // No I18N
          right: 'auto' // No I18N

        });
        /* Get the current position of mouse pointer */

        var offset = opt.offset;

        if (this._isAtCursorPos() || offset) {
          if (offset) {
            this.pageX = parseInt(offset.left);
            this.pageY = parseInt(offset.top);
          } else {
            position = 'bottom-left'; // No I18N
          }

          eventTarget = origEvent;
          eventTarget.pageX = this.pageX;
          eventTarget.pageY = this.pageY;
          positionAlterable = 'flipallfit'; // No I18N
        } else if (opt.position === 'auto') {
          // No I18N
          position = 'bottom'; // No I18N

          positionAlterable = 'flipallfit'; // No I18N
        } else if (positionAlterable === undefined) {
          positionAlterable = false;
        }

        return ZC.Position.get(eventTarget, this.container, {
          rtl: opt.rtl,
          direction: position,
          eventObj: origEvent,
          bufferSpace: this._callout ? 10 : 0,
          positionAlterable: positionAlterable,
          arrowCallback: function arrowCallback(element, direction) {
            $(element).attr('class', 'ztooltip__pointer zh-' + direction); // No I18N
          },
          arrow: opt.displayType === 'callout' ? {
            // No I18N
            element: this._callout,
            direction: true,
            minSpace: 8
          } : undefined
        });
      }
    }, {
      key: "_removeTipHandler",
      value: function _removeTipHandler(immediate) {
        var _this139 = this;

        if (this.container) {
          if (!immediate && this.targetOpt.pauseOnMouseOver && this.container.is(':hover')) {
            // No I18N
            return;
          }

          this._lastTip = null;

          this._animate(this.container, this.targetOpt.animation, 'hide', function () {
            // No I18N
            _this139._callout = null;

            _this139._trigger('hide'); // No I18N

          });
        }
      }
    }, {
      key: "_removeTip",
      value: function _removeTip(immediate, clearTitle) {
        this._lastEvent = false;

        this._clearHideTimer();

        if (this.container) {
          /* This has been incuded becos, for all tip targets, its title is reset on targetleave
          but incase of tip shown using show method, there wont be any targetleave method to clear its title.
            This cannot be done for all case becos removeing tip on target click, its title should not be cleared.
          */
          this.custom && clearTitle && this._clearTitle(true, this.target);

          if (immediate || !this.targetOpt.hideDelay) {
            this._removeTipHandler(immediate);
          } else {
            this.hideTimer = setTimeout(this._removeTipHandler.bind(this), this.targetOpt.hideDelay);
          }
        }
      }
    }, {
      key: "_getOptions",
      value: function _getOptions(target, opt) {
        var titledata = target.attr('title'); // No I18N

        if (titledata && isNaN(titledata) && titledata.indexOf('{') !== -1) {
          // No I18N
          try {
            return JSON.parse(titledata);
          } catch (e) {}
        }

        var targetTitleAttrs = this._getTargetAttrs(target);

        targetTitleAttrs.content = titledata;
        return $.extend(true, {}, this._opts, targetTitleAttrs, opt || {});
      }
    }, {
      key: "_createTooltip",
      value: function _createTooltip() {
        var _this140 = this;

        var targetOpt = this.targetOpt;
        this._opts.callout = targetOpt.displayType === 'callout'; // No I18N

        this._callout = false;

        var element = this._render(!!this.container);

        if (element) {
          // If tooltip is present already, it is not recreated.
          if (this.container) {
            this.container.stop(true, true).hide();
          } else {
            this.container = $(element).on('mouseleave' + this._eventSuffix, function () {
              // No I18N
              if (!_this140.target) {
                _this140._removeTipHandler();
              }
            });
          }
        }

        this.container.css('pointer-events', targetOpt.pauseOnMouseOver ? 'auto' : 'none') // No I18N
        .attr('class', 'ztooltip ' + (targetOpt.className || '') + (targetOpt.rtl ? ' h-rtl' : '')); // No I18N

        if (this._opts.callout) {
          this._callout = this.container.find('.ztooltip__pointer'); // No I18N
        }
      }
    }, {
      key: "_render",
      value: function _render(skipParent) {
        var renderParam = {
          skipParent: skipParent
        };
        return ZC._render(this._opts, this.name, null, this.container && this.container[0], $('body')[0], renderParam); // No I18N
      }
    }, {
      key: "_clearTitle",
      value: function _clearTitle(reset, target) {
        target = target || this.target;

        if (target && target.length) {
          if (reset) {
            target.off(this._eventSuffix);
            var parents = target.data('zdependentElements'); // No I18N

            for (var i = 0; i < parents.length; i++) {
              var tar = $(parents[i]);

              if (tar.attr('title') === undefined) {
                // No I18N
                tar.attr('title', tar.data('ztitle')); // No I18N
              }

              tar.removeData('ztitle'); // No I18N
            }

            target.removeData('zdependentElements'); // No I18N

            var contentId = target.data('ztitleId'); // No I18N

            if (contentId) {
              target.attr('data-title-content-id', contentId) // No I18N
              .removeData('ztitleId'); // No I18N
            }

            this.target = undefined;
          } else {
            /* Fix to remove title attributes of parent elements having title attribute */
            var _parents = target.parents('[title]').toArray(); // No I18N


            _parents.push(target);

            for (var _i9 = 0; _i9 < _parents.length; _i9++) {
              var _tar = $(_parents[_i9]);

              _tar.data('ztitle', _tar.attr('title')); // No I18N


              _tar.removeAttr('title'); // No I18N

            }

            target.data('zdependentElements', _parents); // No I18N

            var _contentId = target.attr('data-title-content-id'); // No I18N


            if (_contentId) {
              target.data('ztitleId', _contentId) // No I18N
              .removeAttr('data-title-content-id'); // No I18N
            }
          }
        }
      }
    }, {
      key: "_trigger",
      value: function _trigger(customEvent, origEvent, target) {
        return this._dispatchEvent(customEvent, origEvent, {
          target: target || this.target,
          tooltip: customEvent === 'show' ? this.container : undefined // No I18N

        });
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        this.element.off('.' + this.name); // No I18N

        this._hide(true);
      }
    }, {
      key: "refresh",
      value: function refresh() {
        if (this._lastEvent) {
          // No I18N
          this._refreshed = true;

          this._targetEnter(this._lastEvent); // No I18N


          this._refreshed = false;
        }
      }
    }, {
      key: "setAttribute",
      value: function setAttribute(optionName, value) {
        if (_typeof(value) === 'object') {
          // No I18N
          if (this._opts[optionName]) {
            $.extend(this._opts[optionName], value);
            return;
          }
        }

        this._opts[optionName] = value;
      }
    }, {
      key: "_appendShortCut",
      value: function _appendShortCut(targetOptions, content) {
        var target = this.target;
        target = target.is('label.zbutton') ? target.prev('input') : target; // No I18N

        var data = ZC._getOpts(target);

        var key = ZShortCut.getInfo(data.actionName, target, false);

        if (key) {
          if (targetOptions.shortcutKeyCustomHTML) {
            key = targetOptions.shortcutKeyCustomHTML.replace(/(#key#)/gi, key);
          } else {
            key = ' (' + key + ')'; // No I18N
          }

          content += key;
        }

        return content;
      }
    }, {
      key: "_updateMargin",
      value: function _updateMargin(margin, positionObject, direction) {
        var marginTop = margin && parseInt(margin.top);
        var marginLeft = margin && parseInt(margin.left);
        var correction = this.targetOpt.rtl ? -1 : 1;
        var elementPosition = positionObject.elementPosition;

        if (isNaN(marginTop)) {
          marginTop = 0;
        }

        if (isNaN(marginLeft)) {
          marginLeft = 0;
        }

        if (this._isAtCursorPos()) {
          var maxCorrection = positionObject.availableHeight - this.container.outerHeight();
          elementPosition.left += marginLeft * correction; // @constant 18

          /* There must be some distance between cursor and the tooltip by default */

          elementPosition.top += marginTop + Math.min(18, maxCorrection);
        } else if (direction === 'top') {
          // No I18N
          elementPosition.top -= marginTop;
        } else if (direction === 'bottom') {
          // No I18N
          elementPosition.top += marginTop;
        } else if (direction === 'right') {
          // No I18N
          elementPosition.left += marginLeft * correction;
        } else if (direction === 'left') {
          // No I18N
          elementPosition.left -= marginLeft * correction;
        }
      }
    }, {
      key: "_getTargetAttrs",
      value: function _getTargetAttrs(target) {
        var tooltipdata = {};
        var attributes = target[0].attributes;
        var keys = Object.keys(attributes);
        keys.forEach(function (key) {
          var attrData = attributes[key]; // Sometimes attrData is null in IE.

          if (attrData) {
            var name = attrData.nodeName;
            var value = attrData.value;

            if (name.match(/^data-title-/)) {
              name = name.replace(/^data-title-/, '') // No I18N
              .replace(/-([a-z])/g, function (g) {
                return g[1].toUpperCase();
              }) // replacing the hyphenated names to camelCase
              .replace(/(html)/gi, 'HTML'); // No I18N

              tooltipdata[name] = value === 'true' || value === 'false' ? value === 'true' : value.indexOf('{') === -1 ? value : ZC._getObject(value); // No I18N
            }
          }
        });
        return tooltipdata;
      }
    }, {
      key: "show",
      value: function show(target, options) {
        target = $(target || this.element);

        if (target.length) {
          options = options || {};
          options.showDelay = 0;

          this._targetEnter(undefined, target, options);
        }

        return target;
      }
    }, {
      key: "hide",
      value: function hide(immediate) {
        this._hide(immediate);
      }
    }, {
      key: "name",
      get: function get() {
        return "ztooltip";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          isMessageHTMLEncoded: false,
          selector: undefined,
          displayType: 'box',
          // No I18N
          position: 'at-cursor',
          // No I18N
          hideOnTargetClick: true,
          margin: undefined,
          showDelay: 500,
          hideDelay: 300,
          maxDisplayTime: 5000,
          reshowDelay: undefined,
          showShortcutKey: true,
          animation: {
            show: {
              name: 'fade' // No I18N

            },
            hide: {
              name: 'fade' // No I18N

            }
          },
          className: undefined,
          innerHTML: undefined,
          pauseOnMouseOver: false,
          positionAlterable: undefined
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['show', // No I18N
        'hide' // No I18N
        ];
      }
    }]);

    return ZTooltip;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZTooltip', ZTooltip);

  (function (ZC) {
    var template = ZC.ztooltip.Templates;

    template.container = function (data) {
      return ZT.html(_templateObject208(), data.children && template.children(data));
    };

    template.children = function (data) {
      return ZT.html(_templateObject209(), ZT.customHTML(data.content), data.callout && ZT.html(_templateObject210()));
    };
  })(ZComponents);

  var ZPopup =
  /*#__PURE__*/
  function (_ZC$CoreComponent19) {
    _inherits(ZPopup, _ZC$CoreComponent19);

    function ZPopup() {
      _classCallCheck(this, ZPopup);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZPopup).apply(this, arguments));
    }

    _createClass(ZPopup, [{
      key: "_bindEvents",
      value: function _bindEvents() {
        var triggers = this._opts.popOn.split(' '); // No I18N


        for (var i = 0; i < triggers.length; i++) {
          switch (triggers[i]) {
            case 'mouseover':
              // No I18N
              this._eventHandler('mouseenter', this._mouseEnterHandler); // No I18N


              this._eventHandler('mouseleave', this._mouseLeaveHandler); // No I18N


              break;

            case 'click':
              // No I18N
              this._eventHandler('click', this._clickHandler); // No I18N


              break;

            case 'focus':
              // No I18N
              this._eventHandler('focusin', this._mouseEnterHandler); // No I18N


              this._eventHandler('focusout', this._mouseLeaveHandler); // No I18N


              break;
          }
        }
      }
    }, {
      key: "_mouseEnterHandler",
      value: function _mouseEnterHandler(orgEvent) {
        this._initPopover();

        this._mouseEnterFired = true;
        this._durationLeft && (this._durationLeft -= new Date().getTime() - this._closeAfterStartTime);
        this._mouseLeaveTimeout && clearTimeout(this._mouseLeaveTimeout);
        this._currentTarget = $(orgEvent.currentTarget);

        if (this._popover && !this._popover.is(':visible')) {
          this._popoverIns.open();
        }

        if (this._opts.pauseOnMouseOver) {
          clearTimeout(this._autoCloseTimer);
        }
      }
    }, {
      key: "_mouseLeaveHandler",
      value: function _mouseLeaveHandler(orgEvent) {
        var _this141 = this;

        this._mouseEnterFired = false;
        this._mouseLeaveTimeout = setTimeout(function () {
          _this141._durationLeft && (_this141._durationLeft -= new Date().getTime() - _this141._closeAfterStartTime);

          if (_this141._popover) {
            var currentPopoverId = _this141._popover.attr('id'); // No I18N


            if (!($(orgEvent.relatedTarget).parents('#' + currentPopoverId).length || $(orgEvent.relatedTarget).attr('id') === '#' + currentPopoverId)) {
              // No I18N
              _this141._popoverIns.close();
            }
          }
        }, this._durationLeft || this._opts.mouseLeaveTime);
      }
    }, {
      key: "_initPopover",
      value: function _initPopover() {
        var opts = this._opts;

        if (!this._popoverIns) {
          var id = opts.popoverId,
              content = opts.content,
              popoverEle,
              createInstance;

          if (id) {
            popoverEle = $('#' + id);

            if (popoverEle.length) {
              this._popoverIns = popoverEle.data('zpopover'); // No I18N

              if (!this._popoverIns) {
                createInstance = true;
              }
            } else {
              popoverEle = $('<div id=' + id + '></div>').appendTo('body'); // No I18N

              createInstance = true;
            }
          } else {
            id = this._getID(undefined, undefined, 'container'); // No I18N

            popoverEle = $('<div id=' + id + '></div>').appendTo('body'); // No I18N

            createInstance = true;
          }

          if (content instanceof $ || typeof content === 'string' && (content[0].indexOf('#') === 0 || content[0].indexOf('.') === 0)) {
            $(content).appendTo(popoverEle); // No I18N
          }

          if (createInstance) {
            var popoverOpts = {}; // Following line omits certain properties that are not in defaults.
            // Object.keys(ZC.ZPopover.prototype._DEFAULTS).forEach((optName) => popoverOpts[optName] = this._opts[optName]);

            popoverOpts = this._opts;
            popoverOpts.forElement = this.element;
            popoverOpts.className = this._opts.className;
            this._popoverIns = ZC.popover(popoverEle, popoverOpts);
            this._popover = popoverEle;
          }
        }

        this._bindPopoverEvents();
      }
    }, {
      key: "close",
      value: function close() {
        this._popoverIns && this._popoverIns.close();
      }
    }, {
      key: "open",
      value: function open() {
        this._initPopover();

        this._popoverIns.open();
      }
    }, {
      key: "_bindPopoverEvents",
      value: function _bindPopoverEvents() {
        var _this142 = this;

        var popOn = this._opts.popOn,
            isMouseover = popOn === 'mouseover'; // No I18N

        if (isMouseover || popOn === 'focus') {
          // No I18N
          var enterEv = isMouseover ? 'mouseenter.' : 'focusin.',
              // No I18N
          exitEv = isMouseover ? 'mouseleave.' : 'focusout.',
              // No I18N
          toBeClosed = false,
              eventPrefix = this.name;
          this._popover && this._popover.off(enterEv + eventPrefix).on(enterEv + eventPrefix, function () {
            _this142._durationLeft && (_this142._durationLeft -= new Date().getTime() - _this142._closeAfterStartTime);
            clearTimeout(_this142._mouseLeaveTimeout);

            if (_this142._opts.pauseOnMouseOver) {
              clearTimeout(_this142._autoCloseTimer);
            }
          }).off(exitEv + eventPrefix).on(exitEv + eventPrefix, function (orgEvent) {
            toBeClosed = !(orgEvent.type === 'focusout' && $(orgEvent.target).closest('.zpopover').length);
            _this142._durationLeft && (_this142._durationLeft -= new Date().getTime() - _this142._closeAfterStartTime);
            _this142._autoCloseTimer = setTimeout(function () {
              return toBeClosed && !_this142._mouseEnterFired && _this142._popoverIns.close();
            }, _this142._durationLeft || 100);
          });
        }
      }
    }, {
      key: "_clickHandler",
      value: function _clickHandler() {
        if (!this._popoverIns || this._popover.is(':hidden')) {
          // No I18N
          this.open();
        } else {
          this.close();
        }
      }
    }, {
      key: "_eventHandler",
      value: function _eventHandler(evName, handler) {
        this.element.on(evName + '.' + this.name, handler.bind(this)); // No I18N
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        if (optionName === 'popOn') {
          // No I18N
          var oldValue = this._opts.popOn,
              element = this.element;
          var triggers = oldValue.split(' '); // No I18N

          for (var i = 0; i < triggers.length; i++) {
            var eventPrefix = this.name,
                focusEv = 'focusin.' + eventPrefix + ' focusout.' + eventPrefix,
                // No I18N
            mouseEv = 'mouseenter.' + eventPrefix + ' mouseleave.' + eventPrefix; // No I18N

            switch (triggers[i]) {
              case 'mouseover':
                // No I18N
                element.off(mouseEv);
                this._popover && this._popover.off(mouseEv);
                break;

              case 'focus':
                // No I18N
                element.off(focusEv);
                this._popover && this._popover.off(focusEv);
                break;

              case 'click':
                // No I18N
                element.off(triggers[i] + '.' + eventPrefix); // No I18N

                break;
            }
          }

          if (value === 'click' && this._opts.delay) {
            // No I18N
            this._opts.delay = undefined;
          }

          this._bindEvents();

          this._bindPopoverEvents();

          this._opts.popOn = value;
        } else {
          var _this$_popoverIns;

          (_this$_popoverIns = this._popoverIns).setAttribute.apply(_this$_popoverIns, arguments);
        }
      }
    }, {
      key: "getComponentElement",
      value: function getComponentElement() {
        this._initPopover();

        return this._popover;
      }
    }, {
      key: "name",
      get: function get() {
        return "zpopup";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          popOn: 'click',
          // No I18N
          popoverId: null,
          content: null,
          mouseLeaveTime: 1500,
          // No I18N
          appendTo: null,
          isContentHTMLEncoded: false,
          isTitleHTMLEncoded: false,
          type: 'modeless',
          // No I18N
          title: '',
          // No I18N
          displayType: 'callout',
          // No I18N
          position: 'auto',
          // No I18N
          closeButton: false,
          closeOnBodyClick: true,
          closeOnEsc: true,
          closeOnScroll: false,
          positionAlterable: true,
          removeOnClose: false,
          detachable: false,
          height: null,
          width: null,
          closeSVGIconId: null,
          closeIconClass: null,
          progressIndicatorIconClass: null,
          progressIndicatorSVGIconId: null,
          wrapAroundKeyboardNavigation: false
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          closeIconClassName: null,
          progressIndicatorIconClassName: null,
          innerHTML: null,
          margin: null,
          offset: null,
          delay: null,
          animation: null,
          messages: {
            close: 'Close' // No I18N

          }
        };
      }
    }]);

    return ZPopup;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZPopup', ZPopup);
  /* $Id$ */

  var ZMenubar =
  /*#__PURE__*/
  function (_ZC$CoreComponent20) {
    _inherits(ZMenubar, _ZC$CoreComponent20);

    function ZMenubar() {
      _classCallCheck(this, ZMenubar);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZMenubar).apply(this, arguments));
    }

    _createClass(ZMenubar, [{
      key: "_create",
      value: function _create() {
        this._openedMenu = undefined;

        this._construct();

        this._bindEvents();
      }
    }, {
      key: "_construct",
      value: function _construct() {
        var _bar = $("ul:first", this.element); //No I18N


        _bar = _bar.length ? _bar : this.element;

        _bar.addClass("zmenubar"); //No I18N


        this._bar = _bar;
        this._menus = _bar.children();
        var base = this;

        this._menus.each(function (index, menu) {
          base._buildMenu($(menu), index);
        });

        _bar.show();
      }
    }, {
      key: "_handleHover",
      value: function _handleHover(targetLI, forceOpen) {
        var menuId = targetLI.data("menuId"); //No I18N

        var _openedMenu = this._openedMenu;

        if (menuId && _openedMenu && _openedMenu !== menuId || forceOpen) {
          var menuEle = $("#" + _openedMenu); //No I18N

          if (menuEle.data("zmenu")) {
            //No I18N
            menuEle.zmenu("hide"); //No I18N
          }

          this._handleOpen(targetLI, null, menuId);
        }
      }
    }, {
      key: "openMenu",
      value: function openMenu(targetLI) {
        this._handleHover(targetLI, true);
      }
    }, {
      key: "_handleOpen",
      value: function _handleOpen(targetLI, openOn, menuId) {
        menuId = menuId || targetLI.data("menuId"); //No I18N

        if (menuId) {
          var menuEle = $("#" + menuId); //No I18N

          if (!menuEle.data("zmenu")) {
            //No I18N
            menuEle.zmenu();
          }

          var baseObj = this,
              keyCode = ZC.keyCode;
          this._subMenuOpened = false;

          if (!menuEle.data("isEventRegistered")) {
            //No I18N
            menuEle.data("isEventRegistered", true); //No I18N

            menuEle.off("zmenushow.zm zmenuhide.zm keydown.zm").on("zmenushow.zm", function (eventObj) {
              //No I18N
              baseObj._openedMenu = menuId;
              $(eventObj.detail.forElement).addClass("is-selected on-hover"); //No I18N
            }).on("zmenuhide.zm", function (eventObj) {
              //No I18N
              $(eventObj.detail.forElement).removeClass("is-selected on-hover"); //No I18N

              baseObj._openedMenu = undefined;
            }).on("zmenuitemhover.zm", function (eventObj) {
              //No I18N
              baseObj._subMenuOpened = eventObj.detail.menuId;
            }).on("keydown.zm", function (eventObj) {
              //No I18N
              if (!baseObj._subMenuOpened) {
                var currentKey = eventObj.keyCode,
                    isLeft = currentKey === keyCode.LEFT;

                if (isLeft || currentKey === keyCode.RIGHT) {
                  var nextTargetLI = targetLI[isLeft ? "prev" : "next"](); //No I18N

                  if (!nextTargetLI.length) {
                    nextTargetLI = baseObj._bar.children(':' + (isLeft ? "last" : "first")); //No I18N
                  }

                  if (nextTargetLI.length) {
                    baseObj._handleHover(nextTargetLI);
                  }
                }
              }
            });
          }

          menuEle.zmenu("show", {
            //No I18N
            forElement: targetLI
          });
        }
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        var baseObj = this;
        var options = this._opts;
        var openOn = options.openOn === "hover" ? "hover" : "click"; //No I18N

        this._bar.on(openOn, function (eventObj) {
          baseObj._handleOpen($(eventObj.target).closest("li"), openOn);
        }).on("mouseover", function (eventObj) {
          //No I18N
          baseObj._handleHover($(eventObj.target).closest("li"));
        });
        /*ZC.$document.on("keydown."+this.widgetName, function(e){ //No I18N
        	//baseObj._keyPressed(e);
        });*/

      }
    }, {
      key: "_buildMenu",
      value: function _buildMenu(menu, index) {
        menu.addClass('zmenubar__item'); //No I18N

        if (window.ZShortCut) {
          ZShortCut.register(menu);
        }

        var data = ZC._getOpts(menu);

        data.label = data.label || menu.text();
        data.index = index;

        if (!data.iconClassName) {
          menu.append("<i class='zmenubar__icon " + data.iconClassName + "'></i>"); //No I18N
        }

        menu.append("<span class='zmenubar__text'>" + data.label + "</span>"); //No I18N

        var menuId = data.menuId;

        if (menuId) {
          var menuLinkEle = $("a", menu); //No I18N

          if (menuLinkEle.length) {
            var menuLinkHref = menuLinkEle.attr("href"); //No I18N

            if (menuLinkHref.indexOf("#") != -1) {
              //No I18N
              var grp = menuLinkHref.split("#"); //No I18N

              menuId = grp[grp.length - 1];
            }

            menuLinkEle.click(function (eventObj) {
              eventObj.preventDefault();
            });
          }

          if (menuId) {
            menu.data("menuId", menuId); //No I18N
          }
        }
      }
    }, {
      key: "_getMenuAt",
      value: function _getMenuAt(index, includeHidden) {
        var menus = !includeHidden ? this._menus : this._bar.children();

        if (index >= menus.length) {
          return [];
        }

        index = !index || index < 0 ? 0 : index;
        return $(menus[index]);
      }
    }, {
      key: "hideMenu",
      value: function hideMenu(index) {
        this._hideMenu(menu);
      }
    }, {
      key: "showMenu",
      value: function showMenu(index) {
        this._hideMenu(menu, true);
      }
    }, {
      key: "_hideMenu",
      value: function _hideMenu(menu, show) {
        var menu = $(this._getMenuAt(index, true));

        if (menu.length && this._menus.length > 1 && show) {
          if (this._isDisabled($(this._bar))) {
            return;
          }

          var option = ZC._getOpts(menu);

          var allowed = this._trigger(show ? 'beforeunhide' : 'beforehide', menu); //No I18N


          if (allowed) {
            menu[show ? "show" : "hide"](); //No I18N

            this._trigger(show ? 'unhide' : 'hide', menu); //No I18N

          }
        }
      }
    }, {
      key: "_handleDisable",
      value: function _handleDisable(enable) {
        var allowed = this._trigger(enable ? 'beforeenable' : 'beforedisable'); //No I18N


        if (allowed) {
          this._disable(!enable, this._menus);

          this._disable(!enable, this._bar);

          this._trigger(enable ? 'enable' : 'disable'); //No I18N

        }
      }
    }, {
      key: "_isDisabled",
      value: function _isDisabled(menu) {
        return menu.attr("disabled") ? true : false; //No I18N
      }
    }, {
      key: "disable",
      value: function disable(enable) {
        this._handleDisable(false);
      }
    }, {
      key: "enable",
      value: function enable() {
        this._handleDisable(true);
      }
    }, {
      key: "_trigger",
      value: function _trigger(event, menu) {
        return this._dispatchEvent(event, event, {
          menu: $(menu || this.element)
        });
      }
      /*_getSelectedMenuIndex(menu) {
      	return this.getData(menu).index;	
      }
      _keyPressed(ev){
      	if(!this._openedMenu){
      		return;
      	}
      	ev.stopPropagation();
      	ev.preventDefault();
      	var maxLen = this._menus.length;
      	var currentSelectedMenuIndex = this._getSelectedMenuIndex($(this._openedMenu));
      	var selectedMenu = currentSelectedMenuIndex;
      	var base = this;
      	var keyCode = ZC.keyCode;
      	switch(ev.keyCode){
      		case keyCode.RIGHT:
      				selectedMenu++;
      			break;
      		case keyCode.LEFT:
      				selectedMenu--;
      			break;
      		case keyCode.HOME:
      				selectedMenu = 0;
      			break;
      		case keyCode.END:
      				selectedMenu = maxLen-1;
      			break;
      	}
      	if(selectedMenu < 0){
      		selectedMenu = maxLen - 1;
      	}else if(selectedMenu >= maxLen){
      		selectedMenu = 0;
      	}
      	if(currentSelectedMenuIndex != selectedMenu) {
      		var menu = this._menus[selectedMenu];
      		$(menu).trigger("click");	//No I18N
      	}
      }*/

    }, {
      key: "name",
      get: function get() {
        return "zmenubar";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          openOn: "click" //No I18N

        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['mouseover', 'mouseout', 'click', 'beforehide', 'hide', 'beforeunhide', 'unhide', 'beforedisable', 'disable', 'beforeenable', 'enable', 'show']; // No I18N
      }
    }]);

    return ZMenubar;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZMenubar', ZMenubar);

  var ZColorBase =
  /*#__PURE__*/
  function (_ZC$CoreComponent21) {
    _inherits(ZColorBase, _ZC$CoreComponent21);

    function ZColorBase() {
      _classCallCheck(this, ZColorBase);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZColorBase).apply(this, arguments));
    }

    _createClass(ZColorBase, [{
      key: "_init",
      value: function _init(element, options) {
        this._fromInit = true;
        this._id = this._getID();
        this._namespace = '.zcolorbase'; // No I18N

        options.value = options.value || element[0].value;

        this._setInitial();

        this._fromInit = false;
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender() {
        var data = this._data;
        var options = this._opts;

        if (!data.rendered || this._domChanged) {
          var width = options.width || !this._useParent && this.element[0].style.width;

          if (width) {
            this.container[0].style.width = isNaN(width) ? width : width + 'px'; // No I18N
          }
        }

        this._storeRef(data, options);

        this._setClassName(data, options);

        this._updateElementValue(data, options);

        if (this._reopen) {
          this._open();

          this._reopen = false;
        }
      }
    }, {
      key: "_preRender",
      value: function _preRender() {
        this._setRenderData(this._data, this._opts, this.element);

        return this._data;
      }
    }, {
      key: "_setRenderData",
      value: function _setRenderData(data, options, element) {
        var selectedInstance = this._selectedInstance;
        data.opened = this._opened;
        data.nofill = !options.icon && this._noFill;
        data.color = selectedInstance.getColor();
        var attrs = data.attrs = data.attrs || {};
        attrs['aria-label'] = this._getI18NText('aria-label').replace(/#value#/g, selectedInstance.getColor('hexa')); // No I18N

        if (!data.rendered || this._domChanged) {
          var colorMode = data.colorMode = options.colorModel;

          if (!ZC.ColorUtil.REGEX.colorMode.test(colorMode)) {
            data.colorModel = this._getClrInstance(options.value).format;
            options.colorModel = 'auto'; // No I18N
          }

          data.alwaysSetAttrs = true;
          data.pickerId = options.pickerId;
          data.disabled = options.disabled || element[0].disabled;
          attrs.tabindex = !data.disabled && (options.tabIndex || element[0].tabIndex);
          data.rtl = options.rtl;
          data.stroke = options.appliedFor === 'stroke'; // No I18N

          data.icon = data.arrow = data.previewStyleAttr = false; // Valid for icon

          if (options.icon) {
            ZC._getIconInfo(options.iconClassName || options.iconClass, options.SVGIconId, null, null, data.icon = {}); // No I18N

          }

          if (!this.isCE) {
            // let style = element
            //     .attr('style')// No I18N
            //     .replace(/(?<=;|^)(\s)*(width|height|display)(\s)*:(\s)*[^;]*;?/g, ''); // No I18N
            // attrs.style = style;
            attrs.title = element.attr('title'); // No I18N
          } // Arrow Data


          if (options.arrowIcon) {
            data.arrow = {
              disabled: data.disabled,
              rtl: data.rtl,
              isCE: this.isCE
            };

            this._setArrowData(data, options);
          }
        } // Valid for stroke


        if (data.stroke || data.icon) {
          data.previewStyleAttr = this._getStyle({
            'border-color': data.color,
            // No I18N
            'border-style': options.previewBorderStyle || 'solid',
            // No I18N
            'border-width': options.previewBorderWidth || (data.icon ? '0px 0px 2px 0px' : '3px') // No I18N

          });
        }

        this._setTogglerData(attrs, options);
      }
    }, {
      key: "_setArrowData",
      value: function _setArrowData(data, options) {
        var CLASSES = this._CLASSES;

        ZC._getIconInfo(options.arrowIconClassName || options.arrowIconClass, options.arrowSVGIconId, 'zc__svg--downarrow ' + CLASSES.ARROWSVGICON, (CLASSES.ICON || '') + ' ' + (CLASSES.ARROW || ''), data.arrow); // No I18N

      }
    }, {
      key: "_setTogglerData",
      value: function _setTogglerData(attrs, options) {
        Object.assign(attrs, {
          'aria-owns': options.pickerId,
          // No I18N
          'aria-haspopup': true,
          // No I18N
          'aria-expanded': this._opened // No I18N

        });
      }
    }, {
      key: "_setClassName",
      value: function _setClassName(data, options) {
        var className = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
        // No I18N
        var CLASSES = this._CLASSES;

        var addClass = function addClass(classToAdd) {
          if (classToAdd) {
            className += ' ' + classToAdd; // No I18N
          }
        };

        addClass(CLASSES.CONTAINER);
        addClass(options.zclassName || options.className);

        if (this._opened) {
          addClass(CLASSES.ACTIVE);
        }

        if (data.disabled) {
          addClass('is-disabled'); // No I18N
        }

        if (data.rtl) {
          addClass('zh-rtl'); // No I18N
        }

        data.className = className;
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        this._addEvents({
          focus: 'focusin',
          // No I18N
          blur: 'focusout',
          // No I18N
          click: 'click' // No I18N

        }, this.container);

        this._addEvents({
          toggleBtnClick: 'mousedown',
          // No I18N
          toggleBtnKeydown: 'keydown' // No I18N

        }, this._toggler);
      }
    }, {
      key: "_toggleBtnClickHandler",
      value: function _toggleBtnClickHandler(orgEvent) {
        if (!orgEvent.button) {
          this._togglePicker(orgEvent);
        }
      }
    }, {
      key: "_toggleBtnKeydownHandler",
      value: function _toggleBtnKeydownHandler(orgEvent) {
        var code = orgEvent.keyCode,
            keyCodes = ZC.keyCode;

        if (code === keyCodes.ENTER || code === keyCodes.SPACE || code === keyCodes.DOWN && this._data.arrow) {
          this._togglePicker(orgEvent);
        }
      }
    }, {
      key: "_focusHandler",
      value: function _focusHandler(orgEvent) {
        clearTimeout(this._blurTimer);

        if (!this._focussed) {
          this._trigger('focus', orgEvent); // No I18N

        }

        this._focussed = true;
      }
    }, {
      key: "_blurHandler",
      value: function _blurHandler(orgEvent) {
        var _this143 = this;

        clearTimeout(this._blurTimer);
        this._blurTimer = setTimeout(function () {
          _this143._focussed = false;

          _this143._trigger('blur', orgEvent); // No I18N

        });
      }
    }, {
      key: "_clickHandler",
      value: function _clickHandler(orgEvent) {
        if (!this._opts.disabled) {
          this._trigger('click', orgEvent); // No I18N

        }
      }
    }, {
      key: "_storeRef",
      value: function _storeRef(data, options) {
        if (!data.rendered || this._domChanged) {
          this._previewBox = false;
          var CLASSES = this._CLASSES,
              container = this.container;
          var previewBox = container.find('.' + CLASSES.PREVIEW); // No I18N

          if (previewBox.length) {
            this._previewBox = previewBox;
          }

          this._toggler = container;
        }
      }
    }, {
      key: "_setInitial",
      value: function _setInitial() {
        var options = this._opts;

        var colorInstance = this._getClrInstance(options.value);

        if (options.value !== 'none' && options.value !== 'transparent' && !colorInstance.isValid()) {
          // No I18N
          options.value = this._DEFAULTS.value;
        }

        this._setValue(options.value);
      }
    }, {
      key: "_getClrInstance",
      value: function _getClrInstance(color) {
        return ZC.ColorUtil.getColorInstance(color);
      }
    }, {
      key: "_setPickerAttributes",
      value: function _setPickerAttributes(orgEvent) {
        var options = this._opts;
        var data = this._data;
        var currentField = this._currentClrField;
        var pickerOptions = data.picker;
        var pickerComp = 'colorpicker'; // No I18N

        var createMethod = 'createColorPicker'; // No I18N

        if (options.pickerType === 'advanced') {
          // No I18N
          pickerComp = 'advancedcolorpicker'; // No I18N

          createMethod = 'createAdvancedColorPicker'; // No I18N
        }

        if (!pickerOptions) {
          var pickerId = options.pickerId || 'picker-' + this._id; // No I18N

          pickerOptions = data.picker = _objectSpread({}, {
            noColorButtonLabel: this._getI18NText(data.stroke ? 'noStroke' : 'noColor'),
            // No I18N
            forElement: this._opts.forElement || this.container
          }, {}, options.pickerOptions || {}, {}, {
            valueColorModel: options.colorModel,
            type: 'popup',
            // No I18N
            rtl: options.rtl,
            locale: options.locale,
            isCE: options.isCE,
            id: pickerId,
            ctype: pickerComp,
            beforedestroy: this._pickerDestroyHandler.bind(this)
          });

          this._toggler.attr('aria-owns', pickerId); // No I18N

        }

        var picker = this._picker = $('#' + pickerOptions.id); // No I18Ns

        pickerOptions.value = options.value;

        if (picker && picker.length) {
          var componentName = this._getPickerName();

          if (componentName) {
            var pickerInstance = ZC[componentName](picker);

            if (!this._opened) {
              pickerInstance.close(orgEvent);
            }

            if (pickerComp === componentName) {
              if (options.pickerId) {
                if (options.resetPickerOptions) {
                  pickerOptions = $.extend(true, {}, pickerInstance._DEFAULTS, pickerOptions);
                }

                if (componentName === 'colorpicker') {
                  // No I18N
                  var advancedPickerOptions = pickerOptions.advancedPickerOptions = pickerOptions.advancedPickerOptions || {};
                  advancedPickerOptions.currentColorField = currentField;
                } else {
                  pickerOptions.currentColorField = currentField;
                }

                pickerInstance.setAttributes(pickerOptions);
              } else if (this._updateAdvPicker) {
                pickerInstance.setAttributes(pickerOptions);
                this._updateAdvPicker = false;
              }

              return;
            }

            this._destroyPicker();
          }
        }

        this._picker = picker = $(ZC[createMethod](pickerOptions));
        pickerOptions.instance = ZC[pickerComp](picker);
      }
    }, {
      key: "_pickerDestroyHandler",
      value: function _pickerDestroyHandler() {
        this._picker = this._opened = false;

        this._updateUI();
      }
    }, {
      key: "_destroyPicker",
      value: function _destroyPicker() {
        if (this._picker) {
          var picker = this._picker;

          this._callPickerMethod('destroy'); // No I18N


          if (this.isCE) {
            picker.remove();
          }
        }
      }
    }, {
      key: "_bindPickerEvents",
      value: function _bindPickerEvents() {
        var _this144 = this;

        var picker = this._picker;
        var pickerNamespace = 'z' + this._data.picker.ctype; // No I18N

        var prefix = this.isCE ? 'z' : pickerNamespace; // No I18N

        var namespace = '.' + this.name + '.' + pickerNamespace; // No I18N

        picker.off(namespace);
        ['select', // No I18N
        'pick', // No I18N
        'close', // No I18N
        'beforeClose', // No I18N
        'open', // No I18N
        'beforeOpen', // No I18N
        'colorPanMouseOver', // No I18N
        'colorPanMouseOut', // No I18N
        'colorPanClick', // No I18N
        'focus'] // No I18N
        .forEach(function (eventName) {
          picker.on(prefix + eventName.toLowerCase() + namespace, _this144._pickerCallback.bind(_this144, _this144['_' + eventName + 'Handler'])); // No I18N
        });
      }
    }, {
      key: "_pickerCallback",
      value: function _pickerCallback(callback, orgEvent) {
        var data = orgEvent.detail;
        orgEvent = orgEvent.originalEvent;

        if (this.isCE) {
          data = orgEvent.detail;
          orgEvent = orgEvent.originalEvent;
        }

        callback.call(this, orgEvent, data);
      }
    }, {
      key: "_colorPanMouseOverHandler",
      value: function _colorPanMouseOverHandler(orgEvent, data) {
        this._trigger('colorpanmouseover', orgEvent, data); // No I18N

      }
    }, {
      key: "_colorPanMouseOutHandler",
      value: function _colorPanMouseOutHandler(orgEvent, data) {
        this._trigger('colorpanmouseout', orgEvent, data); // No I18N

      }
    }, {
      key: "_colorPanClickHandler",
      value: function _colorPanClickHandler(orgEvent, data) {
        this._trigger('colorpanclick', orgEvent, data); // No I18N

      }
    }, {
      key: "_openHandler",
      value: function _openHandler(orgEvent, data) {
        this._opened = true;

        this._updateUI();

        this._trigger('pickeropen', orgEvent, data); // No I18N

      }
    }, {
      key: "_beforeOpenHandler",
      value: function _beforeOpenHandler() {
        this._callPickerMethod('setValue', this._noFill ? 'transparent' : this.getValue()); // No I18N

      }
    }, {
      key: "_closeHandler",
      value: function _closeHandler(orgEvent, data) {
        this._opened = false;
        this._currentClrField = data.options.currentColorField;

        this._updateUI();

        if (!orgEvent || orgEvent.currentTarget === document) {
          this._blurHandler(orgEvent);
        } else {
          this.setFocus(orgEvent);
        }

        this._removeEvents('', this._picker); // No I18N


        this._trigger('pickerclose', orgEvent, data); // No I18N

      }
    }, {
      key: "_beforeCloseHandler",
      value: function _beforeCloseHandler(orgEvent, data) {
        return this._trigger('beforepickerclose', orgEvent, data); // No I18N
      }
    }, {
      key: "_open",
      value: function _open(orgEvent) {
        if (this._trigger('beforepickeropen', orgEvent)) {
          // No I18N
          this._setPickerAttributes(orgEvent);

          this._bindPickerEvents();

          this._callPickerMethod('open', undefined, orgEvent); // No I18N

        }
      }
    }, {
      key: "_close",
      value: function _close(orgEvent) {
        this._opened && this._callPickerMethod('close', orgEvent); // No I18N
      }
    }, {
      key: "_selectHandler",
      value: function _selectHandler(orgEvent, data) {
        if (this._opened) {
          if (data.fromUI) {
            this._trigger('select', orgEvent, data); // No I18N

          }
        }
      }
    }, {
      key: "_pickHandler",
      value: function _pickHandler(orgEvent, data) {
        if (this._opened) {
          if (data.fromUI) {
            this._setValue(data.rgb, orgEvent, data, false);

            this._trigger('pick', orgEvent, data); // No I18N

          }
        }
      }
    }, {
      key: "_setValue",
      value: function _setValue(color, orgEvent, data) {
        var updatePicker = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var isNoFill = color === 'none' || color === 'transparent'; // No I18N

        var colorInstance = this._getClrInstance(isNoFill ? 'transparent' : color); // No I18N


        if (colorInstance.isValid()) {
          var prevColor = this._selectedInstance && this._selectedInstance.getColor();

          this._selectedInstance = colorInstance;
          this._noFill = data && data.noColorButtonClick || isNoFill;

          this._updateUI();

          var currentColor = colorInstance.getColor();

          if (prevColor !== currentColor) {
            if (this._opened && updatePicker) {
              this._callPickerMethod('setValue', currentColor); // No I18N

            }

            this._trigger('change', orgEvent, data); // No I18N

          }
        }
      }
    }, {
      key: "_updateElementValue",
      value: function _updateElementValue(data, options) {
        options.value = this._noFill ? 'transparent' : this._selectedInstance.getColor(data.colorMode, undefined, this._opts.colorModel === 'auto'); // No I18N
      }
    }, {
      key: "_trigger",
      value: function _trigger(customEvent, orgEvent, data) {
        if (!this._fromInit) {
          var selectedInstance = this._selectedInstance;
          var picker = this._picker;
          data = data || {};
          data.value = data.color = this.getValue();
          data.rgb = selectedInstance.getColor();
          data.opacity = selectedInstance.getAlpha();
          data.colorData = selectedInstance.getObject(this._data.colorMode);
          data.picker = picker && picker[0];
          orgEvent = orgEvent && orgEvent.originalEvent ? orgEvent.originalEvent : undefined;
          return this._dispatchEvent(customEvent, orgEvent, data, undefined, !!orgEvent);
        }

        return true;
      }
    }, {
      key: "_togglePicker",
      value: function _togglePicker(orgEvent) {
        if (!this._opts.disabled) {
          if (this._opened) {
            (!orgEvent || orgEvent.type !== 'keydown') && this._close(orgEvent); // No I18N
          } else {
            this._open(orgEvent);
          }
        }
      }
    }, {
      key: "_callPickerMethod",
      value: function _callPickerMethod(methodName, arg1, arg2) {
        ZC[this._getPickerName()](this._picker)[methodName](arg1, arg2);
      }
    }, {
      key: "_getPickerName",
      value: function _getPickerName() {
        var pickerData = this._picker.data();

        return pickerData.zcolorpicker ? 'colorpicker' : pickerData.zadvancedcolorpicker ? 'advancedcolorpicker' : undefined; // No I18N
      }
    }, {
      key: "_updateUI",
      value: function _updateUI() {
        if (this._data.rendered && !this._domChanged) {
          this._render();
        }
      }
    }, {
      key: "_disable",
      value: function _disable(value) {
        this._domChanged = true;

        _get(_getPrototypeOf(ZColorBase.prototype), "_disable", this).call(this, value);

        this.closePicker();
      }
    }, {
      key: "_setAdvAttribute",
      value: function _setAdvAttribute(optionName, value) {
        var options = this._opts;

        if (/^(pickerId|pickerType|pickerOptions|appliedFor|rtl|locale|forElement|colorModel)$/.test(optionName)) {
          options[optionName] = value;
          this._reopen = this._opened;
          this._domChanged = this._updateAdvPicker = true;

          if (optionName === 'pickerId') {
            // No I18N
            this.closePicker();
          }

          this._data.picker = false;
        } else if (/^(icon|iconClassName|iconClass|SVGIconId|arrowIconClassName|arrowIconClass|arrowSVGIconId|previewBorderWidth|previewBorderStyle|tabIndex|width)$/.test(optionName)) {
          options[optionName] = value;
          this._domChanged = true;
        }
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        var response;
        this._addedByComponent = true;

        if (optionName === 'value') {
          // No I18N
          this._domChanged = true;
          this.setValue(value);
        } else {
          response = this._setAdvAttribute(optionName, value);
        }

        this._addedByComponent = false;
        return response;
      }
    }, {
      key: "setFocus",
      value: function setFocus(orgEvent) {
        if (this._trigger('beforefocus', orgEvent)) {
          // No I18N
          this._toggler.focus();
        }
      }
    }, {
      key: "openPicker",
      value: function openPicker(orgEvent) {
        this._open(orgEvent);
      }
    }, {
      key: "closePicker",
      value: function closePicker(orgEvent) {
        this._close(orgEvent);
      }
    }, {
      key: "getValue",
      value: function getValue() {
        return this._opts.value;
      }
    }, {
      key: "setValue",
      value: function setValue(color, orgEvent) {
        this._setValue(color, orgEvent);
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        this._destroyPicker();

        clearTimeout(this._focusTimer);
        clearTimeout(this._blurTimer);
      }
    }, {
      key: "name",
      get: function get() {
        return "zcolorbase";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          value: 'rgba(0,0,0,1)',
          // No I18N
          colorModel: 'auto',
          // No I18N
          pickerId: null,
          pickerType: 'basic',
          // No I18N
          forElement: null,
          disabled: false,
          // util options
          appliedFor: 'fill',
          // No I18N
          arrowIconClass: null,
          arrowSVGIconId: null,
          previewBorderStyle: null,
          previewBorderWidth: null,
          resetPickerOptions: false,
          icon: false,
          width: null,
          iconClass: null,
          SVGIconId: null,
          rtl: null,
          locale: null,
          tabIndex: null
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          iconClassName: null,
          arrowIconClassName: null,
          pickerOptions: {},
          labels: {
            noStroke: 'No Stroke',
            // No I18N
            noColor: 'No Fill',
            // No I18N
            'aria-label': 'Current selected color is #value#' // No I18N

          }
        };
      }
    }, {
      key: "CLASSES",
      get: function get() {
        return {
          CONTAINER: 'zcolorbase',
          // No I18N
          ACTIVE: 'is-active',
          // No I18N
          PREVIEW: 'zcolorbutton__preview',
          // No I18N
          ICON: 'zbutton__icon',
          // No I18N
          ARROW: 'zcolorfield__arrow' // No I18N

        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['change', // No I18N
        'select', // No I18N
        'pick', // No I18N
        'beforepickeropen', // No I18N
        'pickeropen', // No I18N
        'beforepickerclose', // No I18N
        'pickerclose', // No I18N
        'colorpanmouseover', // No I18N
        'colorpanmouseout', // No I18N
        'colorpanclick', // No I18N
        'beforefocus', // No I18N
        'focus', // No I18N
        'blur', // No I18N
        'click' // No I18N
        ];
      }
    }]);

    return ZColorBase;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZColorBase', ZColorBase);

  var ZColorChooser =
  /*#__PURE__*/
  function (_ZC$ZColorBase) {
    _inherits(ZColorChooser, _ZC$ZColorBase);

    function ZColorChooser() {
      _classCallCheck(this, ZColorChooser);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZColorChooser).apply(this, arguments));
    }

    _createClass(ZColorChooser, [{
      key: "_render",
      value: function _render() {
        this._useParent = true;

        this._preRender();

        this._postEachRender();

        this._data.rendered = true;
      }
    }, {
      key: "_storeRef",
      value: function _storeRef() {
        this._toggler = this.container = this.element;
      }
    }, {
      key: "name",
      get: function get() {
        return "zcolorchooser";
      }
    }, {
      key: "CLASSES",
      get: function get() {
        return {
          CONTAINER: 'zcolorchooser',
          // No I18N
          ACTIVE: 'is-selected' // No I18N

        };
      }
    }]);

    return ZColorChooser;
  }(ZC.ZColorBase);

  ZC.registerComponent('ZColorChooser', ZC.ZColorBase, ZColorChooser);

  var ZProgressBar =
  /*#__PURE__*/
  function (_ZC$CoreComponent22) {
    _inherits(ZProgressBar, _ZC$CoreComponent22);

    function ZProgressBar() {
      _classCallCheck(this, ZProgressBar);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZProgressBar).apply(this, arguments));
    }

    _createClass(ZProgressBar, [{
      key: "_init",
      value: function _init() {
        var opts = this._opts; // No I18N

        if (!opts.locale) {
          this._opts.locale = ZC.locale;
        }

        this._eventTriggered = false;

        if (opts.mode === 'indeterminate') {
          // No I18N
          this._data.progressModifier = 'zeffects--move'; // No I18N
        }

        this._data.trackClass = opts.trackClassName + ' ' + opts.trackClass; // No I18N

        this._data.progressClass = opts.progressClassName + ' ' + opts.progressClass; // No I18N

        this._setBarStyles();

        if (!ZC.isEmpty(opts.statusMessage)) {
          this._updateStatusMessageData();
        }
      }
    }, {
      key: "_setBarStyles",
      value: function _setBarStyles() {
        // reused in setAttribute method
        var opts = this._opts;
        this._data.progressStyle = 'background:' + opts.progressColor; // No I18N

        this._data.trackStyle = this._getStyle({
          background: opts.trackColor,
          // No I18N
          border: opts.trackBorder,
          // No I18N
          'border-color': opts.trackBorderColor // No I18N

        });
      }
    }, {
      key: "_postRender",
      value: function _postRender(ele, opts) {
        ele.attr({
          role: 'progressbar',
          // No I18N
          'aria-valuemin': 0,
          // No I18N
          'aria-valuemax': 100 // No I18N

        });
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender(ele) {
        var opts = this._opts,
            data = this._data; // produces prblm in setAttribute case.

        data.className = data.className.replace(/zprogress--group|zprogress--indeterminate|zprogress__labeltop|zprogress__labelleft|zprogress__labelright|zprogress__labelbottom|zprogress__labelinside|zprogress__labelcenter|/g, ''); // No I18N

        var cls = ' zprogress--group '; // No I18N

        if (opts.mode === 'indeterminate') {
          // No I18N
          cls += 'zprogress--indeterminate '; // No I18N
        }

        data.className += cls + (opts.labelModifier || ''); // No I18N

        this._progressValue = ele.find('.zprogress__bar'); // No I18N

        this._progressValue.css('width', opts.mode === 'indeterminate' ? '' : opts.value + '%'); // No I18N


        if (!ZC.isEmpty(opts.statusMessage) && opts.statusMessage.displayType === 'callout' && (!data.rendered || data.isStatusModified)) {
          // No I18N
          data.isStatusModified = null;

          this._setCalloutPosition(); // callout position has to be set based on the rendered callout element's width & height. So, it is handled in postRender.

        }
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this._setValue(value);
      }
    }, {
      key: "getValue",
      value: function getValue() {
        if (this._opts.mode !== 'indeterminate') {
          // No I18N
          return this._opts.value;
        }
      }
    }, {
      key: "_setValue",
      value: function _setValue(value) {
        var _this145 = this;

        var opts = this._opts;

        if (opts.mode !== 'indeterminate' && !isNaN(value)) {
          // No I18N
          value = parseInt(value);
          value > 100 && (value = 100);

          if (opts.value !== value) {
            this._opts.value = value;

            if (this._eventTriggered && value !== 100) {
              // taking reverse direction after 100 is reached.
              this._eventTriggered = false;
            }

            this._progressValue.css('width', value + '%').on(ZC._animationEnd, function () {
              // No I18N
              // updating the status message after the transition has been completed.
              if (!_this145._eventTriggered && _this145._lastValue !== _this145._opts.value) {
                // retaining the last value since transitionend event triggered twice for same width value.
                !ZC.isEmpty(opts.statusMessage) && _this145._updateStatusText();

                _this145._triggerEvent();
              }
            });
          }
        }
      }
    }, {
      key: "_triggerEvent",
      value: function _triggerEvent() {
        var val = this._opts.value,
            data = {
          indicator: this.container,
          value: val
        };
        this.element.attr('aria-valuenow', val); // No I18N

        this._dispatchEvent('change', {}, data); // No I18N


        if (val === 100) {
          this._eventTriggered = true;

          this._dispatchEvent('complete', {}, data); // No I18N

        }

        this._lastValue = val;
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        this.element.removeAttr('role aria-valuenow'); // No I18N
        // this._data = this._opts = Temporarily commenting this since we should find a efficient way to garbage collect objects;

        this._progressValue = this._messageElement = undefined;
      }
    }, {
      key: "_handleProgress",
      value: function _handleProgress(stop) {
        if (this._opts.mode === 'indeterminate') {
          // No I18N
          var modeCls = 'zprogress--indeterminate'; // No I18N

          this.element[stop ? 'removeClass' : 'addClass'](modeCls); // No I18N

          var cls = this._data.className;
          cls = stop ? cls.replace(modeCls, '') : cls + ' ' + modeCls; // No I18N

          this._data.className = cls;
        }
      }
    }, {
      key: "startProgress",
      value: function startProgress() {
        this._handleProgress();
      }
    }, {
      key: "stopProgress",
      value: function stopProgress() {
        this._handleProgress(true);
      }
    }, {
      key: "_updateStatusMessageData",
      value: function _updateStatusMessageData() {
        this._data.isMessageCallout = this._data.isMessageAdjacentTop = this._data.isMessageAdjacentBottom = this._data.isMessageInline = undefined;
        var messageProps = this._opts.statusMessage,
            cls = '',
            dType = messageProps.displayType && this._opts.mode !== 'indeterminate' ? messageProps.displayType : 'adjacent'; // No I18N

        this._data['isMessage' + dType[0].toUpperCase() + dType.slice(1)] = true; // No I18N

        if (!messageProps.position) {
          messageProps.position = dType === 'inline' ? 'center' : dType === 'adjacent' ? 'top' : 'bottom'; // No I18N
        }

        if (dType === 'adjacent') {
          // No I18N
          cls = 'zprogress__label' + (messageProps.position ? messageProps.position : 'top'); // No I18N

          this._data.isMessageAdjacentTop = messageProps.position === 'top' || messageProps.position === 'left'; // No I18N

          this._data.isMessageAdjacentBottom = messageProps.position === 'bottom' || messageProps.position === 'right'; // No I18N
        } else if (dType === 'inline') {
          // No I18N
          cls = 'zprogress__labelinside'; // No I18N

          this._data.inlineClass = messageProps.position === 'left' || messageProps.position === 'right' ? 'zh-align' + messageProps.position : ''; // No I18N

          this._data.inlineTextWidth = window.getComputedStyle(this.element[0]).width;
        } else {
          this._data.calloutClass = 'zh-' + (messageProps.position === 'bottom' ? 'top' : 'bottom'); // No I18N
        }

        this._data.text = messageProps.text.replace(/#value#/g, this._translateEToA(this._opts.value));
        this._opts.labelModifier = cls;
        this.element.attr('aria-valuetext', this._data.text); // No I18N
      }
    }, {
      key: "_setCalloutPosition",
      value: function _setCalloutPosition(renderNotNeeded) {
        var _this$_getStyle;

        var calloutElement = this.element.find('.ztooltip'),
            pointerElement = calloutElement.find('.ztooltip__pointer'),
            propName = this._opts.rtl ? 'right' : 'left',
            // No I18N
        // Revisit - Remove literals
        callout = _defineProperty({}, propName, "calc(50% - ".concat(pointerElement.width() / 2, "px)"));

        this._data.pointerStyle = this._getStyle(callout);
        this._data.calloutStyle = this._getStyle((_this$_getStyle = {
          top: (this._opts.statusMessage.position === 'top' ? -parseInt(this.element.height() + calloutElement.outerHeight(true)) : parseInt(this.element.height() + 5)) + 'px'
        }, _defineProperty(_this$_getStyle, propName, this._progressValue.width() - Math.ceil(calloutElement.outerWidth(true) / 2) + 'px'), _defineProperty(_this$_getStyle, '-webkit-transition', 'all 0.2s ease'), _defineProperty(_this$_getStyle, '-moz-transition', 'all 0.2s ease'), _defineProperty(_this$_getStyle, '-o-transition', 'all 0.2s ease'), _defineProperty(_this$_getStyle, '-ms-transition', 'all 0.2s ease'), _defineProperty(_this$_getStyle, "transition", 'all 0.2s ease'), _this$_getStyle));
        !renderNotNeeded && this._render();
      }
    }, {
      key: "_updateStatusText",
      value: function _updateStatusText() {
        var messageProps = this._opts.statusMessage;
        var formattedText = messageProps.text.replace(/#value#/g, this._translateEToA(this._opts.value));

        if (formattedText.trim() === '') {
          // No I18N
          return;
        }

        this._data.text = messageProps.isTextHTMLEncoded ? formattedText : ZC.encodeHTML(formattedText);

        this._render();

        if (messageProps.displayType === 'callout') {
          // No I18N
          this._setCalloutPosition();
        }

        this.element.attr('aria-valuetext', this._data.text); // No I18N
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        this._domChanged = true;
        var data = this._data;

        if (optionName === 'mode') {
          // No I18N
          if (!ZC.isEmpty(this._opts.statusMessage)) {
            this._opts.mode = value;

            this._updateStatusMessageData();
          }

          data.progressModifier = value === 'indeterminate' ? 'zeffects--move' : ''; // No I18N
        } else if (optionName === 'value') {
          // No I18N
          this._setValue(value);

          this._domChanged = false;
        } else if (optionName === 'progressColor' || optionName === 'trackColor' || optionName === 'trackBorder' || optionName === 'trackBorderColor') {
          // No I18N
          this._opts[optionName] = value;

          this._setBarStyles();
        } else if (optionName === 'trackClassName' || optionName === 'progressClassName') {
          // No I18N
          data[optionName.replace('Name', '')] = value; // No I18N
        } else if (optionName === 'rtl') {
          // No I18N
          if (!ZC.isEmpty(this._opts.statusMessage)) {
            this._opts.rtl = value;

            this._setCalloutPosition(true);
          }
        } else if (optionName === 'statusMessage') {
          // No I18N
          var opts = this._opts;
          opts[optionName] = value === null ? {} : value;

          if (_typeof(opts[optionName]) === 'object' && opts[optionName].text && opts[optionName].text.trim() === '') {
            // No I18N
            return;
          }

          if (value === null) {
            data.isMessageAdjacentTop = data.isMessageInline = data.isMessageAdjacentBottom = data.isMessageCallout = undefined;
          } else {
            this._updateStatusMessageData();
          }

          data.isStatusModified = true;
        }

        this._opts[optionName] = value;
      }
    }, {
      key: "name",
      get: function get() {
        return "zprogressbar";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          mode: 'determinate',
          // No I18N
          value: 0,
          locale: null,
          progressColor: '#4190F2',
          // No I18N
          progressClass: '',
          // No I18N
          trackColor: '#DBDBDB',
          // No I18N
          trackBorder: null,
          trackBorderColor: null,
          trackClass: '',
          // No I18N
          progressTooltipText: '#value#%',
          // No I18N
          trackTooltipText: '100 - #value#%',
          // No I18N
          innerHTML: null
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          progressClassName: '',
          // No I18N
          trackClassName: '',
          // No I18N
          statusMessage: {}
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['complete', 'change']; // No I18N
      }
    }]);

    return ZProgressBar;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZProgressBar', ZProgressBar);

  (function (ZC) {
    var template = ZC.zprogressbar.Templates;

    template.children = function (data) {
      return ZT.html(_templateObject211(), data.isMessageAdjacentTop && ZT.html(_templateObject212(), data.text), data.trackClass, data.trackStyle, data.isMessageInline && ZT.html(_templateObject213(), data.inlineClass || '', data.text), data.progressClass, data.progressModifier || '', data.progressStyle, data.isMessageInline && ZT.html(_templateObject214(), data.inlineClass || '', data.inlineTextWidth, data.text), data.isMessageAdjacentBottom && !data.showMessageInTop && ZT.html(_templateObject215(), data.text), data.isMessageCallout && ZT.html(_templateObject216(), data.calloutStyle, data.text, data.calloutClass || '', data.pointerStyle));
    };
  })(ZComponents);

  var ZProgressWheel =
  /*#__PURE__*/
  function (_ZC$CoreComponent23) {
    _inherits(ZProgressWheel, _ZC$CoreComponent23);

    function ZProgressWheel() {
      _classCallCheck(this, ZProgressWheel);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZProgressWheel).apply(this, arguments));
    }

    _createClass(ZProgressWheel, [{
      key: "_init",
      value: function _init() {
        var opts = this._opts; // No I18N

        this.element.attr({
          role: 'progressbar',
          // No I18N
          'aria-valuemin': 0,
          // No I18N
          'aria-valuemax': 100 // No I18N

        });

        if (!opts.locale) {
          this._opts.locale = ZC.locale;
        }

        this._data.animateClass = opts.mode === 'indeterminate' ? 'zeffects--rotate' : ''; // No I18N

        this._data.trackClass = opts.trackClassName + ' ' + opts.trackClass; // No I18N

        this._data.progressClass = opts.progressClassName + ' ' + opts.progressClass; // No I18N

        this._setWheelData();

        if (!ZC.isEmpty(opts.statusMessage)) {
          this._updateStatusMessageData();
        }
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender() {
        var opts = this._opts,
            data = this._data;
        data.className = data.className.replace(/zprogress--group|zprogress--indeterminate|zprogresscircular--labelcenter|zprogresscircular--labelleft|zprogresscircular--labelright|zprogresscircular--labelbottom|zprogresscircular--labeltop/g, ''); // No I18N

        var cls = ' zprogress--group'; // No I18N

        if (opts.mode === 'indeterminate') {
          // No I18N
          cls += ' zprogress--indeterminate'; // No I18N
        }

        this._data.className += cls + (opts.labelModifier ? ' ' + opts.labelModifier : ''); // No I18N
      }
    }, {
      key: "_setWheelData",
      value: function _setWheelData() {
        // setting circle element related data.
        var opts = this._opts,
            size = opts.size,
            isStr = isNaN(size),
            isMed = typeof size === 'string' && size === 'medium' ? this._MED_DATA[size] : false,
            // No I18N
        diameter = isStr ? isMed ? this._MED_DATA.size : this._SIZES[size] : parseInt(size),
            radius = diameter / 2,
            strokeWidth = isStr ? isMed ? this._MED_DATA.strokeWidth : this._STROKE_WIDTH[size] : opts.strokeWidth,
            circumference = 2 * (radius - parseInt(strokeWidth)) * (22 / 7);
        $.extend(true, this._data, {
          diameter: diameter,
          radius: radius,
          circumference: circumference,
          strokeWidth: strokeWidth,
          axis: radius - parseInt(strokeWidth),
          strokeOffset: opts.mode === 'indeterminate' ? this._calculateStrokeOffset(circumference) : opts.value ? circumference - opts.value * circumference / 100 : circumference // No I18N

        });

        this._setWheelStyles();
      }
    }, {
      key: "_calculateStrokeOffset",
      value: function _calculateStrokeOffset(circumference) {
        if (circumference) {
          // 25% of the circle.
          return circumference - parseFloat(circumference / 4);
        }
      }
    }, {
      key: "_setWheelStyles",
      value: function _setWheelStyles() {
        // reused in _setAttribute method
        var opts = this._opts;
        this._data.progressStyle = this._getStyle({
          stroke: opts.fillGradient || opts.progressColor // No I18N

        });
        this._data.trackStyle = this._getStyle({
          stroke: opts.trackGradient || opts.trackColor,
          // No I18N
          border: opts.trackBorder,
          // No I18N
          'border-color': opts.trackBorderColor // No I18N

        });
      }
    }, {
      key: "getValue",
      value: function getValue() {
        if (this._opts.mode !== 'indeterminate') {
          // No I18N
          return this._opts.value;
        }
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this._setValue(value);
      }
    }, {
      key: "_setValue",
      value: function _setValue(value, dontRender) {
        if (this.element.is(':hidden')) {
          // No I18N
          this.element.show();
        }

        if (isNaN(value)) {
          return;
        }

        var opts = this._opts,
            data = this._data;
        value = parseInt(value);

        if (value > 100) {
          value = 100;
        }

        this._opts.value = value;
        value = data.circumference - value * data.circumference / 100;
        value = value >= 0 ? value : 0;
        data.strokeOffset = value;

        if (!ZC.isEmpty(opts.statusMessage)) {
          this._updateStatusText(opts.statusMessage);
        } // updating tooltip text of circular progress indicators.


        value = this._opts.value;
        data.trackTooltip = opts.trackTooltipText.replace('100 - #value#', 100 - value).replace('#value#', value); // No I18N

        data.progressTooltip = opts.progressTooltipText.replace('#value#', value); // No I18N

        this._triggerEvent();

        !dontRender && this._render();
      }
    }, {
      key: "_triggerEvent",
      value: function _triggerEvent() {
        var val = this._opts.value,
            data = {
          indicator: this.element,
          value: val
        };
        this.element.attr('aria-valuenow', val); // No I18N

        this._dispatchEvent('change', {}, data); // No I18N


        if (val === 100) {
          this._dispatchEvent('complete', {}, data); // No I18N

        }
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        this.element.removeAttr('role aria-valuenow'); // No I18N
      }
    }, {
      key: "_handleProgress",
      value: function _handleProgress(stop) {
        if (this._opts.mode === 'indeterminate') {
          // No I18N
          var modeCls = 'zprogress--indeterminate'; // No I18N

          this.element[stop ? 'removeClass' : 'removeClass'](modeCls); // No I18N

          var cls = this._data.className;
          cls = stop ? cls.replace(modeCls, '') : cls + ' ' + modeCls; // No I18N

          this._data.className = cls;
        }
      }
    }, {
      key: "startProgress",
      value: function startProgress() {
        this._handleProgress();
      }
    }, {
      key: "stopProgress",
      value: function stopProgress() {
        this._handleProgress(true);
      }
    }, {
      key: "_updateStatusMessageData",
      value: function _updateStatusMessageData() {
        var pos = this._opts.statusMessage.position || 'center'; // No I18N
        // Revisit - Check whether it is necessary

        $.extend(true, this._data, {
          showMessageAtTop: pos === 'left' || pos === 'top',
          // No I18N
          showMessageAtBottom: pos === 'right' || pos === 'bottom',
          // No I18N
          showMessageAtCenter: pos === 'center' // No I18N

        });
        this._opts.labelModifier = 'zprogresscircular--label' + pos; // No I18N

        this._updateStatusText();
      }
    }, {
      key: "_updateStatusText",
      value: function _updateStatusText() {
        var messageProps = this._opts.statusMessage,
            formattedText = messageProps.text.replace(/#value#/g, this._opts.value);
        this._data.text = messageProps.isTextHTMLEncoded ? formattedText : ZC.encodeHTML(formattedText);
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        this._domChanged = true;
        var data = this._data;

        if (optionName === 'mode') {
          // No I18N
          var isIndeterminate = value === 'indeterminate'; // No I18N

          this._data.animateClass = isIndeterminate ? 'zeffects--rotate' : ''; // No I18N

          !isIndeterminate && this._setValue(this._opts.value, true); // true is passed to prevent render function from being executed there.
        } else if (optionName === 'value') {
          // No I18N
          this._setValue(value, true);
        } else if (['progressColor', 'trackColor', 'fillGradient', 'trackGradient', 'trackGradient', 'trackBorderColor'].indexOf(optionName) > -1) {
          // No I18N
          this._opts[optionName] = value;

          this._setWheelStyles();
        } else if (optionName === 'progressClassName' || optionName === 'trackClassName') {
          // No I18N
          this._data[optionName.replace('Name', '')] = value; // No I18N
        } else if (optionName === 'statusMessage' || optionName === 'size' || optionName === 'strokeWidth') {
          // No I18N
          this._opts[optionName] = value === null ? {} : value;

          if (optionName === 'statusMessage') {
            // No I18N
            // Revisit - Shorten name
            if (value === null) {
              data.showMessageAtTop = data.showMessageAtCenter = data.showMessageAtBottom = undefined;
            } else {
              this._updateStatusMessageData();
            }
          } else {
            this._setWheelData();
          }
        }

        this._opts[optionName] = value;
      }
    }, {
      key: "name",
      get: function get() {
        return "zprogresswheel";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          mode: 'determinate',
          // No I18N
          value: 0,
          progressColor: '#4190F2',
          // No I18N
          fillGradient: null,
          progressClass: '',
          // No I18N
          trackColor: '#DBDBDB',
          // No I18N
          trackBorder: null,
          trackBorderColor: null,
          locale: null,
          trackGradient: null,
          trackClass: '',
          // No I18N
          size: 'medium',
          // No I18N
          strokeWidth: '3px',
          // No I18N
          progressTooltipText: '#value#%',
          // No I18N
          trackTooltipText: '100 - #value#%',
          // No I18N
          innerHTML: null,
          width: 'auto' // No I18N

        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          progressClassName: '',
          // No I18N
          trackClassName: '',
          // No I18N
          statusMessage: {}
        };
      }
    }, {
      key: "_MED_DATA",
      get: function get() {
        return {
          size: 40,
          strokeWidth: '3px' // No I18N

        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['complete', 'change']; // No I18N
      }
    }, {
      key: "_SIZES",
      get: function get() {
        return {
          micro: 16,
          mini: 20,
          small: 24,
          medium: 40,
          large: 48,
          mega: 64
        };
      }
    }, {
      key: "_STROKE_WIDTH",
      get: function get() {
        return {
          micro: '2px',
          // No I18N
          mini: '2px',
          // No I18N
          small: '2px',
          // No I18N
          medium: '3px',
          // No I18N
          large: '3px',
          // No I18N
          mega: '4px' // No I18N

        };
      }
    }]);

    return ZProgressWheel;
  }(ZC.CoreComponent);

  ZC.registerComponent('ZProgressWheel', ZProgressWheel);

  (function (ZC) {
    var template = ZC.zprogresswheel.Templates;

    template.children = function (data) {
      return ZT.html(_templateObject217(), data.showMessageAtTop ? ZT.html(_templateObject218(), data.text) : '', data.showMessageAtCenter ? ZT.html(_templateObject219(), data.text) : '', data.animateClass, data.diameter, data.diameter, data.trackClass, data.radius, data.radius, data.axis, data.circumference, data.strokeWidth, data.trackStyle, data.trackTooltip, data.progressClass, data.radius, data.radius, data.axis, data.circumference, data.strokeOffset, data.strokeWidth, data.progressStyle, data.progressTooltip, data.showMessageAtBottom ? ZT.html(_templateObject220(), data.text) : '');
    };
  })(ZComponents);

  var ZDateField =
  /*#__PURE__*/
  function (_ZC$ZDateInput2) {
    _inherits(ZDateField, _ZC$ZDateInput2);

    function ZDateField() {
      _classCallCheck(this, ZDateField);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZDateField).apply(this, arguments));
    }

    _createClass(ZDateField, [{
      key: "_create",
      value: function _create() {
        _get(_getPrototypeOf(ZDateField.prototype), "_create", this).apply(this, arguments);
      }
    }, {
      key: "_getDateParts",
      value: function _getDateParts() {
        return {
          d: 'date',
          // No I18N
          M: 'month',
          // No I18N
          y: 'year' // No I18N

        }; // No I18N
      }
    }, {
      key: "_replaceText",
      value: function _replaceText(match) {
        return this._replaceDate(match);
      }
    }, {
      key: "_getRegEx",
      value: function _getRegEx() {
        return /dd{0,3}|MM{0,3}|yyyy|yy|"[^"]*"|'[^']*'/g;
      }
    }, {
      key: "_getMatch",
      value: function _getMatch(match) {
        var arr = ['ddd', 'dddd', 'z', 'zz', 'zzz']; // No I18N

        return arr.indexOf(match) > -1 ? match.replace('d', 'E').replace('z', 'f') : match; // No I18N
      }
    }, {
      key: "_replaceDate",
      value: function _replaceDate(match) {
        var result,
            viewDate = this._viewDate,
            value,
            monthModified = this._monthModified,
            dateModified = this._dateModified,
            yearModified = this._yearModified,
            isModified,
            isDate = ['d', 'dd', 'ddd', 'dddd'].indexOf(match) > -1; // No I18N

        if (['d', 'dd', 'M', 'MM'].indexOf(match) !== -1) {
          // No I18N
          viewDate = isDate ? viewDate.getDate() : viewDate.getMonth() + 1;
          result = (isDate ? dateModified : monthModified) ? match.length === 1 ? viewDate.toString() : (viewDate < 10 ? '0' : '') + viewDate : this._getPlaceholder(match); // No I18N
        } else if (['ddd', 'dddd', 'MMM', 'MMMM'].indexOf(match) !== -1) {
          // No I18N
          viewDate = isDate ? viewDate.getDay() : viewDate.getMonth();
          isModified = isDate ? dateModified && monthModified && yearModified : monthModified;
          value = match.indexOf('d') > -1 ? 'days' : 'months'; // No I18N

          result = isModified ? this._getI18NText(match.length === 3 ? "".concat(value, "Abbreviated") : value)[viewDate] : this._getPlaceholder(match);
        } else if (['yy', 'yyyy'].indexOf(match) !== -1) {
          // No I18N
          this._isYear2Digit = match === 'yy'; // No I18N

          viewDate = viewDate.getFullYear();
          result = yearModified ? this._appendZeros(match === 'yy' ? viewDate % 100 : viewDate, match.length) : this._getPlaceholder(match); // No I18N
        }

        return this._translateEToA(result);
      }
    }, {
      key: "_focusOutHandler",
      value: function _focusOutHandler(orgEvent) {
        var relTarget = $(orgEvent.relatedTarget);

        if (!this._hasPicker || !(this._hasPicker && relTarget.closest('.zdatetimepicker,.zdatetimepicker--group').length)) {
          _get(_getPrototypeOf(ZDateField.prototype), "_focusOutHandler", this).call(this, orgEvent);
        }
      }
    }, {
      key: "_appendZeros",
      value: function _appendZeros(number, chars) {
        var zeroes = ['', '0', '00', '000', '0000'],
            // No I18N
        last;
        number = number.toString();
        last = chars - number.length;
        return last ? zeroes[chars].substring(0, last) + number : number;
      }
    }, {
      key: "_init",
      value: function _init() {
        this._allowedChars = 'dMyz'; // No I18N

        !this._pickerMethods && (this._pickerMethods = {
          create: 'createDatePicker',
          // No I18N
          instance: 'datepicker' // No I18N

        });

        _get(_getPrototypeOf(ZDateField.prototype), "_init", this).apply(this, arguments);

        this._opts.calendarIcon && this._getCalendarIconProps();
      }
    }, {
      key: "_performValidations",
      value: function _performValidations() {
        var opts = this._opts,
            arr = ['date', 'month', 'year']; // No I18N

        if (opts.calendarIcon) {
          ['right', 'left'].indexOf(opts.calendarIconAlignment) === -1 && (opts.calendarIconAlignment = 'right'); // No I18N
        }

        _get(_getPrototypeOf(ZDateField.prototype), "_performValidations", this).call(this, arr.map(function (str) {
          return str + 'Step';
        }), arr); // No I18N

      }
    }, {
      key: "_validateFormat",
      value: function _validateFormat() {
        this._checkFormat(/h|H|m|t/g); // No I18N

      }
    }, {
      key: "_postRender",
      value: function _postRender() {
        _get(_getPrototypeOf(ZDateField.prototype), "_postRender", this).apply(this, arguments);

        this._opts.picker && this._createPicker();
      }
    }, {
      key: "_postEachRender",
      value: function _postEachRender(elem, data) {
        var modified = data.modifiedAttr;

        if (data.calendarIcon && (!modified || modified === 'calendarIcon')) {
          // No I18N
          this._updateCalendarIcon();
        }

        _get(_getPrototypeOf(ZDateField.prototype), "_postEachRender", this).apply(this, arguments);
      }
    }, {
      key: "_getCustomMatch",
      value: function _getCustomMatch(match) {
        return this._getDateMatch(match);
      }
    }, {
      key: "_getDateMatch",
      value: function _getDateMatch(match) {
        var placeholder = this._opts.placeholder;

        if (['d', 'dd', 'ddd', 'dddd'].indexOf(match) > -1) {
          // No I18N
          return placeholder[match.length > 2 ? 'weekDay' : 'date']; // No I18N
        } else if (['M', 'MM', 'MMM', 'MMMM'].indexOf(match) > -1) {
          // No I18N
          return placeholder.month;
        } else if (['yy', 'yyyy'].indexOf(match) > -1) {
          // No I18N
          return placeholder.year;
        }
      }
    }, {
      key: "_getDateValue",
      value: function _getDateValue() {
        return this._dateModified && this._monthModified && this._yearModified ? new Date(+this._viewDate) : undefined;
      }
    }, {
      key: "_modifyValue",
      value: function _modifyValue(newDate, character, offset, isValueComplete) {
        return this._modifyDate(newDate, character, offset, isValueComplete);
      }
    }, {
      key: "_getDateSegment",
      value: function _getDateSegment(value, part) {
        var parts = {
          y: 'FullYear',
          // No I18N
          M: 'Month',
          // No I18N
          d: 'Date' // No I18N

        };
        return value["get".concat(parts[part])]();
      }
    }, {
      key: "_checkValue",
      value: function _checkValue(min, max, minAdd, maxAdd, value) {
        if (value < min) {
          value += max + minAdd;
        } else if (value > max) {
          value %= max + maxAdd;
        }

        return value;
      }
    }, {
      key: "_changeDateValue",
      value: function _changeDateValue(newDate, condition, newValue) {
        if (condition) {
          newDate.setDate(1);
          newDate.setMonth(newValue);
        }
      }
    }, {
      key: "_modifyDate",
      value: function _modifyDate(newDate, character, offset, isValueComplete) {
        var _char4 = this._getDateParts()[character],
            part = '_' + _char4 + 'Modified',
            opts = this._opts,
            newValue = this._getDateSegment(newDate, character),
            checkValue = this._checkValue.bind(this);

        offset && (offset *= opts[_char4 + 'Step']);
        newValue = newValue + offset;

        if (character === 'y') {
          // No I18N
          newValue = checkValue(0, 9999, 0, 1, newValue);
          newValue === 0 && (newValue = 1);
          this._yearModified && newDate.setFullYear(newValue);
        } else if (character === 'M') {
          if (this[part]) {
            if (opts.incrementOnWrapAround && isValueComplete !== undefined) {
              newDate.setMonth(newValue);

              this._changeDateValue(newDate, newDate.getMonth() % 12 !== (newValue + 12) % 12, newValue);
            } else {
              newValue = checkValue(0, 11, 1, 1, newValue);
              var numberOfDays = new Date(newDate.getFullYear(), newValue + 1, 0).getDate();
              newDate.getDate() > numberOfDays && newDate.setDate(numberOfDays);
              newDate.setMonth(newValue);
            }
          } else {
            offset < 0 && newDate.setMonth(11);
          }
        } else if (character === 'd') {
          if (!opts.incrementOnWrapAround || !isValueComplete) {
            newValue = checkValue(1, this._getDaysInAMonth(newDate), -newValue, 0, newValue);
          }

          if (this[part]) {
            newDate.setDate(newValue);
          } else if (offset < 0) {
            newDate.setDate(31);
          }
        }

        return part;
      }
    }, {
      key: "_getDaysInAMonth",
      value: function _getDaysInAMonth(dateValue) {
        return new Date(dateValue.getFullYear(), dateValue.getMonth() + 1, 0).getDate();
      }
    }, {
      key: "_parseSegment",
      value: function _parseSegment(character, currentChar, newDate) {
        return this._parseDate(character, currentChar, newDate);
      }
    }, {
      key: "_getNewValue",
      value: function _getNewValue(newDate, currentChar, part, jumpOnComplete, maxLen) {
        var getValue = 'get' + (part === 'date' ? 'Date' : 'Month'); // No I18N

        var value = newDate[getValue]() + +(part === 'month'); // No I18N

        var newValue = this._isNewValue && this._oldSegment !== this._currentSegment ? 0 : this["_".concat(part, "Modified")] ? value * 10 : 0;
        newValue += parseInt(currentChar);
        this._isNextSegment = !isNaN(newValue) && jumpOnComplete && newValue >= maxLen;
        return newValue;
      }
    }, {
      key: "_sliceValue",
      value: function _sliceValue(max, newValue, str) {
        while (newValue > max) {
          newValue = parseInt(str.slice(1));
        }

        return newValue;
      }
    }, {
      key: "_parseDate",
      value: function _parseDate(character, currentChar, newDate) {
        var jumpOnComplete = this._opts.jumpOnComplete,
            newValue,
            getNewValue = this._getNewValue.bind(this),
            sliceValue = this._sliceValue.bind(this),
            viewDate = this._viewDate;

        if (character === 'd') {
          // No I18N
          var numberOfDays = this._getDaysInAMonth(newDate);

          newValue = getNewValue(newDate, currentChar, 'date', jumpOnComplete, 4); // No I18N

          if (isNaN(newValue)) {
            return;
          }

          var str = newValue.toString();

          if (!jumpOnComplete && newValue > numberOfDays && this._isFastInput) {
            if (str.length === 2) {
              newValue = viewDate.getDate();
            } else if (str.length >= 3) {
              newValue = sliceValue(31, newValue, str);
            }
          } else {
            newValue = newValue > numberOfDays ? jumpOnComplete ? parseInt(str[0]) : parseInt(str.slice(-1)) : newValue;
          }

          this._dateModified = newValue >= 1;

          if (this._dateModified) {
            newDate.setDate(newValue);

            if (newDate.getMonth() !== viewDate.getMonth()) {
              return;
            }
          }
        } else if (character === 'M') {
          // No I18N
          newValue = getNewValue(newDate, currentChar, 'month', jumpOnComplete, 2); // No I18N

          if (isNaN(newValue)) {
            var months = this._getI18NText('months'); // No I18N


            var typedMonthChar = this._typedMonthChar += currentChar.toLowerCase();

            while (typedMonthChar.length > 0) {
              for (var i = 0; i < months.length; i++) {
                if (months[i].toLowerCase().indexOf(typedMonthChar) === 0) {
                  newDate.setMonth(i);
                  this._isNextSegment = jumpOnComplete && this.monthChars.indexOf(typedMonthChar) > -1; // No I18N

                  this._monthModified = true;
                  this._oldDateValue = new Date(+viewDate);
                  this._viewDate = newDate;
                  return true;
                }
              }

              this._typedMonthChar = typedMonthChar.substring(1, typedMonthChar.length);
            }

            return false;
          }

          var _str = newValue.toString();

          if (!jumpOnComplete && newValue > 12 && this._isFastInput) {
            var value = parseInt(_str.slice(1));
            newValue = value > 12 ? parseInt(value.toString()[0]) : viewDate.getMonth() + 1;
          } else if (jumpOnComplete) {
            newValue = newValue > 12 && newValue < 20 ? 12 : newValue > 20 ? _str[0] : newValue;
          } else if (newValue === 111 || newValue === 112) {
            newValue = parseInt(_str.slice(-1));
          } else {
            newValue = sliceValue(12, newValue, _str);
          }

          this._monthModified = newValue >= 1;

          if (this._monthModified) {
            newDate.setMonth(newValue - 1);

            this._changeDateValue(newDate, newDate.getMonth() !== newValue - 1, --newValue);
          }
        } else if (character === 'y') {
          // No I18N
          var is2Digit = this._isYear2Digit;
          newValue = this._yearModified ? is2Digit ? newDate.getFullYear().toString().slice(2) : newDate.getFullYear() * 10 : 0;
          newValue = is2Digit ? parseInt(newValue + currentChar) : newValue + parseInt(currentChar);

          if (isNaN(newValue)) {
            return;
          }

          var yearString = newValue.toString();

          if (is2Digit) {
            if (jumpOnComplete && newValue > 10 && yearString.length === 2 && yearString[1] !== '0') {
              this._isNextSegment = true;
            }

            newValue = sliceValue(99, newValue, yearString);
            this._yearModified = newValue >= 1;

            if (this._yearModified) {
              var century = this._opts.century - 1;
              newValue = parseInt(century.toString() + newValue.toString());
              newDate.setFullYear(newValue);
            }
          } else {
            if (jumpOnComplete && newValue > 1001 && yearString.length === 4 && yearString[3] !== '0') {
              // No I18N
              this._isNextSegment = true;
            }

            newValue = sliceValue(9999, newValue, yearString);
            this._yearModified = newValue >= 1;

            if (this._yearModified) {
              newDate.setFullYear(newValue);
            }
          }
        }

        return newDate;
      }
    }, {
      key: "_isPartModified",
      value: function _isPartModified(character, value) {
        this._isDateModified(character, value);
      }
    }, {
      key: "_isDateModified",
      value: function _isDateModified(character, value) {
        if (['d', 'y', 'M'].indexOf(character) > -1) {
          var chars = this._getDateParts();

          this['_' + chars[character] + 'Modified'] = value; // No I18N

          !value && character === 'M' && (this._typedMonthChar = ''); // No I18N
        }
      }
    }, {
      key: "_setFormat",
      value: function _setFormat() {
        this._setFormatVal(/^(date-short|date-long|date-medium)$/, 'date', 'dd/MM/yyyy'); // No I18N

      }
    }, {
      key: "_getNumberOfDays",
      value: function _getNumberOfDays(year, month) {
        return new Date(year, month, 0).getDate();
      }
    }, {
      key: "_parseValue",
      value: function _parseValue(character, currentChar) {
        _get(_getPrototypeOf(ZDateField.prototype), "_parseValue", this).call(this, character, currentChar);

        this._hasPicker && (this._opts.pickerOptions.disabledDaysOfWeek || this._opts.pickerOptions.disabledDates) && (this._viewDate = this._checkForDisabledDates(this._viewDate));
        return true;
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        _get(_getPrototypeOf(ZDateField.prototype), "_bindEvents", this).call(this);

        this._opts.picker && this._bindPickerEvents();
      }
    }, {
      key: "_keydownHandler",
      value: function _keydownHandler(orgEvent) {
        var pickerElem = this._picker;
        var eventKeycode = orgEvent.keyCode;
        var keyCode = ZC.keyCode;

        if (this._hasPicker) {
          if (pickerElem.is(':visible')) {
            if ([keyCode.ESCAPE, keyCode.ENTER].indexOf(eventKeycode) > -1) {
              ZC[this._pickerMethods.instance](pickerElem).close();
            }
          }

          if (orgEvent.metaKey || orgEvent.ctrlKey) {
            if (keyCode.DOWN === eventKeycode) {
              if (!pickerElem.is(':visible')) {
                // No I18N
                ZC[this._pickerMethods.instance](pickerElem).open();

                return;
              }
            }
          }
        }

        _get(_getPrototypeOf(ZDateField.prototype), "_keydownHandler", this).call(this, orgEvent);
      }
    }, {
      key: "_isDateInstance",
      value: function _isDateInstance(value) {
        return value instanceof Date ? new Date(+value) : value;
      }
    }, {
      key: "_updateElementValue",
      value: function _updateElementValue() {
        _get(_getPrototypeOf(ZDateField.prototype), "_updateElementValue", this).call(this);

        var opts = this._opts,
            value = opts.value,
            lastValue = this._lastValue,
            pickerElem = this._picker;

        if (this._hasPicker && value) {
          if (!lastValue || lastValue && +ZC.Date.parseDate(lastValue, opts.format).date !== +value) {
            ZC[this._pickerMethods.instance](pickerElem).setAttribute('value', new Date(+value));
          }
        }

        if (value) {
          this._lastValue = this._isDateInstance(value);
          (opts.format.indexOf('h') < 0 || opts.indexOf('H') < 0) && value.setHours(0, 0, 0, 0);
        }
      }
    }, {
      key: "_clearActionHandler",
      value: function _clearActionHandler() {
        _get(_getPrototypeOf(ZDateField.prototype), "_clearActionHandler", this).call(this);

        this._picker && ZC[this._pickerMethods.instance](this._picker).setAttribute('value', null); // No I18N
      }
    }, {
      key: "_resetValues",
      value: function _resetValues(character, value) {
        if (!isNaN(value) && character === 'y') {
          this._viewDate.setFullYear(0);
        }
      }
    }, {
      key: "_resetToFirst",
      value: function _resetToFirst(removedChar) {
        this._resetDateToFirst(removedChar);
      }
    }, {
      key: "_resetDateToFirst",
      value: function _resetDateToFirst(removedChar) {
        var obj = {
          M: 'Month',
          // No I18N
          d: 'Date',
          // No I18N
          y: 'FullYear' // No I18N

        };

        if (removedChar && 'Mdy'.indexOf(removedChar > -1)) {
          this._viewDate["set".concat(obj[removedChar])](removedChar === 'y' ? new Date().getFullYear() : 'Mdy'.indexOf(removedChar)); // No I18N

        }
      }
    }, {
      key: "_resetOnBlur",
      value: function _resetOnBlur(_char5) {
        this._resetDateOnBlur(_char5);
      }
    }, {
      key: "_resetDateOnBlur",
      value: function _resetDateOnBlur(_char6) {
        _char6 === 'y' && this._viewDate.setFullYear(0); // No I18N
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        this._picker && this._destroyPicker();

        _get(_getPrototypeOf(ZDateField.prototype), "_destroy", this).call(this);
      }
    }, {
      key: "_getCalendarIconProps",
      value: function _getCalendarIconProps() {
        var data = this._data,
            opts = this._opts,
            icon = this._calendarIcon;
        data.calendarPosition = ''; // No I18N

        var UItype = opts.calendarIconUIType;
        var clsName = 'zdatetimefield__icon' + UItype; // No I18N

        data.calIconClassName = clsName;
        var calProp = {
          className: clsName,
          defaultIconClassName: 'zdatetimefield__icon',
          // No I18N
          iconClassName: opts.calendarIconClassName,
          SVGIconId: opts.calendarSVGIconId,
          defaultSVGIconId: 'zc__svg--calendaricon zbutton__svg',
          // No I18N
          isCE: this.isCE,
          customAttributes: {
            tabindex: -1 // tabindex is set to avoid keyboard navigation to those buttons

          },
          templateRender: true,
          mainElement: icon ? icon[0] : null
        };
        data.calendarIconProps = UItype === 'label' ? ZC._getIconInfo(calProp.iconClassName, calProp.SVGIconId, 'zc__svg--calendaricon zbutton__svg', 'zdatetimefield__icon', calProp) : calProp; // No I18N

        data.calendarPosition = this._getCalendarPosition(UItype, opts.calendarIconAlignment);
      }
    }, {
      key: "_getCalendarPosition",
      value: function _getCalendarPosition(UItype, alignment) {
        if (['right', 'left'].indexOf(alignment) > -1) {
          // No I18N
          return alignment === 'left' ? 'beforeInput' : (UItype === 'button' ? 'after' : 'before') + 'SpinBtn'; // No I18N
        }
      }
    }, {
      key: "_updateCalendarIcon",
      value: function _updateCalendarIcon() {
        var UItype = this._opts.calendarIconUIType,
            container = this.container;
        this._calendarIcon = container.find('.zdatetimefield__icon' + (UItype === 'label' ? 'label' : 'button')); // No I18N

        this._data.calendarIconProps.mainElement = this._calendarIcon[0];
        container.addClass('zdatetimefield zinputfield--withcalendaricon'); // No I18N

        if (UItype === 'button') {
          // No I18N
          container.addClass('zh-hasiconbutton'); // No I18N

          this._addEvents({
            calendarIconClick: 'mousedown' // No I18N

          }, this._calendarIcon);
        }
      }
    }, {
      key: "_calendarIconClickHandler",
      value: function _calendarIconClickHandler(orgEvent) {
        orgEvent.preventDefault();

        if (this._picker && this._picker.is(':visible')) {
          // No I18N
          this._picker.zdatepicker('close'); // No I18N

        } else {
          this._pickerOpenHandler(orgEvent);
        }

        if (this._currentSegment) {
          this._selectText(this._currentSegment);
        } else {
          this._selectCaretPosition(this._input[0], 0, 0);
        }

        this._mouseupHandler(orgEvent);

        this.container.addClass('has-focus'); // No I18N
      }
    }, {
      key: "_handleCalendarIcon",
      value: function _handleCalendarIcon(optionName, value) {
        var componentName = this.name,
            data = this._data,
            opts = this._opts,
            container = this.container,
            UItype = opts.calendarIconUIType,
            calendarCls = 'zinputfield--withcalendaricon'; // No I18N

        if (data.modifiedAttr === 'calendarIcon' && this._calendarIcon) {
          value !== 'button' && this._hasPicker && this._calendarIcon.off('click.' + this.name); // No I18N

          data.calendarPosition = '';
          data.calendarIconProps = null;
          this._calendarIcon = undefined;
          container.removeClass('zh-hasiconbutton ' + calendarCls); // No I18N
        }

        if (value && opts.calendarIcon) {
          // to check if value becomes false, calendarIcon should not be created
          this._getCalendarIconProps();

          this._setBtnValue(data.calendarIconProps, data.calendarIconProps);

          container.addClass(calendarCls + (opts.spinButtons === 'focus' ? ' zdatetimefield--buttonsonhover' : ''));

          if (UItype === 'button') {
            // No I18N
            !opts.showPickerOnFocus && container.off("click.".concat(componentName));
          } else {
            this._addEvents({
              pickerOpen: 'click' // No I18N

            }, container);
          }
        } else {
          this._domChanged = true;
        }
      }
    }, {
      key: "_checkForDisabledDates",
      value: function _checkForDisabledDates(newDate, offset) {
        offset = offset || 1;

        var disabled,
            pickerInstance,
            disabledWeek,
            preserveDate = new Date(newDate.getTime()),
            opts = this._opts,
            isGreater = this._isGreater.bind(this); // checking whether the date is within range


        if (this._hasPicker && isGreater(newDate, opts.min) && isGreater(opts.max, newDate)) {
          pickerInstance = ZC[this._pickerMethods.instance](this._picker);
          disabledWeek = pickerInstance.getAttribute('disabledDaysOfWeek');
          disabled = pickerInstance.getAttribute('disabledDates'); // No I18N

          var newDateVal = new Date(newDate.getTime());
          !this._checkTime && newDateVal.setHours(0, 0, 0, 0);
          var step = opts.dateStep * (offset === 1 ? 1 : -1),
              date = new Date(newDate.getTime());
          !this._checkTime && date.setHours(0, 0, 0, 0);

          while (this._picker.find("[data-time='".concat(date.getTime(), "']")).hasClass('is-disabled')) {
            // No I18N
            if (disabledWeek && disabledWeek.length) {
              for (var i = 0; i < disabledWeek.length; i++) {
                if (newDateVal.getDay() === disabledWeek[i]) {
                  newDateVal.setDate(newDateVal.getDate() + step);
                  newDate = new Date(newDateVal.getTime());
                  i = -1;
                }
              }

              newDate.setHours(preserveDate.getHours(), preserveDate.getMinutes(), preserveDate.getSeconds(), 0);
            }

            if (disabled && disabled.length) {
              for (var _i10 = 0, len = disabled.length; _i10 < len; _i10++) {
                var dateToCheck = void 0,
                    disabledObj = disabled[_i10],
                    changeValue = void 0;

                if (disabledObj.date instanceof Date) {
                  dateToCheck = disabledObj.date;
                } else if (disabledObj.date) {
                  changeValue = false;
                  dateToCheck = disabledObj.date.date;
                  disabledObj.repeatEveryYear && dateToCheck.setFullYear(newDate.getFullYear());
                  disabledObj.repeatEveryMonth && dateToCheck.setMonth(newDate.getMonth());
                } else if (disabledObj.startDate && disabledObj.endDate) {
                  var startDate = disabledObj.startDate.date,
                      endDate = disabledObj.endDate.date;

                  if (disabledObj.repeatEveryYear) {
                    startDate.setFullYear(newDate.getFullYear());
                    endDate.setFullYear(newDate.getFullYear());
                  }

                  if (disabledObj.repeatEveryMonth) {
                    startDate.setMonth(newDate.getMonth());
                    endDate.setMonth(newDate.getMonth());
                  }

                  if (ZC.Date.isGreater(newDateVal, startDate) || ZC.Date.areDatesEqual(startDate, newDateVal)) {
                    changeValue = !!ZC.Date.isGreater(endDate, newDateVal);
                  } else {
                    changeValue = false;
                  }
                }

                if (dateToCheck && ZC.Date.areDatesEqual(dateToCheck, newDateVal) || changeValue) {
                  var dateValue = newDate.getDate() + step;

                  if (!opts.incrementOnWrapAround) {
                    var numberOfDays = new Date(newDateVal.getFullYear(), newDateVal.getMonth() + 1, 0).getDate();

                    if (dateValue < 1) {
                      dateValue = numberOfDays;
                    } else if (dateValue > numberOfDays) {
                      dateValue %= numberOfDays;
                    }
                  }

                  newDateVal.setDate(dateValue);
                  var time = newDateVal.getTime();
                  newDate = new Date(time);
                  _i10 = -1;
                }
              }
            }

            newDate.setHours(preserveDate.getHours(), preserveDate.getMinutes(), preserveDate.getSeconds(), 0);
            date = new Date(newDate.getTime());
            !this._checkTime && date.setHours(0, 0, 0, 0);
          }
        }

        return newDate;
      }
    }, {
      key: "_isGreater",
      value: function _isGreater(first, second) {
        return ZC.Date.isGreater(first, second) && !ZC.Date.areDatesEqual(first, second);
      }
    }, {
      key: "_createPicker",
      value: function _createPicker() {
        var opts = this._opts,
            pickerMethods = this._pickerMethods;
        this._hasPicker = opts.picker;

        if (opts.picker && !opts.pickerId) {
          this._initPicker();
        }

        if (opts.pickerId) {
          var picker = $('#' + opts.pickerId);

          if (picker.length) {
            var data = picker.data('z' + pickerMethods.instance); // No I18N

            if (Object.keys(data).length) {
              this._hasPicker = true;
              this._picker = picker;
              ZC[pickerMethods.instance](this._picker).setAttribute('forElement', this.container); // No I18N
            }
          }
        }

        if (this._hasPicker) {
          this._immediateCommit = ZC[pickerMethods.instance](this._picker).getAttribute('immediateCommit'); // No I18N

          this.container.attr({
            'aria-owns': $(this._picker).attr('id'),
            // No I18N
            'aria-expanded': false // No I18N

          });
        }
      }
    }, {
      key: "_initPicker",
      value: function _initPicker() {
        var min,
            max,
            opts = this._opts,
            pickerOptions = opts.pickerOptions;

        if (opts.min) {
          min = new Date(opts.min.getTime());
        }

        if (opts.max) {
          max = new Date(opts.max.getTime());
        }

        if (!this._checkTime) {
          min && min.setHours(0, 0, 0, 0);
          max && max.setHours(0, 0, 0, 0);
        }

        pickerOptions = $.extend(true, {}, pickerOptions, {
          id: "".concat(this._getID(this.container), "-picker"),
          appendTo: $('body'),
          // No I18N
          isCE: this.isCE,
          rtl: this._opts.rtl,
          // No I18N
          locale: this._opts.locale,
          forElement: this.container,
          minDate: pickerOptions.minDate || min,
          maxDate: pickerOptions.maxDate || max,
          value: opts.value,
          format: opts.format.replace('s', ''),
          // dateTimePicker does not support seconds value
          beforedatecellrender: this._dispatchPickerEventsHandler.bind(this, 'pickerbeforedatecellrender')
        });
        this._picker = ZC[this._pickerMethods.create](pickerOptions);
      }
    }, {
      key: "_bindPickerEvents",
      value: function _bindPickerEvents() {
        var _this146 = this;

        var componentName = this.name,
            baseComp = this.isCE ? 'z' : "z".concat(this._pickerMethods.instance),
            // No I18N
        opts = this._opts;
        this._hasPicker && (opts.calendarIconUIType === 'label' || opts.calendarIconUIType === 'button' && opts.showPickerOnFocus) && this._addEvents({
          // No I18N
          pickerOpen: 'click' // No I18N

        }, this.container);
        var pickerElem = this._picker = $(this._picker);
        pickerElem.off(this._getPicker()._EVENTS.map(function (val) {
          return "z".concat(_this146._pickerMethods.instance).concat(val, ".").concat(_this146.name);
        }).join(' ')); // No I18N

        this._addEvents({
          focusInput: 'mousedown',
          // No I18N
          apply: "".concat(baseComp, "change"),
          // No I18N
          clear: "".concat(baseComp, "clear"),
          // No I18N
          close: "".concat(baseComp, "close"),
          // No I18N
          open: "".concat(baseComp, "open"),
          // No I18N
          beforeClose: "".concat(baseComp, "beforeclose"),
          // No I18N
          beforeOpen: "".concat(baseComp, "beforeopen"),
          // No I18N
          beforeFocus: "".concat(baseComp, "beforefocus") // No I18N

        }, pickerElem);

        var eventList = ['beforedrilldown', 'drilldown', 'datemouseover', 'dateselect', 'monthchange', 'yearchange', 'hourchange', 'minutechange', 'periodchange', 'timechange', 'todaybuttonclick', 'cancel', 'clear']; // No I18N

        for (var i = 0, len = eventList.length; i < len; i++) {
          pickerElem.off(baseComp + eventList[i] + '.' + componentName).on("".concat(baseComp).concat(eventList[i], ".").concat(componentName), this._dispatchPickerEventsHandler.bind(this, 'picker' + eventList[i])); // No I18N
        }
      }
    }, {
      key: "_beforeFocusHandler",
      value: function _beforeFocusHandler(ev) {
        ev.preventDefault();
      }
    }, {
      key: "_focusInputHandler",
      value: function _focusInputHandler() {
        this.container.addClass('has-focus').trigger('focusin'); // No I18N
      }
    }, {
      key: "_clearHandler",
      value: function _clearHandler() {
        if (this._opts.immediateCommit) {
          this.setAttribute('value', null); // No I18N

          this._clearActionHandler();
        }
      }
    }, {
      key: "_dispatchPickerEventsHandler",
      value: function _dispatchPickerEventsHandler(eventKey, orgEvent, ui) {
        if (!ui) {
          ui = orgEvent.detail;
        }

        this._dispatchEvent(eventKey, orgEvent, ui);
      }
    }, {
      key: "_openHandler",
      value: function _openHandler(orgEvent) {
        this.container.attr('aria-expanded', true); // No I18N

        this._dispatchEvent('pickeropen', orgEvent, {
          // No I18N
          value: this._input[0].value,
          dateValue: this._opts.value
        });
      }
    }, {
      key: "_beforeOpenHandler",
      value: function _beforeOpenHandler(orgEvent) {
        var returnValue = this._dispatchEvent('pickerbeforeopen', orgEvent, {
          // No I18N
          value: this._input[0].value,
          dateValue: this._opts.value
        });

        return returnValue;
      }
    }, {
      key: "_beforeCloseHandler",
      value: function _beforeCloseHandler(orgEvent) {
        this._dispatchEvent('pickerbeforeclose', orgEvent, {
          // No I18N
          value: this._input[0].value,
          dateValue: this._opts.value
        });
      }
    }, {
      key: "_closeHandler",
      value: function _closeHandler(orgEvent) {
        this.container.attr('aria-expanded', false); // No I18N

        this._getSegmentValue();

        var value = this._opts.value;

        if (!this._immediateCommit) {
          this.setAttribute('value', this._applyClicked ? this._isDateInstance(value) : this._isDateInstance(this._lastValue)); // No I18N
        }

        this._selectText(this._segment);

        this._mouseupHandler();

        this._applyClicked = false;

        this._dispatchEvent('pickerclose', orgEvent, {
          // No I18N
          value: this._input[0].value,
          dateValue: value
        });
      }
    }, {
      key: "_applyHandler",
      value: function _applyHandler(orgEvent, ui) {
        if (!ui) {
          ui = orgEvent.detail;
        }

        this._applyClicked = true;
        this._lastValue = ui.valueString;

        this._getSegmentValue();

        var format = this._opts.format,
            dateUtil = ZC.Date;

        if (dateUtil.formatDate(this._opts.value, format) !== dateUtil.formatDate(ui.value, format)) {
          // check is included since field value might be already updated via setValue method.
          this.setAttribute('value', ui.value ? ui.valueString : null); // No I18N

          var pickerOptions = ZC[this._pickerMethods.instance](this._picker).getAttributes();

          if (pickerOptions.monthsPerView > 1) {
            var _index6 = parseInt(this._picker.find('.is-selected').closest('li').index()); // No I18N


            this.setAttribute('pickerOptions', {
              // No I18N
              selectedDateMonthViewIndex: _index6
            });
          }
        }

        this._selectText(this._segment);

        this._mouseupHandler(); // this._input.addClass('has-focus'); // No I18N (added for Ok Click)

      }
    }, {
      key: "clearHandler",
      value: function clearHandler() {
        if (this._opts.immediateCommit) {
          this.setAttribute('value', null); // No I18N

          this._clearActionHandler();
        }
      }
    }, {
      key: "_pickerOpenHandler",
      value: function _pickerOpenHandler(orgEvent) {
        var picker = this._picker,
            opts = this._opts;

        this._getSegment();

        orgEvent.preventDefault();

        if (picker && !picker.is(':visible') && !opts.readonly && !opts.disabled && $(orgEvent.target).closest('.zinputfield__clearbutton,.zinputfield__spinbutton').length === 0) {
          // No I18N
          opts.pickerId && this._bindPickerEvents();

          var pickerInstance = ZC[this._pickerMethods.instance](picker);

          pickerInstance.setAttributes({
            forElement: this.container,
            value: this._isDateInstance(opts.value)
          });
          pickerInstance.open();
        }
      }
    }, {
      key: "_getSegmentValue",
      value: function _getSegmentValue() {
        this._getSegment();

        if (!this._segment) {
          this._selectCaretPosition(this._input[0], 0, 0);

          this._getSegment();
        }
      }
    }, {
      key: "_isPickerOpenValid",
      value: function _isPickerOpenValid() {
        var opts = this._opts;
        return opts.calendarIconUIType !== 'button' || opts.calendarIconUIType === 'button' && opts.showPickerOnFocus; // No I18N
      }
    }, {
      key: "_setPickerAttributes",
      value: function _setPickerAttributes(optionName, value) {
        var opts = this._opts,
            componentName = this.name,
            pickerInstance,
            pickerOptions = $.extend(true, {}, opts.pickerOptions);

        if (this._picker) {
          pickerInstance = ZC[this._pickerMethods.instance](this._picker);
        }

        switch (optionName) {
          case 'picker':
            if (value) {
              this._hasPicker = true;

              this._createPicker();

              this._bindPickerEvents();

              this._isPickerOpenValid() && this._addEvents({
                pickerOpen: 'click' // No I18N

              }, this.container);
              opts.calendarIconUIType === 'button' && this._addEvents({
                // No I18N
                calendarIconClick: 'mousedown' // No I18N

              }, this._calendarIcon);
              pickerInstance = ZC[this._pickerMethods.instance](this._picker);
              this._immediateCommit = pickerInstance.getAttribute('immediateCommit'); // No I18N
            } else if (this._picker) {
              opts.pickerOptions = null;

              this._render();

              opts.pickerOptions = pickerOptions;
              this._picker = undefined;
              this._hasPicker = false;
              this.container.off('click.' + componentName); // No I18N
            }

            break;

          case 'pickerOptions':
            // No I18N
            // pickerInstance && pickerInstance.destroy();
            opts.value = this._isDateInstance(opts.value);
            pickerInstance && pickerInstance.setAttributes(pickerOptions);
            break;

          case 'showPickerOnFocus':
            // No I18N
            if (opts.calendarIconUIType === 'button') {
              // No I18N
              this.container.off("click.".concat(componentName));

              if (value) {
                this._addEvents({
                  pickerOpen: 'click' // No I18N

                }, this.container);
              }
            }

            break;
        }
      }
    }, {
      key: "_getPicker",
      value: function _getPicker() {
        return ZC[this._pickerMethods.instance](this._picker);
      }
    }, {
      key: "_destroyPicker",
      value: function _destroyPicker() {
        var _this147 = this;

        var pickerInstance = this._getPicker();

        this._picker.off(pickerInstance._EVENTS.map(function (val) {
          return "z".concat(_this147._pickerMethods.instance).concat(val, ".").concat(_this147.name);
        }).join(' ')); // No I18N


        pickerInstance.destroy();

        this._picker.remove();

        this._picker = undefined;
      }
    }, {
      key: "openPicker",
      value: function openPicker() {
        ZC[this._pickerMethods.instance](this._picker).open();
      }
    }, {
      key: "closePicker",
      value: function closePicker() {
        ZC[this._pickerMethods.instance](this._picker).close();
      }
    }, {
      key: "getPickerElement",
      value: function getPickerElement() {
        return this._picker;
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        var calendarIconOptions = ["calendarIcon", "calendarIconClassName", "calendarSVGIconId", "calendarIconUIType", "calendarIconAlignment"],
            // No I18N
        data = this._data,
            opts = this._opts,
            hasPicker = this._hasPicker,
            setAttribute = _get(_getPrototypeOf(ZDateField.prototype), "_setAttribute", this).bind(this),
            dateValue = opts.value,
            pickerElem = this._picker,
            pickerInstance;

        opts[optionName] = value;

        if (hasPicker) {
          pickerInstance = ZC[this._pickerMethods.instance](pickerElem);
        }

        if (optionName === "century") {
          // No I18N 
          value = value - 1;
          var viewDate = this._viewDate;

          if (!isNaN(value) && value.toString().length === 2) {
            viewDate.setFullYear(parseInt(value.toString() + viewDate.getFullYear().toString().slice(2)));
            dateValue && (opts.value = new Date(viewDate.getTime()));
            opts.century = value + 1;
          } else {
            throw new Error(opts.labels.invalidNumber);
          }
        } else if (optionName === "format" || optionName === "value") {
          // No I18N
          this._lastValue = null;
          setAttribute(optionName, value); // revisit - following set of code is commented since it is unnecessary and also produces issue
          // let calendarIcon = this._calendarIcon, clickEvent = "click." + this.name, isPickerOpenValid = this._isPickerOpenValid(), // No I18N 
          //     container = this.container;   // No I18N 
          // isPickerOpenValid && container.off(clickEvent);
          // calendarIcon && opts.calendarIconUIType === "button" && calendarIcon.off(clickEvent);  // No I18N 
          // if (hasPicker) {
          //    calendarIcon && this._addEvents({
          //         calendarIconClick: 'click' // No I18N 
          //     }, calendarIcon)
          //     isPickerOpenValid && this._addEvents({
          //         pickerOpen: 'click' // No I18N
          //     }, container);
          // }
        } else if (optionName === "min" || optionName === "max") {
          // No I18N
          setAttribute(optionName, value);
          hasPicker && pickerInstance.setAttribute("".concat(optionName, "Date"), this._isDateInstance(value));
        } else if (optionName.indexOf("picker") > -1 || optionName === "showPickerOnFocus") {
          // No I18N
          opts.value = this._isDateInstance(dateValue);

          this._setPickerAttributes(optionName, value);
        } else if (calendarIconOptions.indexOf(optionName) > -1) {
          if (optionName === 'calendarIconUIType' && opts.calendarIcon || optionName === 'calendarIcon') {
            // No I18N 
            data.modifiedAttr = 'calendarIcon'; // No I18N 
          }

          if (optionName === "calendarIconAlignment") {
            // No I18N
            value = ["right", "left"].indexOf(value) > -1 ? value : "right"; // No I18N

            this._domChanged = true;
          }

          this._handleCalendarIcon(optionName, value);
        } else if (optionName === "rtl" && hasPicker) {
          // No I18N
          pickerElem && pickerInstance.setAttribute("rtl", value); // No I18N
        } else if (optionName === "locale") {
          // No I18N
          setAttribute(optionName, value);
          pickerElem && pickerInstance.setAttribute("locale", value); // No I18N
        } else {
          setAttribute(optionName, value);
        }
      }
    }, {
      key: "name",
      get: function get() {
        return "zdatefield";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          format: 'dd/MM/yyyy',
          // No I18N
          dateStep: 1,
          monthStep: 1,
          yearStep: 1,
          picker: false,
          pickerId: null,
          century: 21,
          calendarIcon: false,
          calendarIconClass: null,
          calendarSVGIconId: null,
          calendarIconAlignment: 'right',
          // No I18N
          calendarIconUIType: 'label',
          // No I18N
          showPickerOnFocus: false
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          calendarIconClassName: null,
          placeholder: {
            year: 'year',
            // No I18N
            month: 'month',
            // No I18N
            date: 'date' // No I18N

          },
          pickerOptions: {
            timeFieldType: 'multiple-select-box' // No I18N

          },
          labels: {
            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            // No I18N
            daysAbbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            // No I18N
            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
            // No I18N
            monthsAbbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            // No I18N
            invalidInput: 'Invalid date/time provided. Please provide correct input',
            // No I18N
            invalidNumber: 'Not a number' // No I18N

          }
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['pickerbeforeopen', 'pickeropen', 'pickerbeforeclose', 'pickerclose', 'pickerbeforedatecellrender', 'pickerdatecellrender', 'pickerbeforemonthopen', 'pickerbeforedrilldown', 'pickerdrilldown', 'pickerdatemouseover', 'pickerdateselect', 'pickermonthchange', 'pickeryearchange', 'pickerdecadechange', 'pickertodaybuttonclick', 'pickercancel', 'pickerclear']; // No I18N
      }
    }, {
      key: "monthChars",
      get: function get() {
        return ['f', 's', 'o', 'n', 'd', 'ja', 'may', 'mar', 'ap', 'au', 'jun', 'jul']; // No I18N
      }
    }]);

    return ZDateField;
  }(ZC.ZDateInput);

  ZC.registerComponent('ZDateField', ZC.ZDateInput, ZDateField);

  (function (ZC) {
    var template = ZC.zdatefield.Templates,
        button = ZC.createButton;

    template.container = function (data) {
      return ZT.html(_templateObject221(), data.className, data.title, data.width, data.id, data.children && template.children(data));
    };

    template.children = function (data) {
      return ZT.html(_templateObject222(), data.calendarPosition === 'beforeInput' && template.calendarIcon(data), ZT.html(_templateObject223(), data.tabindex, data.min, data.max, data.readonly, data.readonly, data.disabled, data.disabled, data.maxLength), data.clearButton && button(data.clearButtonProps), data.calendarPosition === 'beforeSpinBtn' && template.calendarIcon(data), data.spinButtons && ZT.html(_templateObject224(), data.isVertical ? button(data.incrementProps) : button(data.decrementProps), data.isVertical ? button(data.decrementProps) : button(data.incrementProps)), data.calendarPosition === 'afterSpinBtn' && template.calendarIcon(data));
    };

    var utilities = ZC.Templates.Utilities;

    template.calendarIcon = function (data) {
      return ZT.html(_templateObject225(), data.calendarIconUIType === 'label' ? ZT.html(_templateObject226(), data.calIconClassName, utilities.icon(data.calendarIconProps)) : button(data.calendarIconProps));
    };
  })(ZComponents);

  var ZColorSelect =
  /*#__PURE__*/
  function (_ZC$ZColorBase2) {
    _inherits(ZColorSelect, _ZC$ZColorBase2);

    function ZColorSelect() {
      _classCallCheck(this, ZColorSelect);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZColorSelect).apply(this, arguments));
    }

    _createClass(ZColorSelect, [{
      key: "_bindEvents",
      value: function _bindEvents() {
        _get(_getPrototypeOf(ZColorSelect.prototype), "_bindEvents", this).call(this);

        this._handleFocus(this.container);
      }
    }, {
      key: "_setRenderData",
      value: function _setRenderData() {
        _get(_getPrototypeOf(ZColorSelect.prototype), "_setRenderData", this).apply(this, arguments);

        this._data.attrs.role = 'button'; // No I18N
      }
    }, {
      key: "_setClassName",
      value: function _setClassName(data, options) {
        _get(_getPrototypeOf(ZColorSelect.prototype), "_setClassName", this).call(this, data, options, data.arrow ? '' : 'zcolorselect--withoutarrow'); // No I18N

      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        if (/^(arrowIcon)$/.test(optionName)) {
          // No I18N
          this._opts[optionName] = value;
          this._domChanged = true;
        } else {
          _get(_getPrototypeOf(ZColorSelect.prototype), "_setAttribute", this).call(this, optionName, value);
        }
      }
    }, {
      key: "name",
      get: function get() {
        return "zcolorselect";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          tabIndex: 0,
          arrowIcon: true
        };
      }
    }, {
      key: "CLASSES",
      get: function get() {
        return {
          CONTAINER: 'zselectbox zcolorselect zselectbox--icononly',
          // No I18N
          ICON: 'zselectbox__icon',
          // No I18N
          PREVIEW: 'zcolorselect__preview',
          // No I18N
          ARROWSVGICON: 'zselectbox__arrow' // No I18N

        };
      }
    }]);

    return ZColorSelect;
  }(ZC.ZColorBase);

  ZC.registerComponent('ZColorSelect', ZC.ZColorBase, ZColorSelect);

  (function (ZC) {
    var template = ZC.zcolorselect.Templates;
    var utilities = ZC.Templates.Utilities;

    template.container = function (data) {
      return ZT.html(_templateObject227(), data.children && template.children(data));
    };

    template.children = function (data) {
      return ZT.html(_templateObject228(), data.nofill ? ZT.html(_templateObject229()) : data.icon || data.stroke ? ZT.html(_templateObject230(), data.previewStyleAttr, data.icon && utilities.icon(data.icon)) : ZT.html(_templateObject231(), data.color), data.arrow && utilities.icon(data.arrow));
    };
  })(ZComponents);

  var ZMenuButton =
  /*#__PURE__*/
  function (_ZC$ZButton) {
    _inherits(ZMenuButton, _ZC$ZButton);

    function ZMenuButton() {
      _classCallCheck(this, ZMenuButton);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZMenuButton).apply(this, arguments));
    }

    _createClass(ZMenuButton, [{
      key: "_init",
      value: function _init() {
        this._opts = ZC.ZMenuButton.init(this._opts);

        _get(_getPrototypeOf(ZMenuButton.prototype), "_init", this).apply(this, arguments);
      }
    }, {
      key: "_updateIcon",
      value: function _updateIcon() {
        var _opts = this._opts;

        if (_opts.arrowIcon) {
          ZC.ZMenuButton.getIconInfo(_opts);
        }
      }
    }, {
      key: "_mousedownHandler",
      value: function _mousedownHandler(event) {
        var _this148 = this;

        var isRightClick = event.which === 3,
            _opts = this._opts,
            _eventPrefix = this._getID(this.element),
            disabled = _opts.disabled; // event.which is added since right click on the menu button should not open the menu.
        // It should open the browser's default right click menu. Referred in Chrome's finder menu.
        // we should close the previously opened menu on right click.


        if (!disabled && ZC.zmenu) {
          window.setTimeout(function () {
            return _this148._showHideMenu(isRightClick, _eventPrefix);
          }, _opts.delay || 0);
        }

        if (disabled || isRightClick) {
          event.stopImmediatePropagation();
          return false;
        }
      }
    }, {
      key: "_keydownHandler",
      value: function _keydownHandler(event) {
        var prevent = false,
            showMenu = false,
            handleKeyCode = false,
            keyCode = event.keyCode,
            key = ZC.keyCode,
            menu = $('#' + this._opts.menuId); // No I18N

        if (keyCode === key.ESCAPE || keyCode === key.TAB) {
          if (menu.is(':visible')) {
            // No I18N
            if (!menu.find('.on-hover').hasClass('zmenu--submenu')) {
              // No I18N
              menu.zmenu('hide'); // No I18N

              keyCode === key.ESCAPE && event.stopPropagation(); // event propagation is prevented since having menubutton inside dialog closes the dialog on escape key press
            } else {
              handleKeyCode = true;
            }
          }
        } else if ((keyCode === key.ENTER || keyCode === key.SPACE) && menu) {
          if (document.activeElement === this.element[0]) {
            prevent = true;

            if (menu.find('.on-hover').length) {
              // No I18N
              handleKeyCode = true;
            } else {
              showMenu = true;
            }
          }
        } else {
          prevent = true;

          if (menu.is(':visible')) {
            handleKeyCode = true;
          } else if (keyCode === key.UP || keyCode === key.DOWN) {
            showMenu = true;
          }
        } // removed the focus set on menu as pressing TAB key from within the menu will have no effect
        // menu.focus(); // focus should be set to menu inorder to handle submenu opening and closing behaviors. Need to revisit.


        if (handleKeyCode) {
          ZC.menu(menu).handleKeyCode(event);
        } else if (showMenu) {
          this._showHideMenu();
        }

        if (prevent) {
          // preventing the default event because while opening the menu, document scroll occurs.
          return false;
        }
      }
    }, {
      key: "_clickHandler",
      value: function _clickHandler(event) {
        this._dispatchEvent('click', event, {
          // No I18N
          button: this.element
        });
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        var listeners = {
          mousedown: 'mousedown',
          // No I18N
          keydown: 'keydown',
          // No I18N
          click: 'click' // No I18N

        };

        if (this._opts.openOn === 'mouseover') {
          // No I18N
          listeners = {
            mouseEnter: 'mouseenter',
            // No I18N
            mouseLeave: 'mouseleave' // No I18N

          };
        }

        this._addEvents(listeners);

        this._handleFocus(this._container);

        if (window.ZShortCut) {
          // shortcut key registration
          ZShortCut.register(this.element);
        }
      }
    }, {
      key: "_showHideMenu",
      value: function _showHideMenu(canClose, _eventPrefix) {
        var _opts = this._opts,
            menu = $('#' + _opts.menuId),
            forElement = menu.data('forElement'); // No I18N

        /* ||
            (_opts.splitbutton && forElement && forElement[0] !== this.element.closest(`.${this._CLASSES.$splitmodifier}`).get(0))
                || (!_opts.splitbutton && forElement && forElement[0] !== this.element.get(0))) */

        if (!canClose && !menu.is(':visible')) {
          // No I18N
          // open the menu
          // menu.zmenu("hide"); // No I18N
          var eventHideEvents = 'zmenuhide.' + _eventPrefix + ' zhide.' + _eventPrefix,
              // No I18N
          eventHandlers = {
            menuHide: eventHideEvents
          };

          if (_opts.openOn === 'mouseover') {
            // No I18N
            eventHandlers.menuMouseEnter = 'mouseenter'; // No I18N

            eventHandlers.menuMouseLeave = 'mouseleave'; // No I18N
          }

          if (!ZC.Browser.isFirefox && !ZC.Browser.isSafari) {
            eventHandlers.menuFocus = 'zmenubeforefocus zbeforefocus'; // No I18N
          }

          this._addEvents(eventHandlers, menu); // If menu button's direction is set as rtl, then menu should also have rtl direction.
          // Revisit - Use our way of component initialization


          menu.zmenu({
            rtl: _opts.rtl
          }); // No I18N

          menu.zmenu('show', {
            // No I18N
            forElement: this._container.data('menuForElement') || this._container // No I18N

          });

          this._handleState(true);

          this._addEvents({
            windowResize: 'resize' // No I18N

          }, ZC.$window);
        } else {
          // close the menu
          if (this._opts.openOn !== 'mouseover') {
            // No I18N
            this._handleState();

            menu.zmenu('hide'); // No I18N
          }
        }
      }
    }, {
      key: "_windowResizeHandler",
      value: function _windowResizeHandler() {
        ZC.currentMenu && ZC.menu(ZC.currentMenu).hide();
      }
    }, {
      key: "_menuFocusHandler",
      value: function _menuFocusHandler() {
        // focusing the menu is prevented inorder to avoid the jerk whenever focus switches from button to menu.
        return false;
      }
    }, {
      key: "_mouseLeaveHandler",
      value: function _mouseLeaveHandler(orgEvent) {
        var _this149 = this;

        var _opts = this._opts,
            menuId = '#' + _opts.menuId;
        this._mouseEnterFired = false;
        this._mouseLeaveTimeout = setTimeout(function () {
          _this149._durationLeft && (_this149._durationLeft -= new Date().getTime() - _this149._closeAfterStartTime);
          var relatedTarget = $(orgEvent.relatedTarget); // !this._cursorInMenu &&

          if (!(relatedTarget.parents(menuId).length || relatedTarget.attr('id') === menuId)) {
            // No I18N
            _this149._handleState();

            $('#' + _opts.menuId).zmenu('hide'); // No I18N
          }
        }, 50);
      }
    }, {
      key: "_menuMouseEnterHandler",
      value: function _menuMouseEnterHandler(orgEvent) {
        // this._cursorInMenu = true;
        this._resetLeaveTimer();
      }
    }, {
      key: "_menuMouseLeaveHandler",
      value: function _menuMouseLeaveHandler(orgEvent) {
        // this._cursorInMenu = false;
        this._mouseLeaveHandler(orgEvent);
      }
    }, {
      key: "_mouseEnterHandler",
      value: function _mouseEnterHandler(orgEvent) {
        this._mouseEnterFired = true;

        this._resetLeaveTimer();

        this._mousedownHandler(orgEvent);
      }
    }, {
      key: "_resetLeaveTimer",
      value: function _resetLeaveTimer(orgEvent) {
        this._durationLeft && (this._durationLeft -= new Date().getTime() - this._closeAfterStartTime);
        this._mouseLeaveTimeout && clearTimeout(this._mouseLeaveTimeout);
      }
    }, {
      key: "_menuHideHandler",
      value: function _menuHideHandler(event, ui) {
        var menuitem = (event.detail || ui || {}).menuitem,
            orgEvent = event.originalEvent;

        if (orgEvent) {
          // Setting focus on menu button on menu close is excluded for footer items
          // since footer items might open dialog element.
          var isFooterItem = menuitem && menuitem.is('.is-fixed'),
              // No I18N
          isMouseUp = orgEvent.type === 'mouseup'; // No I18N

          if (!isFooterItem && isMouseUp) {
            this.element.focus(); // has-kfocus is removed manually since menu hide should not contain has-kfocus visual

            this.element.removeClass('has-kfocus'); // No I18N
          }

          if (isMouseUp || isFooterItem) {
            // No I18N
            this.element.removeClass('has-focus');
          }
        }

        this._handleState();

        this._removeEvents('resize', ZC.$window); // No I18N


        var _eventPrefix = this._getID(this.element);

        this._removeEvents('zmenuhide.' + _eventPrefix + ' zhide.' + _eventPrefix, event.detail.element); // No I18N

      }
    }, {
      key: "_menuShowHandler",
      value: function _menuShowHandler(event, ui) {
        this._mouseLeaveTimeout && clearTimeout(this._mouseLeaveTimeout);

        var _eventPrefix = this._getID(this.element);

        this._removeEvents('zmenushow.' + _eventPrefix + ' zshow.' + _eventPrefix, event.detail.element); // No I18N

      }
    }, {
      key: "_handleState",
      value: function _handleState(openMenu) {
        this._container[openMenu ? 'addClass' : 'removeClass'](this._opts.activeClass); // No I18N


        this.element.attr('aria-expanded', openMenu); // No I18N
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        // Revisit - removeClass Not necessary
        this.element.removeClass('zbutton--menu').removeAttr('aria-haspopup'); // No I18N

        var menu = $('#' + this._opts.menuId),
            // No I18N
        ePre = this._getID(this.element);

        menu.off('zmenuhide.' + ePre + ' zhide.' + ePre); // No I18N

        _get(_getPrototypeOf(ZMenuButton.prototype), "_destroy", this).call(this);
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        if (optionName === 'menuId') {
          // No I18N
          this.element[0].setAttribute('aria-controls', value); // No I18N
        }

        var opts = this._opts;

        if (optionName === 'arrowIconClassName' || optionName === 'arrowIconClass' // No I18N
        || optionName === 'arrowSVGIconId') {
          // No I18N
          opts[optionName] = value;

          this._updateIcon();

          this._domChanged = true;
        } else if (optionName === 'rtl') {
          // No I18N
          ZC.menu($("#".concat(opts.menuId))).setAttribute('rtl', value); // No I18N
        } else {
          return _get(_getPrototypeOf(ZMenuButton.prototype), "_setAttribute", this).call(this, optionName, value);
        }
      }
    }, {
      key: "name",
      get: function get() {
        return "zmenubutton";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          openOn: 'click',
          // No I18N
          menuId: null,
          // No I18N
          delay: 0,
          // No I18N
          arrowIcon: true,
          // No I18N
          arrowIconClass: null,
          // No I18N
          arrowSVGIconId: null,
          // No I18N
          activeClass: 'is-selected' // No I18N

        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          arrowIconClassName: null // No I18N

        };
      }
    }], [{
      key: "getIconInfo",
      value: function getIconInfo(_opts) {
        var iconInfo = ZC._getIconInfo(_opts.arrowIconClassName || _opts.arrowIconClass, _opts.arrowSVGIconId, 'zc__svg--buttonarrow zbutton__svg zbutton__menuarrow', 'zbutton__icon zh-floatright'); // No I18N


        _opts.arrowIcon = true;
        _opts.arrowIconInfo = iconInfo;
        return _opts;
      }
    }, {
      key: "init",
      value: function init(options) {
        options.className += ' zbutton--menu'; // No I18N

        var attrs = options.customAttributes || {};
        attrs['aria-haspopup'] = true; // No I18N

        attrs['aria-expanded'] = false; // No I18N

        attrs['aria-controls'] = options.menuId; // No I18N

        options.customAttributes = attrs;
        return options.arrowIcon ? ZMenuButton.getIconInfo(options) : options;
      }
    }]);

    return ZMenuButton;
  }(ZC.ZButton);

  ZC.registerComponent('ZMenuButton', ZC.ZButton, ZMenuButton);

  (function (ZC) {
    var template = ZC.zmenubutton.Templates,
        icon = ZC.Templates.Utilities.icon;

    template.container = function (data) {
      return ZT.html(_templateObject232(), data.text, data.id, data.role, data.type, data.className, data.children && template.children(data));
    };

    template.children = function (data) {
      return ZT.html(_templateObject233(), data.icon && ZT.html(_templateObject234(), data.iconClassName, data.SVGIconId && ZT.customHTML("<svg class=\"".concat(data.SVGIconClassName, "\"> <use xlink:href=\"").concat(data.SVGIconId, "\" ></use> </svg>"))), data.text && ZT.html(_templateObject235(), data.text), data.arrowIcon && icon(data.arrowIconInfo));
    };
  })(ZComponents);

  var ZFileUpload =
  /*#__PURE__*/
  function (_ZC$ZButton2) {
    _inherits(ZFileUpload, _ZC$ZButton2);

    function ZFileUpload() {
      _classCallCheck(this, ZFileUpload);

      return _possibleConstructorReturn(this, _getPrototypeOf(ZFileUpload).apply(this, arguments));
    }

    _createClass(ZFileUpload, [{
      key: "_postRender",
      value: function _postRender() {
        var _input = this.element,
            _opts = this._opts,
            attrs = _opts.directory ? ZFileUpload.dirAttrValue() : {};

        if (this.isCE) {
          var buttonId = _input.attr('id'); // No I18N


          _input.removeAttr('tabindex'); // No I18N


          $("<input type=file id='" + buttonId + "Input' tabindex=-1 style='display:none' /><label for='" + buttonId + "Input' class='zbutton--fileupload'></label>").appendTo(_input); // No I18N
          // removing the class names added to z-fileupload element.

          _input = _input.find('input'); // No I18N

          this._label = _input.find('label'); // No I18N
        }

        this._input = _input;
        attrs.role = 'fileupload'; // No I18N

        if (_opts.multiple) {
          attrs.multiple = true;
        }

        if (_opts.accept) {
          attrs.accept = _opts.accept;
        }

        this.container.attr(attrs);

        _get(_getPrototypeOf(ZFileUpload.prototype), "_postRender", this).apply(this, arguments);
      }
    }, {
      key: "_bindEvents",
      value: function _bindEvents() {
        this._addEvents({
          change: 'change' // No I18N

        }, this.element);

        this._addEvents({
          containerKeydown: 'keydown',
          // No I18N
          containerClick: 'click mousedown' // No I18N

        });

        this._handleFocus();

        if (window.ZShortCut) {
          ZShortCut.register(this.element);
        }
      }
    }, {
      key: "_changeHandler",
      value: function _changeHandler(event) {
        var ele = this._input,
            files = ele.prop('files'),
            // No I18N
        validatedFiles = {},
            // No I18N
        maxFileCount = this._opts.maxAllowedFiles,
            maxFilesSize = this._opts.maxAllowedSize,
            exceeds = false; // added undefined and null check explicitly since user can provide 0 as value.

        if (this._isNotNull(maxFileCount)) {
          exceeds = this._checkFilesCount(files, maxFileCount);

          if (exceeds) {
            return;
          }
        }

        if (parseInt(maxFilesSize) > 0) {
          validatedFiles = this._checkFilesSize(files, maxFilesSize);
        }

        if (validatedFiles && validatedFiles.length || maxFilesSize === undefined || maxFilesSize === null) {
          this._dispatchEvent('change', event, {
            // No I18N
            input: ele,
            value: ele.val(),
            // No I18N
            files: validatedFiles.length < files.length ? validatedFiles : files // No I18N

          }, ele);
        }
      }
    }, {
      key: "_containerKeydownHandler",
      value: function _containerKeydownHandler(event) {
        if (event.keyCode === ZC.keyCode.ENTER || event.keyCode === ZC.keyCode.SPACE) {
          this[this.isCE ? '_label' : 'container'].trigger('click'); // No I18N
          // preventing the propagation since uploadbutton may be present inside the
          // dialog component which inturn triggers primary action button click.

          event.stopImmediatePropagation(); // prevent default is added since ENTER opens the file chooser two times.

          return false;
        }
      }
    }, {
      key: "_containerClickHandler",
      value: function _containerClickHandler(event) {
        // false is returned to prevent focus while clicking the disabled button.
        if (this.container.hasClass('is-disabled')) {
          // No I18N
          event.type === 'mousedown' && event.stopImmediatePropagation(); // No I18N

          return false;
        }
      }
    }, {
      key: "_showAlert",
      value: function _showAlert(sizeExceeds) {
        var errorMessage = this._getI18NText(sizeExceeds ? 'exceedsAllowedSize' : 'exceedsAllowedFiles', [this._opts[sizeExceeds ? 'maxAllowedSize' : 'maxAllowedFiles']], 'errorMessage'); // No I18N


        if (ZC.AlertDialog) {
          ZC.AlertDialog.close();
          ZC.AlertDialog.open({
            type: 'error',
            // No I18N
            rtl: this._opts.rtl,
            // No I18N
            primaryMessage: errorMessage
          });
        } else {
          window.alert(errorMessage);
        } // clearing the input value as change event will not be triggered in such case.


        this._input[0].value = ''; // No I18N
      }
    }, {
      key: "_setAttribute",
      value: function _setAttribute(optionName, value) {
        var inputEle = this._input;

        if (optionName === 'directory') {
          // No I18N
          var dirAttrValue = ZFileUpload.dirAttrValue();

          if (value) {
            inputEle.attr(dirAttrValue);
          } else {
            inputEle.removeAttr(Object.keys(dirAttrValue).join(' '));
          }
        } else if (optionName === 'accept') {
          // No I18N
          inputEle[value ? 'attr' : 'removeAttr'](optionName, value); // No I18N
        } else {
          _get(_getPrototypeOf(ZFileUpload.prototype), "_setAttribute", this).call(this, optionName, value);

          if (optionName === 'multiple' || optionName === 'disabled') {
            // No I18N
            inputEle[value ? 'attr' : 'removeAttr'](optionName, value); // No I18N
          }
        }

        this._opts[optionName] = value;
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        this.element.off('change.zfileupload'); // No I18N

        _get(_getPrototypeOf(ZFileUpload.prototype), "_destroy", this).call(this);
      }
    }, {
      key: "_checkFilesSize",
      value: function _checkFilesSize(files) {
        var len = files.length,
            size = 0,
            validatedFiles = {},
            file;

        for (var i = 0; i < len; i++) {
          file = files[i];
          size = size + parseFloat(file.size); // size obtained will be in bytes

          if (this._checkAllowedSize(size)) {
            return this._showAlert(true);
          }

          validatedFiles[i] = file;
          validatedFiles.length = i + 1;
        }

        return validatedFiles;
      }
    }, {
      key: "_checkAllowedSize",
      value: function _checkAllowedSize(totalSize) {
        var allowedSize = this._opts.maxAllowedSize,
            sizeType = allowedSize.substring(allowedSize.length - 2).toLowerCase(),
            pow = ['kb', 'mb', 'gb', 'tb'].indexOf(sizeType) + 1; // No I18N

        allowedSize = parseInt(allowedSize); // converting the kb,mb,gb and tb to bytes because file object contains the size in bytes only.

        return Math.ceil(totalSize) > Math.ceil(allowedSize * (pow ? Math.pow(1024, pow) : 1));
      }
    }, {
      key: "_checkFilesCount",
      value: function _checkFilesCount(files, count) {
        var exceeds = files.length > parseInt(count);

        if (exceeds) {
          // clearing the file lists value
          this.value = ''; // No I18N

          this._showAlert();
        }

        return exceeds;
      }
    }, {
      key: "name",
      get: function get() {
        return "zfileupload";
      }
    }, {
      key: "attrs",
      get: function get() {
        return {
          type: 'file',
          // No I18N
          directory: false,
          accept: '',
          // No I18N
          maxAllowedSize: null,
          maxAllowedFiles: null,
          multiple: false
        };
      }
    }, {
      key: "props",
      get: function get() {
        return {
          labels: {
            exceedsAllowedSize: 'File size exceeds the maximum allowed size of {0}.',
            // No I18N
            exceedsAllowedFiles: 'Number of Files Exceeded.' // No I18N

          },
          errorMessage: {
            exceedsAllowedSize: null,
            exceedsAllowedFiles: null
          }
        };
      }
    }, {
      key: "EVENTS",
      get: function get() {
        return ['change']; // No I18N
      }
    }], [{
      key: "dirAttrValue",
      value: function dirAttrValue() {
        return {
          webkitdirectory: '',
          directory: '',
          // No I18N
          mozdirectory: '',
          // No I18N
          odirectory: '',
          msdirectory: ''
        };
      }
    }]);

    return ZFileUpload;
  }(ZC.ZButton);

  ZC.registerComponent('ZFileUpload', ZC.ZButton, ZFileUpload);
})(ZComponents, ZComponents.DOMUtil);

(function (ZC) {
  var template = ZC.zfileupload.Templates;

  template.container = function (data) {
    return ZT.html(_templateObject236(), data.text, data.id, data.role, data.type, data.className, data.children && template.children(data));
  };

  template.children = ZC.zbutton.Templates.children;
})(ZComponents);